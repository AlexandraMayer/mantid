#!/bin/sh
# 
# Supports the git test command.
#
# Copyright 2013 ISIS Rutherford Appleton Laboratory & NScD Oak Ridge National Laboratory
#
# This file is part of Mantid.
#
# Mantid is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Mantid is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# File change history is stored at: <https://github.com/mantidproject/mantid>

# Set top-level command name
CMD_NAME="test"
# Branch to merge to for testing
PRODUCTION_BRANCH="master"
# Config key to store tested branch
BRANCH_CFG_KEY=mantid.workflow.testbranch
# Changes filename
CHANGESFILE_CFG_KEY=mantid.workflow.changesfilename

# Get directory of this file
# The sed expression here replaces all backslashes by forward slashes.
# This helps our Windows users, while not bothering our Unix users.
export CMDFILE_DIR=$(dirname "$(echo "$0" | sed -e 's@\\@/@g')")

usage() {
    echo "Usage: git ${CMD_NAME} start <branchname>"
    echo "       git ${CMD_NAME} pass|fail"
    echo
    echo "In the first form start testing the given <branchname> by checking out ${PRODUCTION_BRANCH} and merging it."
    echo "The branchname that is actually merged is origin/branchname to save checking out a local copy of the branch."
    echo "The name of the branch is recorded in the config for reuse with the second form so that the branch can be deleted"
    echo "Equivalent to:"
    echo "  git fetch -p"
    echo "  git checkout ${PRODUCTION_BRANCH}"
    echo "  git reset --hard origin/${PRODUCTION_BRANCH} (Ensures it looks exactly like origin/${PRODUCTION_BRANCH})"
    echo "  git merge --no-ff <branchname>"
    echo
    echo "In the second form assume testing has started and indicates success/failure. If they"
    echo "  passed: The commits are pushed to origin --> 'git push origin ${PRODUCTION_BRANCH}'"
    echo "  failed: The merged commits are discarded --> 'git reset --hard origin/${PRODUCTION_BRANCH}'"
    echo
    echo "In both forms a fetch & merge of origin/${PRODUCTION_BRANCH} is performed before merging the test branch."
}

checkargs() {
    # Can't use getopt cross-platform
    # 2 args assumes the word start and then a string
    
    TEST_BRANCH=""
    START_MODE=0
    RESULT_MODE=0
    TEST_PASSED=0
    
    if [ $# -eq 2 ]; then
        if [ "$1" != "start" ]; then
            usage
            exit 1
        fi
        START_MODE=1
        TEST_BRANCH=$2
    elif [ $# -eq 1 ]; then
        RESULT_MODE=1
        if [ "$1" = "pass" ]; then
            TEST_PASSED=1
        elif [ "$1" = "fail" ]; then
            TEST_PASSED=0
        else
            usage
            exit 1
        fi
    else
        usage
        exit 1
    fi
}

start_testing() {
    # Check we are not in the middle of testing something else that wasn't finished
    testing=$(git config ${BRANCH_CFG_KEY})
    if [ ! -z "${testing}" ]; then
	echo "It looks like you have already run 'git test start' without a corresponding git test pass/fail."
	echo "If you are unsure run 'git test fail'. This will drop any merges and reset master back to origin/${PRODUCTION_BRANCH}."
	exit 1
    fi    

    # Is the name correct
    remote_branch_exists ${TEST_BRANCH}
    if [ $? -eq 0 ]; then
        echo "Cannot find branch \"${TEST_BRANCH}\" on the remote. Is the name correct?"
        exit 1
    fi    

    startbranch=$(current_branch)
    if [ "${startbranch}" != "${PRODUCTION_BRANCH}" ]; then
        git_ignore_errors checkout ${PRODUCTION_BRANCH}
    fi
    
    # Sanity check
    currentbranch=$(current_branch)
    if [ "${currentbranch}" != "${PRODUCTION_BRANCH}" ]; then
        echo "Error switching to ${PRODUCTION_BRANCH}, cannot continue. Seek help!"
        exit 1
    fi
        
    # Update master
    git_halt_on_error reset --hard origin/${PRODUCTION_BRANCH}
    
    # Merge test branch
    git_ignore_errors merge --no-ff origin/${TEST_BRANCH}
    if [ $? -gt 0 ]; then
	echo "There were conflicts during the merge. If they are trivial please fix them, resolve the merge with 'git add' & 'git commit' and rerun this command."
	echo "If you are unsure, fail the ticket and the talk to the develop so they can solve the issues."
	git_halt_on_error reset --hard origin/${PRODUCTION_BRANCH}
	exit 1
    fi


    # Save a file of the changes made on this branch for review and point the tester to 
    # a prettier version on github
    # Direct tester to a pretty version of changes on branch on github
    # If the branchname contains forward slashes they must be converted to semi-colons for github and underscores for the filename
    changes_branch_gh=$(echo ${TEST_BRANCH} | sed -e "s@/@;@g")
    changes_branch_file=$(echo ${TEST_BRANCH} | sed -e "s@/@_@g")
    repo_stem=$(git config --get remote.origin.url | sed -e 's@.*github.com[:,/]@@' | sed -e 's@\.git$@@')
    changes_address="https://github.com/${repo_stem}/compare/${changes_branch_gh}"

    changes_file=${HOME}/${changes_branch_file}"_log"
    git log --patch HEAD --not origin/master > ${changes_file}

    # Record what we are testing for later pass/fail
    git config ${BRANCH_CFG_KEY} ${TEST_BRANCH}
    # Record the file for deletion later
    git config ${CHANGESFILE_CFG_KEY} ${changes_file}

    echo
    echo "The log of the set of changes made on this branch has been saved to ${changes_file}"
    echo "For a more readable version please visit ${changes_address}"
    echo
    echo "The code should be reviewed, built & the feature tested."
    echo "When complete if:"
    echo "  success: run 'git test pass'"
    echo "  failure: run 'git test fail'"
    echo
 
}

end_testing() {
    testbranch=$(git config ${BRANCH_CFG_KEY})
    if [ -z ${testbranch} ]; then
        echo "The name of the test branch has not been recorded in the config. Was the testing started with 'git test start'?"
        exit 1
    fi

    if [ $TEST_PASSED -eq 1 ]; then
	echo "Testing passed on ${testbranch}. Push master to remote (y/n)?"
	read publish
	if [ "${publish}" = "y" ]; then
	    git_halt_on_error push origin ${PRODUCTION_BRANCH}
	    # Delete branch on the remote
            git_halt_on_error push origin :${testbranch}
            # Delete local branch if there
            local_branch_exists ${testbranch}
            if [ $? -eq 1 ]; then
		git_halt_on_error branch -D ${testbranch}
            fi
	fi
    else
	echo "Testing failed on branch ${testbranch}. Resetting ${PRODUCTION_BRANCH} to origin/${PRODUCTION_BRANCH}"
        git_halt_on_error reset --hard origin/${PRODUCTION_BRANCH}
    fi

    # Remove the stored keys & changes file
    changes_file=$(git config ${CHANGESFILE_CFG_KEY})
    if [ -f "${changes_file}" ]; then
	rm -f ${changes_file}
    fi
    
    git config --unset ${BRANCH_CFG_KEY}
    git config --unset ${CHANGESFILE_CFG_KEY}
}

main() {
    # Helper functions
    . "${CMDFILE_DIR}/gitworkflow-helpers"
    
    checkargs "$@"

    # We need a clean slate
    local_modifications
    if [ $? -eq 1 ]; then
        echo "You have local modifications. Please either:"
        echo " 1) Commit the changes and rerun this command or"
        echo " 2) Run 'git stash', perform the testing, then run 'git stash pop' when testing has finished"
        exit 1
    fi

    # Has a previous merge been resolved?
    merge_in_progress
    if [ $? -eq 1 ]; then
	echo "It looks like there is a merge in progress."
	echo "Resolve any current conflicts with 'git add' & 'git commit' then rerun this command."
	exit 1
    fi

    # Ensure we have everything from the remote
    git_halt_on_error fetch -p
        
    if [ $START_MODE -eq 1 ]; then
        start_testing
    elif [ $RESULT_MODE -eq 1 ]; then
        end_testing
    fi
}

main "$@"
