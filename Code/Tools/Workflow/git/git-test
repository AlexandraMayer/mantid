#!/bin/sh
# 
# Supports the git test command.
#
# Copyright 2013 ISIS Rutherford Appleton Laboratory & NScD Oak Ridge National Laboratory
#
# This file is part of Mantid.
#
# Mantid is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Mantid is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# File change history is stored at: <https://github.com/mantidproject/mantid>

# Set top-level command name
CMD_NAME="test"
# Branch to merge to for testing
PRODUCTION_BRANCH="master"
# Config key to store tested branch
BRANCH_CFG_KEY=mantid.workflow.testbranch

# Get directory of this file
# The sed expression here replaces all backslashes by forward slashes.
# This helps our Windows users, while not bothering our Unix users.
export CMDFILE_DIR=$(dirname "$(echo "$0" | sed -e 's@\\@/@g')")

usage() {
    echo "Usage: git ${CMD_NAME} start <branchname>"
    echo "       git ${CMD_NAME} pass|fail"
    echo
    echo "In the first form start testing the given <branchname> by checking out ${PRODUCTION_BRANCH} and merging it."
    echo "The branchname that is actually merged is origin/branchname to save checking out a local copy of the branch."
    echo "The name of the branch is recorded in the config for reuse with the second form so that the branch can be deleted"
    echo "Equivalent to:"
    echo "  git fetch -p"
    echo "  git checkout ${PRODUCTION_BRANCH}"
    echo "  git reset --hard origin/${PRODUCTION_BRANCH} (Ensures it looks exactly like origin/${PRODUCTION_BRANCH})"
    echo "  git merge --no-ff <branchname>"
    echo
    echo "In the second form assume testing has started and indicates success/failure. If they"
    echo "  passed: The commits are pushed to origin --> 'git push origin ${PRODUCTION_BRANCH}'"
    echo "  failed: The merged commits are discarded --> 'git reset --hard origin/${PRODUCTION_BRANCH}'"
    echo
    echo "In both forms a fetch & merge of origin/${PRODUCTION_BRANCH} is performed before merging the test branch."
}

checkargs() {
    # Can't use getopt cross-platform
    # 2 args assumes the word start and then a string
    
    TEST_BRANCH=""
    START_MODE=0
    RESULT_MODE=0
    TEST_PASSED=0
    
    if [ $# -eq 2 ]; then
        if [ "$1" != "start" ]; then
            usage
            exit 1
        fi
        START_MODE=1
        TEST_BRANCH=$2
    elif [ $# -eq 1 ]; then
        RESULT_MODE=1
        if [ "$1" = "pass" ]; then
            TEST_PASSED=1
        elif [ "$1" = "fail" ]; then
            TEST_PASSED=0
        else
            usage
            exit 1
        fi
    else
        usage
        exit 1
    fi
}

start_testing() {
   # Is the name correct
    remote_branch_exists ${TEST_BRANCH}
    if [ $? -eq 0 ]; then
        echo "Cannot find branch \"${TEST_BRANCH}\" on the remote. Is the name correct?"
        exit 1
    fi    

    startbranch=$(current_branch)
    if [ "${startbranch}" != "${PRODUCTION_BRANCH}" ]; then
        git_ignore_errors checkout ${PRODUCTION_BRANCH}
    fi
    
    # Sanity check
    currentbranch=$(current_branch)
    if [ "${currentbranch}" != "${PRODUCTION_BRANCH}" ]; then
        echo "Error switching to ${PRODUCTION_BRANCH}, cannot continue. Seek help!"
        exit 1
    fi
    
    # Record what we are testing for later pass/fail
    git config ${BRANCH_CFG_KEY} ${startbranch}
    
    # Update master
    git_halt_on_error reset --hard origin/${PRODUCTION_BRANCH}
    
    # Merge test branch
    git_halt_on_error merge --no-ff origin/${TEST_BRANCH}

    echo "Now build the code & test the changes."
    echo "When complete if:"
    echo "  success: run 'git test pass'"
    echo "  failure: run 'git test fail'"
    echo
 
}

end_testing() {
    testbranch=$(git config ${BRANCH_CFG_KEY})
    if [ -z ${testbranch} ]; then
        echo "The name of the test branch has not been recorded in the config. Was the testing started with 'git test start'?"
        exit 1
    fi

    if [ $TEST_PASSED -eq 1 ]; then
        git_halt_on_error push origin ${PRODUCTION_BRANCH}
        
        # Delete branch on the remote
        git_halt_on_error push origin :${testbranch}
        
        # Delete local branch if there
        local_branch_exists ${testbranch}
        if [ $? -eq 1 ]; then
            git_halt_on_error branch -D ${testbranch}
        fi

    else
         git_halt_on_error reset --hard origin/${PRODUCTION_BRANCH}
    fi

    # Remove the stored name
    git config --remove ${BRANCH_CFG_KEY}
}

main() {
    # Helper functions
    . "${CMDFILE_DIR}/gitworkflow-helpers"
    
    checkargs "$@"

    # We need a clean slate
    local_modifications
    if [ $? -eq 1 ]; then
        echo "You have local modifications. Please either:"
        echo " 1) Commit the changes and rerun this command or"
        echo " 2) Run 'git stash', perform the testing, then run 'git stash pop' when testing has finished"
        exit 1
    fi

    # Ensure we have everything from the remote
    git_halt_on_error fetch -p
        
    if [ $START_MODE -eq 1 ]; then
        start_testing
    elif [ $RESULT_MODE -eq 1 ]; then
        end_testing
    fi
}

main "$@"
