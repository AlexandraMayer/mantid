#include "RebinningCutterObjectPanel.h"
#include "pqObjectPanelInterface.h"
#include "pqPropertyManager.h"
#include "pqNamedWidgets.h"
#include "vtkSMStringVectorProperty.h"
#include <QLayout>
#include <QMessageBox>
#include <QCheckBox>
#include "GeometryWidget.h"
#include "MantidVatesAPI/RebinningCutterPresenter.h"
#include "MantidVatesAPI/GeometryXMLParser.h"

RebinningCutterObjectPanel::RebinningCutterObjectPanel(pqProxy* pxy, QWidget* p) :
pqAutoGeneratedObjectPanel(pxy, p), m_geometryXMLString("")
{
  //Auto generated widgets are replaced by Custom Widgets. Autogenerated ones need to be removed.
  removeAutoGeneratedWidgets();

  //Empty geometry widget added to layout.
  m_geometryWidget = new GeometryWidget(DisableDimensionLimits);
  this->layout()->addWidget(m_geometryWidget);
}

/// Event handler for framework event.
void RebinningCutterObjectPanel::updateInformationAndDomains()
{
  this->proxy()->UpdatePropertyInformation();

  vtkSMStringVectorProperty* inputGeometryProperty = vtkSMStringVectorProperty::SafeDownCast(
    this->proxy()->GetProperty("InputGeometryXML"));

  std::string geometryXMLString = inputGeometryProperty->GetElement(0);

  if(m_geometryXMLString != geometryXMLString) //Only attempt to reconstruct the geometry widget if the xml has changed.
  {
    try
    {
      Mantid::VATES::GeometryXMLParser xmlParser(geometryXMLString);
      m_geometryWidget->constructWidget(xmlParser);
      connect(m_geometryWidget, SIGNAL(ignoreBinChanges()), this, SLOT(ignoreBinChangesListner()));

      vtkSMProperty * appliedGeometryXML = this->proxy()->GetProperty("AppliedGeometryXML");

      //Hook up geometry change event to listener on filter.
      this->propertyManager()->registerLink(m_geometryWidget, "GeometryXML",
        SIGNAL(valueChanged()), this->proxy(), appliedGeometryXML);

      m_geometryXMLString = geometryXMLString;
    }
    catch(std::exception& ex)
    {
      QMessageBox::information(NULL, "Setup Not possible.",
        "Could not interpret metadata. Are you using a rebinning source? Check field data.");
    }
  }
}

/// Direct removal of autogenerated widgets.
void RebinningCutterObjectPanel::removeAutoGeneratedWidgets()
{
  popWidget(); // Autogenerated Geometry QLineEdit
  popWidget(); // Autogenerated Geometry QLabel
}

/// Pop widgets off the layout and hide them.
void RebinningCutterObjectPanel::popWidget()
{
  //Pop the last widget off the layout and hide it.
  QLayoutItem* pLayoutItem = layout()->itemAt(layout()->count() - 1);
  QWidget* pWidget = pLayoutItem->widget();
  if (NULL == pWidget)
  {
    throw std::domain_error(
      "Error ::popWidget(). Attempting to pop a non-widget object off the layout!");
  }
  else
  {
    pWidget->setHidden(true);
    this->layout()->removeItem(pLayoutItem);
  }
}

/// Listener for ignore bin changes.
void RebinningCutterObjectPanel::ignoreBinChangesListner()
{
  QLayoutItem *child;
  unsigned int size = layout()->count();
  for(unsigned int i = 0; i < size; i++)
  {
    child = layout()->itemAt(i);
    QWidget* pWidget = child->widget();
    if (NULL != pWidget) // capability query of layout item.
    {
      QCheckBox* checkBox;
      if((checkBox = dynamic_cast<QCheckBox*>(pWidget)) != NULL) //capability query of widget.
      {
        // Apply Clip check box set to unchecked.
        checkBox->setChecked(false);
        break;
      }
    }
  }

}
