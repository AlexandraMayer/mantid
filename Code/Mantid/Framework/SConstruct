#For Framework
import os
import platform
import sys
import shutil
import re
import string
from socket import gethostname

import MantidBuild

if ARGUMENTS.get('rpmbuild',0) == 0 :
    rpmBuild = False
else :
    rpmBuild = True

USRLOCALINCLUDE = '/usr/local/include'
USRLOCALLIB = '/usr/local/lib'
USRINCLUDE = '/usr/include'
USRLIB = '%{_usrlibdir}'
MANTIDLIB = '/opt/Mantid/bin'
MANTIDPLUGINS = '/opt/Mantid/plugins'
  
opts = Options('scons_options.py')
opts.Add('debug','Set to 1 to build debug', 0)
opts.Add('matlab','Set to 1 to build matlab API', 0)
opts.Add('gcc44','Set to 1 to build with gcc44 on RHEL5', 0)
opts.Add('xunitoutput','Set to 1 to make tests output xUnit XML',0)

env = Environment(ENV=os.environ, options = opts)
Help(opts.GenerateHelpText(env))
debug = ARGUMENTS.get('debug', 0)

# on RHEL5 gcc 4.1 is the default
# gcc 4.4 installed under a different name
gcc44 = ARGUMENTS.get('gcc44', 0)

# Check for RHEL5, if so then force gcc44
if platform.dist()[2] == 'Tikanga':
	gcc44 = 1

if int(gcc44) :
    if sys.platform == 'darwin':
        env.Replace(
        CC = '/opt/local/bin/gcc-mp-4.4',
        CXX = '/opt/local/bin/g++-mp-4.4')
    else:
        env["CC"] = "gcc44"
        env["CXX"] = "g++44"
        env["SHCC"] = "gcc44"
        env["SHCXX"] = "g++44"

#get libraries and the library directories
print 'Current path == ',os.getcwd()
cwdpath=os.getcwd()

libList = []
libDirList = []
cflags = []
dirList = []
cppPaths = []
cppdefines = []
lpts = []

boost_path = ''
boost_append = ''
poco_path = ''
nexus_path = ''
third_party = os.path.abspath('../Third_Party/')
opencascade_path = ''
python_path = ''
win64 = ''

# Send debug and release builds to the right place
dest_dir = './release'
if int(debug) == 1:
    dest_dir = './debug'

#Get paths
if os.name == 'nt': 
	print "* COMMENCING WINDOWS BUILD *"
	
	# Get the version of Visual Studio
	vsversion = env['MSVS_VERSION']
	
	boost_path = third_party + '/include/'
	
	python_path = 'C:/Python25/'
	opencascade_path=third_party + '/include/OpenCascade'
	if int(debug) == 0:
		libList.append('PocoUtil')
		libList.append('PocoFoundation')
		libList.append('PocoXML')
	else:
		libList.append('PocoUtild')
		libList.append('PocoFoundationd')
		libList.append('PocoXMLd')
	
	libDirList.append(python_path + '/libs/')
	
	win64=ARGUMENTS.get('win64',0)
	
	if not int(win64):
		libDirList.append(third_party + '/lib/win32/')
		cppPaths
	else:
		print "* Building for 64bit Windows *"
		libDirList.append(third_party + '/lib/win64/')
	
	libList.append('python25')

	libList.append('gsl')
	libList.append('ws2_32')   # winsock library
	libList.append('muparser') # Muparser used in DataHandling
	libList.append('zlib1')    # used in DataObjects

	cppPaths = [boost_path, third_party + '/include/', python_path + '/include/', opencascade_path, third_party+'/include/muParser', third_party+'/include/zlib123', third_party+'/include/hdf5']

	if not int(win64):
		cppPaths.append(third_party+'/include/hdf5/win32/');
	else:
		cppPaths.append(third_party+'/include/hdf5/win64/');

	
	#set up scons to embed manifest files on compilers prior to VS2010
	if vsversion != '10.0':
		env['LINKCOM'] = [env['LINKCOM'], 'mt.exe -nologo -manifest ${TARGET}.manifest -outputresource:$TARGET;1']
		env['SHLINKCOM'] = [env['SHLINKCOM'], 'mt.exe -nologo -manifest ${TARGET}.manifest -outputresource:$TARGET;2']

else:

	print "* COMMENCING LINUX BUILD *"
	f=open('Build/Scons_Linux.conf', 'r')
	for ln in f:
		boost_path=MantidBuild.procHeaderPath(ln,'BOOST_ROOT',boost_path)
		poco_path=MantidBuild.procHeaderPath(ln,'POCO_ROOT',poco_path)
		python_path=MantidBuild.procHeaderPath(ln,'PYTHON_LIB',python_path)
		boost_append=MantidBuild.procHeader(ln,'BOOST_APPEND',boost_append)
		nexus_path=MantidBuild.procHeader(ln,'NEXUS_ROOT',nexus_path)
	f.close()
		
	# Store boost append and nexus path to pass to dependent SConscripts
	env['BOOST_APPEND'] = boost_append
	env['NEXUS_ROOT'] = nexus_path
	opencascade_path= '/opt/OpenCASCADE'
	
	
print "POCO_ROOT: ",poco_path
print "BOOST_ROOT: ",boost_path
print "BOOST_APPEND: ",boost_append
print "THIRD_PARTY: ",third_party
print "PYTHON_ROOT: ",python_path
print "NEXUS ROOT:", nexus_path

if os.name == 'nt':
    env.Append(CPPDEFINES = ['_SCL_SECURE_NO_WARNINGS', '_CRT_SECURE_NO_WARNINGS', '_CRT_SECURE_NO_DEPRECATE', '_CRT_NONSTDC_NO_DEPRECATE', '_SCL_SECURE_NO_DEPRECATE'])
    env.Append(CPPDEFINES = [('MS_VISUAL_STUDIO','1'), ('WINVER','0x0500')])
    env.Append(CPPDEFINES = ['BOOST_ALL_DYN_LINK','NOMINMAX','_USE_MATH_DEFINES', 'WNT'])
    # MG: Even though MSVC defines "_WIN32" gsl checks for "WIN32" and Poco checks for "_WINDOWS" hence the additional defines.
    # We should stick to the standard _WIN32 check though as this is guaranteed to be defined by the MSVC compiler
    env.Append(CPPDEFINES = ['WIN32','_WINDOWS', 'POCO_DLL', 'GSL_DLL'])
    if int(debug) :
        cflags = [ '/W3', '/Od', '/FD', '/EHsc', '/MDd', '/TP',  ]
        cflags.extend([ '/wd4275', '/wd4996'])
        env.Append(CPPDEFINES = ['_DEBUG'])
    else :
        cflags = ['/GL', '/openmp', '/W3','/EHsc', '/MD', '/TP']
        # Optimzation flags. Note that there is a bug in the 64-bit VS 2010 compiler when using the /O2 compiler option so until the hotfix for this is obtained use /O1
        # Bug information here: http://support.microsoft.com/kb/2280741
        if int(win64):
            cflags.extend(['/O1'])
        else:
            cflags.extend(['/O2'])
        cflags.extend(['/wd4251', '/wd4275', '/wd4996'])
        env.Append(LINKFLAGS=['/OPT:REF','/OPT:ICF','/ltcg'])
        # WIN98 optimisation no longer available in VS2010 so option removed
        if vsversion != '10.0':
          env.Append(LINKFLAGS=['/OPT:NOWIN98'])
        
elif platform.system() == 'Linux':
	if not rpmBuild:
		cppPaths.append(poco_path)
		libDirList.append(USRLOCALLIB)
		if os.path.isdir('/usr/local/poco-1.3.1/'+ '/lib/Linux/i686') :
			libDirList.append('/usr/local/poco-1.3.1/' +'/lib/Linux/i686')
		else :
			libDirList.append(poco_path+'/lib')
	else:
		cppPaths.append(USRLOCALINCLUDE + '/Poco/')
		cppPaths.append(USRLOCALINCLUDE+'/Poco/Util')
		
	cppPaths.append(boost_path)
	cppPaths.append(USRINCLUDE)
	cppPaths.append(USRLOCALINCLUDE)
	cppPaths.append(USRINCLUDE+'/muParser')
	
	libDirList.append(USRLIB)

elif platform.system() == 'Darwin':

	cppPaths.append(third_party+'/include')
	cppPaths.append(third_party+'/include/muParser')
        cppPaths.append(third_party+'/include/hdf5')
	env.Append(SHLINKFLAGS='-install_name @executable_path/./${TARGET.file}')
	# Get the version as a tuple
	mac_version = tuple(platform.mac_ver()[0].split(".")[0:2])
	snow_leopard = ('10', '6')
	if mac_version >= snow_leopard:
		print '* Building for Mac OS X 10.6 (Snow Leopard) *'
		libDirList.append(third_party+'/lib/mac-10.6')
	else:
		libDirList.append(third_party+'/lib/mac')
	
if os.name == 'posix':
	cppPaths.append(USRINCLUDE+ '/python' + sys.version[0:3])
	# I've seen nasty things mixing poco release and debug stuff
	if int(debug) == 0:
		libList.append('PocoUtil')
		libList.append('PocoFoundation')
		libList.append('PocoXML')
	else:
		libList.append('PocoUtild')
		libList.append('PocoFoundationd')
		libList.append('PocoXMLd')

	libList.append('boost_regex'+boost_append)
	libList.append('boost_signals'+boost_append)
	libList.append('boost_date_time'+boost_append)
	libList.append('muparser')
	libList.append('gsl')
        libList.append('z')

	# OpenMP support library which doesn't get linked by default for some reason
	# Add the library if it is available on the system
	conf = Configure(env)
	if conf.CheckLib('gomp'):
	   print 'Found OpenMP runtime library, adding to linker list'
	   libList.append('gomp')
	   cflags.append('-fopenmp')
	conf.Finish()

	cflags.append('-Wall')
	cflags.append('-Wextra')
	# Debug symbols are useful in release too
	cflags.append('-g')
	lpts.append('-g')

	if int(debug) :
	    cflags.append('-O0')
	else :
	    cflags.append('-O3')

	cflags.append(MantidBuild.getConfigFlags('gsl-config --cflags'))
	lpts.append(MantidBuild.getConfigFlags('gsl-config --libs'))

print "CPPPATHS: ",cppPaths
print "CFLAGS: ",cflags

libDirList.append(os.path.abspath(dest_dir))

#Export for SConscripts
env.Append(CCFLAGS=cflags)
cppPaths.append('inc')
env.Append(CPPPATH=cppPaths)
env.Replace(MYLIBLIST=libList)
env.Replace(MYLIBDIRLIST=libDirList)

#check existence of Header files
conf = Configure(env)
if conf.CheckCXXHeader('unordered_map.h'):
	conf.env.Append(CPPDEFINES = ['HAS_UNORDERED_MAP_H'])
if not conf.CheckCXXHeader('Notification.h') and not conf.CheckCXXHeader('Poco/Notification.h'):
    print "Failed to find 'Poco/Notification.h'"
    Exit(-1)
if not conf.CheckCXXHeader('muParser.h') and not conf.CheckCXXHeader('muParser/muParser.h'):
    print "Failed to find 'muParser/muParser.h'"
    Exit(-1)
if not conf.CheckCXXHeader('gsl_multimin.h') and not conf.CheckCXXHeader('gsl/gsl_multimin.h'):
    print "Failed to find 'gsl/gsl_multimin.h'"
    Exit(-1)
if not conf.CheckCXXHeader('napi.h'):
    print "Failed to find 'napi.h'"
    Exit(-1)
if not conf.CheckCXXHeader('ssl.h') and not conf.CheckCXXHeader('openssl/ssl.h'):
   print "Failed to find 'openssl/ssl.h'"
   Exit(-1)
if conf.CheckCXXHeader("stdint.h"):
   conf.env.Append(CPPDEFINES = ['HAVE_STDINT_H'])
env = conf.Finish()

#Collect the includes into a single directory 
MantidBuild.collectIncludes('.', 'includes') 

if platform.system() == 'Linux':	
  if rpmBuild :
    lpts.append('-Wl,-rpath,'+MANTIDLIB)
    lpts.append('-Wl,-rpath,'+MANTIDPLUGINS)
  else :
    ##
    ## BIT FOR -Wl,-rpath : This avoids the STUPID STUPID export LD_PATH in run_test 
    ## 
    lpts.append('-Wl,-rpath,' + dest_dir)
  print 'LINKFLAGS: ',lpts
  env.Append(LINKFLAGS=lpts)
elif platform.system() == 'Darwin':
  env.Append(LINKFLAGS='-headerpad_max_install_names')
elif os.name == 'nt': 
  if int(win64):
    lpts.append('/MACHINE:X64')
    env.Append(LINKFLAGS=lpts)
    print 'LINKFLAGS: ',lpts

#Disable assert macro.
if int(debug) == 0:
  env.Append(CPPDEFINES=['NDEBUG'])

# Add defines for CPP
env.Append(CPPDEFINES=["BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG"])

Export('env')

# Real work begins here
import release_version
release_version.writeMantidVersion()

# This order matters slightly! Kernel-geometry-api in that order
coreSubProjs = []
coreSubProjs.append('Kernel')
coreSubProjs.append('Geometry')
coreSubProjs.append('API')

for subproj in coreSubProjs:
	ret = SConscript([subproj+'/SConscript'])
	env.Install(dest_dir, ret['shared'])
	env.Append(MYLIBLIST=ret['libs'])
	env.Append(CPPPATH='#/'+subproj+'/inc')

# Now build DataObjects, PythonAPI & MatlabAPI, 
# which depend on Kernel, Geometry & API.
# Python interface
ret = SConscript('PythonAPI/SConscript')
env.Install(dest_dir, ret['shared'])
# MATLAB interface
matlab = ARGUMENTS.get('matlab', 0)
if int(matlab) :
       ret = SConscript(['MatlabAPI/SConscript'])
       env.Install(dest_dir, ret['shared'])
# Now DataObjects, and insert into list of dependencies
ret = SConscript('DataObjects/SConscript')
env.Install(dest_dir, ret['shared'])
env.Append(MYLIBLIST=ret['libs'])
env.Append(CPPPATH=['#/DataObjects/inc'])

# Now build the libraries which depend on Kernel, Geomerty, API & DataObjects
subProjs = []
subProjs.append('CurveFitting')
subProjs.append('Algorithms')
subProjs.append('DataHandling')
subProjs.append('Nexus')
subProjs.append('Crystal')
subProjs.append('ICat')

for subproj in subProjs:
    ret = SConscript(subproj+'/SConscript')
    if ( len(ret) > 0 ):
       env.Install(dest_dir, ret['shared'])    

# User Algs
# Currently has a dependency on CurveFitting (which ought to be removed)
env.Append(MYLIBLIST='MantidCurveFitting')
env.Append(CPPPATH='#/CurveFitting/inc')
ret = SConscript(['UserAlgorithms/SConscript'])
env.Install('Build/Plugins', ret['shared'])

# Copy required files to the build destination
Command(dest_dir+'/Mantid.properties','Properties/Mantid.properties',Copy("$TARGET","$SOURCE"))
Command(dest_dir+'/MantidFramework.py','PythonAPI/MantidFramework.py',Copy("$TARGET","$SOURCE"))
Command(dest_dir+'/__init__.py','PythonAPI/__init__.py',Copy("$TARGET","$SOURCE"))
Command(dest_dir+'/setup.py','PythonAPI/setup.py',Copy("$TARGET","$SOURCE"))

# The unit tests
skiptest=ARGUMENTS.get('skiptest',0)
if not int(skiptest) and not env.GetOption('clean'):
	print 'Building Tests.  Specify "skiptest=1" to skip the tests'
	# tests
	hudsonbuild=ARGUMENTS.get('xunitoutput',0)
	if not int(hudsonbuild):
		ret = SConscript(['Build/Tests/SConscript'])
	else:
		print 'Using xUnit Output'
		ret = SConscript(['Build/Tests/SConscript_hudson'])
else:
	print "Not Building Tests."
