/*WIKI*

Integrates SCD peaks with a range of radii, in order to plot graphs of the integrated intensity vs radius. This can be useful to determine the correct integration radius for each peak.

[[File:PeakIntensityVsRadius_fig.png|center|350px|{Integrated peak intensity vs integration radius for 3 SCD peaks}]]

The algorithm requires a [[MDWorkspace]] of SCD data in reciprocal space; generated by e.g. [[ConvertToDiffractionMDWorkspace]]. Also, you will need a [[PeaksWorkspace]] as the list of peaks to integrate. This can be generated using [[FindPeaksMD]], for example.

The output will be
a [[Workspace2D]] with one spectrum per peak, where:
* X = peak radius
* Y/E = integrated intensity and error for the corresponding radius.
* Each peak is labeled with a string with "H K L". Use [[IndexPeaks]] to automatically find HKL values for peaks.

This algorithm calls [[IntegratePeaksMD]] repeatedly, with the following
parameters filled in:
* '''PeakRadius''' = the radius, ranging from RadiusStart to RadiusEnd in NumSteps steps.
* '''BackgroundStartRadius''' = radius * BackgroundStartFactor
* '''BackgroundRadius''' = radius * BackgroundEndFactor


*WIKI*/

#include "MantidCrystal/PeakIntensityVsRadius.h"
#include "MantidKernel/System.h"
#include "MantidKernel/Strings.h"
#include "MantidDataObjects/PeaksWorkspace.h"
#include "MantidAPI/IMDEventWorkspace.h"
#include "MantidAPI/TextAxis.h"

using namespace Mantid::Kernel;
using namespace Mantid::API;
using namespace Mantid::DataObjects;

namespace Mantid
{
namespace Crystal
{

  // Register the algorithm into the AlgorithmFactory
  DECLARE_ALGORITHM(PeakIntensityVsRadius)
  


  //----------------------------------------------------------------------------------------------
  /** Constructor
   */
  PeakIntensityVsRadius::PeakIntensityVsRadius()
  {
  }
    
  //----------------------------------------------------------------------------------------------
  /** Destructor
   */
  PeakIntensityVsRadius::~PeakIntensityVsRadius()
  {
  }
  

  //----------------------------------------------------------------------------------------------
  /// Algorithm's name for identification. @see Algorithm::name
  const std::string PeakIntensityVsRadius::name() const { return "PeakIntensityVsRadius";};
  
  /// Algorithm's version for identification. @see Algorithm::version
  int PeakIntensityVsRadius::version() const { return 1;};
  
  /// Algorithm's category for identification. @see Algorithm::category
  const std::string PeakIntensityVsRadius::category() const { return "Crystal";}

  //----------------------------------------------------------------------------------------------
  /// Sets documentation strings for this algorithm
  void PeakIntensityVsRadius::initDocs()
  {
    this->setWikiSummary("Calculate the integrated intensity of peaks vs integration radius.");
    this->setOptionalMessage("Calculate the integrated intensity of peaks vs integration radius.");
  }

  //----------------------------------------------------------------------------------------------
  /** Initialize the algorithm's properties.
   */
  void PeakIntensityVsRadius::init()
  {
    declareProperty(new WorkspaceProperty<IMDEventWorkspace>("InputWorkspace","",Direction::Input),
        "An input MDEventWorkspace containing the SCD data.");
    declareProperty(new WorkspaceProperty<PeaksWorkspace>("PeaksWorkspace","",Direction::Input),
        "The list of peaks to integrate, matching the InputWorkspace.");

    std::vector<std::string> propOptions;
    propOptions.push_back("Q (lab frame)");
    propOptions.push_back("Q (sample frame)");
    propOptions.push_back("HKL");
    declareProperty("CoordinatesToUse", "Q (lab frame)",new ListValidator(propOptions),
      "Which coordinates of the peak center do you wish to use to integrate the peak? This should match the InputWorkspace's dimensions."
       );

    declareProperty("RadiusStart", 0.0, "Radius at which to start integrating." );
    declareProperty("RadiusEnd", 1.0, "Radius at which to stop integrating." );
    declareProperty("NumSteps", 10, "Number of steps, between start and end, to calculate radius." );
    declareProperty("BackgroundStartFactor", 0.0,
        "For background subtraction: the peak radius will be multiplied\n"
        "by this factor and passed to the BackgroundStartRadius parameter.\n"
        "Default 0.0 (no background)." );
    declareProperty("BackgroundEndFactor", 0.0,
        "For background subtraction: the peak radius will be multiplied\n"
        "by this factor and passed to the BackgroundRadius parameter.\n"
        "Default 0.0 (no background)." );

    declareProperty(new WorkspaceProperty<>("OutputWorkspace","",Direction::Output),
        "An output workspace2D containing intensity vs radius.");
  }

  //----------------------------------------------------------------------------------------------
  /** Execute the algorithm.
   */
  void PeakIntensityVsRadius::exec()
  {
    IMDEventWorkspace_sptr inWS = getProperty("InputWorkspace");
    PeaksWorkspace_sptr peaksWS = getProperty("PeaksWorkspace");
    double RadiusStart = getProperty("RadiusStart");
    double RadiusEnd = getProperty("RadiusEnd");
    double BackgroundStartFactor = getProperty("BackgroundStartFactor");
    double BackgroundEndFactor = getProperty("BackgroundEndFactor");
    int NumSteps = getProperty("NumSteps");

    // Create a workspace with one spectrum per peak, and one point per radius step
    MatrixWorkspace_sptr outWS = WorkspaceFactory::Instance().create("Workspace2D", peaksWS->getNumberPeaks(), NumSteps, NumSteps);

    // Create a text axis for axis(1), with H K L of each peak
    TextAxis * ax = new TextAxis(outWS->getNumberHistograms());
    for (int i=0; i<peaksWS->getNumberPeaks(); i++)
    {
      V3D hkl = peaksWS->getPeak(i).getHKL();
      hkl.round(); // Round HKL to make the string prettier
      ax->setLabel(size_t(i), hkl.toString());
    }
    outWS->replaceAxis(1, ax);

    Progress prog(this, 0.0, 1.0, NumSteps);
    double progStep = 1.0 / double(NumSteps);
    for (int step = 0; step < NumSteps; step++)
    {
      // Step from RadiusStart to RadiusEnd, inclusively
      double radius = RadiusStart + double(step) * (RadiusEnd - RadiusStart) / (double(NumSteps-1));
      g_log.debug() << "Integrating radius " << radius << std::endl;
      prog.report("Radius " + Kernel::Strings::toString(radius));

      // Run the integrate algo with this background
      IAlgorithm_sptr alg = this->createSubAlgorithm("IntegratePeaksMD", progStep*double(step), progStep*double(step+1), false);
      alg->setProperty("InputWorkspace", inWS);
      alg->setProperty("PeaksWorkspace", peaksWS);
      alg->setPropertyValue("CoordinatesToUse", this->getPropertyValue("CoordinatesToUse"));
      alg->setProperty("PeakRadius", radius);
      alg->setProperty("BackgroundRadius", radius * BackgroundEndFactor);
      alg->setProperty("BackgroundStartRadius", radius * BackgroundStartFactor);
      alg->setPropertyValue("OutputWorkspace", "__tmp__PeakIntensityVsRadius");
      alg->execute();
      if (alg->isExecuted())
      {
        // Retrieve the integrated workspace
        PeaksWorkspace_sptr outPeaks = alg->getProperty("OutputWorkspace");
        for (int i=0; i<outPeaks->getNumberPeaks(); i++)
        {
          size_t wi = size_t(i); // workspace index in output
          IPeak & p = outPeaks->getPeak(i);
          outWS->dataX(wi)[step] = radius;
          outWS->dataY(wi)[step] = p.getIntensity();
          outWS->dataE(wi)[step] = p.getSigmaIntensity();
        }
      }
      else
      {
        //TODO: Clear the point
      }
    }

    // Fix units and labels
    outWS->setYUnit("Integrated Intensity");
    outWS->getAxis(0)->title() = "Radius";

    setProperty("OutputWorkspace", outWS);
  }



} // namespace Mantid
} // namespace Crystal
