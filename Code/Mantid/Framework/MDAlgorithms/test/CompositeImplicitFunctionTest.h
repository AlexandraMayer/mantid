#ifndef COMPOSITE_IMPLICIT_FUNCTION_TEST_H_
#define COMPOSITE_IMPLICIT_FUNCTION_TEST_H_

#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <cxxtest/TestSuite.h>
#include <cmath>
#include <typeinfo>

#include "MantidMDAlgorithms/CompositeImplicitFunction.h"
#include "MantidAPI/Point3D.h"

class CompositeImplicitFunctionTest : public CxxTest::TestSuite
{
private:

  //Fake ImplicitFunction to verify abstract treatement of nested functions by composite.
  class MockImplicitFunction : public Mantid::API::ImplicitFunction
  {
  public:
    MOCK_CONST_METHOD1(evaluate, bool(const Mantid::API::Point3D* pPoint));
    MOCK_CONST_METHOD0(getName, std::string());
    MOCK_CONST_METHOD0(toXMLString, std::string());
    ~MockImplicitFunction(){}
  };

private:

  class MockPoint3D: public Mantid::API::Point3D
  {
  public:
    MOCK_CONST_METHOD0(getX, double());
    MOCK_CONST_METHOD0(getY, double());
    MOCK_CONST_METHOD0(getZ, double());
  };


public:

  void testFunctionAddition()
  {
    using namespace Mantid::MDAlgorithms;
    CompositeImplicitFunction composite;
    composite.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(new MockImplicitFunction()));
    composite.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(new MockImplicitFunction()));
    TSM_ASSERT_EQUALS("Two functions should have been added to composite", 2, composite.getNFunctions());
  }


  void testEvaluateNestedFunctions()
  {
    using namespace Mantid::MDAlgorithms;

    CompositeImplicitFunction composite;
    MockImplicitFunction* a = new MockImplicitFunction;
    MockImplicitFunction* b = new MockImplicitFunction;
    EXPECT_CALL(*a, evaluate(testing::_)).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*b, evaluate(testing::_)).Times(1);

    composite.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(a));
    composite.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(b));

    MockPoint3D* point = new MockPoint3D;

    composite.evaluate(point);
    TSM_ASSERT("This nested function should have been executed", testing::Mock::VerifyAndClearExpectations(a));
    TSM_ASSERT("This nested function should have been executed", testing::Mock::VerifyAndClearExpectations(b));
    delete point;
  }




  void testRecursiveToXML()
  {
    using namespace Mantid::MDAlgorithms;

    MockImplicitFunction* mockFunctionA = new MockImplicitFunction;
    MockImplicitFunction* mockFunctionB = new MockImplicitFunction;

    EXPECT_CALL(*mockFunctionA, toXMLString()).Times(1).WillOnce(testing::Return("<Function></Function>"));
    EXPECT_CALL(*mockFunctionB, toXMLString()).Times(1).WillOnce(testing::Return("<Function></Function>"));

    CompositeImplicitFunction function;
    function.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(mockFunctionA));	
    function.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(mockFunctionB));	

    TSM_ASSERT_EQUALS("The xml generated by this function did not match the expected schema.", "<Function><Type>CompositeImplicitFunction</Type><ParameterList/><Function></Function><Function></Function></Function>", function.toXMLString());
  }

  void testNotEqual()
  {
    using namespace Mantid::MDAlgorithms;

    CompositeImplicitFunction A;
    CompositeImplicitFunction B;
    CompositeImplicitFunction C;
    C.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(new MockImplicitFunction));
    TSM_ASSERT_DIFFERS("These two objects should not be considered equal as they both have zero nested functions.", A, B);
    TSM_ASSERT_DIFFERS("These two objects should not be considered equal as they have and unequal number of nested functions.", A, C);		
  }

  void testReturnNestedFunctions() //Test access to nested functions.
  {
    using namespace Mantid::MDAlgorithms;
    CompositeImplicitFunction function;

    MockImplicitFunction* mockFunctionA = new MockImplicitFunction;
    MockImplicitFunction* mockFunctionB = new MockImplicitFunction;
    MockImplicitFunction* mockFunctionC = new MockImplicitFunction;
    EXPECT_CALL(*mockFunctionA, getName()).Times(1).WillOnce(testing::Return("A"));
    EXPECT_CALL(*mockFunctionB, getName()).Times(1).WillOnce(testing::Return("B"));
    EXPECT_CALL(*mockFunctionC, getName()).Times(1).WillOnce(testing::Return("C"));

    function.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(mockFunctionA));
    function.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(mockFunctionB));
    function.addFunction(boost::shared_ptr<Mantid::API::ImplicitFunction>(mockFunctionC));

    std::vector<boost::shared_ptr<Mantid::API::ImplicitFunction> > returnedFuncs = function.getFunctions();
    std::vector<boost::shared_ptr<Mantid::API::ImplicitFunction> >::const_iterator it = returnedFuncs.begin();

    TSM_ASSERT_EQUALS("The returned function did not match input function type", (*it)->getName(), "A" );
    it++;
    TSM_ASSERT_EQUALS("The returned function did not match input function type", (*it)->getName(), "B"  );
    it++;
    TSM_ASSERT_EQUALS("The returned function did not match input function type", (*it)->getName(), "C"  );
  }

};


#endif 
