#ifndef MD_FILE_FORMAT_FACTORY_H
#define MD_FILE_FORMAT_FACTORY_H
//----------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------
#include "MDDataObjects/IMD_FileFormat.h"
#include "MantidGeometry/MDGeometry/MDGeometryDescription.h"
#include "MantidKernel/System.h"

/** The class takes the file name and returns file the reader/writer which would understand and interpret the file format 
 *  of the file, provided. If the file is not found, the factory returns the default reader or the one, modified 
 *
 *  The file reader has to satisfy IMD_FileFormat interface
 *
 * not a factory in Mantid sence, as the rules to select file format are defined within the class, so user who creates new format
 * has to add these rules to the class manualy 
 *
 * Proper Mantid factory will be build if this class widely used in a future;

    @author Alex Buts, RAL ISIS
    @date 03/12/2010

    Copyright &copy; 2007-10 ISIS Rutherford Appleton Laboratory & NScD Oak Ridge National Laboratory

    This file is part of Mantid.

    Mantid is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    Mantid is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    File change history is stored at: <https://svn.mantidproject.org/mantid/trunk/Code/Mantid>.
      Code Documentation is available at: <http://doxygen.mantidproject.org>
*/
namespace Mantid
{
namespace MDDataObjects
{
	/** the enum describes the request, a user can make to ask for a particular file reader 
	 *  we are not suppose to handle very complex requests as the file reader should be selected
	 *  acdording to the file format
	*/
	enum user_request{
		best_fit,  //< default file reader
		test_data  //< the reader, which does not reads the file, but returns fake data for rebinning;
	};

class DLLExport MD_FileFormatFactory
{
public:
	/** function returns the file reader which would understand the file format of the file,
	 *  defined by the file name provided.
	 *
	 *  If the file has not been found, the function assumes the 
	 *  new file and returns defauld file reader, bound to this new file
	 */
	static std::auto_ptr<IMD_FileFormat> getFileReader(const char *fileName,user_request rec=best_fit,
		                                               const Geometry::MDGeometryDescription *const pDescr=NULL);
    /** function returns a new file reader/writer with unique temporary name generated by the factory 
     * used for allocation of temporary working files for a target MD workspace; If the target file name 
     * is present, and the file name exists, the file reader get called, while if the file is new, 
     * the new file is created where requested;
     */
    static std::auto_ptr<IMD_FileFormat> getFileReader(user_request rec=best_fit,const char *fileName=NULL);
private:
	// singleton holder
	static MD_FileFormatFactory *pFactory;
	// default constructor and others;
	MD_FileFormatFactory();
	~MD_FileFormatFactory();
	// no copying
	MD_FileFormatFactory(const MD_FileFormatFactory &);
	MD_FileFormatFactory & operator= (const MD_FileFormatFactory &);

   /// logger -> to provide logging, for MD dataset file operations
    static Mantid::Kernel::Logger& f_log;

	IMD_FileFormat* select_file_reader(const char *file_name,user_request rec=best_fit,
		                               const Geometry::MDGeometryDescription *const pDescr=NULL);
	/// function checks if the file provided is binary Horace format file;
	bool isHoraceFile(const char *fileName);

};
/** helper function providing a new file name as a from template and a counter
 *  function checks if a temporary file exists and increases the counter untill finds a file name with free number
*/
DLLExport std::string get_unique_tmp_fileName(void);
} // end namespaces
}
#endif
