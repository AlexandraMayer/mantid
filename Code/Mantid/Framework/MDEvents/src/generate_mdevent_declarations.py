""" Simple script that generates references to all
needed MDEvent<X> instantiations. """
import sys
import os
import time
import datetime

# List of the dimensions to instantiate
dimensions = range(1,10)

topheader = """/* Auto-generated by '%s' 
 *     on %s
 *
 * DO NOT EDIT!
 */ 
 
#include <boost/shared_ptr.hpp>
#include <MantidMDEvents/MDEventFactory.h>
#include <MantidMDEvents/IMDEventWorkspace.h>
#include <MantidMDEvents/MDEventWorkspace.h>
 
""" % (__file__, datetime.datetime.now())
 
header = """
namespace Mantid
{
namespace MDEvents
{
""" 


footer = """
} // namespace Mantid
} // namespace MDEvents 

/* THIS FILE WAS AUTO-GENERATED BY %s - DO NOT EDIT! */ 
""" % (__file__)


#============================================================================================================
#============================================================================================================
factory_top = """

/** Create a MDEventWorkspace of the given type
@param nd :: number of dimensions
@param eventType :: string describing the event type (currently ignored) 
*/
IMDEventWorkspace_sptr MDEventFactory::CreateMDEventWorkspace(size_t nd, std::string eventType)
{
  switch(nd)
  {
"""
factory_lines = """  case (%d):
    return boost::shared_ptr<MDEventWorkspace<%s,%d> >(new MDEventWorkspace<%s,%d>);
"""
factory_bottom = """  default:
    throw std::invalid_argument("Invalid number of dimensions passed to CreateMDEventWorkspace.");
  }
}
"""

def write_factory(f):
    """ Write out a factory method """
    f.write(factory_top)
    for nd in dimensions:
        eventType = "MDEvent<%d>" % nd
        f.write(factory_lines % (nd,eventType,nd,eventType,nd) )
    f.write(factory_bottom)
        
        
#============================================================================================================
#============================================================================================================
#============================================================================================================

# for the calling function macro
macro_top = "#define CALL_MDEVENT_FUNCTION(funcname, workspace) \\ \n{ \\ \n"
macro = """MDEventWorkspace<%s, %d>::sptr MDEW%d = boost::dynamic_pointer_cast<MDEventWorkspace<%s, %d> >(workspace); \\
if (MDEW%d) funcname<%s, %d>(MDEW%d); \\ 
"""

def write_macro(f):
    f.write( "/* \n");
    f.write( macro_top );
    for nd in dimensions:
        eventType = "MDEvent<%d>" % nd
        f.write(macro % (eventType,nd,nd,eventType,nd,nd,eventType,nd,nd) )
    f.write( "} \n");
    f.write( "*/ \n");

#============================================================================================================
#============================================================================================================
#============================================================================================================

def generate():
    print "Generating MDEventFactory.cpp"

    # Classes that have a .cpp file    
    classes_cpp = ["MDBox", "MDEventWorkspace", "MDGridBox"]
    # All of the classes to instantiate
    classes = classes_cpp + ["MDEvent",  "IMDBox"]
    
    f = open("MDEventFactory.cpp", 'w');
    f.write(topheader)
    
    for c in classes:
        f.write('#include "MantidMDEvents/%s.h"\n' % c)
    
    f.write("\n")
    f.write("// We need to include the .cpp files so that the declarations are picked up correctly. Weird, I know. \n") 
    f.write("// See http://www.parashift.com/c++-faq-lite/templates.html#faq-35.13 \n") 
    for c in classes_cpp:
        f.write('#include "%s.cpp"\n' % c)
    f.write("\n")
    
    f.write(header)

    # MDEvent type (just one template arg)
    classes = ["MDEvent"]
    for c in classes:
        f.write("// Instantiations for %s\n" % c )
        for nd in dimensions:
            f.write("template DLLExport class %s<%d>;\n" % (c, nd) )
        f.write("\n\n")

    # Classes with MDEvent<x>,x
    classes = ["MDBox", "IMDBox", "MDGridBox", "MDEventWorkspace"]
    for c in classes:
        f.write("// Instantiations for %s\n" % c )
        for nd in dimensions:
            f.write("template DLLExport class %s<MDEvent<%d>, %d>;\n" % (c, nd, nd) )
        f.write("\n\n")
            
    # Typedefs for MDEventWorkspace
    for nd in dimensions:
        f.write("/// Typedef for a MDEventWorkspace shared_ptr with %d dimension%s \n" % (nd, ['','s'][nd>1]) )
        f.write("typedef MDEventWorkspace<MDEvent<%d>, %d>::sptr MDEventWorkspace%d;\n" % (nd, nd, nd) )
    f.write("\n\n")
            
    write_factory(f)
    
    write_macro(f)
            
    f.write(footer)
    f.close()
    


if __name__=="__main__":
    generate()
