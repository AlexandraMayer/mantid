#include "MantidGeometry/Crystal/SpaceGroupFactory.h"
#include "MantidGeometry/Crystal/SymmetryOperationSymbolParser.h"
#include "MantidKernel/Exception.h"

#include "MantidGeometry/Crystal/ProductOfCyclicGroups.h"
#include "MantidGeometry/Crystal/CenteringGroup.h"

#include "MantidKernel/LibraryManager.h"

#include <boost/make_shared.hpp>
#include <boost/algorithm/string.hpp>

namespace Mantid
{
namespace Geometry
{

/// Creates a space group given the Hermann-Mauguin symbol, throws std::invalid_argument if symbol is not registered.
SpaceGroup_const_sptr SpaceGroupFactoryImpl::createSpaceGroup(const std::string &hmSymbol)
{
    if(!isSubscribed(hmSymbol)) {
        throw std::invalid_argument("Space group with symbol '" + hmSymbol + "' is not registered.");
    }

    return constructFromPrototype(getPrototype(hmSymbol));
}

/// Returns true if space group with given symbol is subscribed.
bool SpaceGroupFactoryImpl::isSubscribed(const std::string &hmSymbol) const
{
    return m_prototypes.find(hmSymbol) != m_prototypes.end();
}

/// Returns true if space group with given number is subscribed.
bool SpaceGroupFactoryImpl::isSubscribed(size_t number) const
{
    return m_numberMap.find(number) != m_numberMap.end();
}

/// Returns a vector with all subscribed space group symbols.
std::vector<std::string> SpaceGroupFactoryImpl::subscribedSpaceGroupSymbols() const
{
    std::vector<std::string> symbols;
    symbols.reserve(m_prototypes.size());

    for(auto it = m_prototypes.begin(); it != m_prototypes.end(); ++it) {
        symbols.push_back(it->first);
    }

    return symbols;
}

/// Returns a vector with all symbols that correspond to a space group number
std::vector<std::string> SpaceGroupFactoryImpl::subscribedSpaceGroupSymbols(size_t number) const
{
    std::vector<std::string> symbols;

    auto keyPair = m_numberMap.equal_range(number);

    for(auto it = keyPair.first; it != keyPair.second; ++it) {
        symbols.push_back(it->second);
    }

    return symbols;
}

/// Returns a vector with all subscribed space group numbers.
std::vector<size_t> SpaceGroupFactoryImpl::subscribedSpaceGroupNumbers() const
{
    std::vector<size_t> numbers;
    numbers.reserve(m_numberMap.size());

    for(auto it = m_numberMap.begin(); it != m_numberMap.end(); it = m_numberMap.upper_bound(it->first)) {
        numbers.push_back(it->first);
    }

    return numbers;
}

/// Unsubscribes the space group with the given Hermann-Mauguin symbol, but throws std::invalid_argument if symbol is not registered.
void SpaceGroupFactoryImpl::unsubscribeSpaceGroup(const std::string &hmSymbol)
{
    if(!isSubscribed(hmSymbol)) {
        throw std::invalid_argument("Cannot unsubscribe space group that is not registered.");
    }

    auto eraseSymbol = m_prototypes.find(hmSymbol);
    m_prototypes.erase(eraseSymbol);

    auto eraseGenerator = m_generatorMap.find(hmSymbol);
    m_generatorMap.erase(eraseGenerator);

    SpaceGroupSubscriptionHelper eraseHelper = eraseGenerator->second;
    auto eraseNumber = m_numberMap.find(eraseHelper.number);

    m_numberMap.erase(eraseNumber);
}

/**
 * Subscribes a space group into the factory using generators
 *
 * With this method one can register a space group that is generated by an algorithm
 * based on the instructions in [1]. Currently it's important that the Herrman-
 * Mauguin symbol starts with an upper case letter, because that is used to generate
 * centering translations (it should be upper case anyway).
 *
 * The method will throw an exception if the number or symbol is already registered.
 *
 * [1] Shmueli, U. Acta Crystallogr. A 40, 559â€“567 (1984).
 *     http://dx.doi.org/10.1107/S0108767384001161
 *
 * @param number :: Space group number according to International Tables for Crystallography A
 * @param hmSymbol :: Herrman-Mauguin symbol with upper case first letter (centering).
 * @param generators ::
 */
void SpaceGroupFactoryImpl::subscribeGeneratedSpaceGroup(size_t number, const std::string &hmSymbol, const std::string &generators)
{
    throwIfSubscribed(hmSymbol);

    subscribeGeneratorInformation(number, hmSymbol, generators, SpaceGroupSubscriptionHelper::GenerationMethod::Generated);
}

/// Subscribes a "tabulated space group" into the factory where all symmetry operations need to be supplied, including centering.
void SpaceGroupFactoryImpl::subscribeTabulatedSpaceGroup(size_t number, const std::string &hmSymbol, const std::string &symmetryOperations)
{
    throwIfSubscribed(hmSymbol);

    subscribeGeneratorInformation(number, hmSymbol, symmetryOperations, SpaceGroupSubscriptionHelper::GenerationMethod::Tabulated);
}

/// Creatings a prototype instance of SpaceGroup using the supplied parameters.
SpaceGroup_const_sptr SpaceGroupFactoryImpl::getPrototype(Group_const_sptr generatingGroup, size_t number, const std::string &hmSymbol) const
{
    if(!generatingGroup) {
        throw std::runtime_error("Could not create Group from supplied symmetry operations.");
    }

    return boost::make_shared<const SpaceGroup>(number, hmSymbol, *generatingGroup);
}

/// Stores a SpaceGroupSubscriptionHelper object which contains all information required for generating a concrete space group.
void SpaceGroupFactoryImpl::subscribeGeneratorInformation(size_t number, const std::string &hmSymbol, const std::string &generators, SpaceGroupSubscriptionHelper::GenerationMethod method)
{
    if(!isValidGeneratorString(generators)) {
        throw std::invalid_argument("Generator contains elements that can not be parsed as symmetry operations: " + generators);
    }

    m_numberMap.insert(std::make_pair(number, hmSymbol));

    SpaceGroup_const_sptr null;
    m_prototypes.insert(std::make_pair(hmSymbol, null));

    m_generatorMap.insert(std::make_pair(hmSymbol, SpaceGroupSubscriptionHelper(number, hmSymbol, generators, method)));
}

bool SpaceGroupFactoryImpl::isValidGeneratorString(const std::string &generatorString) const
{
    std::vector<std::string> generatorStrings;
    boost::split(generatorStrings, generatorString, boost::is_any_of(";"));

    for(auto it = generatorStrings.begin(); it != generatorStrings.end(); ++it) {
        try {
            SymmetryOperationSymbolParser::parseIdentifier(*it);
        } catch(Kernel::Exception::ParseError) {
            return false;
        }
    }

    return true;
}

/// Returns a copy-constructed instance of the supplied space group prototype object.
SpaceGroup_const_sptr SpaceGroupFactoryImpl::constructFromPrototype(const SpaceGroup_const_sptr prototype) const
{
    return boost::make_shared<const SpaceGroup>(*prototype);
}

/// Throws std::invalid_argument if a space group with the given Hermann-Mauguin symbol is already registered in the factory.
void SpaceGroupFactoryImpl::throwIfSubscribed(const std::string &hmSymbol)
{
    if(isSubscribed(hmSymbol)) {
        throw std::invalid_argument("Space group with this symbol is already registered.");
    }
}

/**
 * Generates an actual prototype instance
 *
 * This method tries to create a space group prototype object from the information
 * stored for generating the group. This method is used when a concrete space group
 * is constructed for the first time and no prototype is available yet.
 *
 * @param hmSymbol :: Hermann-Mauguin symbol, has to be registered.
 * @return Space group prototype object.
 */
SpaceGroup_const_sptr SpaceGroupFactoryImpl::generateValidPrototype(const std::string &hmSymbol) const
{
    auto generationInformation = m_generatorMap.find(hmSymbol);

    SpaceGroupSubscriptionHelper helper = generationInformation->second;
    Group_const_sptr generatingGroup;

    switch(helper.generationMethod) {
    case SpaceGroupSubscriptionHelper::GenerationMethod::Generated:
        generatingGroup = generateValidGeneratedGroup(hmSymbol, helper.generationInformation);
        break;
    case SpaceGroupSubscriptionHelper::GenerationMethod::Tabulated:
        generatingGroup = generateValidTabulatedGroup(helper.generationInformation);
        break;
    }

    if(!generatingGroup) {
        throw std::runtime_error("Could not generate valid prototype. Aborting.");
    }

    return getPrototype(generatingGroup, helper.number, hmSymbol);
}

/// Generate a valid generated group from the generator and the HM-symbol using SpaceGroupFactory::getGeneratedGroup.
Group_const_sptr SpaceGroupFactoryImpl::generateValidGeneratedGroup(const std::string &hmSymbol, const std::string &generators) const
{
    std::string centeringSymbol = getCenteringString(hmSymbol);
    return getGeneratedGroup(generators, centeringSymbol);
}

/// Generate a valid tabulated group from the generator string which should be usable by SpaceGroupFactory::getTabulatedGroup.
Group_const_sptr SpaceGroupFactoryImpl::generateValidTabulatedGroup(const std::string &generators) const
{
    return getTabulatedGroup(generators);
}

/// Returns a prototype object for the requested space group and registers it into the factory if it has not been registered before.
SpaceGroup_const_sptr SpaceGroupFactoryImpl::getPrototype(const std::string &hmSymbol)
{
    SpaceGroup_const_sptr prototype = m_prototypes.find(hmSymbol)->second;

    if(!prototype) {
        prototype = generateValidPrototype(hmSymbol);

        registerValidPrototype(prototype);
    }

    return prototype;
}

/// Store prototype in the internal prototype-storage, replace any previously stored prototype with the same HM-symbol.
void SpaceGroupFactoryImpl::registerValidPrototype(const SpaceGroup_const_sptr &prototype)
{
    if(!prototype) {
        throw std::invalid_argument("Cannot register null-prototype.");
    }

    m_prototypes.insert(std::make_pair(prototype->hmSymbol(), prototype));
}

/// Returns a group with the given symmetry operations.
Group_const_sptr SpaceGroupFactoryImpl::getTabulatedGroup(const std::string &symmetryOperations) const
{
    return GroupFactory::create<Group>(symmetryOperations);
}

std::string SpaceGroupFactoryImpl::getCenteringString(const std::string &hmSymbol) const
{
    return hmSymbol.substr(0, 1);
}

/**
 * Returns a group constructed from a generator string and a centering symbol
 *
 * Generators have to be provided as a semicolon separated list of symmetry operations
 * in x,y,z format, for example "-x,-y,-z; -x,y,z; -y,x,z". A ProductOfCyclicGroups using this
 * string is constructed. Centering symbol has to be supported by CenteringGroup. The
 * group is then calculated as the product of these two groups.
 *
 * @param generators :: Semicolon separated list of symmetry operations.
 * @param centeringSymbol :: Symbol for the lattice centering (see CenteringGroup).
 * @return Resulting group.
 */
Group_const_sptr SpaceGroupFactoryImpl::getGeneratedGroup(const std::string &generators, const std::string &centeringSymbol) const
{
    Group_const_sptr baseGroup = GroupFactory::create<ProductOfCyclicGroups>(generators);
    Group_const_sptr centeringGroup = GroupFactory::create<CenteringGroup>(centeringSymbol);

    return baseGroup * centeringGroup;
}

/// Constructor cannot be called, since SingletonHolder is used.
SpaceGroupFactoryImpl::SpaceGroupFactoryImpl() :
    m_numberMap(),
    m_generatorMap(),
    m_prototypes()
{
    Kernel::LibraryManager::Instance();
}

/* Space groups according to International Tables for Crystallography,
 * using the generators specified there.
 *
 * When two origin choices are possible, only the first is given.
 */
// Triclinic
DECLARE_TABULATED_SPACE_GROUP(1, "P 1", "x,y,z")
DECLARE_GENERATED_SPACE_GROUP(2, "P -1", "-x,-y,-z")

// Monoclinic
DECLARE_GENERATED_SPACE_GROUP(3, "P 1 2 1", "-x,y,-z")
DECLARE_GENERATED_SPACE_GROUP(4, "P 1 21 1", "-x,y+1/2,-z")
DECLARE_GENERATED_SPACE_GROUP(5, "C 1 2 1", "-x,y,-z")
DECLARE_GENERATED_SPACE_GROUP(6, "P 1 m 1", "x,-y,z")
DECLARE_GENERATED_SPACE_GROUP(7, "P 1 c 1", "x,-y,z+1/2")
DECLARE_GENERATED_SPACE_GROUP(8, "C 1 m 1", "x,-y,z")
DECLARE_GENERATED_SPACE_GROUP(9, "C 1 c 1", "x,-y,z+1/2")
DECLARE_GENERATED_SPACE_GROUP(10, "P 1 2/m 1", "-x,y,-z; -x,-y,-z")
DECLARE_GENERATED_SPACE_GROUP(11, "P 1 21/m 1", "-x,y+1/2,-z; -x,-y,-z")
DECLARE_GENERATED_SPACE_GROUP(12, "C 1 2/m 1", "-x,y,-z; -x,-y,-z")
DECLARE_GENERATED_SPACE_GROUP(13, "P 1 2/c 1", "-x,y,-z+1/2; -x,-y,-z")
DECLARE_GENERATED_SPACE_GROUP(14, "P 1 21/c 1", "-x,y+1/2,-z+1/2; -x,-y,-z")
DECLARE_GENERATED_SPACE_GROUP(15, "C 1 2/c 1", "-x,y,-z+1/2; -x,-y,-z")

DECLARE_GENERATED_SPACE_GROUP(194, "P 63/m m c", "-y,x-y,z; -x,-y,z+1/2; y,x,-z; -x,-y,-z")

DECLARE_GENERATED_SPACE_GROUP(221, "P m -3 m", "-x,-y,z; -x,y,-z; z,x,y; y,x,-z; -x,-y,-z")
DECLARE_GENERATED_SPACE_GROUP(225, "F m -3 m", "-x,-y,z; -x,y,-z; z,x,y; y,x,-z; -x,-y,-z")
DECLARE_GENERATED_SPACE_GROUP(227, "F d -3 m", "-x,-y+1/2,z+1/2; -x+1/2,y+1/2,-z; z,x,y; y+3/4,x+1/4,-z+3/4; -x+1/4,-y+1/4,-z+1/4")
DECLARE_GENERATED_SPACE_GROUP(229, "I m -3 m", "-x,-y,z; -x,y,-z; z,x,y; y,x,-z; -x,-y,-z")

} // namespace Geometry
} // namespace Mantid
