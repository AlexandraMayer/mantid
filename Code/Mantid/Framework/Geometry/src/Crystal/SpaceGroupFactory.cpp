#include "MantidGeometry/Crystal/SpaceGroupFactory.h"
#include "MantidGeometry/Crystal/SymmetryOperationFactory.h"

#include "MantidGeometry/Crystal/ProductGroup.h"
#include "MantidGeometry/Crystal/CenteringGroup.h"

#include "MantidKernel/LibraryManager.h"

#include <boost/make_shared.hpp>

namespace Mantid
{
namespace Geometry
{

/// Creates a space group given the Hermann-Mauguin symbol, throws std::invalid_argument if symbol is not registered.
SpaceGroup_const_sptr SpaceGroupFactoryImpl::createSpaceGroup(const std::string &hmSymbol) const
{
    if(!isSubscribed(hmSymbol)) {
        throw std::invalid_argument("Space group with symbol '" + hmSymbol + "' is not registered.");
    }

    return constructFromPrototype(m_prototypesBySymbol.find(hmSymbol)->second);
}

/// Creates a space group given the ITA space group number, throws std::invalid_argument if number is not registered.
SpaceGroup_const_sptr SpaceGroupFactoryImpl::createSpaceGroup(size_t number) const
{
    if(!isSubscribed(number)) {
        throw std::invalid_argument("Space group with requested number is not registered.");
    }

    return constructFromPrototype(m_prototypesByNumber.find(number)->second);
}

/// Returns true if space group with given symbol is subscribed.
bool SpaceGroupFactoryImpl::isSubscribed(const std::string &hmSymbol) const
{
    return m_prototypesBySymbol.find(hmSymbol) != m_prototypesBySymbol.end();
}

/// Returns true if space group with given number is subscribed.
bool SpaceGroupFactoryImpl::isSubscribed(size_t number) const
{
    return m_prototypesByNumber.find(number) != m_prototypesByNumber.end();
}

/// Returns a vector with all subscribed space group symbols.
std::vector<std::string> SpaceGroupFactoryImpl::subscribedSpaceGroupSymbols() const
{
    std::vector<std::string> symbols;
    symbols.reserve(m_prototypesBySymbol.size());

    for(auto it = m_prototypesBySymbol.begin(); it != m_prototypesBySymbol.end(); ++it) {
        symbols.push_back(it->first);
    }

    return symbols;
}

/// Returns a vector with all subscribed space group numbers.
std::vector<size_t> SpaceGroupFactoryImpl::subscribedSpaceGroupNumbers() const
{
    std::vector<size_t> numbers;
    numbers.reserve(m_prototypesByNumber.size());

    for(auto it = m_prototypesByNumber.begin(); it != m_prototypesByNumber.end(); ++it) {
        numbers.push_back(it->first);
    }

    return numbers;
}

/// Unsubscribes the space group with the given Hermann-Mauguin symbol, but throws std::invalid_argument if symbol is not registered.
void SpaceGroupFactoryImpl::unsubscribeSpaceGroup(const std::string &hmSymbol)
{
    if(!isSubscribed(hmSymbol)) {
        throw std::invalid_argument("Cannot unsubscribe space group that is not registered.");
    }

    auto eraseSymbol = m_prototypesBySymbol.find(hmSymbol);
    SpaceGroup_const_sptr spaceGroup = eraseSymbol->second;

    auto eraseNumber = m_prototypesByNumber.find(spaceGroup->number());
    m_prototypesByNumber.erase(eraseNumber);
    m_prototypesBySymbol.erase(eraseSymbol);
}

/// Unsubscribes the space group with the given number, but throws std::invalid_argument if number is not registered.
void SpaceGroupFactoryImpl::unsubscribeSpaceGroup(size_t number)
{
    if(!isSubscribed(number)) {
        throw std::invalid_argument("Cannot unsubscribe space group that is not registered.");
    }

    auto eraseNumber = m_prototypesByNumber.find(number);
    SpaceGroup_const_sptr spaceGroup = eraseNumber->second;

    auto eraseSymbol = m_prototypesBySymbol.find(spaceGroup->hmSymbol());
    m_prototypesBySymbol.erase(eraseSymbol);
    m_prototypesByNumber.erase(eraseNumber);
}

/**
 * Subscribes a space group into the factory using generators
 *
 * With this method one can register a space group that is generated by an algorithm
 * based on the instructions in [1]. Currently it's important that the Herrman-
 * Mauguin symbol starts with an upper case letter, because that is used to generate
 * centering translations (it should be upper case anyway).
 *
 * The method will throw an exception if the number or symbol is already registered.
 *
 * [1] Shmueli, U. Acta Crystallogr. A 40, 559â€“567 (1984).
        http://dx.doi.org/10.1107/S0108767384001161
 *
 * @param number :: Space group number according to International Tables for Crystallography A
 * @param hmSymbol :: Herrman-Mauguin symbol with upper case first letter (centering).
 * @param generators ::
 */
void SpaceGroupFactoryImpl::subscribeGeneratedSpaceGroup(size_t number, const std::string &hmSymbol, const std::string &generators)
{
    throwIfSubscribed(number, hmSymbol);

    // Generate factor group and centering group
    std::string centeringSymbol = getCenteringString(hmSymbol);
    Group_const_sptr generatingGroup = getGeneratedGroup(generators, centeringSymbol);

    SpaceGroup_const_sptr prototype = getPrototype(generatingGroup, number, hmSymbol);
    subscribe(prototype);
}

void SpaceGroupFactoryImpl::subscribeTabulatedSpaceGroup(size_t number, const std::string &hmSymbol, const std::string &symmetryOperations)
{
    throwIfSubscribed(number, hmSymbol);

    // Generate a group using the supplied symmetry operations
    Group_const_sptr generatingGroup = getTabulatedGroup(symmetryOperations);

    SpaceGroup_const_sptr prototype = getPrototype(generatingGroup, number, hmSymbol);
    subscribe(prototype);
}

SpaceGroup_const_sptr SpaceGroupFactoryImpl::getPrototype(Group_const_sptr generatingGroup, size_t number, const std::string &hmSymbol) const
{
    if(!generatingGroup) {
        throw std::runtime_error("Could not create Group from supplied symmetry operations.");
    }

    return boost::make_shared<const SpaceGroup>(number, hmSymbol, *generatingGroup);
}

SpaceGroup_const_sptr SpaceGroupFactoryImpl::constructFromPrototype(const SpaceGroup_const_sptr prototype) const
{
    return boost::make_shared<const SpaceGroup>(*prototype);
}

void SpaceGroupFactoryImpl::throwIfSubscribed(size_t number, const std::string &hmSymbol)
{
    if(isSubscribed(number) || isSubscribed(hmSymbol)) {
        throw std::invalid_argument("Space group with this number/symbol is already registered.");
    }
}

void SpaceGroupFactoryImpl::subscribe(const SpaceGroup_const_sptr &prototype)
{
    m_prototypesByNumber.insert(std::make_pair(prototype->number(), prototype));
    m_prototypesBySymbol.insert(std::make_pair(prototype->hmSymbol(), prototype));
}

Group_const_sptr SpaceGroupFactoryImpl::getTabulatedGroup(const std::string &symmetryOperations) const
{
    return GroupFactory::create<Group>(symmetryOperations);
}

std::string SpaceGroupFactoryImpl::getCenteringString(const std::string &hmSymbol) const
{
    return hmSymbol.substr(0, 1);
}

Group_const_sptr SpaceGroupFactoryImpl::getGeneratedGroup(const std::string &generators, const std::string &centeringSymbol) const
{
    Group_const_sptr baseGroup = GroupFactory::create<ProductGroup>(generators);
    Group_const_sptr centeringGroup = GroupFactory::create<CenteringGroup>(centeringSymbol);

    return baseGroup * centeringGroup;
}

SpaceGroupFactoryImpl::SpaceGroupFactoryImpl() :
    m_prototypesByNumber(),
    m_prototypesBySymbol()
{
    Kernel::LibraryManager::Instance();
}

DECLARE_TABULATED_SPACE_GROUP(1, "P1", "x,y,z");

DECLARE_GENERATED_SPACE_GROUP(2, "P-1", "-x,-y,-z");
DECLARE_GENERATED_SPACE_GROUP(225, "Fm-3m", "-x,-y,z; -x,y,-z; z,x,y; y,x,-z; -x,-y,-z");
DECLARE_GENERATED_SPACE_GROUP(229, "Im-3m", "-x,-y,z; -x,y,-z; z,x,y; y,x,-z; -x,-y,-z");

} // namespace Geometry
} // namespace Mantid
