//----------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------
#include <windows.h>

namespace {  // Anonymous namespace

  MEMORYSTATUSEX memStatus; ///< A Windows structure holding information about memory usage

  size_t ReservedMem()
  {
    MEMORY_BASIC_INFORMATION info; // Windows structure

    char *addr = NULL;
    size_t unusedReserved = 0; // total reserved space
    DWORDLONG size = 0;
    DWORDLONG GB2 = memStatus.ullTotalVirtual; // Maximum memory available to the process

    // Loop over all virtual memory to find out the status of every block.
    do
    {
      VirtualQuery(addr,&info,sizeof(MEMORY_BASIC_INFORMATION));
          
      // Count up the total size of reserved but unused blocks
      if (info.State == MEM_RESERVE) unusedReserved += info.RegionSize;

      addr += info.RegionSize; // Move up to the starting address for the next call
      size += info.RegionSize;
    } 
    while(size < GB2);

    // Convert from bytes to KB
    unusedReserved /= 1024;

    return unusedReserved;
  }
  
}

namespace Mantid
{
namespace API
{

void MemoryManagerImpl::init()
{
  memStatus.dwLength = sizeof(MEMORYSTATUSEX);

  // Try to enable the Low Fragmentation Heap for all heaps
  // Bit of a brute force approach, but don't know which heap workspace data end up on
  HANDLE hHeaps[1025];
  // Get the number of heaps
  const DWORD numHeap = GetProcessHeaps(1024, hHeaps);
  g_log.debug() << "Number of heaps: " << GetProcessHeaps(0, NULL) << "\n";
  ULONG ulEnableLFH = 2; // 2 = Low Fragmentation Heap
  for(DWORD i = 0; i < numHeap; i++)
  {
    if(!HeapSetInformation(hHeaps[i], HeapCompatibilityInformation, &ulEnableLFH, sizeof(ulEnableLFH)))
    {
      g_log.debug() << "Failed to enable the LFH for heap " << i << "\n";
    }
  }
}

MemoryInfo MemoryManagerImpl::getMemoryInfo()
{
  MemoryInfo mi;
  
  GlobalMemoryStatusEx( &memStatus );

  if (memStatus.ullTotalPhys < memStatus.ullTotalVirtual)
  {
    mi.availMemory = static_cast<int>(memStatus.ullAvailPhys/1024);
    mi.totalMemory = static_cast<int>(memStatus.ullTotalPhys/1024);
  }
  else// All virtual memory will be physical, but a process cannot have more than TotalVirtual.
  {
    mi.availMemory = static_cast<int>(memStatus.ullAvailVirtual/1024);
    mi.totalMemory = static_cast<int>(memStatus.ullTotalVirtual/1024);
  }

  mi.freeRatio = static_cast<int>(100.0*mi.availMemory/mi.totalMemory);
  g_log.debug() << "Percentage of memory taken to be available for use: "
      << mi.freeRatio << "%.\n";
  return mi;
}

} // namespace API
} // namespace Mantid
