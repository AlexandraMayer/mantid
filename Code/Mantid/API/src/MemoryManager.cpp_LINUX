//----------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------
#include <iomanip>
#include <iostream>
#include <limits>

#include <unistd.h>
#include <malloc.h>

#include <fstream>
#include <sstream>

namespace {  // Anonymous namespace

/**
 * A unix specific function to read values from /proc/meminfo
 * @param mi A struct to fill with the appropriate values
 */
bool MemoryManagerImpl::ReadMemInfo(MemoryInfo & mi)
{
  std::ifstream file("/proc/meminfo");
  std::string line;
  int values_found(0);
  //Need to set this to zero
  mi.availMemory = 0;
  while (getline(file, line))
  {
    std::istringstream is(line);
    std::string tag;
    long value(0);
    is >> tag >> value;
    if (!is)
      return false;
    if (tag == "MemTotal:")
    {
      ++values_found;
      mi.totalMemory = value;
      g_log.debug() << "Linux - Total memory available: " << value << " KB.\n";
    }
    else if (tag == "MemFree:")
    {
      ++values_found;
      mi.availMemory += value;
      g_log.debug() << "Linux - Free memory reported: " << value << " KB.\n";
    }
    else if (tag == "Cached:")
    {
      ++values_found;
      mi.availMemory += (8*value/10);
      g_log.debug() << "Linux - Cached memory reported: " << value
          << " KB. Note: Using 80% of this value as additional free memory.\n";
    }
    else
      continue;
    if (values_found == 3)
    {
      g_log.debug() << "Linux - Memory taken to be available for use (incl. cache): " << mi.availMemory
          << " KB.\n";
      file.close();
      return true;
    }
  }
  file.close();
  return false;
}

}

void MemoryManagerImpl::init()
{
  /* The line below tells malloc to use a different memory allocation system call (mmap) to the 'usual'
   * one (sbrk) for requests above the threshold of the second argument (in bytes). The effect of this 
   * is that, for the current threshold value of 8*4096, storage for workspaces having 4096 or greater
   * bins per spectrum will be allocated using mmap.
   * This should have the effect that memory is returned to the kernel as soon as a workspace is deleted,
   * preventing things going to managed workspaces when they shouldn't. This will also hopefully reduce
   * memory fragmentation.
   * Potential downsides to look out for are whether this memory allocation technique makes things
   * noticeably slower and whether it wastes memory (mmap allocates in blocks of the system page size.
   */
  mallopt(M_MMAP_THRESHOLD, 8*4096);
}

MemoryInfo MemoryManagerImpl::getMemoryInfo()
{
  MemoryInfo mi;
  
  /*
   * As usual things are more complex on Linux. I think we need to take into account
   * the value of Cached as well since, especially if the system has been running for a long time,
   * MemFree will seem a lot smaller than it should be.
   *
   * The only way I can see as to get acces to the Cached value is from the /proc/meminfo file
   * so if this is not successful I'll fall back to using the sysconf method and forget the cache
   */
  if (!ReadMemInfo(mi))
  {
    long int totPages = sysconf(_SC_PHYS_PAGES);
    long int avPages = sysconf(_SC_AVPHYS_PAGES);
    long int pageSize = sysconf(_SC_PAGESIZE);
    mi.availMemory = avPages / 1024 * pageSize;
    mi.totalMemory = totPages / 1024 * pageSize;
  }
  // Can get the info on the memory that we've already obtained but aren't using right now
  const int unusedReserved = mallinfo().fordblks/1024;
  g_log.debug() << "Linux - Adding reserved but unused memory of " << unusedReserved << " KB\n";
  mi.availMemory += unusedReserved;

  mi.freeRatio = static_cast<int>(100.0*mi.availMemory/mi.totalMemory);
  g_log.debug() << "Percentage of memory taken to be available for use (incl. cache): "
      << mi.freeRatio << "%.\n";
  return mi;
}
