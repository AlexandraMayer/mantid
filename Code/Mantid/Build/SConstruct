#For Framework

import os
import platform
import sys

from socket import gethostname


def procHeaderPath(ln,keyname,out):
  ## Strips the header components if in existance and returns:
  ## Yes this is ugly repetition in a loop.
  if ln.startswith(keyname):
    out=ln[len(keyname)+1:].strip('\n')
    if out[-1]!='/':
      out+='/'
  return out

def procHeader(ln,keyname,out):
  ## Strips the header components if in existance and returns:
  ## Yes this is ugly repetition in a loop.
  if ln.startswith(keyname):
    out=ln[len(keyname)+1:].strip('\n')
  return out



#get libraries and the library directories
# NOTE : ../ and . are STUPID :
# That is because -Wl,-rpath= . IS YOUR CURRENT WORKING DIRECTORY AT RUNTIME
# Therefore when you build some thing and put a hardlink into the creation point
# of a library it needs to be fully pathed. PLEASE do not change it back again.
print 'Current path == ',os.getcwd()
cwdpath=os.getcwd()
uppath=os.path.abspath('../')

libDirList = [uppath,cwdpath ]
libList = ['python' + sys.version[0:3].replace('.','')]
cflags = []
dirList = []
cppPaths = []

## Get Paths for various builds 
dirpath=os.listdir(uppath)
while(len(dirpath)):
  try:
    item=dirpath.pop(0)
    if not item.startswith('Geometry') and not item.startswith('Main'):
      for file in os.listdir("../"+item):
	fullPath="../"+item+"/"+file
	if (file=="inc"):
	  cppPaths.append(fullPath)
	elif (file=="src"):
	  dirList.append(item)
	  print "SRC PATH == ",item
	elif (os.path.isdir(fullPath) and (not file.endswith('svn'))
	and (not file.endswith('test'))):
	  dirpath.append(fullPath[3:])
  except:
    pass


if os.name == 'nt':
  # assume this is Windows
  libDirList.append('../../Third_Party/lib/win32/')
  libDirList.append('c:/python25/libs')
  
  cppPaths.append('../../Third_Party/include')
  cppPaths.append('c:/python25/include')
  
  libDir = '../../Third_Party/lib/win32/'
  cflags = ['-W3','/EHsc', '/MDd', '/Zi', '/TP', '/wd4275', '/DWIN32', '/D_DEBUG', '/D_WINDOWS', '/DPOCO_DLL', '/DWINVER=0x0500', '/D_USE_MATH_DEFINES']
  
  for file in os.listdir(libDir):
    if file.endswith('.dll'):
      libList.append(file.replace('.dll',''))

else:       ## so this must be posix

  boost_path = ''
  poco_path = ''
  boost_append=''
  fortran_type=''
  third_party=''
  prebuild=''
  #Get paths
  f=open('Scons_Linux.conf', 'r')
  
  for ln in f:
    boost_path=procHeaderPath(ln,'BOOST_ROOT',boost_path)
    poco_path=procHeaderPath(ln,'POCO_ROOT',poco_path)
    boost_append=procHeader(ln,'BOOST_APPEND',boost_append)
    fortran_type=procHeader(ln,'FORTRAN',fortran_type)
    third_party=procHeader(ln,'THIRD',third_party)
    prebuild=procHeader(ln,'PREBUILD',prebuild)
  f.close()

  print "POCO_ROOT: ",poco_path
  print "BOOST_ROOT: ",boost_path
  print "BOOST_APPEND: ",boost_append
  print "FORTRAN: ",boost_append
  print "THIRD_PARTY: ",third_party


  cflags = ['-Wall', '-fPIC']
  cppPaths.append(boost_path)
  cppPaths.append('/usr/include/python' + sys.version[0:3])
  cppPaths.append(poco_path + 'Foundation/include')
  
#GET LIST OF CPPS
codeFolder = '/src'
listCpps = []
pathToRoot = '../'

for fname in dirList:
  print "dir:",fname 
  if os.path.isdir(pathToRoot + fname):
    if fname != '.svn' and fname != 'LinuxBuildScripts' and fname != 'Build':
      #does folder contain /src?
      if os.path.exists(pathToRoot + fname + codeFolder):
	files = os.listdir(pathToRoot + fname + codeFolder)
	for file in files:
	  if (file.endswith('.cpp') or file.endswith('.c') or file.endswith('.f')):
	    listCpps.append(pathToRoot + fname + codeFolder + '/' +  file)

listCpps.append(os.path.abspath('../Geometry/src/CompAssembly.cpp'))
listCpps.append(os.path.abspath('../Geometry/src/Component.cpp'))
listCpps.append(os.path.abspath('../Geometry/src/Detector.cpp'))
listCpps.append(os.path.abspath('../Geometry/src/ObjComponent.cpp'))
listCpps.append(os.path.abspath('../Geometry/src/Quat.cpp'))
listCpps.append(os.path.abspath('../Geometry/src/V3D.cpp'))

cppPaths.append(os.path.abspath('../Geometry/inc/'))

	    


if (fortran_type!='g77'):
  cflags.append('-D__GFORTRAN__')                         ## Get correct information to the cpp extern "C"

else:
  libDirList.append('/usr/lib/gcc/i386-redhat-linux/3.4.6/')
  libDirList.append('/usr/lib/gcc/i686-pc-linux-gnu/3.4.6/')
  libList.append('g2c')

if (prebuild!=''):
  libList.append(prebuild)

                                                         
# set header include paths
env = Environment(CPPPATH=cppPaths,FORTRAN='gfortran')
env.Append( CCFLAGS = cflags)
##  env.Append( FORTRANFLAGS = '-fsecond-underscore')       ## THIS DOESN'T WORK SEE BUG Report 21 November 2007 follow u

#BUILD CODE
if os.name == 'nt':
  env.SharedLibrary('Mantid', listCpps, LIBS=libList, LIBPATH=libDirList, RPATH=libDirList)
else:
  env.SharedLibrary('Mantid', listCpps, LIBS=[ ], LIBPATH=[ ] )


