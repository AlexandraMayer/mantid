/* soapC.cpp
   Generated by gSOAP 2.7.16 from ICATService.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "MantidIcat/GSoapGenerated/soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.16 2010-05-04 14:40:10 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__datasetInclude:
		return soap_in_ns1__datasetInclude(soap, NULL, NULL, "ns1:datasetInclude");
	case SOAP_TYPE_ns1__elementType:
		return soap_in_ns1__elementType(soap, NULL, NULL, "ns1:elementType");
	case SOAP_TYPE_ns1__investigationInclude:
		return soap_in_ns1__investigationInclude(soap, NULL, NULL, "ns1:investigationInclude");
	case SOAP_TYPE_ns1__keywordType:
		return soap_in_ns1__keywordType(soap, NULL, NULL, "ns1:keywordType");
	case SOAP_TYPE_ns1__datafileInclude:
		return soap_in_ns1__datafileInclude(soap, NULL, NULL, "ns1:datafileInclude");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__datasetInclude_:
		return soap_in_ns1__datasetInclude_(soap, NULL, NULL, "ns1:datasetInclude");
	case SOAP_TYPE_ns1__elementType_:
		return soap_in_ns1__elementType_(soap, NULL, NULL, "ns1:elementType");
	case SOAP_TYPE_ns1__investigationInclude_:
		return soap_in_ns1__investigationInclude_(soap, NULL, NULL, "ns1:investigationInclude");
	case SOAP_TYPE_ns1__keywordType_:
		return soap_in_ns1__keywordType_(soap, NULL, NULL, "ns1:keywordType");
	case SOAP_TYPE_ns1__datafileInclude_:
		return soap_in_ns1__datafileInclude_(soap, NULL, NULL, "ns1:datafileInclude");
	case SOAP_TYPE_ns3__SessionException:
		return soap_in_ns3__SessionException(soap, NULL, NULL, "ns3:SessionException");
	case SOAP_TYPE_ns1__getDatasetsResponse:
		return soap_in_ns1__getDatasetsResponse(soap, NULL, NULL, "ns1:getDatasetsResponse");
	case SOAP_TYPE_ns1__getDatasets:
		return soap_in_ns1__getDatasets(soap, NULL, NULL, "ns1:getDatasets");
	case SOAP_TYPE_ns1__listParametersResponse:
		return soap_in_ns1__listParametersResponse(soap, NULL, NULL, "ns1:listParametersResponse");
	case SOAP_TYPE_ns1__listParameters:
		return soap_in_ns1__listParameters(soap, NULL, NULL, "ns1:listParameters");
	case SOAP_TYPE_ns1__modifyDataFileParameterResponse:
		return soap_in_ns1__modifyDataFileParameterResponse(soap, NULL, NULL, "ns1:modifyDataFileParameterResponse");
	case SOAP_TYPE_ns1__modifyDataFileParameter:
		return soap_in_ns1__modifyDataFileParameter(soap, NULL, NULL, "ns1:modifyDataFileParameter");
	case SOAP_TYPE_ns1__deleteSampleParameterResponse:
		return soap_in_ns1__deleteSampleParameterResponse(soap, NULL, NULL, "ns1:deleteSampleParameterResponse");
	case SOAP_TYPE_ns1__deleteSampleParameter:
		return soap_in_ns1__deleteSampleParameter(soap, NULL, NULL, "ns1:deleteSampleParameter");
	case SOAP_TYPE_ns1__addDataFileParameterResponse:
		return soap_in_ns1__addDataFileParameterResponse(soap, NULL, NULL, "ns1:addDataFileParameterResponse");
	case SOAP_TYPE_ns1__addDataFileParameter:
		return soap_in_ns1__addDataFileParameter(soap, NULL, NULL, "ns1:addDataFileParameter");
	case SOAP_TYPE_ns1__searchDatasetsBySampleResponse:
		return soap_in_ns1__searchDatasetsBySampleResponse(soap, NULL, NULL, "ns1:searchDatasetsBySampleResponse");
	case SOAP_TYPE_ns1__searchDatasetsBySample:
		return soap_in_ns1__searchDatasetsBySample(soap, NULL, NULL, "ns1:searchDatasetsBySample");
	case SOAP_TYPE_ns1__addPublicationResponse:
		return soap_in_ns1__addPublicationResponse(soap, NULL, NULL, "ns1:addPublicationResponse");
	case SOAP_TYPE_ns1__addPublication:
		return soap_in_ns1__addPublication(soap, NULL, NULL, "ns1:addPublication");
	case SOAP_TYPE_ns1__createInvestigationResponse:
		return soap_in_ns1__createInvestigationResponse(soap, NULL, NULL, "ns1:createInvestigationResponse");
	case SOAP_TYPE_ns1__createInvestigation:
		return soap_in_ns1__createInvestigation(soap, NULL, NULL, "ns1:createInvestigation");
	case SOAP_TYPE_ns1__deleteDataFileParameterResponse:
		return soap_in_ns1__deleteDataFileParameterResponse(soap, NULL, NULL, "ns1:deleteDataFileParameterResponse");
	case SOAP_TYPE_ns1__deleteDataFileParameter:
		return soap_in_ns1__deleteDataFileParameter(soap, NULL, NULL, "ns1:deleteDataFileParameter");
	case SOAP_TYPE_ns1__getInvestigationResponse:
		return soap_in_ns1__getInvestigationResponse(soap, NULL, NULL, "ns1:getInvestigationResponse");
	case SOAP_TYPE_ns1__getInvestigation:
		return soap_in_ns1__getInvestigation(soap, NULL, NULL, "ns1:getInvestigation");
	case SOAP_TYPE_ns1__getInvestigationIncludesResponse:
		return soap_in_ns1__getInvestigationIncludesResponse(soap, NULL, NULL, "ns1:getInvestigationIncludesResponse");
	case SOAP_TYPE_ns1__getInvestigationIncludes:
		return soap_in_ns1__getInvestigationIncludes(soap, NULL, NULL, "ns1:getInvestigationIncludes");
	case SOAP_TYPE_ns1__modifyDataFileResponse:
		return soap_in_ns1__modifyDataFileResponse(soap, NULL, NULL, "ns1:modifyDataFileResponse");
	case SOAP_TYPE_ns1__modifyDataFile:
		return soap_in_ns1__modifyDataFile(soap, NULL, NULL, "ns1:modifyDataFile");
	case SOAP_TYPE_ns1__getDatafileResponse:
		return soap_in_ns1__getDatafileResponse(soap, NULL, NULL, "ns1:getDatafileResponse");
	case SOAP_TYPE_ns1__getDatafile:
		return soap_in_ns1__getDatafile(soap, NULL, NULL, "ns1:getDatafile");
	case SOAP_TYPE_ns1__ICATAPIException:
		return soap_in_ns1__ICATAPIException(soap, NULL, NULL, "ns1:ICATAPIException");
	case SOAP_TYPE_ns1__ingestMetadataResponse:
		return soap_in_ns1__ingestMetadataResponse(soap, NULL, NULL, "ns1:ingestMetadataResponse");
	case SOAP_TYPE_ns1__ingestMetadata:
		return soap_in_ns1__ingestMetadata(soap, NULL, NULL, "ns1:ingestMetadata");
	case SOAP_TYPE_ns1__listRolesResponse:
		return soap_in_ns1__listRolesResponse(soap, NULL, NULL, "ns1:listRolesResponse");
	case SOAP_TYPE_ns1__listRoles:
		return soap_in_ns1__listRoles(soap, NULL, NULL, "ns1:listRoles");
	case SOAP_TYPE_ns1__getDatasetResponse:
		return soap_in_ns1__getDatasetResponse(soap, NULL, NULL, "ns1:getDatasetResponse");
	case SOAP_TYPE_ns1__getDataset:
		return soap_in_ns1__getDataset(soap, NULL, NULL, "ns1:getDataset");
	case SOAP_TYPE_ns1__getDatasetIncludesResponse:
		return soap_in_ns1__getDatasetIncludesResponse(soap, NULL, NULL, "ns1:getDatasetIncludesResponse");
	case SOAP_TYPE_ns1__getDatasetIncludes:
		return soap_in_ns1__getDatasetIncludes(soap, NULL, NULL, "ns1:getDatasetIncludes");
	case SOAP_TYPE_ns1__updateAuthorisationResponse:
		return soap_in_ns1__updateAuthorisationResponse(soap, NULL, NULL, "ns1:updateAuthorisationResponse");
	case SOAP_TYPE_ns1__updateAuthorisation:
		return soap_in_ns1__updateAuthorisation(soap, NULL, NULL, "ns1:updateAuthorisation");
	case SOAP_TYPE_ns1__deleteAuthorisationResponse:
		return soap_in_ns1__deleteAuthorisationResponse(soap, NULL, NULL, "ns1:deleteAuthorisationResponse");
	case SOAP_TYPE_ns1__deleteAuthorisation:
		return soap_in_ns1__deleteAuthorisation(soap, NULL, NULL, "ns1:deleteAuthorisation");
	case SOAP_TYPE_ns1__loginResponse:
		return soap_in_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_ns1__login:
		return soap_in_ns1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_ns1__loginLifetimeResponse:
		return soap_in_ns1__loginLifetimeResponse(soap, NULL, NULL, "ns1:loginLifetimeResponse");
	case SOAP_TYPE_ns1__loginLifetime:
		return soap_in_ns1__loginLifetime(soap, NULL, NULL, "ns1:loginLifetime");
	case SOAP_TYPE_ns1__deletePublicationResponse:
		return soap_in_ns1__deletePublicationResponse(soap, NULL, NULL, "ns1:deletePublicationResponse");
	case SOAP_TYPE_ns1__deletePublication:
		return soap_in_ns1__deletePublication(soap, NULL, NULL, "ns1:deletePublication");
	case SOAP_TYPE_ns1__addSampleResponse:
		return soap_in_ns1__addSampleResponse(soap, NULL, NULL, "ns1:addSampleResponse");
	case SOAP_TYPE_ns1__addSample:
		return soap_in_ns1__addSample(soap, NULL, NULL, "ns1:addSample");
	case SOAP_TYPE_ns1__addAuthorisationResponse:
		return soap_in_ns1__addAuthorisationResponse(soap, NULL, NULL, "ns1:addAuthorisationResponse");
	case SOAP_TYPE_ns1__addAuthorisation:
		return soap_in_ns1__addAuthorisation(soap, NULL, NULL, "ns1:addAuthorisation");
	case SOAP_TYPE_ns1__addDataSetParameterResponse:
		return soap_in_ns1__addDataSetParameterResponse(soap, NULL, NULL, "ns1:addDataSetParameterResponse");
	case SOAP_TYPE_ns1__addDataSetParameter:
		return soap_in_ns1__addDataSetParameter(soap, NULL, NULL, "ns1:addDataSetParameter");
	case SOAP_TYPE_ns1__createDataFilesResponse:
		return soap_in_ns1__createDataFilesResponse(soap, NULL, NULL, "ns1:createDataFilesResponse");
	case SOAP_TYPE_ns1__createDataFiles:
		return soap_in_ns1__createDataFiles(soap, NULL, NULL, "ns1:createDataFiles");
	case SOAP_TYPE_ns1__modifyInvestigatorResponse:
		return soap_in_ns1__modifyInvestigatorResponse(soap, NULL, NULL, "ns1:modifyInvestigatorResponse");
	case SOAP_TYPE_ns1__modifyInvestigator:
		return soap_in_ns1__modifyInvestigator(soap, NULL, NULL, "ns1:modifyInvestigator");
	case SOAP_TYPE_ns1__modifySampleParameterResponse:
		return soap_in_ns1__modifySampleParameterResponse(soap, NULL, NULL, "ns1:modifySampleParameterResponse");
	case SOAP_TYPE_ns1__modifySampleParameter:
		return soap_in_ns1__modifySampleParameter(soap, NULL, NULL, "ns1:modifySampleParameter");
	case SOAP_TYPE_ns1__listDatafileFormatsResponse:
		return soap_in_ns1__listDatafileFormatsResponse(soap, NULL, NULL, "ns1:listDatafileFormatsResponse");
	case SOAP_TYPE_ns1__listDatafileFormats:
		return soap_in_ns1__listDatafileFormats(soap, NULL, NULL, "ns1:listDatafileFormats");
	case SOAP_TYPE_ns1__searchByAdvancedPaginationResponse:
		return soap_in_ns1__searchByAdvancedPaginationResponse(soap, NULL, NULL, "ns1:searchByAdvancedPaginationResponse");
	case SOAP_TYPE_ns1__searchByAdvancedPagination:
		return soap_in_ns1__searchByAdvancedPagination(soap, NULL, NULL, "ns1:searchByAdvancedPagination");
	case SOAP_TYPE_ns1__searchByAdvancedResponse:
		return soap_in_ns1__searchByAdvancedResponse(soap, NULL, NULL, "ns1:searchByAdvancedResponse");
	case SOAP_TYPE_ns1__advancedSearchDetails:
		return soap_in_ns1__advancedSearchDetails(soap, NULL, NULL, "ns1:advancedSearchDetails");
	case SOAP_TYPE_ns1__searchByAdvanced:
		return soap_in_ns1__searchByAdvanced(soap, NULL, NULL, "ns1:searchByAdvanced");
	case SOAP_TYPE_ns1__searchByRunNumberPaginationResponse:
		return soap_in_ns1__searchByRunNumberPaginationResponse(soap, NULL, NULL, "ns1:searchByRunNumberPaginationResponse");
	case SOAP_TYPE_ns1__searchByRunNumberPagination:
		return soap_in_ns1__searchByRunNumberPagination(soap, NULL, NULL, "ns1:searchByRunNumberPagination");
	case SOAP_TYPE_ns1__searchByRunNumberResponse:
		return soap_in_ns1__searchByRunNumberResponse(soap, NULL, NULL, "ns1:searchByRunNumberResponse");
	case SOAP_TYPE_ns1__searchByRunNumber:
		return soap_in_ns1__searchByRunNumber(soap, NULL, NULL, "ns1:searchByRunNumber");
	case SOAP_TYPE_ns1__addDataSetParametersResponse:
		return soap_in_ns1__addDataSetParametersResponse(soap, NULL, NULL, "ns1:addDataSetParametersResponse");
	case SOAP_TYPE_ns1__addDataSetParameters:
		return soap_in_ns1__addDataSetParameters(soap, NULL, NULL, "ns1:addDataSetParameters");
	case SOAP_TYPE_ns1__deleteKeywordResponse:
		return soap_in_ns1__deleteKeywordResponse(soap, NULL, NULL, "ns1:deleteKeywordResponse");
	case SOAP_TYPE_ns1__deleteKeyword:
		return soap_in_ns1__deleteKeyword(soap, NULL, NULL, "ns1:deleteKeyword");
	case SOAP_TYPE_ns1__deleteSampleResponse:
		return soap_in_ns1__deleteSampleResponse(soap, NULL, NULL, "ns1:deleteSampleResponse");
	case SOAP_TYPE_ns1__deleteSample:
		return soap_in_ns1__deleteSample(soap, NULL, NULL, "ns1:deleteSample");
	case SOAP_TYPE_ns1__listDatasetStatusResponse:
		return soap_in_ns1__listDatasetStatusResponse(soap, NULL, NULL, "ns1:listDatasetStatusResponse");
	case SOAP_TYPE_ns1__listDatasetStatus:
		return soap_in_ns1__listDatasetStatus(soap, NULL, NULL, "ns1:listDatasetStatus");
	case SOAP_TYPE_ns1__modifyInvestigationResponse:
		return soap_in_ns1__modifyInvestigationResponse(soap, NULL, NULL, "ns1:modifyInvestigationResponse");
	case SOAP_TYPE_ns1__modifyInvestigation:
		return soap_in_ns1__modifyInvestigation(soap, NULL, NULL, "ns1:modifyInvestigation");
	case SOAP_TYPE_ns1__addKeywordResponse:
		return soap_in_ns1__addKeywordResponse(soap, NULL, NULL, "ns1:addKeywordResponse");
	case SOAP_TYPE_ns1__addKeyword:
		return soap_in_ns1__addKeyword(soap, NULL, NULL, "ns1:addKeyword");
	case SOAP_TYPE_ns1__icatAuthorisation:
		return soap_in_ns1__icatAuthorisation(soap, NULL, NULL, "ns1:icatAuthorisation");
	case SOAP_TYPE_ns1__getAuthorisationsResponse:
		return soap_in_ns1__getAuthorisationsResponse(soap, NULL, NULL, "ns1:getAuthorisationsResponse");
	case SOAP_TYPE_ns1__getAuthorisations:
		return soap_in_ns1__getAuthorisations(soap, NULL, NULL, "ns1:getAuthorisations");
	case SOAP_TYPE_ns1__removeDataSetResponse:
		return soap_in_ns1__removeDataSetResponse(soap, NULL, NULL, "ns1:removeDataSetResponse");
	case SOAP_TYPE_ns1__removeDataSet:
		return soap_in_ns1__removeDataSet(soap, NULL, NULL, "ns1:removeDataSet");
	case SOAP_TYPE_ns1__modifyDataSetParameterResponse:
		return soap_in_ns1__modifyDataSetParameterResponse(soap, NULL, NULL, "ns1:modifyDataSetParameterResponse");
	case SOAP_TYPE_ns1__modifyDataSetParameter:
		return soap_in_ns1__modifyDataSetParameter(soap, NULL, NULL, "ns1:modifyDataSetParameter");
	case SOAP_TYPE_ns1__listInvestigationTypesResponse:
		return soap_in_ns1__listInvestigationTypesResponse(soap, NULL, NULL, "ns1:listInvestigationTypesResponse");
	case SOAP_TYPE_ns1__listInvestigationTypes:
		return soap_in_ns1__listInvestigationTypes(soap, NULL, NULL, "ns1:listInvestigationTypes");
	case SOAP_TYPE_ns1__getKeywordsForUserTypeResponse:
		return soap_in_ns1__getKeywordsForUserTypeResponse(soap, NULL, NULL, "ns1:getKeywordsForUserTypeResponse");
	case SOAP_TYPE_ns1__getKeywordsForUserType:
		return soap_in_ns1__getKeywordsForUserType(soap, NULL, NULL, "ns1:getKeywordsForUserType");
	case SOAP_TYPE_ns1__getKeywordsForUserMaxResponse:
		return soap_in_ns1__getKeywordsForUserMaxResponse(soap, NULL, NULL, "ns1:getKeywordsForUserMaxResponse");
	case SOAP_TYPE_ns1__getKeywordsForUserMax:
		return soap_in_ns1__getKeywordsForUserMax(soap, NULL, NULL, "ns1:getKeywordsForUserMax");
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse:
		return soap_in_ns1__getKeywordsForUserStartWithMaxResponse(soap, NULL, NULL, "ns1:getKeywordsForUserStartWithMaxResponse");
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMax:
		return soap_in_ns1__getKeywordsForUserStartWithMax(soap, NULL, NULL, "ns1:getKeywordsForUserStartWithMax");
	case SOAP_TYPE_ns1__getKeywordsForUserResponse:
		return soap_in_ns1__getKeywordsForUserResponse(soap, NULL, NULL, "ns1:getKeywordsForUserResponse");
	case SOAP_TYPE_ns1__getKeywordsForUser:
		return soap_in_ns1__getKeywordsForUser(soap, NULL, NULL, "ns1:getKeywordsForUser");
	case SOAP_TYPE_ns1__downloadDatafileResponse:
		return soap_in_ns1__downloadDatafileResponse(soap, NULL, NULL, "ns1:downloadDatafileResponse");
	case SOAP_TYPE_ns1__downloadDatafile:
		return soap_in_ns1__downloadDatafile(soap, NULL, NULL, "ns1:downloadDatafile");
	case SOAP_TYPE_ns1__setDataSetSampleResponse:
		return soap_in_ns1__setDataSetSampleResponse(soap, NULL, NULL, "ns1:setDataSetSampleResponse");
	case SOAP_TYPE_ns1__setDataSetSample:
		return soap_in_ns1__setDataSetSample(soap, NULL, NULL, "ns1:setDataSetSample");
	case SOAP_TYPE_ns1__deleteDataSetParameterResponse:
		return soap_in_ns1__deleteDataSetParameterResponse(soap, NULL, NULL, "ns1:deleteDataSetParameterResponse");
	case SOAP_TYPE_ns1__deleteDataSetParameter:
		return soap_in_ns1__deleteDataSetParameter(soap, NULL, NULL, "ns1:deleteDataSetParameter");
	case SOAP_TYPE_ns1__removeSampleParameterResponse:
		return soap_in_ns1__removeSampleParameterResponse(soap, NULL, NULL, "ns1:removeSampleParameterResponse");
	case SOAP_TYPE_ns1__removeSampleParameter:
		return soap_in_ns1__removeSampleParameter(soap, NULL, NULL, "ns1:removeSampleParameter");
	case SOAP_TYPE_ns1__createDataSetResponse:
		return soap_in_ns1__createDataSetResponse(soap, NULL, NULL, "ns1:createDataSetResponse");
	case SOAP_TYPE_ns1__createDataSet:
		return soap_in_ns1__createDataSet(soap, NULL, NULL, "ns1:createDataSet");
	case SOAP_TYPE_ns1__addInvestigatorResponse:
		return soap_in_ns1__addInvestigatorResponse(soap, NULL, NULL, "ns1:addInvestigatorResponse");
	case SOAP_TYPE_ns1__addInvestigator:
		return soap_in_ns1__addInvestigator(soap, NULL, NULL, "ns1:addInvestigator");
	case SOAP_TYPE_ns1__deleteInvestigatorResponse:
		return soap_in_ns1__deleteInvestigatorResponse(soap, NULL, NULL, "ns1:deleteInvestigatorResponse");
	case SOAP_TYPE_ns1__deleteInvestigator:
		return soap_in_ns1__deleteInvestigator(soap, NULL, NULL, "ns1:deleteInvestigator");
	case SOAP_TYPE_ns1__getICATAPIVersionResponse:
		return soap_in_ns1__getICATAPIVersionResponse(soap, NULL, NULL, "ns1:getICATAPIVersionResponse");
	case SOAP_TYPE_ns1__getICATAPIVersion:
		return soap_in_ns1__getICATAPIVersion(soap, NULL, NULL, "ns1:getICATAPIVersion");
	case SOAP_TYPE_ns1__getDatafilesResponse:
		return soap_in_ns1__getDatafilesResponse(soap, NULL, NULL, "ns1:getDatafilesResponse");
	case SOAP_TYPE_ns1__getDatafiles:
		return soap_in_ns1__getDatafiles(soap, NULL, NULL, "ns1:getDatafiles");
	case SOAP_TYPE_ns1__deleteDataSetResponse:
		return soap_in_ns1__deleteDataSetResponse(soap, NULL, NULL, "ns1:deleteDataSetResponse");
	case SOAP_TYPE_ns1__deleteDataSet:
		return soap_in_ns1__deleteDataSet(soap, NULL, NULL, "ns1:deleteDataSet");
	case SOAP_TYPE_ns1__getInvestigationsIncludesResponse:
		return soap_in_ns1__getInvestigationsIncludesResponse(soap, NULL, NULL, "ns1:getInvestigationsIncludesResponse");
	case SOAP_TYPE_ns1__getInvestigationsIncludes:
		return soap_in_ns1__getInvestigationsIncludes(soap, NULL, NULL, "ns1:getInvestigationsIncludes");
	case SOAP_TYPE_ns1__removeDataFileParameterResponse:
		return soap_in_ns1__removeDataFileParameterResponse(soap, NULL, NULL, "ns1:removeDataFileParameterResponse");
	case SOAP_TYPE_ns1__removeDataFileParameter:
		return soap_in_ns1__removeDataFileParameter(soap, NULL, NULL, "ns1:removeDataFileParameter");
	case SOAP_TYPE_ns1__searchByUserIDPaginationResponse:
		return soap_in_ns1__searchByUserIDPaginationResponse(soap, NULL, NULL, "ns1:searchByUserIDPaginationResponse");
	case SOAP_TYPE_ns1__searchByUserIDPagination:
		return soap_in_ns1__searchByUserIDPagination(soap, NULL, NULL, "ns1:searchByUserIDPagination");
	case SOAP_TYPE_ns1__searchByUserIDResponse:
		return soap_in_ns1__searchByUserIDResponse(soap, NULL, NULL, "ns1:searchByUserIDResponse");
	case SOAP_TYPE_ns1__searchByUserID:
		return soap_in_ns1__searchByUserID(soap, NULL, NULL, "ns1:searchByUserID");
	case SOAP_TYPE_ns1__modifyPublicationResponse:
		return soap_in_ns1__modifyPublicationResponse(soap, NULL, NULL, "ns1:modifyPublicationResponse");
	case SOAP_TYPE_ns1__modifyPublication:
		return soap_in_ns1__modifyPublication(soap, NULL, NULL, "ns1:modifyPublication");
	case SOAP_TYPE_ns1__removeDataSetParameterResponse:
		return soap_in_ns1__removeDataSetParameterResponse(soap, NULL, NULL, "ns1:removeDataSetParameterResponse");
	case SOAP_TYPE_ns1__removeDataSetParameter:
		return soap_in_ns1__removeDataSetParameter(soap, NULL, NULL, "ns1:removeDataSetParameter");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse:
		return soap_in_ns1__getMyInvestigationsIncludesPaginationResponse(soap, NULL, NULL, "ns1:getMyInvestigationsIncludesPaginationResponse");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination:
		return soap_in_ns1__getMyInvestigationsIncludesPagination(soap, NULL, NULL, "ns1:getMyInvestigationsIncludesPagination");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse:
		return soap_in_ns1__getMyInvestigationsIncludesResponse(soap, NULL, NULL, "ns1:getMyInvestigationsIncludesResponse");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludes:
		return soap_in_ns1__getMyInvestigationsIncludes(soap, NULL, NULL, "ns1:getMyInvestigationsIncludes");
	case SOAP_TYPE_ns1__getMyInvestigationsResponse:
		return soap_in_ns1__getMyInvestigationsResponse(soap, NULL, NULL, "ns1:getMyInvestigationsResponse");
	case SOAP_TYPE_ns1__getMyInvestigations:
		return soap_in_ns1__getMyInvestigations(soap, NULL, NULL, "ns1:getMyInvestigations");
	case SOAP_TYPE_ns1__searchByKeywordsAllResponse:
		return soap_in_ns1__searchByKeywordsAllResponse(soap, NULL, NULL, "ns1:searchByKeywordsAllResponse");
	case SOAP_TYPE_ns1__keywordDetails:
		return soap_in_ns1__keywordDetails(soap, NULL, NULL, "ns1:keywordDetails");
	case SOAP_TYPE_ns1__searchByKeywordsAll:
		return soap_in_ns1__searchByKeywordsAll(soap, NULL, NULL, "ns1:searchByKeywordsAll");
	case SOAP_TYPE_ns1__searchByKeywordsResponse:
		return soap_in_ns1__searchByKeywordsResponse(soap, NULL, NULL, "ns1:searchByKeywordsResponse");
	case SOAP_TYPE_ns1__searchByKeywords:
		return soap_in_ns1__searchByKeywords(soap, NULL, NULL, "ns1:searchByKeywords");
	case SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse:
		return soap_in_ns1__checkDatasetDownloadAccessResponse(soap, NULL, NULL, "ns1:checkDatasetDownloadAccessResponse");
	case SOAP_TYPE_ns1__checkDatasetDownloadAccess:
		return soap_in_ns1__checkDatasetDownloadAccess(soap, NULL, NULL, "ns1:checkDatasetDownloadAccess");
	case SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse:
		return soap_in_ns1__searchByUserSurnamePaginationResponse(soap, NULL, NULL, "ns1:searchByUserSurnamePaginationResponse");
	case SOAP_TYPE_ns1__searchByUserSurnamePagination:
		return soap_in_ns1__searchByUserSurnamePagination(soap, NULL, NULL, "ns1:searchByUserSurnamePagination");
	case SOAP_TYPE_ns1__shiftPK:
		return soap_in_ns1__shiftPK(soap, NULL, NULL, "ns1:shiftPK");
	case SOAP_TYPE_ns1__shift:
		return soap_in_ns1__shift(soap, NULL, NULL, "ns1:shift");
	case SOAP_TYPE_ns1__publication:
		return soap_in_ns1__publication(soap, NULL, NULL, "ns1:publication");
	case SOAP_TYPE_ns1__keyword:
		return soap_in_ns1__keyword(soap, NULL, NULL, "ns1:keyword");
	case SOAP_TYPE_ns1__investigator:
		return soap_in_ns1__investigator(soap, NULL, NULL, "ns1:investigator");
	case SOAP_TYPE_ns1__investigation:
		return soap_in_ns1__investigation(soap, NULL, NULL, "ns1:investigation");
	case SOAP_TYPE_ns1__searchByUserSurnameResponse:
		return soap_in_ns1__searchByUserSurnameResponse(soap, NULL, NULL, "ns1:searchByUserSurnameResponse");
	case SOAP_TYPE_ns1__searchByUserSurname:
		return soap_in_ns1__searchByUserSurname(soap, NULL, NULL, "ns1:searchByUserSurname");
	case SOAP_TYPE_ns1__deleteDataFileResponse:
		return soap_in_ns1__deleteDataFileResponse(soap, NULL, NULL, "ns1:deleteDataFileResponse");
	case SOAP_TYPE_ns1__deleteDataFile:
		return soap_in_ns1__deleteDataFile(soap, NULL, NULL, "ns1:deleteDataFile");
	case SOAP_TYPE_ns1__downloadInfo:
		return soap_in_ns1__downloadInfo(soap, NULL, NULL, "ns1:downloadInfo");
	case SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse:
		return soap_in_ns1__checkDatafileDownloadAccessResponse(soap, NULL, NULL, "ns1:checkDatafileDownloadAccessResponse");
	case SOAP_TYPE_ns1__checkDatafileDownloadAccess:
		return soap_in_ns1__checkDatafileDownloadAccess(soap, NULL, NULL, "ns1:checkDatafileDownloadAccess");
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse:
		return soap_in_ns1__getFacilityUserByFacilityUserIdResponse(soap, NULL, NULL, "ns1:getFacilityUserByFacilityUserIdResponse");
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserId:
		return soap_in_ns1__getFacilityUserByFacilityUserId(soap, NULL, NULL, "ns1:getFacilityUserByFacilityUserId");
	case SOAP_TYPE_ns1__addSampleParameterResponse:
		return soap_in_ns1__addSampleParameterResponse(soap, NULL, NULL, "ns1:addSampleParameterResponse");
	case SOAP_TYPE_ns1__addSampleParameter:
		return soap_in_ns1__addSampleParameter(soap, NULL, NULL, "ns1:addSampleParameter");
	case SOAP_TYPE_ns1__modifyDataSetResponse:
		return soap_in_ns1__modifyDataSetResponse(soap, NULL, NULL, "ns1:modifyDataSetResponse");
	case SOAP_TYPE_ns1__modifyDataSet:
		return soap_in_ns1__modifyDataSet(soap, NULL, NULL, "ns1:modifyDataSet");
	case SOAP_TYPE_ns1__downloadDatafilesResponse:
		return soap_in_ns1__downloadDatafilesResponse(soap, NULL, NULL, "ns1:downloadDatafilesResponse");
	case SOAP_TYPE_ns1__downloadDatafiles:
		return soap_in_ns1__downloadDatafiles(soap, NULL, NULL, "ns1:downloadDatafiles");
	case SOAP_TYPE_ns1__NoSuchUserException:
		return soap_in_ns1__NoSuchUserException(soap, NULL, NULL, "ns1:NoSuchUserException");
	case SOAP_TYPE_ns1__userDetails:
		return soap_in_ns1__userDetails(soap, NULL, NULL, "ns1:userDetails");
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		return soap_in_ns1__getUserDetailsResponse(soap, NULL, NULL, "ns1:getUserDetailsResponse");
	case SOAP_TYPE_ns1__getUserDetails:
		return soap_in_ns1__getUserDetails(soap, NULL, NULL, "ns1:getUserDetails");
	case SOAP_TYPE_ns1__getAllKeywordsResponse:
		return soap_in_ns1__getAllKeywordsResponse(soap, NULL, NULL, "ns1:getAllKeywordsResponse");
	case SOAP_TYPE_ns1__getAllKeywords:
		return soap_in_ns1__getAllKeywords(soap, NULL, NULL, "ns1:getAllKeywords");
	case SOAP_TYPE_ns1__removePublicationResponse:
		return soap_in_ns1__removePublicationResponse(soap, NULL, NULL, "ns1:removePublicationResponse");
	case SOAP_TYPE_ns1__removePublication:
		return soap_in_ns1__removePublication(soap, NULL, NULL, "ns1:removePublication");
	case SOAP_TYPE_ns1__createDataSetsResponse:
		return soap_in_ns1__createDataSetsResponse(soap, NULL, NULL, "ns1:createDataSetsResponse");
	case SOAP_TYPE_ns1__parameterPK:
		return soap_in_ns1__parameterPK(soap, NULL, NULL, "ns1:parameterPK");
	case SOAP_TYPE_ns1__parameter:
		return soap_in_ns1__parameter(soap, NULL, NULL, "ns1:parameter");
	case SOAP_TYPE_ns1__datasetParameterPK:
		return soap_in_ns1__datasetParameterPK(soap, NULL, NULL, "ns1:datasetParameterPK");
	case SOAP_TYPE_ns1__datasetParameter:
		return soap_in_ns1__datasetParameter(soap, NULL, NULL, "ns1:datasetParameter");
	case SOAP_TYPE_ns1__dataset:
		return soap_in_ns1__dataset(soap, NULL, NULL, "ns1:dataset");
	case SOAP_TYPE_ns1__createDataSets:
		return soap_in_ns1__createDataSets(soap, NULL, NULL, "ns1:createDataSets");
	case SOAP_TYPE_ns1__deleteInvestigationResponse:
		return soap_in_ns1__deleteInvestigationResponse(soap, NULL, NULL, "ns1:deleteInvestigationResponse");
	case SOAP_TYPE_ns1__deleteInvestigation:
		return soap_in_ns1__deleteInvestigation(soap, NULL, NULL, "ns1:deleteInvestigation");
	case SOAP_TYPE_ns1__removeKeywordResponse:
		return soap_in_ns1__removeKeywordResponse(soap, NULL, NULL, "ns1:removeKeywordResponse");
	case SOAP_TYPE_ns1__keywordPK:
		return soap_in_ns1__keywordPK(soap, NULL, NULL, "ns1:keywordPK");
	case SOAP_TYPE_ns1__removeKeyword:
		return soap_in_ns1__removeKeyword(soap, NULL, NULL, "ns1:removeKeyword");
	case SOAP_TYPE_ns1__removeInvestigationResponse:
		return soap_in_ns1__removeInvestigationResponse(soap, NULL, NULL, "ns1:removeInvestigationResponse");
	case SOAP_TYPE_ns1__removeInvestigation:
		return soap_in_ns1__removeInvestigation(soap, NULL, NULL, "ns1:removeInvestigation");
	case SOAP_TYPE_ns1__removeInvestigatorResponse:
		return soap_in_ns1__removeInvestigatorResponse(soap, NULL, NULL, "ns1:removeInvestigatorResponse");
	case SOAP_TYPE_ns1__investigatorPK:
		return soap_in_ns1__investigatorPK(soap, NULL, NULL, "ns1:investigatorPK");
	case SOAP_TYPE_ns1__removeInvestigator:
		return soap_in_ns1__removeInvestigator(soap, NULL, NULL, "ns1:removeInvestigator");
	case SOAP_TYPE_ns1__facilityUser:
		return soap_in_ns1__facilityUser(soap, NULL, NULL, "ns1:facilityUser");
	case SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse:
		return soap_in_ns1__getFacilityUserByFederalIdResponse(soap, NULL, NULL, "ns1:getFacilityUserByFederalIdResponse");
	case SOAP_TYPE_ns1__getFacilityUserByFederalId:
		return soap_in_ns1__getFacilityUserByFederalId(soap, NULL, NULL, "ns1:getFacilityUserByFederalId");
	case SOAP_TYPE_ns1__downloadDatasetResponse:
		return soap_in_ns1__downloadDatasetResponse(soap, NULL, NULL, "ns1:downloadDatasetResponse");
	case SOAP_TYPE_ns1__downloadDataset:
		return soap_in_ns1__downloadDataset(soap, NULL, NULL, "ns1:downloadDataset");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_in_ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_in_ns1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_ns1__facilityCycle:
		return soap_in_ns1__facilityCycle(soap, NULL, NULL, "ns1:facilityCycle");
	case SOAP_TYPE_ns1__listFacilityCyclesResponse:
		return soap_in_ns1__listFacilityCyclesResponse(soap, NULL, NULL, "ns1:listFacilityCyclesResponse");
	case SOAP_TYPE_ns1__listFacilityCycles:
		return soap_in_ns1__listFacilityCycles(soap, NULL, NULL, "ns1:listFacilityCycles");
	case SOAP_TYPE_ns1__addDataFileParametersResponse:
		return soap_in_ns1__addDataFileParametersResponse(soap, NULL, NULL, "ns1:addDataFileParametersResponse");
	case SOAP_TYPE_ns1__addDataFileParameters:
		return soap_in_ns1__addDataFileParameters(soap, NULL, NULL, "ns1:addDataFileParameters");
	case SOAP_TYPE_ns1__removeAuthorisationResponse:
		return soap_in_ns1__removeAuthorisationResponse(soap, NULL, NULL, "ns1:removeAuthorisationResponse");
	case SOAP_TYPE_ns1__removeAuthorisation:
		return soap_in_ns1__removeAuthorisation(soap, NULL, NULL, "ns1:removeAuthorisation");
	case SOAP_TYPE_ns1__removeDataFileResponse:
		return soap_in_ns1__removeDataFileResponse(soap, NULL, NULL, "ns1:removeDataFileResponse");
	case SOAP_TYPE_ns1__removeDataFile:
		return soap_in_ns1__removeDataFile(soap, NULL, NULL, "ns1:removeDataFile");
	case SOAP_TYPE_ns1__modifySampleResponse:
		return soap_in_ns1__modifySampleResponse(soap, NULL, NULL, "ns1:modifySampleResponse");
	case SOAP_TYPE_ns1__modifySample:
		return soap_in_ns1__modifySample(soap, NULL, NULL, "ns1:modifySample");
	case SOAP_TYPE_ns1__ValidationException:
		return soap_in_ns1__ValidationException(soap, NULL, NULL, "ns1:ValidationException");
	case SOAP_TYPE_ns1__createDataFileResponse:
		return soap_in_ns1__createDataFileResponse(soap, NULL, NULL, "ns1:createDataFileResponse");
	case SOAP_TYPE_ns1__relatedDatafilesPK:
		return soap_in_ns1__relatedDatafilesPK(soap, NULL, NULL, "ns1:relatedDatafilesPK");
	case SOAP_TYPE_ns1__relatedDatafiles:
		return soap_in_ns1__relatedDatafiles(soap, NULL, NULL, "ns1:relatedDatafiles");
	case SOAP_TYPE_ns1__datafileParameterPK:
		return soap_in_ns1__datafileParameterPK(soap, NULL, NULL, "ns1:datafileParameterPK");
	case SOAP_TYPE_ns1__datafileParameter:
		return soap_in_ns1__datafileParameter(soap, NULL, NULL, "ns1:datafileParameter");
	case SOAP_TYPE_ns1__datafileFormatPK:
		return soap_in_ns1__datafileFormatPK(soap, NULL, NULL, "ns1:datafileFormatPK");
	case SOAP_TYPE_ns1__datafileFormat:
		return soap_in_ns1__datafileFormat(soap, NULL, NULL, "ns1:datafileFormat");
	case SOAP_TYPE_ns1__datafile:
		return soap_in_ns1__datafile(soap, NULL, NULL, "ns1:datafile");
	case SOAP_TYPE_ns1__createDataFile:
		return soap_in_ns1__createDataFile(soap, NULL, NULL, "ns1:createDataFile");
	case SOAP_TYPE_ns1__listInstrumentsResponse:
		return soap_in_ns1__listInstrumentsResponse(soap, NULL, NULL, "ns1:listInstrumentsResponse");
	case SOAP_TYPE_ns1__listInstruments:
		return soap_in_ns1__listInstruments(soap, NULL, NULL, "ns1:listInstruments");
	case SOAP_TYPE_ns1__NoSuchObjectFoundException:
		return soap_in_ns1__NoSuchObjectFoundException(soap, NULL, NULL, "ns1:NoSuchObjectFoundException");
	case SOAP_TYPE_ns1__InsufficientPrivilegesException:
		return soap_in_ns1__InsufficientPrivilegesException(soap, NULL, NULL, "ns1:InsufficientPrivilegesException");
	case SOAP_TYPE_ns1__removeSampleResponse:
		return soap_in_ns1__removeSampleResponse(soap, NULL, NULL, "ns1:removeSampleResponse");
	case SOAP_TYPE_ns1__removeSample:
		return soap_in_ns1__removeSample(soap, NULL, NULL, "ns1:removeSample");
	case SOAP_TYPE_ns1__icatRole:
		return soap_in_ns1__icatRole(soap, NULL, NULL, "ns1:icatRole");
	case SOAP_TYPE_ns1__entityPrimaryKeyBaseBean:
		return soap_in_ns1__entityPrimaryKeyBaseBean(soap, NULL, NULL, "ns1:entityPrimaryKeyBaseBean");
	case SOAP_TYPE_ns1__sampleParameterPK:
		return soap_in_ns1__sampleParameterPK(soap, NULL, NULL, "ns1:sampleParameterPK");
	case SOAP_TYPE_ns1__sampleParameter:
		return soap_in_ns1__sampleParameter(soap, NULL, NULL, "ns1:sampleParameter");
	case SOAP_TYPE_ns1__entityBaseBean:
		return soap_in_ns1__entityBaseBean(soap, NULL, NULL, "ns1:entityBaseBean");
	case SOAP_TYPE_ns1__sample:
		return soap_in_ns1__sample(soap, NULL, NULL, "ns1:sample");
	case SOAP_TYPE_ns1__searchSamplesBySampleNameResponse:
		return soap_in_ns1__searchSamplesBySampleNameResponse(soap, NULL, NULL, "ns1:searchSamplesBySampleNameResponse");
	case SOAP_TYPE_ns1__searchSamplesBySampleName:
		return soap_in_ns1__searchSamplesBySampleName(soap, NULL, NULL, "ns1:searchSamplesBySampleName");
	case SOAP_TYPE_ns1__listDatasetTypesResponse:
		return soap_in_ns1__listDatasetTypesResponse(soap, NULL, NULL, "ns1:listDatasetTypesResponse");
	case SOAP_TYPE_ns1__listDatasetTypes:
		return soap_in_ns1__listDatasetTypes(soap, NULL, NULL, "ns1:listDatasetTypes");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__getICATAPIVersionResponse:
		return soap_in_PointerTons1__getICATAPIVersionResponse(soap, NULL, NULL, "ns1:getICATAPIVersionResponse");
	case SOAP_TYPE_PointerTons1__getICATAPIVersion:
		return soap_in_PointerTons1__getICATAPIVersion(soap, NULL, NULL, "ns1:getICATAPIVersion");
	case SOAP_TYPE_PointerTons1__listFacilityCyclesResponse:
		return soap_in_PointerTons1__listFacilityCyclesResponse(soap, NULL, NULL, "ns1:listFacilityCyclesResponse");
	case SOAP_TYPE_PointerTons1__listFacilityCycles:
		return soap_in_PointerTons1__listFacilityCycles(soap, NULL, NULL, "ns1:listFacilityCycles");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFederalIdResponse:
		return soap_in_PointerTons1__getFacilityUserByFederalIdResponse(soap, NULL, NULL, "ns1:getFacilityUserByFederalIdResponse");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFederalId:
		return soap_in_PointerTons1__getFacilityUserByFederalId(soap, NULL, NULL, "ns1:getFacilityUserByFederalId");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserIdResponse:
		return soap_in_PointerTons1__getFacilityUserByFacilityUserIdResponse(soap, NULL, NULL, "ns1:getFacilityUserByFacilityUserIdResponse");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserId:
		return soap_in_PointerTons1__getFacilityUserByFacilityUserId(soap, NULL, NULL, "ns1:getFacilityUserByFacilityUserId");
	case SOAP_TYPE_PointerTons1__searchDatasetsBySampleResponse:
		return soap_in_PointerTons1__searchDatasetsBySampleResponse(soap, NULL, NULL, "ns1:searchDatasetsBySampleResponse");
	case SOAP_TYPE_PointerTons1__searchDatasetsBySample:
		return soap_in_PointerTons1__searchDatasetsBySample(soap, NULL, NULL, "ns1:searchDatasetsBySample");
	case SOAP_TYPE_PointerTons1__checkDatasetDownloadAccessResponse:
		return soap_in_PointerTons1__checkDatasetDownloadAccessResponse(soap, NULL, NULL, "ns1:checkDatasetDownloadAccessResponse");
	case SOAP_TYPE_PointerTons1__checkDatasetDownloadAccess:
		return soap_in_PointerTons1__checkDatasetDownloadAccess(soap, NULL, NULL, "ns1:checkDatasetDownloadAccess");
	case SOAP_TYPE_PointerTons1__checkDatafileDownloadAccessResponse:
		return soap_in_PointerTons1__checkDatafileDownloadAccessResponse(soap, NULL, NULL, "ns1:checkDatafileDownloadAccessResponse");
	case SOAP_TYPE_PointerTons1__checkDatafileDownloadAccess:
		return soap_in_PointerTons1__checkDatafileDownloadAccess(soap, NULL, NULL, "ns1:checkDatafileDownloadAccess");
	case SOAP_TYPE_PointerTons1__downloadDatasetResponse:
		return soap_in_PointerTons1__downloadDatasetResponse(soap, NULL, NULL, "ns1:downloadDatasetResponse");
	case SOAP_TYPE_PointerTons1__downloadDataset:
		return soap_in_PointerTons1__downloadDataset(soap, NULL, NULL, "ns1:downloadDataset");
	case SOAP_TYPE_PointerTons1__downloadDatafilesResponse:
		return soap_in_PointerTons1__downloadDatafilesResponse(soap, NULL, NULL, "ns1:downloadDatafilesResponse");
	case SOAP_TYPE_PointerTons1__downloadDatafiles:
		return soap_in_PointerTons1__downloadDatafiles(soap, NULL, NULL, "ns1:downloadDatafiles");
	case SOAP_TYPE_PointerTons1__downloadDatafileResponse:
		return soap_in_PointerTons1__downloadDatafileResponse(soap, NULL, NULL, "ns1:downloadDatafileResponse");
	case SOAP_TYPE_PointerTons1__downloadDatafile:
		return soap_in_PointerTons1__downloadDatafile(soap, NULL, NULL, "ns1:downloadDatafile");
	case SOAP_TYPE_PointerTons1__listParametersResponse:
		return soap_in_PointerTons1__listParametersResponse(soap, NULL, NULL, "ns1:listParametersResponse");
	case SOAP_TYPE_PointerTons1__listParameters:
		return soap_in_PointerTons1__listParameters(soap, NULL, NULL, "ns1:listParameters");
	case SOAP_TYPE_PointerTons1__listInvestigationTypesResponse:
		return soap_in_PointerTons1__listInvestigationTypesResponse(soap, NULL, NULL, "ns1:listInvestigationTypesResponse");
	case SOAP_TYPE_PointerTons1__listInvestigationTypes:
		return soap_in_PointerTons1__listInvestigationTypes(soap, NULL, NULL, "ns1:listInvestigationTypes");
	case SOAP_TYPE_PointerTons1__listRolesResponse:
		return soap_in_PointerTons1__listRolesResponse(soap, NULL, NULL, "ns1:listRolesResponse");
	case SOAP_TYPE_PointerTons1__listRoles:
		return soap_in_PointerTons1__listRoles(soap, NULL, NULL, "ns1:listRoles");
	case SOAP_TYPE_PointerTons1__listInstrumentsResponse:
		return soap_in_PointerTons1__listInstrumentsResponse(soap, NULL, NULL, "ns1:listInstrumentsResponse");
	case SOAP_TYPE_PointerTons1__listInstruments:
		return soap_in_PointerTons1__listInstruments(soap, NULL, NULL, "ns1:listInstruments");
	case SOAP_TYPE_PointerTons1__searchByUserSurnamePaginationResponse:
		return soap_in_PointerTons1__searchByUserSurnamePaginationResponse(soap, NULL, NULL, "ns1:searchByUserSurnamePaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByUserSurnamePagination:
		return soap_in_PointerTons1__searchByUserSurnamePagination(soap, NULL, NULL, "ns1:searchByUserSurnamePagination");
	case SOAP_TYPE_PointerTons1__searchByUserSurnameResponse:
		return soap_in_PointerTons1__searchByUserSurnameResponse(soap, NULL, NULL, "ns1:searchByUserSurnameResponse");
	case SOAP_TYPE_PointerTons1__searchByUserSurname:
		return soap_in_PointerTons1__searchByUserSurname(soap, NULL, NULL, "ns1:searchByUserSurname");
	case SOAP_TYPE_PointerTons1__searchByUserIDPaginationResponse:
		return soap_in_PointerTons1__searchByUserIDPaginationResponse(soap, NULL, NULL, "ns1:searchByUserIDPaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByUserIDPagination:
		return soap_in_PointerTons1__searchByUserIDPagination(soap, NULL, NULL, "ns1:searchByUserIDPagination");
	case SOAP_TYPE_PointerTons1__searchByUserIDResponse:
		return soap_in_PointerTons1__searchByUserIDResponse(soap, NULL, NULL, "ns1:searchByUserIDResponse");
	case SOAP_TYPE_PointerTons1__searchByUserID:
		return soap_in_PointerTons1__searchByUserID(soap, NULL, NULL, "ns1:searchByUserID");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPaginationResponse:
		return soap_in_PointerTons1__getMyInvestigationsIncludesPaginationResponse(soap, NULL, NULL, "ns1:getMyInvestigationsIncludesPaginationResponse");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPagination:
		return soap_in_PointerTons1__getMyInvestigationsIncludesPagination(soap, NULL, NULL, "ns1:getMyInvestigationsIncludesPagination");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesResponse:
		return soap_in_PointerTons1__getMyInvestigationsIncludesResponse(soap, NULL, NULL, "ns1:getMyInvestigationsIncludesResponse");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludes:
		return soap_in_PointerTons1__getMyInvestigationsIncludes(soap, NULL, NULL, "ns1:getMyInvestigationsIncludes");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsResponse:
		return soap_in_PointerTons1__getMyInvestigationsResponse(soap, NULL, NULL, "ns1:getMyInvestigationsResponse");
	case SOAP_TYPE_PointerTons1__getMyInvestigations:
		return soap_in_PointerTons1__getMyInvestigations(soap, NULL, NULL, "ns1:getMyInvestigations");
	case SOAP_TYPE_PointerTons1__searchByKeywordsAllResponse:
		return soap_in_PointerTons1__searchByKeywordsAllResponse(soap, NULL, NULL, "ns1:searchByKeywordsAllResponse");
	case SOAP_TYPE_PointerTons1__searchByKeywordsAll:
		return soap_in_PointerTons1__searchByKeywordsAll(soap, NULL, NULL, "ns1:searchByKeywordsAll");
	case SOAP_TYPE_PointerTons1__searchByKeywordsResponse:
		return soap_in_PointerTons1__searchByKeywordsResponse(soap, NULL, NULL, "ns1:searchByKeywordsResponse");
	case SOAP_TYPE_PointerTons1__searchByKeywords:
		return soap_in_PointerTons1__searchByKeywords(soap, NULL, NULL, "ns1:searchByKeywords");
	case SOAP_TYPE_PointerTons1__searchByAdvancedPaginationResponse:
		return soap_in_PointerTons1__searchByAdvancedPaginationResponse(soap, NULL, NULL, "ns1:searchByAdvancedPaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByAdvancedPagination:
		return soap_in_PointerTons1__searchByAdvancedPagination(soap, NULL, NULL, "ns1:searchByAdvancedPagination");
	case SOAP_TYPE_PointerTons1__searchByAdvancedResponse:
		return soap_in_PointerTons1__searchByAdvancedResponse(soap, NULL, NULL, "ns1:searchByAdvancedResponse");
	case SOAP_TYPE_PointerTons1__searchByAdvanced:
		return soap_in_PointerTons1__searchByAdvanced(soap, NULL, NULL, "ns1:searchByAdvanced");
	case SOAP_TYPE_PointerTons1__setDataSetSampleResponse:
		return soap_in_PointerTons1__setDataSetSampleResponse(soap, NULL, NULL, "ns1:setDataSetSampleResponse");
	case SOAP_TYPE_PointerTons1__setDataSetSample:
		return soap_in_PointerTons1__setDataSetSample(soap, NULL, NULL, "ns1:setDataSetSample");
	case SOAP_TYPE_PointerTons1__deleteDataSetParameterResponse:
		return soap_in_PointerTons1__deleteDataSetParameterResponse(soap, NULL, NULL, "ns1:deleteDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__deleteDataSetParameter:
		return soap_in_PointerTons1__deleteDataSetParameter(soap, NULL, NULL, "ns1:deleteDataSetParameter");
	case SOAP_TYPE_PointerTons1__removeDataSetParameterResponse:
		return soap_in_PointerTons1__removeDataSetParameterResponse(soap, NULL, NULL, "ns1:removeDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__removeDataSetParameter:
		return soap_in_PointerTons1__removeDataSetParameter(soap, NULL, NULL, "ns1:removeDataSetParameter");
	case SOAP_TYPE_PointerTons1__modifyDataSetParameterResponse:
		return soap_in_PointerTons1__modifyDataSetParameterResponse(soap, NULL, NULL, "ns1:modifyDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__modifyDataSetParameter:
		return soap_in_PointerTons1__modifyDataSetParameter(soap, NULL, NULL, "ns1:modifyDataSetParameter");
	case SOAP_TYPE_PointerTons1__addDataSetParametersResponse:
		return soap_in_PointerTons1__addDataSetParametersResponse(soap, NULL, NULL, "ns1:addDataSetParametersResponse");
	case SOAP_TYPE_PointerTons1__addDataSetParameters:
		return soap_in_PointerTons1__addDataSetParameters(soap, NULL, NULL, "ns1:addDataSetParameters");
	case SOAP_TYPE_PointerTons1__addDataSetParameterResponse:
		return soap_in_PointerTons1__addDataSetParameterResponse(soap, NULL, NULL, "ns1:addDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__addDataSetParameter:
		return soap_in_PointerTons1__addDataSetParameter(soap, NULL, NULL, "ns1:addDataSetParameter");
	case SOAP_TYPE_PointerTons1__modifyDataSetResponse:
		return soap_in_PointerTons1__modifyDataSetResponse(soap, NULL, NULL, "ns1:modifyDataSetResponse");
	case SOAP_TYPE_PointerTons1__modifyDataSet:
		return soap_in_PointerTons1__modifyDataSet(soap, NULL, NULL, "ns1:modifyDataSet");
	case SOAP_TYPE_PointerTons1__deleteDataSetResponse:
		return soap_in_PointerTons1__deleteDataSetResponse(soap, NULL, NULL, "ns1:deleteDataSetResponse");
	case SOAP_TYPE_PointerTons1__deleteDataSet:
		return soap_in_PointerTons1__deleteDataSet(soap, NULL, NULL, "ns1:deleteDataSet");
	case SOAP_TYPE_PointerTons1__removeDataSetResponse:
		return soap_in_PointerTons1__removeDataSetResponse(soap, NULL, NULL, "ns1:removeDataSetResponse");
	case SOAP_TYPE_PointerTons1__removeDataSet:
		return soap_in_PointerTons1__removeDataSet(soap, NULL, NULL, "ns1:removeDataSet");
	case SOAP_TYPE_PointerTons1__createDataSetsResponse:
		return soap_in_PointerTons1__createDataSetsResponse(soap, NULL, NULL, "ns1:createDataSetsResponse");
	case SOAP_TYPE_PointerTons1__createDataSets:
		return soap_in_PointerTons1__createDataSets(soap, NULL, NULL, "ns1:createDataSets");
	case SOAP_TYPE_PointerTons1__createDataSetResponse:
		return soap_in_PointerTons1__createDataSetResponse(soap, NULL, NULL, "ns1:createDataSetResponse");
	case SOAP_TYPE_PointerTons1__createDataSet:
		return soap_in_PointerTons1__createDataSet(soap, NULL, NULL, "ns1:createDataSet");
	case SOAP_TYPE_PointerTons1__getDatasetsResponse:
		return soap_in_PointerTons1__getDatasetsResponse(soap, NULL, NULL, "ns1:getDatasetsResponse");
	case SOAP_TYPE_PointerTons1__getDatasets:
		return soap_in_PointerTons1__getDatasets(soap, NULL, NULL, "ns1:getDatasets");
	case SOAP_TYPE_PointerTons1__listDatasetStatusResponse:
		return soap_in_PointerTons1__listDatasetStatusResponse(soap, NULL, NULL, "ns1:listDatasetStatusResponse");
	case SOAP_TYPE_PointerTons1__listDatasetStatus:
		return soap_in_PointerTons1__listDatasetStatus(soap, NULL, NULL, "ns1:listDatasetStatus");
	case SOAP_TYPE_PointerTons1__listDatasetTypesResponse:
		return soap_in_PointerTons1__listDatasetTypesResponse(soap, NULL, NULL, "ns1:listDatasetTypesResponse");
	case SOAP_TYPE_PointerTons1__listDatasetTypes:
		return soap_in_PointerTons1__listDatasetTypes(soap, NULL, NULL, "ns1:listDatasetTypes");
	case SOAP_TYPE_PointerTons1__searchSamplesBySampleNameResponse:
		return soap_in_PointerTons1__searchSamplesBySampleNameResponse(soap, NULL, NULL, "ns1:searchSamplesBySampleNameResponse");
	case SOAP_TYPE_PointerTons1__searchSamplesBySampleName:
		return soap_in_PointerTons1__searchSamplesBySampleName(soap, NULL, NULL, "ns1:searchSamplesBySampleName");
	case SOAP_TYPE_PointerTons1__listDatafileFormatsResponse:
		return soap_in_PointerTons1__listDatafileFormatsResponse(soap, NULL, NULL, "ns1:listDatafileFormatsResponse");
	case SOAP_TYPE_PointerTons1__listDatafileFormats:
		return soap_in_PointerTons1__listDatafileFormats(soap, NULL, NULL, "ns1:listDatafileFormats");
	case SOAP_TYPE_PointerTons1__searchByRunNumberPaginationResponse:
		return soap_in_PointerTons1__searchByRunNumberPaginationResponse(soap, NULL, NULL, "ns1:searchByRunNumberPaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByRunNumberPagination:
		return soap_in_PointerTons1__searchByRunNumberPagination(soap, NULL, NULL, "ns1:searchByRunNumberPagination");
	case SOAP_TYPE_PointerTons1__searchByRunNumberResponse:
		return soap_in_PointerTons1__searchByRunNumberResponse(soap, NULL, NULL, "ns1:searchByRunNumberResponse");
	case SOAP_TYPE_PointerTons1__searchByRunNumber:
		return soap_in_PointerTons1__searchByRunNumber(soap, NULL, NULL, "ns1:searchByRunNumber");
	case SOAP_TYPE_PointerTons1__getAllKeywordsResponse:
		return soap_in_PointerTons1__getAllKeywordsResponse(soap, NULL, NULL, "ns1:getAllKeywordsResponse");
	case SOAP_TYPE_PointerTons1__getAllKeywords:
		return soap_in_PointerTons1__getAllKeywords(soap, NULL, NULL, "ns1:getAllKeywords");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserTypeResponse:
		return soap_in_PointerTons1__getKeywordsForUserTypeResponse(soap, NULL, NULL, "ns1:getKeywordsForUserTypeResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserType:
		return soap_in_PointerTons1__getKeywordsForUserType(soap, NULL, NULL, "ns1:getKeywordsForUserType");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserMaxResponse:
		return soap_in_PointerTons1__getKeywordsForUserMaxResponse(soap, NULL, NULL, "ns1:getKeywordsForUserMaxResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserMax:
		return soap_in_PointerTons1__getKeywordsForUserMax(soap, NULL, NULL, "ns1:getKeywordsForUserMax");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMaxResponse:
		return soap_in_PointerTons1__getKeywordsForUserStartWithMaxResponse(soap, NULL, NULL, "ns1:getKeywordsForUserStartWithMaxResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMax:
		return soap_in_PointerTons1__getKeywordsForUserStartWithMax(soap, NULL, NULL, "ns1:getKeywordsForUserStartWithMax");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserResponse:
		return soap_in_PointerTons1__getKeywordsForUserResponse(soap, NULL, NULL, "ns1:getKeywordsForUserResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUser:
		return soap_in_PointerTons1__getKeywordsForUser(soap, NULL, NULL, "ns1:getKeywordsForUser");
	case SOAP_TYPE_PointerTons1__modifySampleParameterResponse:
		return soap_in_PointerTons1__modifySampleParameterResponse(soap, NULL, NULL, "ns1:modifySampleParameterResponse");
	case SOAP_TYPE_PointerTons1__modifySampleParameter:
		return soap_in_PointerTons1__modifySampleParameter(soap, NULL, NULL, "ns1:modifySampleParameter");
	case SOAP_TYPE_PointerTons1__deleteSampleParameterResponse:
		return soap_in_PointerTons1__deleteSampleParameterResponse(soap, NULL, NULL, "ns1:deleteSampleParameterResponse");
	case SOAP_TYPE_PointerTons1__deleteSampleParameter:
		return soap_in_PointerTons1__deleteSampleParameter(soap, NULL, NULL, "ns1:deleteSampleParameter");
	case SOAP_TYPE_PointerTons1__removeSampleParameterResponse:
		return soap_in_PointerTons1__removeSampleParameterResponse(soap, NULL, NULL, "ns1:removeSampleParameterResponse");
	case SOAP_TYPE_PointerTons1__removeSampleParameter:
		return soap_in_PointerTons1__removeSampleParameter(soap, NULL, NULL, "ns1:removeSampleParameter");
	case SOAP_TYPE_PointerTons1__modifySampleResponse:
		return soap_in_PointerTons1__modifySampleResponse(soap, NULL, NULL, "ns1:modifySampleResponse");
	case SOAP_TYPE_PointerTons1__modifySample:
		return soap_in_PointerTons1__modifySample(soap, NULL, NULL, "ns1:modifySample");
	case SOAP_TYPE_PointerTons1__deleteSampleResponse:
		return soap_in_PointerTons1__deleteSampleResponse(soap, NULL, NULL, "ns1:deleteSampleResponse");
	case SOAP_TYPE_PointerTons1__deleteSample:
		return soap_in_PointerTons1__deleteSample(soap, NULL, NULL, "ns1:deleteSample");
	case SOAP_TYPE_PointerTons1__removeSampleResponse:
		return soap_in_PointerTons1__removeSampleResponse(soap, NULL, NULL, "ns1:removeSampleResponse");
	case SOAP_TYPE_PointerTons1__removeSample:
		return soap_in_PointerTons1__removeSample(soap, NULL, NULL, "ns1:removeSample");
	case SOAP_TYPE_PointerTons1__deleteInvestigatorResponse:
		return soap_in_PointerTons1__deleteInvestigatorResponse(soap, NULL, NULL, "ns1:deleteInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__deleteInvestigator:
		return soap_in_PointerTons1__deleteInvestigator(soap, NULL, NULL, "ns1:deleteInvestigator");
	case SOAP_TYPE_PointerTons1__modifyInvestigatorResponse:
		return soap_in_PointerTons1__modifyInvestigatorResponse(soap, NULL, NULL, "ns1:modifyInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__modifyInvestigator:
		return soap_in_PointerTons1__modifyInvestigator(soap, NULL, NULL, "ns1:modifyInvestigator");
	case SOAP_TYPE_PointerTons1__removeInvestigatorResponse:
		return soap_in_PointerTons1__removeInvestigatorResponse(soap, NULL, NULL, "ns1:removeInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__removeInvestigator:
		return soap_in_PointerTons1__removeInvestigator(soap, NULL, NULL, "ns1:removeInvestigator");
	case SOAP_TYPE_PointerTons1__modifyPublicationResponse:
		return soap_in_PointerTons1__modifyPublicationResponse(soap, NULL, NULL, "ns1:modifyPublicationResponse");
	case SOAP_TYPE_PointerTons1__modifyPublication:
		return soap_in_PointerTons1__modifyPublication(soap, NULL, NULL, "ns1:modifyPublication");
	case SOAP_TYPE_PointerTons1__deletePublicationResponse:
		return soap_in_PointerTons1__deletePublicationResponse(soap, NULL, NULL, "ns1:deletePublicationResponse");
	case SOAP_TYPE_PointerTons1__deletePublication:
		return soap_in_PointerTons1__deletePublication(soap, NULL, NULL, "ns1:deletePublication");
	case SOAP_TYPE_PointerTons1__removePublicationResponse:
		return soap_in_PointerTons1__removePublicationResponse(soap, NULL, NULL, "ns1:removePublicationResponse");
	case SOAP_TYPE_PointerTons1__removePublication:
		return soap_in_PointerTons1__removePublication(soap, NULL, NULL, "ns1:removePublication");
	case SOAP_TYPE_PointerTons1__deleteKeywordResponse:
		return soap_in_PointerTons1__deleteKeywordResponse(soap, NULL, NULL, "ns1:deleteKeywordResponse");
	case SOAP_TYPE_PointerTons1__deleteKeyword:
		return soap_in_PointerTons1__deleteKeyword(soap, NULL, NULL, "ns1:deleteKeyword");
	case SOAP_TYPE_PointerTons1__removeKeywordResponse:
		return soap_in_PointerTons1__removeKeywordResponse(soap, NULL, NULL, "ns1:removeKeywordResponse");
	case SOAP_TYPE_PointerTons1__removeKeyword:
		return soap_in_PointerTons1__removeKeyword(soap, NULL, NULL, "ns1:removeKeyword");
	case SOAP_TYPE_PointerTons1__modifyInvestigationResponse:
		return soap_in_PointerTons1__modifyInvestigationResponse(soap, NULL, NULL, "ns1:modifyInvestigationResponse");
	case SOAP_TYPE_PointerTons1__modifyInvestigation:
		return soap_in_PointerTons1__modifyInvestigation(soap, NULL, NULL, "ns1:modifyInvestigation");
	case SOAP_TYPE_PointerTons1__deleteInvestigationResponse:
		return soap_in_PointerTons1__deleteInvestigationResponse(soap, NULL, NULL, "ns1:deleteInvestigationResponse");
	case SOAP_TYPE_PointerTons1__deleteInvestigation:
		return soap_in_PointerTons1__deleteInvestigation(soap, NULL, NULL, "ns1:deleteInvestigation");
	case SOAP_TYPE_PointerTons1__removeInvestigationResponse:
		return soap_in_PointerTons1__removeInvestigationResponse(soap, NULL, NULL, "ns1:removeInvestigationResponse");
	case SOAP_TYPE_PointerTons1__removeInvestigation:
		return soap_in_PointerTons1__removeInvestigation(soap, NULL, NULL, "ns1:removeInvestigation");
	case SOAP_TYPE_PointerTons1__createInvestigationResponse:
		return soap_in_PointerTons1__createInvestigationResponse(soap, NULL, NULL, "ns1:createInvestigationResponse");
	case SOAP_TYPE_PointerTons1__createInvestigation:
		return soap_in_PointerTons1__createInvestigation(soap, NULL, NULL, "ns1:createInvestigation");
	case SOAP_TYPE_PointerTons1__getInvestigationsIncludesResponse:
		return soap_in_PointerTons1__getInvestigationsIncludesResponse(soap, NULL, NULL, "ns1:getInvestigationsIncludesResponse");
	case SOAP_TYPE_PointerTons1__getInvestigationsIncludes:
		return soap_in_PointerTons1__getInvestigationsIncludes(soap, NULL, NULL, "ns1:getInvestigationsIncludes");
	case SOAP_TYPE_PointerTons1__updateAuthorisationResponse:
		return soap_in_PointerTons1__updateAuthorisationResponse(soap, NULL, NULL, "ns1:updateAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__updateAuthorisation:
		return soap_in_PointerTons1__updateAuthorisation(soap, NULL, NULL, "ns1:updateAuthorisation");
	case SOAP_TYPE_PointerTons1__removeAuthorisationResponse:
		return soap_in_PointerTons1__removeAuthorisationResponse(soap, NULL, NULL, "ns1:removeAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__removeAuthorisation:
		return soap_in_PointerTons1__removeAuthorisation(soap, NULL, NULL, "ns1:removeAuthorisation");
	case SOAP_TYPE_PointerTons1__deleteAuthorisationResponse:
		return soap_in_PointerTons1__deleteAuthorisationResponse(soap, NULL, NULL, "ns1:deleteAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__deleteAuthorisation:
		return soap_in_PointerTons1__deleteAuthorisation(soap, NULL, NULL, "ns1:deleteAuthorisation");
	case SOAP_TYPE_PointerTons1__addAuthorisationResponse:
		return soap_in_PointerTons1__addAuthorisationResponse(soap, NULL, NULL, "ns1:addAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__addAuthorisation:
		return soap_in_PointerTons1__addAuthorisation(soap, NULL, NULL, "ns1:addAuthorisation");
	case SOAP_TYPE_PointerTons1__getAuthorisationsResponse:
		return soap_in_PointerTons1__getAuthorisationsResponse(soap, NULL, NULL, "ns1:getAuthorisationsResponse");
	case SOAP_TYPE_PointerTons1__getAuthorisations:
		return soap_in_PointerTons1__getAuthorisations(soap, NULL, NULL, "ns1:getAuthorisations");
	case SOAP_TYPE_PointerTons1__deleteDataFileParameterResponse:
		return soap_in_PointerTons1__deleteDataFileParameterResponse(soap, NULL, NULL, "ns1:deleteDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__deleteDataFileParameter:
		return soap_in_PointerTons1__deleteDataFileParameter(soap, NULL, NULL, "ns1:deleteDataFileParameter");
	case SOAP_TYPE_PointerTons1__removeDataFileParameterResponse:
		return soap_in_PointerTons1__removeDataFileParameterResponse(soap, NULL, NULL, "ns1:removeDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__removeDataFileParameter:
		return soap_in_PointerTons1__removeDataFileParameter(soap, NULL, NULL, "ns1:removeDataFileParameter");
	case SOAP_TYPE_PointerTons1__modifyDataFileParameterResponse:
		return soap_in_PointerTons1__modifyDataFileParameterResponse(soap, NULL, NULL, "ns1:modifyDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__modifyDataFileParameter:
		return soap_in_PointerTons1__modifyDataFileParameter(soap, NULL, NULL, "ns1:modifyDataFileParameter");
	case SOAP_TYPE_PointerTons1__addDataFileParametersResponse:
		return soap_in_PointerTons1__addDataFileParametersResponse(soap, NULL, NULL, "ns1:addDataFileParametersResponse");
	case SOAP_TYPE_PointerTons1__addDataFileParameters:
		return soap_in_PointerTons1__addDataFileParameters(soap, NULL, NULL, "ns1:addDataFileParameters");
	case SOAP_TYPE_PointerTons1__modifyDataFileResponse:
		return soap_in_PointerTons1__modifyDataFileResponse(soap, NULL, NULL, "ns1:modifyDataFileResponse");
	case SOAP_TYPE_PointerTons1__modifyDataFile:
		return soap_in_PointerTons1__modifyDataFile(soap, NULL, NULL, "ns1:modifyDataFile");
	case SOAP_TYPE_PointerTons1__removeDataFileResponse:
		return soap_in_PointerTons1__removeDataFileResponse(soap, NULL, NULL, "ns1:removeDataFileResponse");
	case SOAP_TYPE_PointerTons1__removeDataFile:
		return soap_in_PointerTons1__removeDataFile(soap, NULL, NULL, "ns1:removeDataFile");
	case SOAP_TYPE_PointerTons1__deleteDataFileResponse:
		return soap_in_PointerTons1__deleteDataFileResponse(soap, NULL, NULL, "ns1:deleteDataFileResponse");
	case SOAP_TYPE_PointerTons1__deleteDataFile:
		return soap_in_PointerTons1__deleteDataFile(soap, NULL, NULL, "ns1:deleteDataFile");
	case SOAP_TYPE_PointerTons1__createDataFilesResponse:
		return soap_in_PointerTons1__createDataFilesResponse(soap, NULL, NULL, "ns1:createDataFilesResponse");
	case SOAP_TYPE_PointerTons1__createDataFiles:
		return soap_in_PointerTons1__createDataFiles(soap, NULL, NULL, "ns1:createDataFiles");
	case SOAP_TYPE_PointerTons1__createDataFileResponse:
		return soap_in_PointerTons1__createDataFileResponse(soap, NULL, NULL, "ns1:createDataFileResponse");
	case SOAP_TYPE_PointerTons1__createDataFile:
		return soap_in_PointerTons1__createDataFile(soap, NULL, NULL, "ns1:createDataFile");
	case SOAP_TYPE_PointerTons1__getDatafilesResponse:
		return soap_in_PointerTons1__getDatafilesResponse(soap, NULL, NULL, "ns1:getDatafilesResponse");
	case SOAP_TYPE_PointerTons1__getDatafiles:
		return soap_in_PointerTons1__getDatafiles(soap, NULL, NULL, "ns1:getDatafiles");
	case SOAP_TYPE_PointerTons1__ingestMetadataResponse:
		return soap_in_PointerTons1__ingestMetadataResponse(soap, NULL, NULL, "ns1:ingestMetadataResponse");
	case SOAP_TYPE_PointerTons1__ingestMetadata:
		return soap_in_PointerTons1__ingestMetadata(soap, NULL, NULL, "ns1:ingestMetadata");
	case SOAP_TYPE_PointerTons1__getUserDetailsResponse:
		return soap_in_PointerTons1__getUserDetailsResponse(soap, NULL, NULL, "ns1:getUserDetailsResponse");
	case SOAP_TYPE_PointerTons1__getUserDetails:
		return soap_in_PointerTons1__getUserDetails(soap, NULL, NULL, "ns1:getUserDetails");
	case SOAP_TYPE_PointerTons1__addDataFileParameterResponse:
		return soap_in_PointerTons1__addDataFileParameterResponse(soap, NULL, NULL, "ns1:addDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__addDataFileParameter:
		return soap_in_PointerTons1__addDataFileParameter(soap, NULL, NULL, "ns1:addDataFileParameter");
	case SOAP_TYPE_PointerTons1__getDatafileResponse:
		return soap_in_PointerTons1__getDatafileResponse(soap, NULL, NULL, "ns1:getDatafileResponse");
	case SOAP_TYPE_PointerTons1__getDatafile:
		return soap_in_PointerTons1__getDatafile(soap, NULL, NULL, "ns1:getDatafile");
	case SOAP_TYPE_PointerTons1__getDatasetIncludesResponse:
		return soap_in_PointerTons1__getDatasetIncludesResponse(soap, NULL, NULL, "ns1:getDatasetIncludesResponse");
	case SOAP_TYPE_PointerTons1__getDatasetIncludes:
		return soap_in_PointerTons1__getDatasetIncludes(soap, NULL, NULL, "ns1:getDatasetIncludes");
	case SOAP_TYPE_PointerTons1__getDatasetResponse:
		return soap_in_PointerTons1__getDatasetResponse(soap, NULL, NULL, "ns1:getDatasetResponse");
	case SOAP_TYPE_PointerTons1__getDataset:
		return soap_in_PointerTons1__getDataset(soap, NULL, NULL, "ns1:getDataset");
	case SOAP_TYPE_PointerTons1__getInvestigationIncludesResponse:
		return soap_in_PointerTons1__getInvestigationIncludesResponse(soap, NULL, NULL, "ns1:getInvestigationIncludesResponse");
	case SOAP_TYPE_PointerTons1__getInvestigationIncludes:
		return soap_in_PointerTons1__getInvestigationIncludes(soap, NULL, NULL, "ns1:getInvestigationIncludes");
	case SOAP_TYPE_PointerTons1__getInvestigationResponse:
		return soap_in_PointerTons1__getInvestigationResponse(soap, NULL, NULL, "ns1:getInvestigationResponse");
	case SOAP_TYPE_PointerTons1__getInvestigation:
		return soap_in_PointerTons1__getInvestigation(soap, NULL, NULL, "ns1:getInvestigation");
	case SOAP_TYPE_PointerTons1__addInvestigatorResponse:
		return soap_in_PointerTons1__addInvestigatorResponse(soap, NULL, NULL, "ns1:addInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__addInvestigator:
		return soap_in_PointerTons1__addInvestigator(soap, NULL, NULL, "ns1:addInvestigator");
	case SOAP_TYPE_PointerTons1__addKeywordResponse:
		return soap_in_PointerTons1__addKeywordResponse(soap, NULL, NULL, "ns1:addKeywordResponse");
	case SOAP_TYPE_PointerTons1__addKeyword:
		return soap_in_PointerTons1__addKeyword(soap, NULL, NULL, "ns1:addKeyword");
	case SOAP_TYPE_PointerTons1__addPublicationResponse:
		return soap_in_PointerTons1__addPublicationResponse(soap, NULL, NULL, "ns1:addPublicationResponse");
	case SOAP_TYPE_PointerTons1__addPublication:
		return soap_in_PointerTons1__addPublication(soap, NULL, NULL, "ns1:addPublication");
	case SOAP_TYPE_PointerTons1__addSampleParameterResponse:
		return soap_in_PointerTons1__addSampleParameterResponse(soap, NULL, NULL, "ns1:addSampleParameterResponse");
	case SOAP_TYPE_PointerTons1__addSampleParameter:
		return soap_in_PointerTons1__addSampleParameter(soap, NULL, NULL, "ns1:addSampleParameter");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_in_PointerTons1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_in_PointerTons1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_PointerTons1__addSampleResponse:
		return soap_in_PointerTons1__addSampleResponse(soap, NULL, NULL, "ns1:addSampleResponse");
	case SOAP_TYPE_PointerTons1__addSample:
		return soap_in_PointerTons1__addSample(soap, NULL, NULL, "ns1:addSample");
	case SOAP_TYPE_PointerTons1__loginLifetimeResponse:
		return soap_in_PointerTons1__loginLifetimeResponse(soap, NULL, NULL, "ns1:loginLifetimeResponse");
	case SOAP_TYPE_PointerTons1__loginLifetime:
		return soap_in_PointerTons1__loginLifetime(soap, NULL, NULL, "ns1:loginLifetime");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_in_PointerTons1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__login:
		return soap_in_PointerTons1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_PointerTons1__ValidationException:
		return soap_in_PointerTons1__ValidationException(soap, NULL, NULL, "ns1:ValidationException");
	case SOAP_TYPE_PointerTons3__SessionException:
		return soap_in_PointerTons3__SessionException(soap, NULL, NULL, "ns3:SessionException");
	case SOAP_TYPE_PointerTons1__NoSuchUserException:
		return soap_in_PointerTons1__NoSuchUserException(soap, NULL, NULL, "ns1:NoSuchUserException");
	case SOAP_TYPE_PointerTons1__NoSuchObjectFoundException:
		return soap_in_PointerTons1__NoSuchObjectFoundException(soap, NULL, NULL, "ns1:NoSuchObjectFoundException");
	case SOAP_TYPE_PointerTons1__InsufficientPrivilegesException:
		return soap_in_PointerTons1__InsufficientPrivilegesException(soap, NULL, NULL, "ns1:InsufficientPrivilegesException");
	case SOAP_TYPE_PointerTons1__ICATAPIException:
		return soap_in_PointerTons1__ICATAPIException(soap, NULL, NULL, "ns1:ICATAPIException");
	case SOAP_TYPE_PointerTons1__shiftPK:
		return soap_in_PointerTons1__shiftPK(soap, NULL, NULL, "ns1:shiftPK");
	case SOAP_TYPE_PointerTons1__shift:
		return soap_in_PointerTons1__shift(soap, NULL, NULL, "ns1:shift");
	case SOAP_TYPE_PointerTons1__parameterPK:
		return soap_in_PointerTons1__parameterPK(soap, NULL, NULL, "ns1:parameterPK");
	case SOAP_TYPE_PointerTons1__relatedDatafilesPK:
		return soap_in_PointerTons1__relatedDatafilesPK(soap, NULL, NULL, "ns1:relatedDatafilesPK");
	case SOAP_TYPE_PointerTons1__datafileFormatPK:
		return soap_in_PointerTons1__datafileFormatPK(soap, NULL, NULL, "ns1:datafileFormatPK");
	case SOAP_TYPE_PointerTons1__relatedDatafiles:
		return soap_in_PointerTons1__relatedDatafiles(soap, NULL, NULL, "ns1:relatedDatafiles");
	case SOAP_TYPE_PointerTons1__datafileInclude:
		return soap_in_PointerTons1__datafileInclude(soap, NULL, NULL, "ns1:datafileInclude");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__parameter:
		return soap_in_PointerTons1__parameter(soap, NULL, NULL, "ns1:parameter");
	case SOAP_TYPE_PointerTons1__datasetInclude:
		return soap_in_PointerTons1__datasetInclude(soap, NULL, NULL, "ns1:datasetInclude");
	case SOAP_TYPE_PointerTons1__datafileFormat:
		return soap_in_PointerTons1__datafileFormat(soap, NULL, NULL, "ns1:datafileFormat");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__advancedSearchDetails:
		return soap_in_PointerTons1__advancedSearchDetails(soap, NULL, NULL, "ns1:advancedSearchDetails");
	case SOAP_TYPE_PointerTons1__keyword:
		return soap_in_PointerTons1__keyword(soap, NULL, NULL, "ns1:keyword");
	case SOAP_TYPE_PointerTons1__icatAuthorisation:
		return soap_in_PointerTons1__icatAuthorisation(soap, NULL, NULL, "ns1:icatAuthorisation");
	case SOAP_TYPE_PointerTons1__elementType:
		return soap_in_PointerTons1__elementType(soap, NULL, NULL, "ns1:elementType");
	case SOAP_TYPE_PointerTons1__datasetParameter:
		return soap_in_PointerTons1__datasetParameter(soap, NULL, NULL, "ns1:datasetParameter");
	case SOAP_TYPE_PointerTons1__sampleParameterPK:
		return soap_in_PointerTons1__sampleParameterPK(soap, NULL, NULL, "ns1:sampleParameterPK");
	case SOAP_TYPE_PointerTons1__investigator:
		return soap_in_PointerTons1__investigator(soap, NULL, NULL, "ns1:investigator");
	case SOAP_TYPE_PointerTons1__datafileParameterPK:
		return soap_in_PointerTons1__datafileParameterPK(soap, NULL, NULL, "ns1:datafileParameterPK");
	case SOAP_TYPE_PointerTons1__publication:
		return soap_in_PointerTons1__publication(soap, NULL, NULL, "ns1:publication");
	case SOAP_TYPE_PointerTons1__datasetParameterPK:
		return soap_in_PointerTons1__datasetParameterPK(soap, NULL, NULL, "ns1:datasetParameterPK");
	case SOAP_TYPE_PointerTons1__investigationInclude:
		return soap_in_PointerTons1__investigationInclude(soap, NULL, NULL, "ns1:investigationInclude");
	case SOAP_TYPE_PointerTons1__keywordDetails:
		return soap_in_PointerTons1__keywordDetails(soap, NULL, NULL, "ns1:keywordDetails");
	case SOAP_TYPE_PointerTons1__investigation:
		return soap_in_PointerTons1__investigation(soap, NULL, NULL, "ns1:investigation");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__downloadInfo:
		return soap_in_PointerTons1__downloadInfo(soap, NULL, NULL, "ns1:downloadInfo");
	case SOAP_TYPE_PointerTons1__sampleParameter:
		return soap_in_PointerTons1__sampleParameter(soap, NULL, NULL, "ns1:sampleParameter");
	case SOAP_TYPE_PointerTons1__userDetails:
		return soap_in_PointerTons1__userDetails(soap, NULL, NULL, "ns1:userDetails");
	case SOAP_TYPE_PointerTons1__keywordType:
		return soap_in_PointerTons1__keywordType(soap, NULL, NULL, "ns1:keywordType");
	case SOAP_TYPE_PointerTons1__dataset:
		return soap_in_PointerTons1__dataset(soap, NULL, NULL, "ns1:dataset");
	case SOAP_TYPE_PointerTons1__keywordPK:
		return soap_in_PointerTons1__keywordPK(soap, NULL, NULL, "ns1:keywordPK");
	case SOAP_TYPE_PointerTons1__investigatorPK:
		return soap_in_PointerTons1__investigatorPK(soap, NULL, NULL, "ns1:investigatorPK");
	case SOAP_TYPE_PointerTons1__facilityUser:
		return soap_in_PointerTons1__facilityUser(soap, NULL, NULL, "ns1:facilityUser");
	case SOAP_TYPE_PointerTons1__facilityCycle:
		return soap_in_PointerTons1__facilityCycle(soap, NULL, NULL, "ns1:facilityCycle");
	case SOAP_TYPE_PointerTons1__datafileParameter:
		return soap_in_PointerTons1__datafileParameter(soap, NULL, NULL, "ns1:datafileParameter");
	case SOAP_TYPE_PointerTons1__datafile:
		return soap_in_PointerTons1__datafile(soap, NULL, NULL, "ns1:datafile");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons1__icatRole:
		return soap_in_PointerTons1__icatRole(soap, NULL, NULL, "ns1:icatRole");
	case SOAP_TYPE_PointerTons1__sample:
		return soap_in_PointerTons1__sample(soap, NULL, NULL, "ns1:sample");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:datasetInclude"))
		{	*type = SOAP_TYPE_ns1__datasetInclude_;
			return soap_in_ns1__datasetInclude_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:elementType"))
		{	*type = SOAP_TYPE_ns1__elementType_;
			return soap_in_ns1__elementType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:investigationInclude"))
		{	*type = SOAP_TYPE_ns1__investigationInclude_;
			return soap_in_ns1__investigationInclude_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:keywordType"))
		{	*type = SOAP_TYPE_ns1__keywordType_;
			return soap_in_ns1__keywordType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datafileInclude"))
		{	*type = SOAP_TYPE_ns1__datafileInclude_;
			return soap_in_ns1__datafileInclude_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SessionException"))
		{	*type = SOAP_TYPE_ns3__SessionException;
			return soap_in_ns3__SessionException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatasetsResponse"))
		{	*type = SOAP_TYPE_ns1__getDatasetsResponse;
			return soap_in_ns1__getDatasetsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatasets"))
		{	*type = SOAP_TYPE_ns1__getDatasets;
			return soap_in_ns1__getDatasets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listParametersResponse"))
		{	*type = SOAP_TYPE_ns1__listParametersResponse;
			return soap_in_ns1__listParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listParameters"))
		{	*type = SOAP_TYPE_ns1__listParameters;
			return soap_in_ns1__listParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataFileParameterResponse"))
		{	*type = SOAP_TYPE_ns1__modifyDataFileParameterResponse;
			return soap_in_ns1__modifyDataFileParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataFileParameter"))
		{	*type = SOAP_TYPE_ns1__modifyDataFileParameter;
			return soap_in_ns1__modifyDataFileParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteSampleParameterResponse"))
		{	*type = SOAP_TYPE_ns1__deleteSampleParameterResponse;
			return soap_in_ns1__deleteSampleParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteSampleParameter"))
		{	*type = SOAP_TYPE_ns1__deleteSampleParameter;
			return soap_in_ns1__deleteSampleParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataFileParameterResponse"))
		{	*type = SOAP_TYPE_ns1__addDataFileParameterResponse;
			return soap_in_ns1__addDataFileParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataFileParameter"))
		{	*type = SOAP_TYPE_ns1__addDataFileParameter;
			return soap_in_ns1__addDataFileParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchDatasetsBySampleResponse"))
		{	*type = SOAP_TYPE_ns1__searchDatasetsBySampleResponse;
			return soap_in_ns1__searchDatasetsBySampleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchDatasetsBySample"))
		{	*type = SOAP_TYPE_ns1__searchDatasetsBySample;
			return soap_in_ns1__searchDatasetsBySample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addPublicationResponse"))
		{	*type = SOAP_TYPE_ns1__addPublicationResponse;
			return soap_in_ns1__addPublicationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addPublication"))
		{	*type = SOAP_TYPE_ns1__addPublication;
			return soap_in_ns1__addPublication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createInvestigationResponse"))
		{	*type = SOAP_TYPE_ns1__createInvestigationResponse;
			return soap_in_ns1__createInvestigationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createInvestigation"))
		{	*type = SOAP_TYPE_ns1__createInvestigation;
			return soap_in_ns1__createInvestigation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataFileParameterResponse"))
		{	*type = SOAP_TYPE_ns1__deleteDataFileParameterResponse;
			return soap_in_ns1__deleteDataFileParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataFileParameter"))
		{	*type = SOAP_TYPE_ns1__deleteDataFileParameter;
			return soap_in_ns1__deleteDataFileParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInvestigationResponse"))
		{	*type = SOAP_TYPE_ns1__getInvestigationResponse;
			return soap_in_ns1__getInvestigationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInvestigation"))
		{	*type = SOAP_TYPE_ns1__getInvestigation;
			return soap_in_ns1__getInvestigation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInvestigationIncludesResponse"))
		{	*type = SOAP_TYPE_ns1__getInvestigationIncludesResponse;
			return soap_in_ns1__getInvestigationIncludesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInvestigationIncludes"))
		{	*type = SOAP_TYPE_ns1__getInvestigationIncludes;
			return soap_in_ns1__getInvestigationIncludes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataFileResponse"))
		{	*type = SOAP_TYPE_ns1__modifyDataFileResponse;
			return soap_in_ns1__modifyDataFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataFile"))
		{	*type = SOAP_TYPE_ns1__modifyDataFile;
			return soap_in_ns1__modifyDataFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatafileResponse"))
		{	*type = SOAP_TYPE_ns1__getDatafileResponse;
			return soap_in_ns1__getDatafileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatafile"))
		{	*type = SOAP_TYPE_ns1__getDatafile;
			return soap_in_ns1__getDatafile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ICATAPIException"))
		{	*type = SOAP_TYPE_ns1__ICATAPIException;
			return soap_in_ns1__ICATAPIException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ingestMetadataResponse"))
		{	*type = SOAP_TYPE_ns1__ingestMetadataResponse;
			return soap_in_ns1__ingestMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ingestMetadata"))
		{	*type = SOAP_TYPE_ns1__ingestMetadata;
			return soap_in_ns1__ingestMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listRolesResponse"))
		{	*type = SOAP_TYPE_ns1__listRolesResponse;
			return soap_in_ns1__listRolesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listRoles"))
		{	*type = SOAP_TYPE_ns1__listRoles;
			return soap_in_ns1__listRoles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatasetResponse"))
		{	*type = SOAP_TYPE_ns1__getDatasetResponse;
			return soap_in_ns1__getDatasetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDataset"))
		{	*type = SOAP_TYPE_ns1__getDataset;
			return soap_in_ns1__getDataset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatasetIncludesResponse"))
		{	*type = SOAP_TYPE_ns1__getDatasetIncludesResponse;
			return soap_in_ns1__getDatasetIncludesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatasetIncludes"))
		{	*type = SOAP_TYPE_ns1__getDatasetIncludes;
			return soap_in_ns1__getDatasetIncludes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAuthorisationResponse"))
		{	*type = SOAP_TYPE_ns1__updateAuthorisationResponse;
			return soap_in_ns1__updateAuthorisationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAuthorisation"))
		{	*type = SOAP_TYPE_ns1__updateAuthorisation;
			return soap_in_ns1__updateAuthorisation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteAuthorisationResponse"))
		{	*type = SOAP_TYPE_ns1__deleteAuthorisationResponse;
			return soap_in_ns1__deleteAuthorisationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteAuthorisation"))
		{	*type = SOAP_TYPE_ns1__deleteAuthorisation;
			return soap_in_ns1__deleteAuthorisation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE_ns1__loginResponse;
			return soap_in_ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE_ns1__login;
			return soap_in_ns1__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginLifetimeResponse"))
		{	*type = SOAP_TYPE_ns1__loginLifetimeResponse;
			return soap_in_ns1__loginLifetimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginLifetime"))
		{	*type = SOAP_TYPE_ns1__loginLifetime;
			return soap_in_ns1__loginLifetime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deletePublicationResponse"))
		{	*type = SOAP_TYPE_ns1__deletePublicationResponse;
			return soap_in_ns1__deletePublicationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deletePublication"))
		{	*type = SOAP_TYPE_ns1__deletePublication;
			return soap_in_ns1__deletePublication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addSampleResponse"))
		{	*type = SOAP_TYPE_ns1__addSampleResponse;
			return soap_in_ns1__addSampleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addSample"))
		{	*type = SOAP_TYPE_ns1__addSample;
			return soap_in_ns1__addSample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addAuthorisationResponse"))
		{	*type = SOAP_TYPE_ns1__addAuthorisationResponse;
			return soap_in_ns1__addAuthorisationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addAuthorisation"))
		{	*type = SOAP_TYPE_ns1__addAuthorisation;
			return soap_in_ns1__addAuthorisation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataSetParameterResponse"))
		{	*type = SOAP_TYPE_ns1__addDataSetParameterResponse;
			return soap_in_ns1__addDataSetParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataSetParameter"))
		{	*type = SOAP_TYPE_ns1__addDataSetParameter;
			return soap_in_ns1__addDataSetParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataFilesResponse"))
		{	*type = SOAP_TYPE_ns1__createDataFilesResponse;
			return soap_in_ns1__createDataFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataFiles"))
		{	*type = SOAP_TYPE_ns1__createDataFiles;
			return soap_in_ns1__createDataFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyInvestigatorResponse"))
		{	*type = SOAP_TYPE_ns1__modifyInvestigatorResponse;
			return soap_in_ns1__modifyInvestigatorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyInvestigator"))
		{	*type = SOAP_TYPE_ns1__modifyInvestigator;
			return soap_in_ns1__modifyInvestigator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifySampleParameterResponse"))
		{	*type = SOAP_TYPE_ns1__modifySampleParameterResponse;
			return soap_in_ns1__modifySampleParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifySampleParameter"))
		{	*type = SOAP_TYPE_ns1__modifySampleParameter;
			return soap_in_ns1__modifySampleParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listDatafileFormatsResponse"))
		{	*type = SOAP_TYPE_ns1__listDatafileFormatsResponse;
			return soap_in_ns1__listDatafileFormatsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listDatafileFormats"))
		{	*type = SOAP_TYPE_ns1__listDatafileFormats;
			return soap_in_ns1__listDatafileFormats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByAdvancedPaginationResponse"))
		{	*type = SOAP_TYPE_ns1__searchByAdvancedPaginationResponse;
			return soap_in_ns1__searchByAdvancedPaginationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByAdvancedPagination"))
		{	*type = SOAP_TYPE_ns1__searchByAdvancedPagination;
			return soap_in_ns1__searchByAdvancedPagination(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByAdvancedResponse"))
		{	*type = SOAP_TYPE_ns1__searchByAdvancedResponse;
			return soap_in_ns1__searchByAdvancedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:advancedSearchDetails"))
		{	*type = SOAP_TYPE_ns1__advancedSearchDetails;
			return soap_in_ns1__advancedSearchDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByAdvanced"))
		{	*type = SOAP_TYPE_ns1__searchByAdvanced;
			return soap_in_ns1__searchByAdvanced(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByRunNumberPaginationResponse"))
		{	*type = SOAP_TYPE_ns1__searchByRunNumberPaginationResponse;
			return soap_in_ns1__searchByRunNumberPaginationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByRunNumberPagination"))
		{	*type = SOAP_TYPE_ns1__searchByRunNumberPagination;
			return soap_in_ns1__searchByRunNumberPagination(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByRunNumberResponse"))
		{	*type = SOAP_TYPE_ns1__searchByRunNumberResponse;
			return soap_in_ns1__searchByRunNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByRunNumber"))
		{	*type = SOAP_TYPE_ns1__searchByRunNumber;
			return soap_in_ns1__searchByRunNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataSetParametersResponse"))
		{	*type = SOAP_TYPE_ns1__addDataSetParametersResponse;
			return soap_in_ns1__addDataSetParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataSetParameters"))
		{	*type = SOAP_TYPE_ns1__addDataSetParameters;
			return soap_in_ns1__addDataSetParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteKeywordResponse"))
		{	*type = SOAP_TYPE_ns1__deleteKeywordResponse;
			return soap_in_ns1__deleteKeywordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteKeyword"))
		{	*type = SOAP_TYPE_ns1__deleteKeyword;
			return soap_in_ns1__deleteKeyword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteSampleResponse"))
		{	*type = SOAP_TYPE_ns1__deleteSampleResponse;
			return soap_in_ns1__deleteSampleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteSample"))
		{	*type = SOAP_TYPE_ns1__deleteSample;
			return soap_in_ns1__deleteSample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listDatasetStatusResponse"))
		{	*type = SOAP_TYPE_ns1__listDatasetStatusResponse;
			return soap_in_ns1__listDatasetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listDatasetStatus"))
		{	*type = SOAP_TYPE_ns1__listDatasetStatus;
			return soap_in_ns1__listDatasetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyInvestigationResponse"))
		{	*type = SOAP_TYPE_ns1__modifyInvestigationResponse;
			return soap_in_ns1__modifyInvestigationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyInvestigation"))
		{	*type = SOAP_TYPE_ns1__modifyInvestigation;
			return soap_in_ns1__modifyInvestigation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addKeywordResponse"))
		{	*type = SOAP_TYPE_ns1__addKeywordResponse;
			return soap_in_ns1__addKeywordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addKeyword"))
		{	*type = SOAP_TYPE_ns1__addKeyword;
			return soap_in_ns1__addKeyword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:icatAuthorisation"))
		{	*type = SOAP_TYPE_ns1__icatAuthorisation;
			return soap_in_ns1__icatAuthorisation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuthorisationsResponse"))
		{	*type = SOAP_TYPE_ns1__getAuthorisationsResponse;
			return soap_in_ns1__getAuthorisationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuthorisations"))
		{	*type = SOAP_TYPE_ns1__getAuthorisations;
			return soap_in_ns1__getAuthorisations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataSetResponse"))
		{	*type = SOAP_TYPE_ns1__removeDataSetResponse;
			return soap_in_ns1__removeDataSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataSet"))
		{	*type = SOAP_TYPE_ns1__removeDataSet;
			return soap_in_ns1__removeDataSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataSetParameterResponse"))
		{	*type = SOAP_TYPE_ns1__modifyDataSetParameterResponse;
			return soap_in_ns1__modifyDataSetParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataSetParameter"))
		{	*type = SOAP_TYPE_ns1__modifyDataSetParameter;
			return soap_in_ns1__modifyDataSetParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listInvestigationTypesResponse"))
		{	*type = SOAP_TYPE_ns1__listInvestigationTypesResponse;
			return soap_in_ns1__listInvestigationTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listInvestigationTypes"))
		{	*type = SOAP_TYPE_ns1__listInvestigationTypes;
			return soap_in_ns1__listInvestigationTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUserTypeResponse"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUserTypeResponse;
			return soap_in_ns1__getKeywordsForUserTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUserType"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUserType;
			return soap_in_ns1__getKeywordsForUserType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUserMaxResponse"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUserMaxResponse;
			return soap_in_ns1__getKeywordsForUserMaxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUserMax"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUserMax;
			return soap_in_ns1__getKeywordsForUserMax(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUserStartWithMaxResponse"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse;
			return soap_in_ns1__getKeywordsForUserStartWithMaxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUserStartWithMax"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUserStartWithMax;
			return soap_in_ns1__getKeywordsForUserStartWithMax(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUserResponse"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUserResponse;
			return soap_in_ns1__getKeywordsForUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getKeywordsForUser"))
		{	*type = SOAP_TYPE_ns1__getKeywordsForUser;
			return soap_in_ns1__getKeywordsForUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadDatafileResponse"))
		{	*type = SOAP_TYPE_ns1__downloadDatafileResponse;
			return soap_in_ns1__downloadDatafileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadDatafile"))
		{	*type = SOAP_TYPE_ns1__downloadDatafile;
			return soap_in_ns1__downloadDatafile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setDataSetSampleResponse"))
		{	*type = SOAP_TYPE_ns1__setDataSetSampleResponse;
			return soap_in_ns1__setDataSetSampleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setDataSetSample"))
		{	*type = SOAP_TYPE_ns1__setDataSetSample;
			return soap_in_ns1__setDataSetSample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataSetParameterResponse"))
		{	*type = SOAP_TYPE_ns1__deleteDataSetParameterResponse;
			return soap_in_ns1__deleteDataSetParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataSetParameter"))
		{	*type = SOAP_TYPE_ns1__deleteDataSetParameter;
			return soap_in_ns1__deleteDataSetParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeSampleParameterResponse"))
		{	*type = SOAP_TYPE_ns1__removeSampleParameterResponse;
			return soap_in_ns1__removeSampleParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeSampleParameter"))
		{	*type = SOAP_TYPE_ns1__removeSampleParameter;
			return soap_in_ns1__removeSampleParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataSetResponse"))
		{	*type = SOAP_TYPE_ns1__createDataSetResponse;
			return soap_in_ns1__createDataSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataSet"))
		{	*type = SOAP_TYPE_ns1__createDataSet;
			return soap_in_ns1__createDataSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addInvestigatorResponse"))
		{	*type = SOAP_TYPE_ns1__addInvestigatorResponse;
			return soap_in_ns1__addInvestigatorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addInvestigator"))
		{	*type = SOAP_TYPE_ns1__addInvestigator;
			return soap_in_ns1__addInvestigator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteInvestigatorResponse"))
		{	*type = SOAP_TYPE_ns1__deleteInvestigatorResponse;
			return soap_in_ns1__deleteInvestigatorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteInvestigator"))
		{	*type = SOAP_TYPE_ns1__deleteInvestigator;
			return soap_in_ns1__deleteInvestigator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getICATAPIVersionResponse"))
		{	*type = SOAP_TYPE_ns1__getICATAPIVersionResponse;
			return soap_in_ns1__getICATAPIVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getICATAPIVersion"))
		{	*type = SOAP_TYPE_ns1__getICATAPIVersion;
			return soap_in_ns1__getICATAPIVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatafilesResponse"))
		{	*type = SOAP_TYPE_ns1__getDatafilesResponse;
			return soap_in_ns1__getDatafilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatafiles"))
		{	*type = SOAP_TYPE_ns1__getDatafiles;
			return soap_in_ns1__getDatafiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataSetResponse"))
		{	*type = SOAP_TYPE_ns1__deleteDataSetResponse;
			return soap_in_ns1__deleteDataSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataSet"))
		{	*type = SOAP_TYPE_ns1__deleteDataSet;
			return soap_in_ns1__deleteDataSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInvestigationsIncludesResponse"))
		{	*type = SOAP_TYPE_ns1__getInvestigationsIncludesResponse;
			return soap_in_ns1__getInvestigationsIncludesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getInvestigationsIncludes"))
		{	*type = SOAP_TYPE_ns1__getInvestigationsIncludes;
			return soap_in_ns1__getInvestigationsIncludes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataFileParameterResponse"))
		{	*type = SOAP_TYPE_ns1__removeDataFileParameterResponse;
			return soap_in_ns1__removeDataFileParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataFileParameter"))
		{	*type = SOAP_TYPE_ns1__removeDataFileParameter;
			return soap_in_ns1__removeDataFileParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserIDPaginationResponse"))
		{	*type = SOAP_TYPE_ns1__searchByUserIDPaginationResponse;
			return soap_in_ns1__searchByUserIDPaginationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserIDPagination"))
		{	*type = SOAP_TYPE_ns1__searchByUserIDPagination;
			return soap_in_ns1__searchByUserIDPagination(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserIDResponse"))
		{	*type = SOAP_TYPE_ns1__searchByUserIDResponse;
			return soap_in_ns1__searchByUserIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserID"))
		{	*type = SOAP_TYPE_ns1__searchByUserID;
			return soap_in_ns1__searchByUserID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyPublicationResponse"))
		{	*type = SOAP_TYPE_ns1__modifyPublicationResponse;
			return soap_in_ns1__modifyPublicationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyPublication"))
		{	*type = SOAP_TYPE_ns1__modifyPublication;
			return soap_in_ns1__modifyPublication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataSetParameterResponse"))
		{	*type = SOAP_TYPE_ns1__removeDataSetParameterResponse;
			return soap_in_ns1__removeDataSetParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataSetParameter"))
		{	*type = SOAP_TYPE_ns1__removeDataSetParameter;
			return soap_in_ns1__removeDataSetParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyInvestigationsIncludesPaginationResponse"))
		{	*type = SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse;
			return soap_in_ns1__getMyInvestigationsIncludesPaginationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyInvestigationsIncludesPagination"))
		{	*type = SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination;
			return soap_in_ns1__getMyInvestigationsIncludesPagination(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyInvestigationsIncludesResponse"))
		{	*type = SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse;
			return soap_in_ns1__getMyInvestigationsIncludesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyInvestigationsIncludes"))
		{	*type = SOAP_TYPE_ns1__getMyInvestigationsIncludes;
			return soap_in_ns1__getMyInvestigationsIncludes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyInvestigationsResponse"))
		{	*type = SOAP_TYPE_ns1__getMyInvestigationsResponse;
			return soap_in_ns1__getMyInvestigationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyInvestigations"))
		{	*type = SOAP_TYPE_ns1__getMyInvestigations;
			return soap_in_ns1__getMyInvestigations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByKeywordsAllResponse"))
		{	*type = SOAP_TYPE_ns1__searchByKeywordsAllResponse;
			return soap_in_ns1__searchByKeywordsAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:keywordDetails"))
		{	*type = SOAP_TYPE_ns1__keywordDetails;
			return soap_in_ns1__keywordDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByKeywordsAll"))
		{	*type = SOAP_TYPE_ns1__searchByKeywordsAll;
			return soap_in_ns1__searchByKeywordsAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByKeywordsResponse"))
		{	*type = SOAP_TYPE_ns1__searchByKeywordsResponse;
			return soap_in_ns1__searchByKeywordsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByKeywords"))
		{	*type = SOAP_TYPE_ns1__searchByKeywords;
			return soap_in_ns1__searchByKeywords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkDatasetDownloadAccessResponse"))
		{	*type = SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse;
			return soap_in_ns1__checkDatasetDownloadAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkDatasetDownloadAccess"))
		{	*type = SOAP_TYPE_ns1__checkDatasetDownloadAccess;
			return soap_in_ns1__checkDatasetDownloadAccess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserSurnamePaginationResponse"))
		{	*type = SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse;
			return soap_in_ns1__searchByUserSurnamePaginationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserSurnamePagination"))
		{	*type = SOAP_TYPE_ns1__searchByUserSurnamePagination;
			return soap_in_ns1__searchByUserSurnamePagination(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:shiftPK"))
		{	*type = SOAP_TYPE_ns1__shiftPK;
			return soap_in_ns1__shiftPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:shift"))
		{	*type = SOAP_TYPE_ns1__shift;
			return soap_in_ns1__shift(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:publication"))
		{	*type = SOAP_TYPE_ns1__publication;
			return soap_in_ns1__publication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:keyword"))
		{	*type = SOAP_TYPE_ns1__keyword;
			return soap_in_ns1__keyword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:investigator"))
		{	*type = SOAP_TYPE_ns1__investigator;
			return soap_in_ns1__investigator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:investigation"))
		{	*type = SOAP_TYPE_ns1__investigation;
			return soap_in_ns1__investigation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserSurnameResponse"))
		{	*type = SOAP_TYPE_ns1__searchByUserSurnameResponse;
			return soap_in_ns1__searchByUserSurnameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchByUserSurname"))
		{	*type = SOAP_TYPE_ns1__searchByUserSurname;
			return soap_in_ns1__searchByUserSurname(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataFileResponse"))
		{	*type = SOAP_TYPE_ns1__deleteDataFileResponse;
			return soap_in_ns1__deleteDataFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDataFile"))
		{	*type = SOAP_TYPE_ns1__deleteDataFile;
			return soap_in_ns1__deleteDataFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadInfo"))
		{	*type = SOAP_TYPE_ns1__downloadInfo;
			return soap_in_ns1__downloadInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkDatafileDownloadAccessResponse"))
		{	*type = SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse;
			return soap_in_ns1__checkDatafileDownloadAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkDatafileDownloadAccess"))
		{	*type = SOAP_TYPE_ns1__checkDatafileDownloadAccess;
			return soap_in_ns1__checkDatafileDownloadAccess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFacilityUserByFacilityUserIdResponse"))
		{	*type = SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse;
			return soap_in_ns1__getFacilityUserByFacilityUserIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFacilityUserByFacilityUserId"))
		{	*type = SOAP_TYPE_ns1__getFacilityUserByFacilityUserId;
			return soap_in_ns1__getFacilityUserByFacilityUserId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addSampleParameterResponse"))
		{	*type = SOAP_TYPE_ns1__addSampleParameterResponse;
			return soap_in_ns1__addSampleParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addSampleParameter"))
		{	*type = SOAP_TYPE_ns1__addSampleParameter;
			return soap_in_ns1__addSampleParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataSetResponse"))
		{	*type = SOAP_TYPE_ns1__modifyDataSetResponse;
			return soap_in_ns1__modifyDataSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyDataSet"))
		{	*type = SOAP_TYPE_ns1__modifyDataSet;
			return soap_in_ns1__modifyDataSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadDatafilesResponse"))
		{	*type = SOAP_TYPE_ns1__downloadDatafilesResponse;
			return soap_in_ns1__downloadDatafilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadDatafiles"))
		{	*type = SOAP_TYPE_ns1__downloadDatafiles;
			return soap_in_ns1__downloadDatafiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoSuchUserException"))
		{	*type = SOAP_TYPE_ns1__NoSuchUserException;
			return soap_in_ns1__NoSuchUserException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userDetails"))
		{	*type = SOAP_TYPE_ns1__userDetails;
			return soap_in_ns1__userDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetailsResponse"))
		{	*type = SOAP_TYPE_ns1__getUserDetailsResponse;
			return soap_in_ns1__getUserDetailsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetails"))
		{	*type = SOAP_TYPE_ns1__getUserDetails;
			return soap_in_ns1__getUserDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllKeywordsResponse"))
		{	*type = SOAP_TYPE_ns1__getAllKeywordsResponse;
			return soap_in_ns1__getAllKeywordsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllKeywords"))
		{	*type = SOAP_TYPE_ns1__getAllKeywords;
			return soap_in_ns1__getAllKeywords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removePublicationResponse"))
		{	*type = SOAP_TYPE_ns1__removePublicationResponse;
			return soap_in_ns1__removePublicationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removePublication"))
		{	*type = SOAP_TYPE_ns1__removePublication;
			return soap_in_ns1__removePublication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataSetsResponse"))
		{	*type = SOAP_TYPE_ns1__createDataSetsResponse;
			return soap_in_ns1__createDataSetsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:parameterPK"))
		{	*type = SOAP_TYPE_ns1__parameterPK;
			return soap_in_ns1__parameterPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:parameter"))
		{	*type = SOAP_TYPE_ns1__parameter;
			return soap_in_ns1__parameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datasetParameterPK"))
		{	*type = SOAP_TYPE_ns1__datasetParameterPK;
			return soap_in_ns1__datasetParameterPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datasetParameter"))
		{	*type = SOAP_TYPE_ns1__datasetParameter;
			return soap_in_ns1__datasetParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:dataset"))
		{	*type = SOAP_TYPE_ns1__dataset;
			return soap_in_ns1__dataset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataSets"))
		{	*type = SOAP_TYPE_ns1__createDataSets;
			return soap_in_ns1__createDataSets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteInvestigationResponse"))
		{	*type = SOAP_TYPE_ns1__deleteInvestigationResponse;
			return soap_in_ns1__deleteInvestigationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteInvestigation"))
		{	*type = SOAP_TYPE_ns1__deleteInvestigation;
			return soap_in_ns1__deleteInvestigation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeKeywordResponse"))
		{	*type = SOAP_TYPE_ns1__removeKeywordResponse;
			return soap_in_ns1__removeKeywordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:keywordPK"))
		{	*type = SOAP_TYPE_ns1__keywordPK;
			return soap_in_ns1__keywordPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeKeyword"))
		{	*type = SOAP_TYPE_ns1__removeKeyword;
			return soap_in_ns1__removeKeyword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeInvestigationResponse"))
		{	*type = SOAP_TYPE_ns1__removeInvestigationResponse;
			return soap_in_ns1__removeInvestigationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeInvestigation"))
		{	*type = SOAP_TYPE_ns1__removeInvestigation;
			return soap_in_ns1__removeInvestigation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeInvestigatorResponse"))
		{	*type = SOAP_TYPE_ns1__removeInvestigatorResponse;
			return soap_in_ns1__removeInvestigatorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:investigatorPK"))
		{	*type = SOAP_TYPE_ns1__investigatorPK;
			return soap_in_ns1__investigatorPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeInvestigator"))
		{	*type = SOAP_TYPE_ns1__removeInvestigator;
			return soap_in_ns1__removeInvestigator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:facilityUser"))
		{	*type = SOAP_TYPE_ns1__facilityUser;
			return soap_in_ns1__facilityUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFacilityUserByFederalIdResponse"))
		{	*type = SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse;
			return soap_in_ns1__getFacilityUserByFederalIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFacilityUserByFederalId"))
		{	*type = SOAP_TYPE_ns1__getFacilityUserByFederalId;
			return soap_in_ns1__getFacilityUserByFederalId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadDatasetResponse"))
		{	*type = SOAP_TYPE_ns1__downloadDatasetResponse;
			return soap_in_ns1__downloadDatasetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadDataset"))
		{	*type = SOAP_TYPE_ns1__downloadDataset;
			return soap_in_ns1__downloadDataset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE_ns1__logoutResponse;
			return soap_in_ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE_ns1__logout;
			return soap_in_ns1__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:facilityCycle"))
		{	*type = SOAP_TYPE_ns1__facilityCycle;
			return soap_in_ns1__facilityCycle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listFacilityCyclesResponse"))
		{	*type = SOAP_TYPE_ns1__listFacilityCyclesResponse;
			return soap_in_ns1__listFacilityCyclesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listFacilityCycles"))
		{	*type = SOAP_TYPE_ns1__listFacilityCycles;
			return soap_in_ns1__listFacilityCycles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataFileParametersResponse"))
		{	*type = SOAP_TYPE_ns1__addDataFileParametersResponse;
			return soap_in_ns1__addDataFileParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDataFileParameters"))
		{	*type = SOAP_TYPE_ns1__addDataFileParameters;
			return soap_in_ns1__addDataFileParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeAuthorisationResponse"))
		{	*type = SOAP_TYPE_ns1__removeAuthorisationResponse;
			return soap_in_ns1__removeAuthorisationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeAuthorisation"))
		{	*type = SOAP_TYPE_ns1__removeAuthorisation;
			return soap_in_ns1__removeAuthorisation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataFileResponse"))
		{	*type = SOAP_TYPE_ns1__removeDataFileResponse;
			return soap_in_ns1__removeDataFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeDataFile"))
		{	*type = SOAP_TYPE_ns1__removeDataFile;
			return soap_in_ns1__removeDataFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifySampleResponse"))
		{	*type = SOAP_TYPE_ns1__modifySampleResponse;
			return soap_in_ns1__modifySampleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifySample"))
		{	*type = SOAP_TYPE_ns1__modifySample;
			return soap_in_ns1__modifySample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValidationException"))
		{	*type = SOAP_TYPE_ns1__ValidationException;
			return soap_in_ns1__ValidationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataFileResponse"))
		{	*type = SOAP_TYPE_ns1__createDataFileResponse;
			return soap_in_ns1__createDataFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:relatedDatafilesPK"))
		{	*type = SOAP_TYPE_ns1__relatedDatafilesPK;
			return soap_in_ns1__relatedDatafilesPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:relatedDatafiles"))
		{	*type = SOAP_TYPE_ns1__relatedDatafiles;
			return soap_in_ns1__relatedDatafiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datafileParameterPK"))
		{	*type = SOAP_TYPE_ns1__datafileParameterPK;
			return soap_in_ns1__datafileParameterPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datafileParameter"))
		{	*type = SOAP_TYPE_ns1__datafileParameter;
			return soap_in_ns1__datafileParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datafileFormatPK"))
		{	*type = SOAP_TYPE_ns1__datafileFormatPK;
			return soap_in_ns1__datafileFormatPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datafileFormat"))
		{	*type = SOAP_TYPE_ns1__datafileFormat;
			return soap_in_ns1__datafileFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datafile"))
		{	*type = SOAP_TYPE_ns1__datafile;
			return soap_in_ns1__datafile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDataFile"))
		{	*type = SOAP_TYPE_ns1__createDataFile;
			return soap_in_ns1__createDataFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listInstrumentsResponse"))
		{	*type = SOAP_TYPE_ns1__listInstrumentsResponse;
			return soap_in_ns1__listInstrumentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listInstruments"))
		{	*type = SOAP_TYPE_ns1__listInstruments;
			return soap_in_ns1__listInstruments(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoSuchObjectFoundException"))
		{	*type = SOAP_TYPE_ns1__NoSuchObjectFoundException;
			return soap_in_ns1__NoSuchObjectFoundException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsufficientPrivilegesException"))
		{	*type = SOAP_TYPE_ns1__InsufficientPrivilegesException;
			return soap_in_ns1__InsufficientPrivilegesException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeSampleResponse"))
		{	*type = SOAP_TYPE_ns1__removeSampleResponse;
			return soap_in_ns1__removeSampleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeSample"))
		{	*type = SOAP_TYPE_ns1__removeSample;
			return soap_in_ns1__removeSample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:icatRole"))
		{	*type = SOAP_TYPE_ns1__icatRole;
			return soap_in_ns1__icatRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:entityPrimaryKeyBaseBean"))
		{	*type = SOAP_TYPE_ns1__entityPrimaryKeyBaseBean;
			return soap_in_ns1__entityPrimaryKeyBaseBean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sampleParameterPK"))
		{	*type = SOAP_TYPE_ns1__sampleParameterPK;
			return soap_in_ns1__sampleParameterPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sampleParameter"))
		{	*type = SOAP_TYPE_ns1__sampleParameter;
			return soap_in_ns1__sampleParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:entityBaseBean"))
		{	*type = SOAP_TYPE_ns1__entityBaseBean;
			return soap_in_ns1__entityBaseBean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sample"))
		{	*type = SOAP_TYPE_ns1__sample;
			return soap_in_ns1__sample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchSamplesBySampleNameResponse"))
		{	*type = SOAP_TYPE_ns1__searchSamplesBySampleNameResponse;
			return soap_in_ns1__searchSamplesBySampleNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchSamplesBySampleName"))
		{	*type = SOAP_TYPE_ns1__searchSamplesBySampleName;
			return soap_in_ns1__searchSamplesBySampleName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listDatasetTypesResponse"))
		{	*type = SOAP_TYPE_ns1__listDatasetTypesResponse;
			return soap_in_ns1__listDatasetTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listDatasetTypes"))
		{	*type = SOAP_TYPE_ns1__listDatasetTypes;
			return soap_in_ns1__listDatasetTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float;
			return soap_in_xsd__float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datasetInclude"))
		{	*type = SOAP_TYPE_ns1__datasetInclude;
			return soap_in_ns1__datasetInclude(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:elementType"))
		{	*type = SOAP_TYPE_ns1__elementType;
			return soap_in_ns1__elementType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:investigationInclude"))
		{	*type = SOAP_TYPE_ns1__investigationInclude;
			return soap_in_ns1__investigationInclude(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:keywordType"))
		{	*type = SOAP_TYPE_ns1__keywordType;
			return soap_in_ns1__keywordType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:datafileInclude"))
		{	*type = SOAP_TYPE_ns1__datafileInclude;
			return soap_in_ns1__datafileInclude(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__datasetInclude:
		return soap_out_ns1__datasetInclude(soap, tag, id, (const enum ns1__datasetInclude *)ptr, "ns1:datasetInclude");
	case SOAP_TYPE_ns1__elementType:
		return soap_out_ns1__elementType(soap, tag, id, (const enum ns1__elementType *)ptr, "ns1:elementType");
	case SOAP_TYPE_ns1__investigationInclude:
		return soap_out_ns1__investigationInclude(soap, tag, id, (const enum ns1__investigationInclude *)ptr, "ns1:investigationInclude");
	case SOAP_TYPE_ns1__keywordType:
		return soap_out_ns1__keywordType(soap, tag, id, (const enum ns1__keywordType *)ptr, "ns1:keywordType");
	case SOAP_TYPE_ns1__datafileInclude:
		return soap_out_ns1__datafileInclude(soap, tag, id, (const enum ns1__datafileInclude *)ptr, "ns1:datafileInclude");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__datasetInclude_:
		return ((ns1__datasetInclude_ *)ptr)->soap_out(soap, tag, id, "ns1:datasetInclude");
	case SOAP_TYPE_ns1__elementType_:
		return ((ns1__elementType_ *)ptr)->soap_out(soap, tag, id, "ns1:elementType");
	case SOAP_TYPE_ns1__investigationInclude_:
		return ((ns1__investigationInclude_ *)ptr)->soap_out(soap, tag, id, "ns1:investigationInclude");
	case SOAP_TYPE_ns1__keywordType_:
		return ((ns1__keywordType_ *)ptr)->soap_out(soap, tag, id, "ns1:keywordType");
	case SOAP_TYPE_ns1__datafileInclude_:
		return ((ns1__datafileInclude_ *)ptr)->soap_out(soap, tag, id, "ns1:datafileInclude");
	case SOAP_TYPE_ns3__SessionException:
		return ((ns3__SessionException *)ptr)->soap_out(soap, tag, id, "ns3:SessionException");
	case SOAP_TYPE_ns1__getDatasetsResponse:
		return ((ns1__getDatasetsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDatasetsResponse");
	case SOAP_TYPE_ns1__getDatasets:
		return ((ns1__getDatasets *)ptr)->soap_out(soap, tag, id, "ns1:getDatasets");
	case SOAP_TYPE_ns1__listParametersResponse:
		return ((ns1__listParametersResponse *)ptr)->soap_out(soap, tag, id, "ns1:listParametersResponse");
	case SOAP_TYPE_ns1__listParameters:
		return ((ns1__listParameters *)ptr)->soap_out(soap, tag, id, "ns1:listParameters");
	case SOAP_TYPE_ns1__modifyDataFileParameterResponse:
		return ((ns1__modifyDataFileParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataFileParameterResponse");
	case SOAP_TYPE_ns1__modifyDataFileParameter:
		return ((ns1__modifyDataFileParameter *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataFileParameter");
	case SOAP_TYPE_ns1__deleteSampleParameterResponse:
		return ((ns1__deleteSampleParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteSampleParameterResponse");
	case SOAP_TYPE_ns1__deleteSampleParameter:
		return ((ns1__deleteSampleParameter *)ptr)->soap_out(soap, tag, id, "ns1:deleteSampleParameter");
	case SOAP_TYPE_ns1__addDataFileParameterResponse:
		return ((ns1__addDataFileParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:addDataFileParameterResponse");
	case SOAP_TYPE_ns1__addDataFileParameter:
		return ((ns1__addDataFileParameter *)ptr)->soap_out(soap, tag, id, "ns1:addDataFileParameter");
	case SOAP_TYPE_ns1__searchDatasetsBySampleResponse:
		return ((ns1__searchDatasetsBySampleResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchDatasetsBySampleResponse");
	case SOAP_TYPE_ns1__searchDatasetsBySample:
		return ((ns1__searchDatasetsBySample *)ptr)->soap_out(soap, tag, id, "ns1:searchDatasetsBySample");
	case SOAP_TYPE_ns1__addPublicationResponse:
		return ((ns1__addPublicationResponse *)ptr)->soap_out(soap, tag, id, "ns1:addPublicationResponse");
	case SOAP_TYPE_ns1__addPublication:
		return ((ns1__addPublication *)ptr)->soap_out(soap, tag, id, "ns1:addPublication");
	case SOAP_TYPE_ns1__createInvestigationResponse:
		return ((ns1__createInvestigationResponse *)ptr)->soap_out(soap, tag, id, "ns1:createInvestigationResponse");
	case SOAP_TYPE_ns1__createInvestigation:
		return ((ns1__createInvestigation *)ptr)->soap_out(soap, tag, id, "ns1:createInvestigation");
	case SOAP_TYPE_ns1__deleteDataFileParameterResponse:
		return ((ns1__deleteDataFileParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataFileParameterResponse");
	case SOAP_TYPE_ns1__deleteDataFileParameter:
		return ((ns1__deleteDataFileParameter *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataFileParameter");
	case SOAP_TYPE_ns1__getInvestigationResponse:
		return ((ns1__getInvestigationResponse *)ptr)->soap_out(soap, tag, id, "ns1:getInvestigationResponse");
	case SOAP_TYPE_ns1__getInvestigation:
		return ((ns1__getInvestigation *)ptr)->soap_out(soap, tag, id, "ns1:getInvestigation");
	case SOAP_TYPE_ns1__getInvestigationIncludesResponse:
		return ((ns1__getInvestigationIncludesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getInvestigationIncludesResponse");
	case SOAP_TYPE_ns1__getInvestigationIncludes:
		return ((ns1__getInvestigationIncludes *)ptr)->soap_out(soap, tag, id, "ns1:getInvestigationIncludes");
	case SOAP_TYPE_ns1__modifyDataFileResponse:
		return ((ns1__modifyDataFileResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataFileResponse");
	case SOAP_TYPE_ns1__modifyDataFile:
		return ((ns1__modifyDataFile *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataFile");
	case SOAP_TYPE_ns1__getDatafileResponse:
		return ((ns1__getDatafileResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDatafileResponse");
	case SOAP_TYPE_ns1__getDatafile:
		return ((ns1__getDatafile *)ptr)->soap_out(soap, tag, id, "ns1:getDatafile");
	case SOAP_TYPE_ns1__ICATAPIException:
		return ((ns1__ICATAPIException *)ptr)->soap_out(soap, tag, id, "ns1:ICATAPIException");
	case SOAP_TYPE_ns1__ingestMetadataResponse:
		return ((ns1__ingestMetadataResponse *)ptr)->soap_out(soap, tag, id, "ns1:ingestMetadataResponse");
	case SOAP_TYPE_ns1__ingestMetadata:
		return ((ns1__ingestMetadata *)ptr)->soap_out(soap, tag, id, "ns1:ingestMetadata");
	case SOAP_TYPE_ns1__listRolesResponse:
		return ((ns1__listRolesResponse *)ptr)->soap_out(soap, tag, id, "ns1:listRolesResponse");
	case SOAP_TYPE_ns1__listRoles:
		return ((ns1__listRoles *)ptr)->soap_out(soap, tag, id, "ns1:listRoles");
	case SOAP_TYPE_ns1__getDatasetResponse:
		return ((ns1__getDatasetResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDatasetResponse");
	case SOAP_TYPE_ns1__getDataset:
		return ((ns1__getDataset *)ptr)->soap_out(soap, tag, id, "ns1:getDataset");
	case SOAP_TYPE_ns1__getDatasetIncludesResponse:
		return ((ns1__getDatasetIncludesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDatasetIncludesResponse");
	case SOAP_TYPE_ns1__getDatasetIncludes:
		return ((ns1__getDatasetIncludes *)ptr)->soap_out(soap, tag, id, "ns1:getDatasetIncludes");
	case SOAP_TYPE_ns1__updateAuthorisationResponse:
		return ((ns1__updateAuthorisationResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateAuthorisationResponse");
	case SOAP_TYPE_ns1__updateAuthorisation:
		return ((ns1__updateAuthorisation *)ptr)->soap_out(soap, tag, id, "ns1:updateAuthorisation");
	case SOAP_TYPE_ns1__deleteAuthorisationResponse:
		return ((ns1__deleteAuthorisationResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteAuthorisationResponse");
	case SOAP_TYPE_ns1__deleteAuthorisation:
		return ((ns1__deleteAuthorisation *)ptr)->soap_out(soap, tag, id, "ns1:deleteAuthorisation");
	case SOAP_TYPE_ns1__loginResponse:
		return ((ns1__loginResponse *)ptr)->soap_out(soap, tag, id, "ns1:loginResponse");
	case SOAP_TYPE_ns1__login:
		return ((ns1__login *)ptr)->soap_out(soap, tag, id, "ns1:login");
	case SOAP_TYPE_ns1__loginLifetimeResponse:
		return ((ns1__loginLifetimeResponse *)ptr)->soap_out(soap, tag, id, "ns1:loginLifetimeResponse");
	case SOAP_TYPE_ns1__loginLifetime:
		return ((ns1__loginLifetime *)ptr)->soap_out(soap, tag, id, "ns1:loginLifetime");
	case SOAP_TYPE_ns1__deletePublicationResponse:
		return ((ns1__deletePublicationResponse *)ptr)->soap_out(soap, tag, id, "ns1:deletePublicationResponse");
	case SOAP_TYPE_ns1__deletePublication:
		return ((ns1__deletePublication *)ptr)->soap_out(soap, tag, id, "ns1:deletePublication");
	case SOAP_TYPE_ns1__addSampleResponse:
		return ((ns1__addSampleResponse *)ptr)->soap_out(soap, tag, id, "ns1:addSampleResponse");
	case SOAP_TYPE_ns1__addSample:
		return ((ns1__addSample *)ptr)->soap_out(soap, tag, id, "ns1:addSample");
	case SOAP_TYPE_ns1__addAuthorisationResponse:
		return ((ns1__addAuthorisationResponse *)ptr)->soap_out(soap, tag, id, "ns1:addAuthorisationResponse");
	case SOAP_TYPE_ns1__addAuthorisation:
		return ((ns1__addAuthorisation *)ptr)->soap_out(soap, tag, id, "ns1:addAuthorisation");
	case SOAP_TYPE_ns1__addDataSetParameterResponse:
		return ((ns1__addDataSetParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:addDataSetParameterResponse");
	case SOAP_TYPE_ns1__addDataSetParameter:
		return ((ns1__addDataSetParameter *)ptr)->soap_out(soap, tag, id, "ns1:addDataSetParameter");
	case SOAP_TYPE_ns1__createDataFilesResponse:
		return ((ns1__createDataFilesResponse *)ptr)->soap_out(soap, tag, id, "ns1:createDataFilesResponse");
	case SOAP_TYPE_ns1__createDataFiles:
		return ((ns1__createDataFiles *)ptr)->soap_out(soap, tag, id, "ns1:createDataFiles");
	case SOAP_TYPE_ns1__modifyInvestigatorResponse:
		return ((ns1__modifyInvestigatorResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifyInvestigatorResponse");
	case SOAP_TYPE_ns1__modifyInvestigator:
		return ((ns1__modifyInvestigator *)ptr)->soap_out(soap, tag, id, "ns1:modifyInvestigator");
	case SOAP_TYPE_ns1__modifySampleParameterResponse:
		return ((ns1__modifySampleParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifySampleParameterResponse");
	case SOAP_TYPE_ns1__modifySampleParameter:
		return ((ns1__modifySampleParameter *)ptr)->soap_out(soap, tag, id, "ns1:modifySampleParameter");
	case SOAP_TYPE_ns1__listDatafileFormatsResponse:
		return ((ns1__listDatafileFormatsResponse *)ptr)->soap_out(soap, tag, id, "ns1:listDatafileFormatsResponse");
	case SOAP_TYPE_ns1__listDatafileFormats:
		return ((ns1__listDatafileFormats *)ptr)->soap_out(soap, tag, id, "ns1:listDatafileFormats");
	case SOAP_TYPE_ns1__searchByAdvancedPaginationResponse:
		return ((ns1__searchByAdvancedPaginationResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByAdvancedPaginationResponse");
	case SOAP_TYPE_ns1__searchByAdvancedPagination:
		return ((ns1__searchByAdvancedPagination *)ptr)->soap_out(soap, tag, id, "ns1:searchByAdvancedPagination");
	case SOAP_TYPE_ns1__searchByAdvancedResponse:
		return ((ns1__searchByAdvancedResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByAdvancedResponse");
	case SOAP_TYPE_ns1__advancedSearchDetails:
		return ((ns1__advancedSearchDetails *)ptr)->soap_out(soap, tag, id, "ns1:advancedSearchDetails");
	case SOAP_TYPE_ns1__searchByAdvanced:
		return ((ns1__searchByAdvanced *)ptr)->soap_out(soap, tag, id, "ns1:searchByAdvanced");
	case SOAP_TYPE_ns1__searchByRunNumberPaginationResponse:
		return ((ns1__searchByRunNumberPaginationResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByRunNumberPaginationResponse");
	case SOAP_TYPE_ns1__searchByRunNumberPagination:
		return ((ns1__searchByRunNumberPagination *)ptr)->soap_out(soap, tag, id, "ns1:searchByRunNumberPagination");
	case SOAP_TYPE_ns1__searchByRunNumberResponse:
		return ((ns1__searchByRunNumberResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByRunNumberResponse");
	case SOAP_TYPE_ns1__searchByRunNumber:
		return ((ns1__searchByRunNumber *)ptr)->soap_out(soap, tag, id, "ns1:searchByRunNumber");
	case SOAP_TYPE_ns1__addDataSetParametersResponse:
		return ((ns1__addDataSetParametersResponse *)ptr)->soap_out(soap, tag, id, "ns1:addDataSetParametersResponse");
	case SOAP_TYPE_ns1__addDataSetParameters:
		return ((ns1__addDataSetParameters *)ptr)->soap_out(soap, tag, id, "ns1:addDataSetParameters");
	case SOAP_TYPE_ns1__deleteKeywordResponse:
		return ((ns1__deleteKeywordResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteKeywordResponse");
	case SOAP_TYPE_ns1__deleteKeyword:
		return ((ns1__deleteKeyword *)ptr)->soap_out(soap, tag, id, "ns1:deleteKeyword");
	case SOAP_TYPE_ns1__deleteSampleResponse:
		return ((ns1__deleteSampleResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteSampleResponse");
	case SOAP_TYPE_ns1__deleteSample:
		return ((ns1__deleteSample *)ptr)->soap_out(soap, tag, id, "ns1:deleteSample");
	case SOAP_TYPE_ns1__listDatasetStatusResponse:
		return ((ns1__listDatasetStatusResponse *)ptr)->soap_out(soap, tag, id, "ns1:listDatasetStatusResponse");
	case SOAP_TYPE_ns1__listDatasetStatus:
		return ((ns1__listDatasetStatus *)ptr)->soap_out(soap, tag, id, "ns1:listDatasetStatus");
	case SOAP_TYPE_ns1__modifyInvestigationResponse:
		return ((ns1__modifyInvestigationResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifyInvestigationResponse");
	case SOAP_TYPE_ns1__modifyInvestigation:
		return ((ns1__modifyInvestigation *)ptr)->soap_out(soap, tag, id, "ns1:modifyInvestigation");
	case SOAP_TYPE_ns1__addKeywordResponse:
		return ((ns1__addKeywordResponse *)ptr)->soap_out(soap, tag, id, "ns1:addKeywordResponse");
	case SOAP_TYPE_ns1__addKeyword:
		return ((ns1__addKeyword *)ptr)->soap_out(soap, tag, id, "ns1:addKeyword");
	case SOAP_TYPE_ns1__icatAuthorisation:
		return ((ns1__icatAuthorisation *)ptr)->soap_out(soap, tag, id, "ns1:icatAuthorisation");
	case SOAP_TYPE_ns1__getAuthorisationsResponse:
		return ((ns1__getAuthorisationsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getAuthorisationsResponse");
	case SOAP_TYPE_ns1__getAuthorisations:
		return ((ns1__getAuthorisations *)ptr)->soap_out(soap, tag, id, "ns1:getAuthorisations");
	case SOAP_TYPE_ns1__removeDataSetResponse:
		return ((ns1__removeDataSetResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeDataSetResponse");
	case SOAP_TYPE_ns1__removeDataSet:
		return ((ns1__removeDataSet *)ptr)->soap_out(soap, tag, id, "ns1:removeDataSet");
	case SOAP_TYPE_ns1__modifyDataSetParameterResponse:
		return ((ns1__modifyDataSetParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataSetParameterResponse");
	case SOAP_TYPE_ns1__modifyDataSetParameter:
		return ((ns1__modifyDataSetParameter *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataSetParameter");
	case SOAP_TYPE_ns1__listInvestigationTypesResponse:
		return ((ns1__listInvestigationTypesResponse *)ptr)->soap_out(soap, tag, id, "ns1:listInvestigationTypesResponse");
	case SOAP_TYPE_ns1__listInvestigationTypes:
		return ((ns1__listInvestigationTypes *)ptr)->soap_out(soap, tag, id, "ns1:listInvestigationTypes");
	case SOAP_TYPE_ns1__getKeywordsForUserTypeResponse:
		return ((ns1__getKeywordsForUserTypeResponse *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUserTypeResponse");
	case SOAP_TYPE_ns1__getKeywordsForUserType:
		return ((ns1__getKeywordsForUserType *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUserType");
	case SOAP_TYPE_ns1__getKeywordsForUserMaxResponse:
		return ((ns1__getKeywordsForUserMaxResponse *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUserMaxResponse");
	case SOAP_TYPE_ns1__getKeywordsForUserMax:
		return ((ns1__getKeywordsForUserMax *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUserMax");
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse:
		return ((ns1__getKeywordsForUserStartWithMaxResponse *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUserStartWithMaxResponse");
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMax:
		return ((ns1__getKeywordsForUserStartWithMax *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUserStartWithMax");
	case SOAP_TYPE_ns1__getKeywordsForUserResponse:
		return ((ns1__getKeywordsForUserResponse *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUserResponse");
	case SOAP_TYPE_ns1__getKeywordsForUser:
		return ((ns1__getKeywordsForUser *)ptr)->soap_out(soap, tag, id, "ns1:getKeywordsForUser");
	case SOAP_TYPE_ns1__downloadDatafileResponse:
		return ((ns1__downloadDatafileResponse *)ptr)->soap_out(soap, tag, id, "ns1:downloadDatafileResponse");
	case SOAP_TYPE_ns1__downloadDatafile:
		return ((ns1__downloadDatafile *)ptr)->soap_out(soap, tag, id, "ns1:downloadDatafile");
	case SOAP_TYPE_ns1__setDataSetSampleResponse:
		return ((ns1__setDataSetSampleResponse *)ptr)->soap_out(soap, tag, id, "ns1:setDataSetSampleResponse");
	case SOAP_TYPE_ns1__setDataSetSample:
		return ((ns1__setDataSetSample *)ptr)->soap_out(soap, tag, id, "ns1:setDataSetSample");
	case SOAP_TYPE_ns1__deleteDataSetParameterResponse:
		return ((ns1__deleteDataSetParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataSetParameterResponse");
	case SOAP_TYPE_ns1__deleteDataSetParameter:
		return ((ns1__deleteDataSetParameter *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataSetParameter");
	case SOAP_TYPE_ns1__removeSampleParameterResponse:
		return ((ns1__removeSampleParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeSampleParameterResponse");
	case SOAP_TYPE_ns1__removeSampleParameter:
		return ((ns1__removeSampleParameter *)ptr)->soap_out(soap, tag, id, "ns1:removeSampleParameter");
	case SOAP_TYPE_ns1__createDataSetResponse:
		return ((ns1__createDataSetResponse *)ptr)->soap_out(soap, tag, id, "ns1:createDataSetResponse");
	case SOAP_TYPE_ns1__createDataSet:
		return ((ns1__createDataSet *)ptr)->soap_out(soap, tag, id, "ns1:createDataSet");
	case SOAP_TYPE_ns1__addInvestigatorResponse:
		return ((ns1__addInvestigatorResponse *)ptr)->soap_out(soap, tag, id, "ns1:addInvestigatorResponse");
	case SOAP_TYPE_ns1__addInvestigator:
		return ((ns1__addInvestigator *)ptr)->soap_out(soap, tag, id, "ns1:addInvestigator");
	case SOAP_TYPE_ns1__deleteInvestigatorResponse:
		return ((ns1__deleteInvestigatorResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteInvestigatorResponse");
	case SOAP_TYPE_ns1__deleteInvestigator:
		return ((ns1__deleteInvestigator *)ptr)->soap_out(soap, tag, id, "ns1:deleteInvestigator");
	case SOAP_TYPE_ns1__getICATAPIVersionResponse:
		return ((ns1__getICATAPIVersionResponse *)ptr)->soap_out(soap, tag, id, "ns1:getICATAPIVersionResponse");
	case SOAP_TYPE_ns1__getICATAPIVersion:
		return ((ns1__getICATAPIVersion *)ptr)->soap_out(soap, tag, id, "ns1:getICATAPIVersion");
	case SOAP_TYPE_ns1__getDatafilesResponse:
		return ((ns1__getDatafilesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDatafilesResponse");
	case SOAP_TYPE_ns1__getDatafiles:
		return ((ns1__getDatafiles *)ptr)->soap_out(soap, tag, id, "ns1:getDatafiles");
	case SOAP_TYPE_ns1__deleteDataSetResponse:
		return ((ns1__deleteDataSetResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataSetResponse");
	case SOAP_TYPE_ns1__deleteDataSet:
		return ((ns1__deleteDataSet *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataSet");
	case SOAP_TYPE_ns1__getInvestigationsIncludesResponse:
		return ((ns1__getInvestigationsIncludesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getInvestigationsIncludesResponse");
	case SOAP_TYPE_ns1__getInvestigationsIncludes:
		return ((ns1__getInvestigationsIncludes *)ptr)->soap_out(soap, tag, id, "ns1:getInvestigationsIncludes");
	case SOAP_TYPE_ns1__removeDataFileParameterResponse:
		return ((ns1__removeDataFileParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeDataFileParameterResponse");
	case SOAP_TYPE_ns1__removeDataFileParameter:
		return ((ns1__removeDataFileParameter *)ptr)->soap_out(soap, tag, id, "ns1:removeDataFileParameter");
	case SOAP_TYPE_ns1__searchByUserIDPaginationResponse:
		return ((ns1__searchByUserIDPaginationResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserIDPaginationResponse");
	case SOAP_TYPE_ns1__searchByUserIDPagination:
		return ((ns1__searchByUserIDPagination *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserIDPagination");
	case SOAP_TYPE_ns1__searchByUserIDResponse:
		return ((ns1__searchByUserIDResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserIDResponse");
	case SOAP_TYPE_ns1__searchByUserID:
		return ((ns1__searchByUserID *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserID");
	case SOAP_TYPE_ns1__modifyPublicationResponse:
		return ((ns1__modifyPublicationResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifyPublicationResponse");
	case SOAP_TYPE_ns1__modifyPublication:
		return ((ns1__modifyPublication *)ptr)->soap_out(soap, tag, id, "ns1:modifyPublication");
	case SOAP_TYPE_ns1__removeDataSetParameterResponse:
		return ((ns1__removeDataSetParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeDataSetParameterResponse");
	case SOAP_TYPE_ns1__removeDataSetParameter:
		return ((ns1__removeDataSetParameter *)ptr)->soap_out(soap, tag, id, "ns1:removeDataSetParameter");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse:
		return ((ns1__getMyInvestigationsIncludesPaginationResponse *)ptr)->soap_out(soap, tag, id, "ns1:getMyInvestigationsIncludesPaginationResponse");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination:
		return ((ns1__getMyInvestigationsIncludesPagination *)ptr)->soap_out(soap, tag, id, "ns1:getMyInvestigationsIncludesPagination");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse:
		return ((ns1__getMyInvestigationsIncludesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getMyInvestigationsIncludesResponse");
	case SOAP_TYPE_ns1__getMyInvestigationsIncludes:
		return ((ns1__getMyInvestigationsIncludes *)ptr)->soap_out(soap, tag, id, "ns1:getMyInvestigationsIncludes");
	case SOAP_TYPE_ns1__getMyInvestigationsResponse:
		return ((ns1__getMyInvestigationsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getMyInvestigationsResponse");
	case SOAP_TYPE_ns1__getMyInvestigations:
		return ((ns1__getMyInvestigations *)ptr)->soap_out(soap, tag, id, "ns1:getMyInvestigations");
	case SOAP_TYPE_ns1__searchByKeywordsAllResponse:
		return ((ns1__searchByKeywordsAllResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByKeywordsAllResponse");
	case SOAP_TYPE_ns1__keywordDetails:
		return ((ns1__keywordDetails *)ptr)->soap_out(soap, tag, id, "ns1:keywordDetails");
	case SOAP_TYPE_ns1__searchByKeywordsAll:
		return ((ns1__searchByKeywordsAll *)ptr)->soap_out(soap, tag, id, "ns1:searchByKeywordsAll");
	case SOAP_TYPE_ns1__searchByKeywordsResponse:
		return ((ns1__searchByKeywordsResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByKeywordsResponse");
	case SOAP_TYPE_ns1__searchByKeywords:
		return ((ns1__searchByKeywords *)ptr)->soap_out(soap, tag, id, "ns1:searchByKeywords");
	case SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse:
		return ((ns1__checkDatasetDownloadAccessResponse *)ptr)->soap_out(soap, tag, id, "ns1:checkDatasetDownloadAccessResponse");
	case SOAP_TYPE_ns1__checkDatasetDownloadAccess:
		return ((ns1__checkDatasetDownloadAccess *)ptr)->soap_out(soap, tag, id, "ns1:checkDatasetDownloadAccess");
	case SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse:
		return ((ns1__searchByUserSurnamePaginationResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserSurnamePaginationResponse");
	case SOAP_TYPE_ns1__searchByUserSurnamePagination:
		return ((ns1__searchByUserSurnamePagination *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserSurnamePagination");
	case SOAP_TYPE_ns1__shiftPK:
		return ((ns1__shiftPK *)ptr)->soap_out(soap, tag, id, "ns1:shiftPK");
	case SOAP_TYPE_ns1__shift:
		return ((ns1__shift *)ptr)->soap_out(soap, tag, id, "ns1:shift");
	case SOAP_TYPE_ns1__publication:
		return ((ns1__publication *)ptr)->soap_out(soap, tag, id, "ns1:publication");
	case SOAP_TYPE_ns1__keyword:
		return ((ns1__keyword *)ptr)->soap_out(soap, tag, id, "ns1:keyword");
	case SOAP_TYPE_ns1__investigator:
		return ((ns1__investigator *)ptr)->soap_out(soap, tag, id, "ns1:investigator");
	case SOAP_TYPE_ns1__investigation:
		return ((ns1__investigation *)ptr)->soap_out(soap, tag, id, "ns1:investigation");
	case SOAP_TYPE_ns1__searchByUserSurnameResponse:
		return ((ns1__searchByUserSurnameResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserSurnameResponse");
	case SOAP_TYPE_ns1__searchByUserSurname:
		return ((ns1__searchByUserSurname *)ptr)->soap_out(soap, tag, id, "ns1:searchByUserSurname");
	case SOAP_TYPE_ns1__deleteDataFileResponse:
		return ((ns1__deleteDataFileResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataFileResponse");
	case SOAP_TYPE_ns1__deleteDataFile:
		return ((ns1__deleteDataFile *)ptr)->soap_out(soap, tag, id, "ns1:deleteDataFile");
	case SOAP_TYPE_ns1__downloadInfo:
		return ((ns1__downloadInfo *)ptr)->soap_out(soap, tag, id, "ns1:downloadInfo");
	case SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse:
		return ((ns1__checkDatafileDownloadAccessResponse *)ptr)->soap_out(soap, tag, id, "ns1:checkDatafileDownloadAccessResponse");
	case SOAP_TYPE_ns1__checkDatafileDownloadAccess:
		return ((ns1__checkDatafileDownloadAccess *)ptr)->soap_out(soap, tag, id, "ns1:checkDatafileDownloadAccess");
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse:
		return ((ns1__getFacilityUserByFacilityUserIdResponse *)ptr)->soap_out(soap, tag, id, "ns1:getFacilityUserByFacilityUserIdResponse");
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserId:
		return ((ns1__getFacilityUserByFacilityUserId *)ptr)->soap_out(soap, tag, id, "ns1:getFacilityUserByFacilityUserId");
	case SOAP_TYPE_ns1__addSampleParameterResponse:
		return ((ns1__addSampleParameterResponse *)ptr)->soap_out(soap, tag, id, "ns1:addSampleParameterResponse");
	case SOAP_TYPE_ns1__addSampleParameter:
		return ((ns1__addSampleParameter *)ptr)->soap_out(soap, tag, id, "ns1:addSampleParameter");
	case SOAP_TYPE_ns1__modifyDataSetResponse:
		return ((ns1__modifyDataSetResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataSetResponse");
	case SOAP_TYPE_ns1__modifyDataSet:
		return ((ns1__modifyDataSet *)ptr)->soap_out(soap, tag, id, "ns1:modifyDataSet");
	case SOAP_TYPE_ns1__downloadDatafilesResponse:
		return ((ns1__downloadDatafilesResponse *)ptr)->soap_out(soap, tag, id, "ns1:downloadDatafilesResponse");
	case SOAP_TYPE_ns1__downloadDatafiles:
		return ((ns1__downloadDatafiles *)ptr)->soap_out(soap, tag, id, "ns1:downloadDatafiles");
	case SOAP_TYPE_ns1__NoSuchUserException:
		return ((ns1__NoSuchUserException *)ptr)->soap_out(soap, tag, id, "ns1:NoSuchUserException");
	case SOAP_TYPE_ns1__userDetails:
		return ((ns1__userDetails *)ptr)->soap_out(soap, tag, id, "ns1:userDetails");
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		return ((ns1__getUserDetailsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getUserDetailsResponse");
	case SOAP_TYPE_ns1__getUserDetails:
		return ((ns1__getUserDetails *)ptr)->soap_out(soap, tag, id, "ns1:getUserDetails");
	case SOAP_TYPE_ns1__getAllKeywordsResponse:
		return ((ns1__getAllKeywordsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getAllKeywordsResponse");
	case SOAP_TYPE_ns1__getAllKeywords:
		return ((ns1__getAllKeywords *)ptr)->soap_out(soap, tag, id, "ns1:getAllKeywords");
	case SOAP_TYPE_ns1__removePublicationResponse:
		return ((ns1__removePublicationResponse *)ptr)->soap_out(soap, tag, id, "ns1:removePublicationResponse");
	case SOAP_TYPE_ns1__removePublication:
		return ((ns1__removePublication *)ptr)->soap_out(soap, tag, id, "ns1:removePublication");
	case SOAP_TYPE_ns1__createDataSetsResponse:
		return ((ns1__createDataSetsResponse *)ptr)->soap_out(soap, tag, id, "ns1:createDataSetsResponse");
	case SOAP_TYPE_ns1__parameterPK:
		return ((ns1__parameterPK *)ptr)->soap_out(soap, tag, id, "ns1:parameterPK");
	case SOAP_TYPE_ns1__parameter:
		return ((ns1__parameter *)ptr)->soap_out(soap, tag, id, "ns1:parameter");
	case SOAP_TYPE_ns1__datasetParameterPK:
		return ((ns1__datasetParameterPK *)ptr)->soap_out(soap, tag, id, "ns1:datasetParameterPK");
	case SOAP_TYPE_ns1__datasetParameter:
		return ((ns1__datasetParameter *)ptr)->soap_out(soap, tag, id, "ns1:datasetParameter");
	case SOAP_TYPE_ns1__dataset:
		return ((ns1__dataset *)ptr)->soap_out(soap, tag, id, "ns1:dataset");
	case SOAP_TYPE_ns1__createDataSets:
		return ((ns1__createDataSets *)ptr)->soap_out(soap, tag, id, "ns1:createDataSets");
	case SOAP_TYPE_ns1__deleteInvestigationResponse:
		return ((ns1__deleteInvestigationResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteInvestigationResponse");
	case SOAP_TYPE_ns1__deleteInvestigation:
		return ((ns1__deleteInvestigation *)ptr)->soap_out(soap, tag, id, "ns1:deleteInvestigation");
	case SOAP_TYPE_ns1__removeKeywordResponse:
		return ((ns1__removeKeywordResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeKeywordResponse");
	case SOAP_TYPE_ns1__keywordPK:
		return ((ns1__keywordPK *)ptr)->soap_out(soap, tag, id, "ns1:keywordPK");
	case SOAP_TYPE_ns1__removeKeyword:
		return ((ns1__removeKeyword *)ptr)->soap_out(soap, tag, id, "ns1:removeKeyword");
	case SOAP_TYPE_ns1__removeInvestigationResponse:
		return ((ns1__removeInvestigationResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeInvestigationResponse");
	case SOAP_TYPE_ns1__removeInvestigation:
		return ((ns1__removeInvestigation *)ptr)->soap_out(soap, tag, id, "ns1:removeInvestigation");
	case SOAP_TYPE_ns1__removeInvestigatorResponse:
		return ((ns1__removeInvestigatorResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeInvestigatorResponse");
	case SOAP_TYPE_ns1__investigatorPK:
		return ((ns1__investigatorPK *)ptr)->soap_out(soap, tag, id, "ns1:investigatorPK");
	case SOAP_TYPE_ns1__removeInvestigator:
		return ((ns1__removeInvestigator *)ptr)->soap_out(soap, tag, id, "ns1:removeInvestigator");
	case SOAP_TYPE_ns1__facilityUser:
		return ((ns1__facilityUser *)ptr)->soap_out(soap, tag, id, "ns1:facilityUser");
	case SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse:
		return ((ns1__getFacilityUserByFederalIdResponse *)ptr)->soap_out(soap, tag, id, "ns1:getFacilityUserByFederalIdResponse");
	case SOAP_TYPE_ns1__getFacilityUserByFederalId:
		return ((ns1__getFacilityUserByFederalId *)ptr)->soap_out(soap, tag, id, "ns1:getFacilityUserByFederalId");
	case SOAP_TYPE_ns1__downloadDatasetResponse:
		return ((ns1__downloadDatasetResponse *)ptr)->soap_out(soap, tag, id, "ns1:downloadDatasetResponse");
	case SOAP_TYPE_ns1__downloadDataset:
		return ((ns1__downloadDataset *)ptr)->soap_out(soap, tag, id, "ns1:downloadDataset");
	case SOAP_TYPE_ns1__logoutResponse:
		return ((ns1__logoutResponse *)ptr)->soap_out(soap, tag, id, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return ((ns1__logout *)ptr)->soap_out(soap, tag, id, "ns1:logout");
	case SOAP_TYPE_ns1__facilityCycle:
		return ((ns1__facilityCycle *)ptr)->soap_out(soap, tag, id, "ns1:facilityCycle");
	case SOAP_TYPE_ns1__listFacilityCyclesResponse:
		return ((ns1__listFacilityCyclesResponse *)ptr)->soap_out(soap, tag, id, "ns1:listFacilityCyclesResponse");
	case SOAP_TYPE_ns1__listFacilityCycles:
		return ((ns1__listFacilityCycles *)ptr)->soap_out(soap, tag, id, "ns1:listFacilityCycles");
	case SOAP_TYPE_ns1__addDataFileParametersResponse:
		return ((ns1__addDataFileParametersResponse *)ptr)->soap_out(soap, tag, id, "ns1:addDataFileParametersResponse");
	case SOAP_TYPE_ns1__addDataFileParameters:
		return ((ns1__addDataFileParameters *)ptr)->soap_out(soap, tag, id, "ns1:addDataFileParameters");
	case SOAP_TYPE_ns1__removeAuthorisationResponse:
		return ((ns1__removeAuthorisationResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeAuthorisationResponse");
	case SOAP_TYPE_ns1__removeAuthorisation:
		return ((ns1__removeAuthorisation *)ptr)->soap_out(soap, tag, id, "ns1:removeAuthorisation");
	case SOAP_TYPE_ns1__removeDataFileResponse:
		return ((ns1__removeDataFileResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeDataFileResponse");
	case SOAP_TYPE_ns1__removeDataFile:
		return ((ns1__removeDataFile *)ptr)->soap_out(soap, tag, id, "ns1:removeDataFile");
	case SOAP_TYPE_ns1__modifySampleResponse:
		return ((ns1__modifySampleResponse *)ptr)->soap_out(soap, tag, id, "ns1:modifySampleResponse");
	case SOAP_TYPE_ns1__modifySample:
		return ((ns1__modifySample *)ptr)->soap_out(soap, tag, id, "ns1:modifySample");
	case SOAP_TYPE_ns1__ValidationException:
		return ((ns1__ValidationException *)ptr)->soap_out(soap, tag, id, "ns1:ValidationException");
	case SOAP_TYPE_ns1__createDataFileResponse:
		return ((ns1__createDataFileResponse *)ptr)->soap_out(soap, tag, id, "ns1:createDataFileResponse");
	case SOAP_TYPE_ns1__relatedDatafilesPK:
		return ((ns1__relatedDatafilesPK *)ptr)->soap_out(soap, tag, id, "ns1:relatedDatafilesPK");
	case SOAP_TYPE_ns1__relatedDatafiles:
		return ((ns1__relatedDatafiles *)ptr)->soap_out(soap, tag, id, "ns1:relatedDatafiles");
	case SOAP_TYPE_ns1__datafileParameterPK:
		return ((ns1__datafileParameterPK *)ptr)->soap_out(soap, tag, id, "ns1:datafileParameterPK");
	case SOAP_TYPE_ns1__datafileParameter:
		return ((ns1__datafileParameter *)ptr)->soap_out(soap, tag, id, "ns1:datafileParameter");
	case SOAP_TYPE_ns1__datafileFormatPK:
		return ((ns1__datafileFormatPK *)ptr)->soap_out(soap, tag, id, "ns1:datafileFormatPK");
	case SOAP_TYPE_ns1__datafileFormat:
		return ((ns1__datafileFormat *)ptr)->soap_out(soap, tag, id, "ns1:datafileFormat");
	case SOAP_TYPE_ns1__datafile:
		return ((ns1__datafile *)ptr)->soap_out(soap, tag, id, "ns1:datafile");
	case SOAP_TYPE_ns1__createDataFile:
		return ((ns1__createDataFile *)ptr)->soap_out(soap, tag, id, "ns1:createDataFile");
	case SOAP_TYPE_ns1__listInstrumentsResponse:
		return ((ns1__listInstrumentsResponse *)ptr)->soap_out(soap, tag, id, "ns1:listInstrumentsResponse");
	case SOAP_TYPE_ns1__listInstruments:
		return ((ns1__listInstruments *)ptr)->soap_out(soap, tag, id, "ns1:listInstruments");
	case SOAP_TYPE_ns1__NoSuchObjectFoundException:
		return ((ns1__NoSuchObjectFoundException *)ptr)->soap_out(soap, tag, id, "ns1:NoSuchObjectFoundException");
	case SOAP_TYPE_ns1__InsufficientPrivilegesException:
		return ((ns1__InsufficientPrivilegesException *)ptr)->soap_out(soap, tag, id, "ns1:InsufficientPrivilegesException");
	case SOAP_TYPE_ns1__removeSampleResponse:
		return ((ns1__removeSampleResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeSampleResponse");
	case SOAP_TYPE_ns1__removeSample:
		return ((ns1__removeSample *)ptr)->soap_out(soap, tag, id, "ns1:removeSample");
	case SOAP_TYPE_ns1__icatRole:
		return ((ns1__icatRole *)ptr)->soap_out(soap, tag, id, "ns1:icatRole");
	case SOAP_TYPE_ns1__entityPrimaryKeyBaseBean:
		return ((ns1__entityPrimaryKeyBaseBean *)ptr)->soap_out(soap, tag, id, "ns1:entityPrimaryKeyBaseBean");
	case SOAP_TYPE_ns1__sampleParameterPK:
		return ((ns1__sampleParameterPK *)ptr)->soap_out(soap, tag, id, "ns1:sampleParameterPK");
	case SOAP_TYPE_ns1__sampleParameter:
		return ((ns1__sampleParameter *)ptr)->soap_out(soap, tag, id, "ns1:sampleParameter");
	case SOAP_TYPE_ns1__entityBaseBean:
		return ((ns1__entityBaseBean *)ptr)->soap_out(soap, tag, id, "ns1:entityBaseBean");
	case SOAP_TYPE_ns1__sample:
		return ((ns1__sample *)ptr)->soap_out(soap, tag, id, "ns1:sample");
	case SOAP_TYPE_ns1__searchSamplesBySampleNameResponse:
		return ((ns1__searchSamplesBySampleNameResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchSamplesBySampleNameResponse");
	case SOAP_TYPE_ns1__searchSamplesBySampleName:
		return ((ns1__searchSamplesBySampleName *)ptr)->soap_out(soap, tag, id, "ns1:searchSamplesBySampleName");
	case SOAP_TYPE_ns1__listDatasetTypesResponse:
		return ((ns1__listDatasetTypesResponse *)ptr)->soap_out(soap, tag, id, "ns1:listDatasetTypesResponse");
	case SOAP_TYPE_ns1__listDatasetTypes:
		return ((ns1__listDatasetTypes *)ptr)->soap_out(soap, tag, id, "ns1:listDatasetTypes");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return ((xsd__float *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__getICATAPIVersionResponse:
		return soap_out_PointerTons1__getICATAPIVersionResponse(soap, tag, id, (ns1__getICATAPIVersionResponse *const*)ptr, "ns1:getICATAPIVersionResponse");
	case SOAP_TYPE_PointerTons1__getICATAPIVersion:
		return soap_out_PointerTons1__getICATAPIVersion(soap, tag, id, (ns1__getICATAPIVersion *const*)ptr, "ns1:getICATAPIVersion");
	case SOAP_TYPE_PointerTons1__listFacilityCyclesResponse:
		return soap_out_PointerTons1__listFacilityCyclesResponse(soap, tag, id, (ns1__listFacilityCyclesResponse *const*)ptr, "ns1:listFacilityCyclesResponse");
	case SOAP_TYPE_PointerTons1__listFacilityCycles:
		return soap_out_PointerTons1__listFacilityCycles(soap, tag, id, (ns1__listFacilityCycles *const*)ptr, "ns1:listFacilityCycles");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFederalIdResponse:
		return soap_out_PointerTons1__getFacilityUserByFederalIdResponse(soap, tag, id, (ns1__getFacilityUserByFederalIdResponse *const*)ptr, "ns1:getFacilityUserByFederalIdResponse");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFederalId:
		return soap_out_PointerTons1__getFacilityUserByFederalId(soap, tag, id, (ns1__getFacilityUserByFederalId *const*)ptr, "ns1:getFacilityUserByFederalId");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserIdResponse:
		return soap_out_PointerTons1__getFacilityUserByFacilityUserIdResponse(soap, tag, id, (ns1__getFacilityUserByFacilityUserIdResponse *const*)ptr, "ns1:getFacilityUserByFacilityUserIdResponse");
	case SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserId:
		return soap_out_PointerTons1__getFacilityUserByFacilityUserId(soap, tag, id, (ns1__getFacilityUserByFacilityUserId *const*)ptr, "ns1:getFacilityUserByFacilityUserId");
	case SOAP_TYPE_PointerTons1__searchDatasetsBySampleResponse:
		return soap_out_PointerTons1__searchDatasetsBySampleResponse(soap, tag, id, (ns1__searchDatasetsBySampleResponse *const*)ptr, "ns1:searchDatasetsBySampleResponse");
	case SOAP_TYPE_PointerTons1__searchDatasetsBySample:
		return soap_out_PointerTons1__searchDatasetsBySample(soap, tag, id, (ns1__searchDatasetsBySample *const*)ptr, "ns1:searchDatasetsBySample");
	case SOAP_TYPE_PointerTons1__checkDatasetDownloadAccessResponse:
		return soap_out_PointerTons1__checkDatasetDownloadAccessResponse(soap, tag, id, (ns1__checkDatasetDownloadAccessResponse *const*)ptr, "ns1:checkDatasetDownloadAccessResponse");
	case SOAP_TYPE_PointerTons1__checkDatasetDownloadAccess:
		return soap_out_PointerTons1__checkDatasetDownloadAccess(soap, tag, id, (ns1__checkDatasetDownloadAccess *const*)ptr, "ns1:checkDatasetDownloadAccess");
	case SOAP_TYPE_PointerTons1__checkDatafileDownloadAccessResponse:
		return soap_out_PointerTons1__checkDatafileDownloadAccessResponse(soap, tag, id, (ns1__checkDatafileDownloadAccessResponse *const*)ptr, "ns1:checkDatafileDownloadAccessResponse");
	case SOAP_TYPE_PointerTons1__checkDatafileDownloadAccess:
		return soap_out_PointerTons1__checkDatafileDownloadAccess(soap, tag, id, (ns1__checkDatafileDownloadAccess *const*)ptr, "ns1:checkDatafileDownloadAccess");
	case SOAP_TYPE_PointerTons1__downloadDatasetResponse:
		return soap_out_PointerTons1__downloadDatasetResponse(soap, tag, id, (ns1__downloadDatasetResponse *const*)ptr, "ns1:downloadDatasetResponse");
	case SOAP_TYPE_PointerTons1__downloadDataset:
		return soap_out_PointerTons1__downloadDataset(soap, tag, id, (ns1__downloadDataset *const*)ptr, "ns1:downloadDataset");
	case SOAP_TYPE_PointerTons1__downloadDatafilesResponse:
		return soap_out_PointerTons1__downloadDatafilesResponse(soap, tag, id, (ns1__downloadDatafilesResponse *const*)ptr, "ns1:downloadDatafilesResponse");
	case SOAP_TYPE_PointerTons1__downloadDatafiles:
		return soap_out_PointerTons1__downloadDatafiles(soap, tag, id, (ns1__downloadDatafiles *const*)ptr, "ns1:downloadDatafiles");
	case SOAP_TYPE_PointerTons1__downloadDatafileResponse:
		return soap_out_PointerTons1__downloadDatafileResponse(soap, tag, id, (ns1__downloadDatafileResponse *const*)ptr, "ns1:downloadDatafileResponse");
	case SOAP_TYPE_PointerTons1__downloadDatafile:
		return soap_out_PointerTons1__downloadDatafile(soap, tag, id, (ns1__downloadDatafile *const*)ptr, "ns1:downloadDatafile");
	case SOAP_TYPE_PointerTons1__listParametersResponse:
		return soap_out_PointerTons1__listParametersResponse(soap, tag, id, (ns1__listParametersResponse *const*)ptr, "ns1:listParametersResponse");
	case SOAP_TYPE_PointerTons1__listParameters:
		return soap_out_PointerTons1__listParameters(soap, tag, id, (ns1__listParameters *const*)ptr, "ns1:listParameters");
	case SOAP_TYPE_PointerTons1__listInvestigationTypesResponse:
		return soap_out_PointerTons1__listInvestigationTypesResponse(soap, tag, id, (ns1__listInvestigationTypesResponse *const*)ptr, "ns1:listInvestigationTypesResponse");
	case SOAP_TYPE_PointerTons1__listInvestigationTypes:
		return soap_out_PointerTons1__listInvestigationTypes(soap, tag, id, (ns1__listInvestigationTypes *const*)ptr, "ns1:listInvestigationTypes");
	case SOAP_TYPE_PointerTons1__listRolesResponse:
		return soap_out_PointerTons1__listRolesResponse(soap, tag, id, (ns1__listRolesResponse *const*)ptr, "ns1:listRolesResponse");
	case SOAP_TYPE_PointerTons1__listRoles:
		return soap_out_PointerTons1__listRoles(soap, tag, id, (ns1__listRoles *const*)ptr, "ns1:listRoles");
	case SOAP_TYPE_PointerTons1__listInstrumentsResponse:
		return soap_out_PointerTons1__listInstrumentsResponse(soap, tag, id, (ns1__listInstrumentsResponse *const*)ptr, "ns1:listInstrumentsResponse");
	case SOAP_TYPE_PointerTons1__listInstruments:
		return soap_out_PointerTons1__listInstruments(soap, tag, id, (ns1__listInstruments *const*)ptr, "ns1:listInstruments");
	case SOAP_TYPE_PointerTons1__searchByUserSurnamePaginationResponse:
		return soap_out_PointerTons1__searchByUserSurnamePaginationResponse(soap, tag, id, (ns1__searchByUserSurnamePaginationResponse *const*)ptr, "ns1:searchByUserSurnamePaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByUserSurnamePagination:
		return soap_out_PointerTons1__searchByUserSurnamePagination(soap, tag, id, (ns1__searchByUserSurnamePagination *const*)ptr, "ns1:searchByUserSurnamePagination");
	case SOAP_TYPE_PointerTons1__searchByUserSurnameResponse:
		return soap_out_PointerTons1__searchByUserSurnameResponse(soap, tag, id, (ns1__searchByUserSurnameResponse *const*)ptr, "ns1:searchByUserSurnameResponse");
	case SOAP_TYPE_PointerTons1__searchByUserSurname:
		return soap_out_PointerTons1__searchByUserSurname(soap, tag, id, (ns1__searchByUserSurname *const*)ptr, "ns1:searchByUserSurname");
	case SOAP_TYPE_PointerTons1__searchByUserIDPaginationResponse:
		return soap_out_PointerTons1__searchByUserIDPaginationResponse(soap, tag, id, (ns1__searchByUserIDPaginationResponse *const*)ptr, "ns1:searchByUserIDPaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByUserIDPagination:
		return soap_out_PointerTons1__searchByUserIDPagination(soap, tag, id, (ns1__searchByUserIDPagination *const*)ptr, "ns1:searchByUserIDPagination");
	case SOAP_TYPE_PointerTons1__searchByUserIDResponse:
		return soap_out_PointerTons1__searchByUserIDResponse(soap, tag, id, (ns1__searchByUserIDResponse *const*)ptr, "ns1:searchByUserIDResponse");
	case SOAP_TYPE_PointerTons1__searchByUserID:
		return soap_out_PointerTons1__searchByUserID(soap, tag, id, (ns1__searchByUserID *const*)ptr, "ns1:searchByUserID");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPaginationResponse:
		return soap_out_PointerTons1__getMyInvestigationsIncludesPaginationResponse(soap, tag, id, (ns1__getMyInvestigationsIncludesPaginationResponse *const*)ptr, "ns1:getMyInvestigationsIncludesPaginationResponse");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPagination:
		return soap_out_PointerTons1__getMyInvestigationsIncludesPagination(soap, tag, id, (ns1__getMyInvestigationsIncludesPagination *const*)ptr, "ns1:getMyInvestigationsIncludesPagination");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesResponse:
		return soap_out_PointerTons1__getMyInvestigationsIncludesResponse(soap, tag, id, (ns1__getMyInvestigationsIncludesResponse *const*)ptr, "ns1:getMyInvestigationsIncludesResponse");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludes:
		return soap_out_PointerTons1__getMyInvestigationsIncludes(soap, tag, id, (ns1__getMyInvestigationsIncludes *const*)ptr, "ns1:getMyInvestigationsIncludes");
	case SOAP_TYPE_PointerTons1__getMyInvestigationsResponse:
		return soap_out_PointerTons1__getMyInvestigationsResponse(soap, tag, id, (ns1__getMyInvestigationsResponse *const*)ptr, "ns1:getMyInvestigationsResponse");
	case SOAP_TYPE_PointerTons1__getMyInvestigations:
		return soap_out_PointerTons1__getMyInvestigations(soap, tag, id, (ns1__getMyInvestigations *const*)ptr, "ns1:getMyInvestigations");
	case SOAP_TYPE_PointerTons1__searchByKeywordsAllResponse:
		return soap_out_PointerTons1__searchByKeywordsAllResponse(soap, tag, id, (ns1__searchByKeywordsAllResponse *const*)ptr, "ns1:searchByKeywordsAllResponse");
	case SOAP_TYPE_PointerTons1__searchByKeywordsAll:
		return soap_out_PointerTons1__searchByKeywordsAll(soap, tag, id, (ns1__searchByKeywordsAll *const*)ptr, "ns1:searchByKeywordsAll");
	case SOAP_TYPE_PointerTons1__searchByKeywordsResponse:
		return soap_out_PointerTons1__searchByKeywordsResponse(soap, tag, id, (ns1__searchByKeywordsResponse *const*)ptr, "ns1:searchByKeywordsResponse");
	case SOAP_TYPE_PointerTons1__searchByKeywords:
		return soap_out_PointerTons1__searchByKeywords(soap, tag, id, (ns1__searchByKeywords *const*)ptr, "ns1:searchByKeywords");
	case SOAP_TYPE_PointerTons1__searchByAdvancedPaginationResponse:
		return soap_out_PointerTons1__searchByAdvancedPaginationResponse(soap, tag, id, (ns1__searchByAdvancedPaginationResponse *const*)ptr, "ns1:searchByAdvancedPaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByAdvancedPagination:
		return soap_out_PointerTons1__searchByAdvancedPagination(soap, tag, id, (ns1__searchByAdvancedPagination *const*)ptr, "ns1:searchByAdvancedPagination");
	case SOAP_TYPE_PointerTons1__searchByAdvancedResponse:
		return soap_out_PointerTons1__searchByAdvancedResponse(soap, tag, id, (ns1__searchByAdvancedResponse *const*)ptr, "ns1:searchByAdvancedResponse");
	case SOAP_TYPE_PointerTons1__searchByAdvanced:
		return soap_out_PointerTons1__searchByAdvanced(soap, tag, id, (ns1__searchByAdvanced *const*)ptr, "ns1:searchByAdvanced");
	case SOAP_TYPE_PointerTons1__setDataSetSampleResponse:
		return soap_out_PointerTons1__setDataSetSampleResponse(soap, tag, id, (ns1__setDataSetSampleResponse *const*)ptr, "ns1:setDataSetSampleResponse");
	case SOAP_TYPE_PointerTons1__setDataSetSample:
		return soap_out_PointerTons1__setDataSetSample(soap, tag, id, (ns1__setDataSetSample *const*)ptr, "ns1:setDataSetSample");
	case SOAP_TYPE_PointerTons1__deleteDataSetParameterResponse:
		return soap_out_PointerTons1__deleteDataSetParameterResponse(soap, tag, id, (ns1__deleteDataSetParameterResponse *const*)ptr, "ns1:deleteDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__deleteDataSetParameter:
		return soap_out_PointerTons1__deleteDataSetParameter(soap, tag, id, (ns1__deleteDataSetParameter *const*)ptr, "ns1:deleteDataSetParameter");
	case SOAP_TYPE_PointerTons1__removeDataSetParameterResponse:
		return soap_out_PointerTons1__removeDataSetParameterResponse(soap, tag, id, (ns1__removeDataSetParameterResponse *const*)ptr, "ns1:removeDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__removeDataSetParameter:
		return soap_out_PointerTons1__removeDataSetParameter(soap, tag, id, (ns1__removeDataSetParameter *const*)ptr, "ns1:removeDataSetParameter");
	case SOAP_TYPE_PointerTons1__modifyDataSetParameterResponse:
		return soap_out_PointerTons1__modifyDataSetParameterResponse(soap, tag, id, (ns1__modifyDataSetParameterResponse *const*)ptr, "ns1:modifyDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__modifyDataSetParameter:
		return soap_out_PointerTons1__modifyDataSetParameter(soap, tag, id, (ns1__modifyDataSetParameter *const*)ptr, "ns1:modifyDataSetParameter");
	case SOAP_TYPE_PointerTons1__addDataSetParametersResponse:
		return soap_out_PointerTons1__addDataSetParametersResponse(soap, tag, id, (ns1__addDataSetParametersResponse *const*)ptr, "ns1:addDataSetParametersResponse");
	case SOAP_TYPE_PointerTons1__addDataSetParameters:
		return soap_out_PointerTons1__addDataSetParameters(soap, tag, id, (ns1__addDataSetParameters *const*)ptr, "ns1:addDataSetParameters");
	case SOAP_TYPE_PointerTons1__addDataSetParameterResponse:
		return soap_out_PointerTons1__addDataSetParameterResponse(soap, tag, id, (ns1__addDataSetParameterResponse *const*)ptr, "ns1:addDataSetParameterResponse");
	case SOAP_TYPE_PointerTons1__addDataSetParameter:
		return soap_out_PointerTons1__addDataSetParameter(soap, tag, id, (ns1__addDataSetParameter *const*)ptr, "ns1:addDataSetParameter");
	case SOAP_TYPE_PointerTons1__modifyDataSetResponse:
		return soap_out_PointerTons1__modifyDataSetResponse(soap, tag, id, (ns1__modifyDataSetResponse *const*)ptr, "ns1:modifyDataSetResponse");
	case SOAP_TYPE_PointerTons1__modifyDataSet:
		return soap_out_PointerTons1__modifyDataSet(soap, tag, id, (ns1__modifyDataSet *const*)ptr, "ns1:modifyDataSet");
	case SOAP_TYPE_PointerTons1__deleteDataSetResponse:
		return soap_out_PointerTons1__deleteDataSetResponse(soap, tag, id, (ns1__deleteDataSetResponse *const*)ptr, "ns1:deleteDataSetResponse");
	case SOAP_TYPE_PointerTons1__deleteDataSet:
		return soap_out_PointerTons1__deleteDataSet(soap, tag, id, (ns1__deleteDataSet *const*)ptr, "ns1:deleteDataSet");
	case SOAP_TYPE_PointerTons1__removeDataSetResponse:
		return soap_out_PointerTons1__removeDataSetResponse(soap, tag, id, (ns1__removeDataSetResponse *const*)ptr, "ns1:removeDataSetResponse");
	case SOAP_TYPE_PointerTons1__removeDataSet:
		return soap_out_PointerTons1__removeDataSet(soap, tag, id, (ns1__removeDataSet *const*)ptr, "ns1:removeDataSet");
	case SOAP_TYPE_PointerTons1__createDataSetsResponse:
		return soap_out_PointerTons1__createDataSetsResponse(soap, tag, id, (ns1__createDataSetsResponse *const*)ptr, "ns1:createDataSetsResponse");
	case SOAP_TYPE_PointerTons1__createDataSets:
		return soap_out_PointerTons1__createDataSets(soap, tag, id, (ns1__createDataSets *const*)ptr, "ns1:createDataSets");
	case SOAP_TYPE_PointerTons1__createDataSetResponse:
		return soap_out_PointerTons1__createDataSetResponse(soap, tag, id, (ns1__createDataSetResponse *const*)ptr, "ns1:createDataSetResponse");
	case SOAP_TYPE_PointerTons1__createDataSet:
		return soap_out_PointerTons1__createDataSet(soap, tag, id, (ns1__createDataSet *const*)ptr, "ns1:createDataSet");
	case SOAP_TYPE_PointerTons1__getDatasetsResponse:
		return soap_out_PointerTons1__getDatasetsResponse(soap, tag, id, (ns1__getDatasetsResponse *const*)ptr, "ns1:getDatasetsResponse");
	case SOAP_TYPE_PointerTons1__getDatasets:
		return soap_out_PointerTons1__getDatasets(soap, tag, id, (ns1__getDatasets *const*)ptr, "ns1:getDatasets");
	case SOAP_TYPE_PointerTons1__listDatasetStatusResponse:
		return soap_out_PointerTons1__listDatasetStatusResponse(soap, tag, id, (ns1__listDatasetStatusResponse *const*)ptr, "ns1:listDatasetStatusResponse");
	case SOAP_TYPE_PointerTons1__listDatasetStatus:
		return soap_out_PointerTons1__listDatasetStatus(soap, tag, id, (ns1__listDatasetStatus *const*)ptr, "ns1:listDatasetStatus");
	case SOAP_TYPE_PointerTons1__listDatasetTypesResponse:
		return soap_out_PointerTons1__listDatasetTypesResponse(soap, tag, id, (ns1__listDatasetTypesResponse *const*)ptr, "ns1:listDatasetTypesResponse");
	case SOAP_TYPE_PointerTons1__listDatasetTypes:
		return soap_out_PointerTons1__listDatasetTypes(soap, tag, id, (ns1__listDatasetTypes *const*)ptr, "ns1:listDatasetTypes");
	case SOAP_TYPE_PointerTons1__searchSamplesBySampleNameResponse:
		return soap_out_PointerTons1__searchSamplesBySampleNameResponse(soap, tag, id, (ns1__searchSamplesBySampleNameResponse *const*)ptr, "ns1:searchSamplesBySampleNameResponse");
	case SOAP_TYPE_PointerTons1__searchSamplesBySampleName:
		return soap_out_PointerTons1__searchSamplesBySampleName(soap, tag, id, (ns1__searchSamplesBySampleName *const*)ptr, "ns1:searchSamplesBySampleName");
	case SOAP_TYPE_PointerTons1__listDatafileFormatsResponse:
		return soap_out_PointerTons1__listDatafileFormatsResponse(soap, tag, id, (ns1__listDatafileFormatsResponse *const*)ptr, "ns1:listDatafileFormatsResponse");
	case SOAP_TYPE_PointerTons1__listDatafileFormats:
		return soap_out_PointerTons1__listDatafileFormats(soap, tag, id, (ns1__listDatafileFormats *const*)ptr, "ns1:listDatafileFormats");
	case SOAP_TYPE_PointerTons1__searchByRunNumberPaginationResponse:
		return soap_out_PointerTons1__searchByRunNumberPaginationResponse(soap, tag, id, (ns1__searchByRunNumberPaginationResponse *const*)ptr, "ns1:searchByRunNumberPaginationResponse");
	case SOAP_TYPE_PointerTons1__searchByRunNumberPagination:
		return soap_out_PointerTons1__searchByRunNumberPagination(soap, tag, id, (ns1__searchByRunNumberPagination *const*)ptr, "ns1:searchByRunNumberPagination");
	case SOAP_TYPE_PointerTons1__searchByRunNumberResponse:
		return soap_out_PointerTons1__searchByRunNumberResponse(soap, tag, id, (ns1__searchByRunNumberResponse *const*)ptr, "ns1:searchByRunNumberResponse");
	case SOAP_TYPE_PointerTons1__searchByRunNumber:
		return soap_out_PointerTons1__searchByRunNumber(soap, tag, id, (ns1__searchByRunNumber *const*)ptr, "ns1:searchByRunNumber");
	case SOAP_TYPE_PointerTons1__getAllKeywordsResponse:
		return soap_out_PointerTons1__getAllKeywordsResponse(soap, tag, id, (ns1__getAllKeywordsResponse *const*)ptr, "ns1:getAllKeywordsResponse");
	case SOAP_TYPE_PointerTons1__getAllKeywords:
		return soap_out_PointerTons1__getAllKeywords(soap, tag, id, (ns1__getAllKeywords *const*)ptr, "ns1:getAllKeywords");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserTypeResponse:
		return soap_out_PointerTons1__getKeywordsForUserTypeResponse(soap, tag, id, (ns1__getKeywordsForUserTypeResponse *const*)ptr, "ns1:getKeywordsForUserTypeResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserType:
		return soap_out_PointerTons1__getKeywordsForUserType(soap, tag, id, (ns1__getKeywordsForUserType *const*)ptr, "ns1:getKeywordsForUserType");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserMaxResponse:
		return soap_out_PointerTons1__getKeywordsForUserMaxResponse(soap, tag, id, (ns1__getKeywordsForUserMaxResponse *const*)ptr, "ns1:getKeywordsForUserMaxResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserMax:
		return soap_out_PointerTons1__getKeywordsForUserMax(soap, tag, id, (ns1__getKeywordsForUserMax *const*)ptr, "ns1:getKeywordsForUserMax");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMaxResponse:
		return soap_out_PointerTons1__getKeywordsForUserStartWithMaxResponse(soap, tag, id, (ns1__getKeywordsForUserStartWithMaxResponse *const*)ptr, "ns1:getKeywordsForUserStartWithMaxResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMax:
		return soap_out_PointerTons1__getKeywordsForUserStartWithMax(soap, tag, id, (ns1__getKeywordsForUserStartWithMax *const*)ptr, "ns1:getKeywordsForUserStartWithMax");
	case SOAP_TYPE_PointerTons1__getKeywordsForUserResponse:
		return soap_out_PointerTons1__getKeywordsForUserResponse(soap, tag, id, (ns1__getKeywordsForUserResponse *const*)ptr, "ns1:getKeywordsForUserResponse");
	case SOAP_TYPE_PointerTons1__getKeywordsForUser:
		return soap_out_PointerTons1__getKeywordsForUser(soap, tag, id, (ns1__getKeywordsForUser *const*)ptr, "ns1:getKeywordsForUser");
	case SOAP_TYPE_PointerTons1__modifySampleParameterResponse:
		return soap_out_PointerTons1__modifySampleParameterResponse(soap, tag, id, (ns1__modifySampleParameterResponse *const*)ptr, "ns1:modifySampleParameterResponse");
	case SOAP_TYPE_PointerTons1__modifySampleParameter:
		return soap_out_PointerTons1__modifySampleParameter(soap, tag, id, (ns1__modifySampleParameter *const*)ptr, "ns1:modifySampleParameter");
	case SOAP_TYPE_PointerTons1__deleteSampleParameterResponse:
		return soap_out_PointerTons1__deleteSampleParameterResponse(soap, tag, id, (ns1__deleteSampleParameterResponse *const*)ptr, "ns1:deleteSampleParameterResponse");
	case SOAP_TYPE_PointerTons1__deleteSampleParameter:
		return soap_out_PointerTons1__deleteSampleParameter(soap, tag, id, (ns1__deleteSampleParameter *const*)ptr, "ns1:deleteSampleParameter");
	case SOAP_TYPE_PointerTons1__removeSampleParameterResponse:
		return soap_out_PointerTons1__removeSampleParameterResponse(soap, tag, id, (ns1__removeSampleParameterResponse *const*)ptr, "ns1:removeSampleParameterResponse");
	case SOAP_TYPE_PointerTons1__removeSampleParameter:
		return soap_out_PointerTons1__removeSampleParameter(soap, tag, id, (ns1__removeSampleParameter *const*)ptr, "ns1:removeSampleParameter");
	case SOAP_TYPE_PointerTons1__modifySampleResponse:
		return soap_out_PointerTons1__modifySampleResponse(soap, tag, id, (ns1__modifySampleResponse *const*)ptr, "ns1:modifySampleResponse");
	case SOAP_TYPE_PointerTons1__modifySample:
		return soap_out_PointerTons1__modifySample(soap, tag, id, (ns1__modifySample *const*)ptr, "ns1:modifySample");
	case SOAP_TYPE_PointerTons1__deleteSampleResponse:
		return soap_out_PointerTons1__deleteSampleResponse(soap, tag, id, (ns1__deleteSampleResponse *const*)ptr, "ns1:deleteSampleResponse");
	case SOAP_TYPE_PointerTons1__deleteSample:
		return soap_out_PointerTons1__deleteSample(soap, tag, id, (ns1__deleteSample *const*)ptr, "ns1:deleteSample");
	case SOAP_TYPE_PointerTons1__removeSampleResponse:
		return soap_out_PointerTons1__removeSampleResponse(soap, tag, id, (ns1__removeSampleResponse *const*)ptr, "ns1:removeSampleResponse");
	case SOAP_TYPE_PointerTons1__removeSample:
		return soap_out_PointerTons1__removeSample(soap, tag, id, (ns1__removeSample *const*)ptr, "ns1:removeSample");
	case SOAP_TYPE_PointerTons1__deleteInvestigatorResponse:
		return soap_out_PointerTons1__deleteInvestigatorResponse(soap, tag, id, (ns1__deleteInvestigatorResponse *const*)ptr, "ns1:deleteInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__deleteInvestigator:
		return soap_out_PointerTons1__deleteInvestigator(soap, tag, id, (ns1__deleteInvestigator *const*)ptr, "ns1:deleteInvestigator");
	case SOAP_TYPE_PointerTons1__modifyInvestigatorResponse:
		return soap_out_PointerTons1__modifyInvestigatorResponse(soap, tag, id, (ns1__modifyInvestigatorResponse *const*)ptr, "ns1:modifyInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__modifyInvestigator:
		return soap_out_PointerTons1__modifyInvestigator(soap, tag, id, (ns1__modifyInvestigator *const*)ptr, "ns1:modifyInvestigator");
	case SOAP_TYPE_PointerTons1__removeInvestigatorResponse:
		return soap_out_PointerTons1__removeInvestigatorResponse(soap, tag, id, (ns1__removeInvestigatorResponse *const*)ptr, "ns1:removeInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__removeInvestigator:
		return soap_out_PointerTons1__removeInvestigator(soap, tag, id, (ns1__removeInvestigator *const*)ptr, "ns1:removeInvestigator");
	case SOAP_TYPE_PointerTons1__modifyPublicationResponse:
		return soap_out_PointerTons1__modifyPublicationResponse(soap, tag, id, (ns1__modifyPublicationResponse *const*)ptr, "ns1:modifyPublicationResponse");
	case SOAP_TYPE_PointerTons1__modifyPublication:
		return soap_out_PointerTons1__modifyPublication(soap, tag, id, (ns1__modifyPublication *const*)ptr, "ns1:modifyPublication");
	case SOAP_TYPE_PointerTons1__deletePublicationResponse:
		return soap_out_PointerTons1__deletePublicationResponse(soap, tag, id, (ns1__deletePublicationResponse *const*)ptr, "ns1:deletePublicationResponse");
	case SOAP_TYPE_PointerTons1__deletePublication:
		return soap_out_PointerTons1__deletePublication(soap, tag, id, (ns1__deletePublication *const*)ptr, "ns1:deletePublication");
	case SOAP_TYPE_PointerTons1__removePublicationResponse:
		return soap_out_PointerTons1__removePublicationResponse(soap, tag, id, (ns1__removePublicationResponse *const*)ptr, "ns1:removePublicationResponse");
	case SOAP_TYPE_PointerTons1__removePublication:
		return soap_out_PointerTons1__removePublication(soap, tag, id, (ns1__removePublication *const*)ptr, "ns1:removePublication");
	case SOAP_TYPE_PointerTons1__deleteKeywordResponse:
		return soap_out_PointerTons1__deleteKeywordResponse(soap, tag, id, (ns1__deleteKeywordResponse *const*)ptr, "ns1:deleteKeywordResponse");
	case SOAP_TYPE_PointerTons1__deleteKeyword:
		return soap_out_PointerTons1__deleteKeyword(soap, tag, id, (ns1__deleteKeyword *const*)ptr, "ns1:deleteKeyword");
	case SOAP_TYPE_PointerTons1__removeKeywordResponse:
		return soap_out_PointerTons1__removeKeywordResponse(soap, tag, id, (ns1__removeKeywordResponse *const*)ptr, "ns1:removeKeywordResponse");
	case SOAP_TYPE_PointerTons1__removeKeyword:
		return soap_out_PointerTons1__removeKeyword(soap, tag, id, (ns1__removeKeyword *const*)ptr, "ns1:removeKeyword");
	case SOAP_TYPE_PointerTons1__modifyInvestigationResponse:
		return soap_out_PointerTons1__modifyInvestigationResponse(soap, tag, id, (ns1__modifyInvestigationResponse *const*)ptr, "ns1:modifyInvestigationResponse");
	case SOAP_TYPE_PointerTons1__modifyInvestigation:
		return soap_out_PointerTons1__modifyInvestigation(soap, tag, id, (ns1__modifyInvestigation *const*)ptr, "ns1:modifyInvestigation");
	case SOAP_TYPE_PointerTons1__deleteInvestigationResponse:
		return soap_out_PointerTons1__deleteInvestigationResponse(soap, tag, id, (ns1__deleteInvestigationResponse *const*)ptr, "ns1:deleteInvestigationResponse");
	case SOAP_TYPE_PointerTons1__deleteInvestigation:
		return soap_out_PointerTons1__deleteInvestigation(soap, tag, id, (ns1__deleteInvestigation *const*)ptr, "ns1:deleteInvestigation");
	case SOAP_TYPE_PointerTons1__removeInvestigationResponse:
		return soap_out_PointerTons1__removeInvestigationResponse(soap, tag, id, (ns1__removeInvestigationResponse *const*)ptr, "ns1:removeInvestigationResponse");
	case SOAP_TYPE_PointerTons1__removeInvestigation:
		return soap_out_PointerTons1__removeInvestigation(soap, tag, id, (ns1__removeInvestigation *const*)ptr, "ns1:removeInvestigation");
	case SOAP_TYPE_PointerTons1__createInvestigationResponse:
		return soap_out_PointerTons1__createInvestigationResponse(soap, tag, id, (ns1__createInvestigationResponse *const*)ptr, "ns1:createInvestigationResponse");
	case SOAP_TYPE_PointerTons1__createInvestigation:
		return soap_out_PointerTons1__createInvestigation(soap, tag, id, (ns1__createInvestigation *const*)ptr, "ns1:createInvestigation");
	case SOAP_TYPE_PointerTons1__getInvestigationsIncludesResponse:
		return soap_out_PointerTons1__getInvestigationsIncludesResponse(soap, tag, id, (ns1__getInvestigationsIncludesResponse *const*)ptr, "ns1:getInvestigationsIncludesResponse");
	case SOAP_TYPE_PointerTons1__getInvestigationsIncludes:
		return soap_out_PointerTons1__getInvestigationsIncludes(soap, tag, id, (ns1__getInvestigationsIncludes *const*)ptr, "ns1:getInvestigationsIncludes");
	case SOAP_TYPE_PointerTons1__updateAuthorisationResponse:
		return soap_out_PointerTons1__updateAuthorisationResponse(soap, tag, id, (ns1__updateAuthorisationResponse *const*)ptr, "ns1:updateAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__updateAuthorisation:
		return soap_out_PointerTons1__updateAuthorisation(soap, tag, id, (ns1__updateAuthorisation *const*)ptr, "ns1:updateAuthorisation");
	case SOAP_TYPE_PointerTons1__removeAuthorisationResponse:
		return soap_out_PointerTons1__removeAuthorisationResponse(soap, tag, id, (ns1__removeAuthorisationResponse *const*)ptr, "ns1:removeAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__removeAuthorisation:
		return soap_out_PointerTons1__removeAuthorisation(soap, tag, id, (ns1__removeAuthorisation *const*)ptr, "ns1:removeAuthorisation");
	case SOAP_TYPE_PointerTons1__deleteAuthorisationResponse:
		return soap_out_PointerTons1__deleteAuthorisationResponse(soap, tag, id, (ns1__deleteAuthorisationResponse *const*)ptr, "ns1:deleteAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__deleteAuthorisation:
		return soap_out_PointerTons1__deleteAuthorisation(soap, tag, id, (ns1__deleteAuthorisation *const*)ptr, "ns1:deleteAuthorisation");
	case SOAP_TYPE_PointerTons1__addAuthorisationResponse:
		return soap_out_PointerTons1__addAuthorisationResponse(soap, tag, id, (ns1__addAuthorisationResponse *const*)ptr, "ns1:addAuthorisationResponse");
	case SOAP_TYPE_PointerTons1__addAuthorisation:
		return soap_out_PointerTons1__addAuthorisation(soap, tag, id, (ns1__addAuthorisation *const*)ptr, "ns1:addAuthorisation");
	case SOAP_TYPE_PointerTons1__getAuthorisationsResponse:
		return soap_out_PointerTons1__getAuthorisationsResponse(soap, tag, id, (ns1__getAuthorisationsResponse *const*)ptr, "ns1:getAuthorisationsResponse");
	case SOAP_TYPE_PointerTons1__getAuthorisations:
		return soap_out_PointerTons1__getAuthorisations(soap, tag, id, (ns1__getAuthorisations *const*)ptr, "ns1:getAuthorisations");
	case SOAP_TYPE_PointerTons1__deleteDataFileParameterResponse:
		return soap_out_PointerTons1__deleteDataFileParameterResponse(soap, tag, id, (ns1__deleteDataFileParameterResponse *const*)ptr, "ns1:deleteDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__deleteDataFileParameter:
		return soap_out_PointerTons1__deleteDataFileParameter(soap, tag, id, (ns1__deleteDataFileParameter *const*)ptr, "ns1:deleteDataFileParameter");
	case SOAP_TYPE_PointerTons1__removeDataFileParameterResponse:
		return soap_out_PointerTons1__removeDataFileParameterResponse(soap, tag, id, (ns1__removeDataFileParameterResponse *const*)ptr, "ns1:removeDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__removeDataFileParameter:
		return soap_out_PointerTons1__removeDataFileParameter(soap, tag, id, (ns1__removeDataFileParameter *const*)ptr, "ns1:removeDataFileParameter");
	case SOAP_TYPE_PointerTons1__modifyDataFileParameterResponse:
		return soap_out_PointerTons1__modifyDataFileParameterResponse(soap, tag, id, (ns1__modifyDataFileParameterResponse *const*)ptr, "ns1:modifyDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__modifyDataFileParameter:
		return soap_out_PointerTons1__modifyDataFileParameter(soap, tag, id, (ns1__modifyDataFileParameter *const*)ptr, "ns1:modifyDataFileParameter");
	case SOAP_TYPE_PointerTons1__addDataFileParametersResponse:
		return soap_out_PointerTons1__addDataFileParametersResponse(soap, tag, id, (ns1__addDataFileParametersResponse *const*)ptr, "ns1:addDataFileParametersResponse");
	case SOAP_TYPE_PointerTons1__addDataFileParameters:
		return soap_out_PointerTons1__addDataFileParameters(soap, tag, id, (ns1__addDataFileParameters *const*)ptr, "ns1:addDataFileParameters");
	case SOAP_TYPE_PointerTons1__modifyDataFileResponse:
		return soap_out_PointerTons1__modifyDataFileResponse(soap, tag, id, (ns1__modifyDataFileResponse *const*)ptr, "ns1:modifyDataFileResponse");
	case SOAP_TYPE_PointerTons1__modifyDataFile:
		return soap_out_PointerTons1__modifyDataFile(soap, tag, id, (ns1__modifyDataFile *const*)ptr, "ns1:modifyDataFile");
	case SOAP_TYPE_PointerTons1__removeDataFileResponse:
		return soap_out_PointerTons1__removeDataFileResponse(soap, tag, id, (ns1__removeDataFileResponse *const*)ptr, "ns1:removeDataFileResponse");
	case SOAP_TYPE_PointerTons1__removeDataFile:
		return soap_out_PointerTons1__removeDataFile(soap, tag, id, (ns1__removeDataFile *const*)ptr, "ns1:removeDataFile");
	case SOAP_TYPE_PointerTons1__deleteDataFileResponse:
		return soap_out_PointerTons1__deleteDataFileResponse(soap, tag, id, (ns1__deleteDataFileResponse *const*)ptr, "ns1:deleteDataFileResponse");
	case SOAP_TYPE_PointerTons1__deleteDataFile:
		return soap_out_PointerTons1__deleteDataFile(soap, tag, id, (ns1__deleteDataFile *const*)ptr, "ns1:deleteDataFile");
	case SOAP_TYPE_PointerTons1__createDataFilesResponse:
		return soap_out_PointerTons1__createDataFilesResponse(soap, tag, id, (ns1__createDataFilesResponse *const*)ptr, "ns1:createDataFilesResponse");
	case SOAP_TYPE_PointerTons1__createDataFiles:
		return soap_out_PointerTons1__createDataFiles(soap, tag, id, (ns1__createDataFiles *const*)ptr, "ns1:createDataFiles");
	case SOAP_TYPE_PointerTons1__createDataFileResponse:
		return soap_out_PointerTons1__createDataFileResponse(soap, tag, id, (ns1__createDataFileResponse *const*)ptr, "ns1:createDataFileResponse");
	case SOAP_TYPE_PointerTons1__createDataFile:
		return soap_out_PointerTons1__createDataFile(soap, tag, id, (ns1__createDataFile *const*)ptr, "ns1:createDataFile");
	case SOAP_TYPE_PointerTons1__getDatafilesResponse:
		return soap_out_PointerTons1__getDatafilesResponse(soap, tag, id, (ns1__getDatafilesResponse *const*)ptr, "ns1:getDatafilesResponse");
	case SOAP_TYPE_PointerTons1__getDatafiles:
		return soap_out_PointerTons1__getDatafiles(soap, tag, id, (ns1__getDatafiles *const*)ptr, "ns1:getDatafiles");
	case SOAP_TYPE_PointerTons1__ingestMetadataResponse:
		return soap_out_PointerTons1__ingestMetadataResponse(soap, tag, id, (ns1__ingestMetadataResponse *const*)ptr, "ns1:ingestMetadataResponse");
	case SOAP_TYPE_PointerTons1__ingestMetadata:
		return soap_out_PointerTons1__ingestMetadata(soap, tag, id, (ns1__ingestMetadata *const*)ptr, "ns1:ingestMetadata");
	case SOAP_TYPE_PointerTons1__getUserDetailsResponse:
		return soap_out_PointerTons1__getUserDetailsResponse(soap, tag, id, (ns1__getUserDetailsResponse *const*)ptr, "ns1:getUserDetailsResponse");
	case SOAP_TYPE_PointerTons1__getUserDetails:
		return soap_out_PointerTons1__getUserDetails(soap, tag, id, (ns1__getUserDetails *const*)ptr, "ns1:getUserDetails");
	case SOAP_TYPE_PointerTons1__addDataFileParameterResponse:
		return soap_out_PointerTons1__addDataFileParameterResponse(soap, tag, id, (ns1__addDataFileParameterResponse *const*)ptr, "ns1:addDataFileParameterResponse");
	case SOAP_TYPE_PointerTons1__addDataFileParameter:
		return soap_out_PointerTons1__addDataFileParameter(soap, tag, id, (ns1__addDataFileParameter *const*)ptr, "ns1:addDataFileParameter");
	case SOAP_TYPE_PointerTons1__getDatafileResponse:
		return soap_out_PointerTons1__getDatafileResponse(soap, tag, id, (ns1__getDatafileResponse *const*)ptr, "ns1:getDatafileResponse");
	case SOAP_TYPE_PointerTons1__getDatafile:
		return soap_out_PointerTons1__getDatafile(soap, tag, id, (ns1__getDatafile *const*)ptr, "ns1:getDatafile");
	case SOAP_TYPE_PointerTons1__getDatasetIncludesResponse:
		return soap_out_PointerTons1__getDatasetIncludesResponse(soap, tag, id, (ns1__getDatasetIncludesResponse *const*)ptr, "ns1:getDatasetIncludesResponse");
	case SOAP_TYPE_PointerTons1__getDatasetIncludes:
		return soap_out_PointerTons1__getDatasetIncludes(soap, tag, id, (ns1__getDatasetIncludes *const*)ptr, "ns1:getDatasetIncludes");
	case SOAP_TYPE_PointerTons1__getDatasetResponse:
		return soap_out_PointerTons1__getDatasetResponse(soap, tag, id, (ns1__getDatasetResponse *const*)ptr, "ns1:getDatasetResponse");
	case SOAP_TYPE_PointerTons1__getDataset:
		return soap_out_PointerTons1__getDataset(soap, tag, id, (ns1__getDataset *const*)ptr, "ns1:getDataset");
	case SOAP_TYPE_PointerTons1__getInvestigationIncludesResponse:
		return soap_out_PointerTons1__getInvestigationIncludesResponse(soap, tag, id, (ns1__getInvestigationIncludesResponse *const*)ptr, "ns1:getInvestigationIncludesResponse");
	case SOAP_TYPE_PointerTons1__getInvestigationIncludes:
		return soap_out_PointerTons1__getInvestigationIncludes(soap, tag, id, (ns1__getInvestigationIncludes *const*)ptr, "ns1:getInvestigationIncludes");
	case SOAP_TYPE_PointerTons1__getInvestigationResponse:
		return soap_out_PointerTons1__getInvestigationResponse(soap, tag, id, (ns1__getInvestigationResponse *const*)ptr, "ns1:getInvestigationResponse");
	case SOAP_TYPE_PointerTons1__getInvestigation:
		return soap_out_PointerTons1__getInvestigation(soap, tag, id, (ns1__getInvestigation *const*)ptr, "ns1:getInvestigation");
	case SOAP_TYPE_PointerTons1__addInvestigatorResponse:
		return soap_out_PointerTons1__addInvestigatorResponse(soap, tag, id, (ns1__addInvestigatorResponse *const*)ptr, "ns1:addInvestigatorResponse");
	case SOAP_TYPE_PointerTons1__addInvestigator:
		return soap_out_PointerTons1__addInvestigator(soap, tag, id, (ns1__addInvestigator *const*)ptr, "ns1:addInvestigator");
	case SOAP_TYPE_PointerTons1__addKeywordResponse:
		return soap_out_PointerTons1__addKeywordResponse(soap, tag, id, (ns1__addKeywordResponse *const*)ptr, "ns1:addKeywordResponse");
	case SOAP_TYPE_PointerTons1__addKeyword:
		return soap_out_PointerTons1__addKeyword(soap, tag, id, (ns1__addKeyword *const*)ptr, "ns1:addKeyword");
	case SOAP_TYPE_PointerTons1__addPublicationResponse:
		return soap_out_PointerTons1__addPublicationResponse(soap, tag, id, (ns1__addPublicationResponse *const*)ptr, "ns1:addPublicationResponse");
	case SOAP_TYPE_PointerTons1__addPublication:
		return soap_out_PointerTons1__addPublication(soap, tag, id, (ns1__addPublication *const*)ptr, "ns1:addPublication");
	case SOAP_TYPE_PointerTons1__addSampleParameterResponse:
		return soap_out_PointerTons1__addSampleParameterResponse(soap, tag, id, (ns1__addSampleParameterResponse *const*)ptr, "ns1:addSampleParameterResponse");
	case SOAP_TYPE_PointerTons1__addSampleParameter:
		return soap_out_PointerTons1__addSampleParameter(soap, tag, id, (ns1__addSampleParameter *const*)ptr, "ns1:addSampleParameter");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_out_PointerTons1__logoutResponse(soap, tag, id, (ns1__logoutResponse *const*)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_out_PointerTons1__logout(soap, tag, id, (ns1__logout *const*)ptr, "ns1:logout");
	case SOAP_TYPE_PointerTons1__addSampleResponse:
		return soap_out_PointerTons1__addSampleResponse(soap, tag, id, (ns1__addSampleResponse *const*)ptr, "ns1:addSampleResponse");
	case SOAP_TYPE_PointerTons1__addSample:
		return soap_out_PointerTons1__addSample(soap, tag, id, (ns1__addSample *const*)ptr, "ns1:addSample");
	case SOAP_TYPE_PointerTons1__loginLifetimeResponse:
		return soap_out_PointerTons1__loginLifetimeResponse(soap, tag, id, (ns1__loginLifetimeResponse *const*)ptr, "ns1:loginLifetimeResponse");
	case SOAP_TYPE_PointerTons1__loginLifetime:
		return soap_out_PointerTons1__loginLifetime(soap, tag, id, (ns1__loginLifetime *const*)ptr, "ns1:loginLifetime");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_out_PointerTons1__loginResponse(soap, tag, id, (ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__login:
		return soap_out_PointerTons1__login(soap, tag, id, (ns1__login *const*)ptr, "ns1:login");
	case SOAP_TYPE_PointerTons1__ValidationException:
		return soap_out_PointerTons1__ValidationException(soap, tag, id, (ns1__ValidationException *const*)ptr, "ns1:ValidationException");
	case SOAP_TYPE_PointerTons3__SessionException:
		return soap_out_PointerTons3__SessionException(soap, tag, id, (ns3__SessionException *const*)ptr, "ns3:SessionException");
	case SOAP_TYPE_PointerTons1__NoSuchUserException:
		return soap_out_PointerTons1__NoSuchUserException(soap, tag, id, (ns1__NoSuchUserException *const*)ptr, "ns1:NoSuchUserException");
	case SOAP_TYPE_PointerTons1__NoSuchObjectFoundException:
		return soap_out_PointerTons1__NoSuchObjectFoundException(soap, tag, id, (ns1__NoSuchObjectFoundException *const*)ptr, "ns1:NoSuchObjectFoundException");
	case SOAP_TYPE_PointerTons1__InsufficientPrivilegesException:
		return soap_out_PointerTons1__InsufficientPrivilegesException(soap, tag, id, (ns1__InsufficientPrivilegesException *const*)ptr, "ns1:InsufficientPrivilegesException");
	case SOAP_TYPE_PointerTons1__ICATAPIException:
		return soap_out_PointerTons1__ICATAPIException(soap, tag, id, (ns1__ICATAPIException *const*)ptr, "ns1:ICATAPIException");
	case SOAP_TYPE_PointerTons1__shiftPK:
		return soap_out_PointerTons1__shiftPK(soap, tag, id, (ns1__shiftPK *const*)ptr, "ns1:shiftPK");
	case SOAP_TYPE_PointerTons1__shift:
		return soap_out_PointerTons1__shift(soap, tag, id, (ns1__shift *const*)ptr, "ns1:shift");
	case SOAP_TYPE_PointerTons1__parameterPK:
		return soap_out_PointerTons1__parameterPK(soap, tag, id, (ns1__parameterPK *const*)ptr, "ns1:parameterPK");
	case SOAP_TYPE_PointerTons1__relatedDatafilesPK:
		return soap_out_PointerTons1__relatedDatafilesPK(soap, tag, id, (ns1__relatedDatafilesPK *const*)ptr, "ns1:relatedDatafilesPK");
	case SOAP_TYPE_PointerTons1__datafileFormatPK:
		return soap_out_PointerTons1__datafileFormatPK(soap, tag, id, (ns1__datafileFormatPK *const*)ptr, "ns1:datafileFormatPK");
	case SOAP_TYPE_PointerTons1__relatedDatafiles:
		return soap_out_PointerTons1__relatedDatafiles(soap, tag, id, (ns1__relatedDatafiles *const*)ptr, "ns1:relatedDatafiles");
	case SOAP_TYPE_PointerTons1__datafileInclude:
		return soap_out_PointerTons1__datafileInclude(soap, tag, id, (enum ns1__datafileInclude *const*)ptr, "ns1:datafileInclude");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__parameter:
		return soap_out_PointerTons1__parameter(soap, tag, id, (ns1__parameter *const*)ptr, "ns1:parameter");
	case SOAP_TYPE_PointerTons1__datasetInclude:
		return soap_out_PointerTons1__datasetInclude(soap, tag, id, (enum ns1__datasetInclude *const*)ptr, "ns1:datasetInclude");
	case SOAP_TYPE_PointerTons1__datafileFormat:
		return soap_out_PointerTons1__datafileFormat(soap, tag, id, (ns1__datafileFormat *const*)ptr, "ns1:datafileFormat");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__advancedSearchDetails:
		return soap_out_PointerTons1__advancedSearchDetails(soap, tag, id, (ns1__advancedSearchDetails *const*)ptr, "ns1:advancedSearchDetails");
	case SOAP_TYPE_PointerTons1__keyword:
		return soap_out_PointerTons1__keyword(soap, tag, id, (ns1__keyword *const*)ptr, "ns1:keyword");
	case SOAP_TYPE_PointerTons1__icatAuthorisation:
		return soap_out_PointerTons1__icatAuthorisation(soap, tag, id, (ns1__icatAuthorisation *const*)ptr, "ns1:icatAuthorisation");
	case SOAP_TYPE_PointerTons1__elementType:
		return soap_out_PointerTons1__elementType(soap, tag, id, (enum ns1__elementType *const*)ptr, "ns1:elementType");
	case SOAP_TYPE_PointerTons1__datasetParameter:
		return soap_out_PointerTons1__datasetParameter(soap, tag, id, (ns1__datasetParameter *const*)ptr, "ns1:datasetParameter");
	case SOAP_TYPE_PointerTons1__sampleParameterPK:
		return soap_out_PointerTons1__sampleParameterPK(soap, tag, id, (ns1__sampleParameterPK *const*)ptr, "ns1:sampleParameterPK");
	case SOAP_TYPE_PointerTons1__investigator:
		return soap_out_PointerTons1__investigator(soap, tag, id, (ns1__investigator *const*)ptr, "ns1:investigator");
	case SOAP_TYPE_PointerTons1__datafileParameterPK:
		return soap_out_PointerTons1__datafileParameterPK(soap, tag, id, (ns1__datafileParameterPK *const*)ptr, "ns1:datafileParameterPK");
	case SOAP_TYPE_PointerTons1__publication:
		return soap_out_PointerTons1__publication(soap, tag, id, (ns1__publication *const*)ptr, "ns1:publication");
	case SOAP_TYPE_PointerTons1__datasetParameterPK:
		return soap_out_PointerTons1__datasetParameterPK(soap, tag, id, (ns1__datasetParameterPK *const*)ptr, "ns1:datasetParameterPK");
	case SOAP_TYPE_PointerTons1__investigationInclude:
		return soap_out_PointerTons1__investigationInclude(soap, tag, id, (enum ns1__investigationInclude *const*)ptr, "ns1:investigationInclude");
	case SOAP_TYPE_PointerTons1__keywordDetails:
		return soap_out_PointerTons1__keywordDetails(soap, tag, id, (ns1__keywordDetails *const*)ptr, "ns1:keywordDetails");
	case SOAP_TYPE_PointerTons1__investigation:
		return soap_out_PointerTons1__investigation(soap, tag, id, (ns1__investigation *const*)ptr, "ns1:investigation");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__downloadInfo:
		return soap_out_PointerTons1__downloadInfo(soap, tag, id, (ns1__downloadInfo *const*)ptr, "ns1:downloadInfo");
	case SOAP_TYPE_PointerTons1__sampleParameter:
		return soap_out_PointerTons1__sampleParameter(soap, tag, id, (ns1__sampleParameter *const*)ptr, "ns1:sampleParameter");
	case SOAP_TYPE_PointerTons1__userDetails:
		return soap_out_PointerTons1__userDetails(soap, tag, id, (ns1__userDetails *const*)ptr, "ns1:userDetails");
	case SOAP_TYPE_PointerTons1__keywordType:
		return soap_out_PointerTons1__keywordType(soap, tag, id, (enum ns1__keywordType *const*)ptr, "ns1:keywordType");
	case SOAP_TYPE_PointerTons1__dataset:
		return soap_out_PointerTons1__dataset(soap, tag, id, (ns1__dataset *const*)ptr, "ns1:dataset");
	case SOAP_TYPE_PointerTons1__keywordPK:
		return soap_out_PointerTons1__keywordPK(soap, tag, id, (ns1__keywordPK *const*)ptr, "ns1:keywordPK");
	case SOAP_TYPE_PointerTons1__investigatorPK:
		return soap_out_PointerTons1__investigatorPK(soap, tag, id, (ns1__investigatorPK *const*)ptr, "ns1:investigatorPK");
	case SOAP_TYPE_PointerTons1__facilityUser:
		return soap_out_PointerTons1__facilityUser(soap, tag, id, (ns1__facilityUser *const*)ptr, "ns1:facilityUser");
	case SOAP_TYPE_PointerTons1__facilityCycle:
		return soap_out_PointerTons1__facilityCycle(soap, tag, id, (ns1__facilityCycle *const*)ptr, "ns1:facilityCycle");
	case SOAP_TYPE_PointerTons1__datafileParameter:
		return soap_out_PointerTons1__datafileParameter(soap, tag, id, (ns1__datafileParameter *const*)ptr, "ns1:datafileParameter");
	case SOAP_TYPE_PointerTons1__datafile:
		return soap_out_PointerTons1__datafile(soap, tag, id, (ns1__datafile *const*)ptr, "ns1:datafile");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons1__icatRole:
		return soap_out_PointerTons1__icatRole(soap, tag, id, (ns1__icatRole *const*)ptr, "ns1:icatRole");
	case SOAP_TYPE_PointerTons1__sample:
		return soap_out_PointerTons1__sample(soap, tag, id, (ns1__sample *const*)ptr, "ns1:sample");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__datasetInclude_:
		((ns1__datasetInclude_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__elementType_:
		((ns1__elementType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__investigationInclude_:
		((ns1__investigationInclude_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__keywordType_:
		((ns1__keywordType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datafileInclude_:
		((ns1__datafileInclude_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__SessionException:
		((ns3__SessionException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatasetsResponse:
		((ns1__getDatasetsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatasets:
		((ns1__getDatasets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listParametersResponse:
		((ns1__listParametersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listParameters:
		((ns1__listParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataFileParameterResponse:
		((ns1__modifyDataFileParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataFileParameter:
		((ns1__modifyDataFileParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteSampleParameterResponse:
		((ns1__deleteSampleParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteSampleParameter:
		((ns1__deleteSampleParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataFileParameterResponse:
		((ns1__addDataFileParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataFileParameter:
		((ns1__addDataFileParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchDatasetsBySampleResponse:
		((ns1__searchDatasetsBySampleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchDatasetsBySample:
		((ns1__searchDatasetsBySample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addPublicationResponse:
		((ns1__addPublicationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addPublication:
		((ns1__addPublication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createInvestigationResponse:
		((ns1__createInvestigationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createInvestigation:
		((ns1__createInvestigation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataFileParameterResponse:
		((ns1__deleteDataFileParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataFileParameter:
		((ns1__deleteDataFileParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getInvestigationResponse:
		((ns1__getInvestigationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getInvestigation:
		((ns1__getInvestigation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getInvestigationIncludesResponse:
		((ns1__getInvestigationIncludesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getInvestigationIncludes:
		((ns1__getInvestigationIncludes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataFileResponse:
		((ns1__modifyDataFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataFile:
		((ns1__modifyDataFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatafileResponse:
		((ns1__getDatafileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatafile:
		((ns1__getDatafile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ICATAPIException:
		((ns1__ICATAPIException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ingestMetadataResponse:
		((ns1__ingestMetadataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ingestMetadata:
		((ns1__ingestMetadata *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listRolesResponse:
		((ns1__listRolesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listRoles:
		((ns1__listRoles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatasetResponse:
		((ns1__getDatasetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDataset:
		((ns1__getDataset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatasetIncludesResponse:
		((ns1__getDatasetIncludesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatasetIncludes:
		((ns1__getDatasetIncludes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateAuthorisationResponse:
		((ns1__updateAuthorisationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateAuthorisation:
		((ns1__updateAuthorisation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteAuthorisationResponse:
		((ns1__deleteAuthorisationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteAuthorisation:
		((ns1__deleteAuthorisation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		((ns1__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__login:
		((ns1__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loginLifetimeResponse:
		((ns1__loginLifetimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loginLifetime:
		((ns1__loginLifetime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deletePublicationResponse:
		((ns1__deletePublicationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deletePublication:
		((ns1__deletePublication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addSampleResponse:
		((ns1__addSampleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addSample:
		((ns1__addSample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addAuthorisationResponse:
		((ns1__addAuthorisationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addAuthorisation:
		((ns1__addAuthorisation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataSetParameterResponse:
		((ns1__addDataSetParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataSetParameter:
		((ns1__addDataSetParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataFilesResponse:
		((ns1__createDataFilesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataFiles:
		((ns1__createDataFiles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyInvestigatorResponse:
		((ns1__modifyInvestigatorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyInvestigator:
		((ns1__modifyInvestigator *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifySampleParameterResponse:
		((ns1__modifySampleParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifySampleParameter:
		((ns1__modifySampleParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listDatafileFormatsResponse:
		((ns1__listDatafileFormatsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listDatafileFormats:
		((ns1__listDatafileFormats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByAdvancedPaginationResponse:
		((ns1__searchByAdvancedPaginationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByAdvancedPagination:
		((ns1__searchByAdvancedPagination *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByAdvancedResponse:
		((ns1__searchByAdvancedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__advancedSearchDetails:
		((ns1__advancedSearchDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByAdvanced:
		((ns1__searchByAdvanced *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByRunNumberPaginationResponse:
		((ns1__searchByRunNumberPaginationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByRunNumberPagination:
		((ns1__searchByRunNumberPagination *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByRunNumberResponse:
		((ns1__searchByRunNumberResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByRunNumber:
		((ns1__searchByRunNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataSetParametersResponse:
		((ns1__addDataSetParametersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataSetParameters:
		((ns1__addDataSetParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteKeywordResponse:
		((ns1__deleteKeywordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteKeyword:
		((ns1__deleteKeyword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteSampleResponse:
		((ns1__deleteSampleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteSample:
		((ns1__deleteSample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listDatasetStatusResponse:
		((ns1__listDatasetStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listDatasetStatus:
		((ns1__listDatasetStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyInvestigationResponse:
		((ns1__modifyInvestigationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyInvestigation:
		((ns1__modifyInvestigation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addKeywordResponse:
		((ns1__addKeywordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addKeyword:
		((ns1__addKeyword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__icatAuthorisation:
		((ns1__icatAuthorisation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAuthorisationsResponse:
		((ns1__getAuthorisationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAuthorisations:
		((ns1__getAuthorisations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataSetResponse:
		((ns1__removeDataSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataSet:
		((ns1__removeDataSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataSetParameterResponse:
		((ns1__modifyDataSetParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataSetParameter:
		((ns1__modifyDataSetParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listInvestigationTypesResponse:
		((ns1__listInvestigationTypesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listInvestigationTypes:
		((ns1__listInvestigationTypes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserTypeResponse:
		((ns1__getKeywordsForUserTypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserType:
		((ns1__getKeywordsForUserType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserMaxResponse:
		((ns1__getKeywordsForUserMaxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserMax:
		((ns1__getKeywordsForUserMax *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse:
		((ns1__getKeywordsForUserStartWithMaxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMax:
		((ns1__getKeywordsForUserStartWithMax *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserResponse:
		((ns1__getKeywordsForUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUser:
		((ns1__getKeywordsForUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadDatafileResponse:
		((ns1__downloadDatafileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadDatafile:
		((ns1__downloadDatafile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setDataSetSampleResponse:
		((ns1__setDataSetSampleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setDataSetSample:
		((ns1__setDataSetSample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataSetParameterResponse:
		((ns1__deleteDataSetParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataSetParameter:
		((ns1__deleteDataSetParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeSampleParameterResponse:
		((ns1__removeSampleParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeSampleParameter:
		((ns1__removeSampleParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataSetResponse:
		((ns1__createDataSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataSet:
		((ns1__createDataSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addInvestigatorResponse:
		((ns1__addInvestigatorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addInvestigator:
		((ns1__addInvestigator *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteInvestigatorResponse:
		((ns1__deleteInvestigatorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteInvestigator:
		((ns1__deleteInvestigator *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getICATAPIVersionResponse:
		((ns1__getICATAPIVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getICATAPIVersion:
		((ns1__getICATAPIVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatafilesResponse:
		((ns1__getDatafilesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDatafiles:
		((ns1__getDatafiles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataSetResponse:
		((ns1__deleteDataSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataSet:
		((ns1__deleteDataSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getInvestigationsIncludesResponse:
		((ns1__getInvestigationsIncludesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getInvestigationsIncludes:
		((ns1__getInvestigationsIncludes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataFileParameterResponse:
		((ns1__removeDataFileParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataFileParameter:
		((ns1__removeDataFileParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserIDPaginationResponse:
		((ns1__searchByUserIDPaginationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserIDPagination:
		((ns1__searchByUserIDPagination *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserIDResponse:
		((ns1__searchByUserIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserID:
		((ns1__searchByUserID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyPublicationResponse:
		((ns1__modifyPublicationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyPublication:
		((ns1__modifyPublication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataSetParameterResponse:
		((ns1__removeDataSetParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataSetParameter:
		((ns1__removeDataSetParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse:
		((ns1__getMyInvestigationsIncludesPaginationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination:
		((ns1__getMyInvestigationsIncludesPagination *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse:
		((ns1__getMyInvestigationsIncludesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludes:
		((ns1__getMyInvestigationsIncludes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsResponse:
		((ns1__getMyInvestigationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyInvestigations:
		((ns1__getMyInvestigations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByKeywordsAllResponse:
		((ns1__searchByKeywordsAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__keywordDetails:
		((ns1__keywordDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByKeywordsAll:
		((ns1__searchByKeywordsAll *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByKeywordsResponse:
		((ns1__searchByKeywordsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByKeywords:
		((ns1__searchByKeywords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse:
		((ns1__checkDatasetDownloadAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkDatasetDownloadAccess:
		((ns1__checkDatasetDownloadAccess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse:
		((ns1__searchByUserSurnamePaginationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserSurnamePagination:
		((ns1__searchByUserSurnamePagination *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__shiftPK:
		((ns1__shiftPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__shift:
		((ns1__shift *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__publication:
		((ns1__publication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__keyword:
		((ns1__keyword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__investigator:
		((ns1__investigator *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__investigation:
		((ns1__investigation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserSurnameResponse:
		((ns1__searchByUserSurnameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchByUserSurname:
		((ns1__searchByUserSurname *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataFileResponse:
		((ns1__deleteDataFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDataFile:
		((ns1__deleteDataFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadInfo:
		((ns1__downloadInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse:
		((ns1__checkDatafileDownloadAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkDatafileDownloadAccess:
		((ns1__checkDatafileDownloadAccess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse:
		((ns1__getFacilityUserByFacilityUserIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserId:
		((ns1__getFacilityUserByFacilityUserId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addSampleParameterResponse:
		((ns1__addSampleParameterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addSampleParameter:
		((ns1__addSampleParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataSetResponse:
		((ns1__modifyDataSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifyDataSet:
		((ns1__modifyDataSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadDatafilesResponse:
		((ns1__downloadDatafilesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadDatafiles:
		((ns1__downloadDatafiles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NoSuchUserException:
		((ns1__NoSuchUserException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__userDetails:
		((ns1__userDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		((ns1__getUserDetailsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getUserDetails:
		((ns1__getUserDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAllKeywordsResponse:
		((ns1__getAllKeywordsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAllKeywords:
		((ns1__getAllKeywords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removePublicationResponse:
		((ns1__removePublicationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removePublication:
		((ns1__removePublication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataSetsResponse:
		((ns1__createDataSetsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__parameterPK:
		((ns1__parameterPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__parameter:
		((ns1__parameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datasetParameterPK:
		((ns1__datasetParameterPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datasetParameter:
		((ns1__datasetParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__dataset:
		((ns1__dataset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataSets:
		((ns1__createDataSets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteInvestigationResponse:
		((ns1__deleteInvestigationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteInvestigation:
		((ns1__deleteInvestigation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeKeywordResponse:
		((ns1__removeKeywordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__keywordPK:
		((ns1__keywordPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeKeyword:
		((ns1__removeKeyword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeInvestigationResponse:
		((ns1__removeInvestigationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeInvestigation:
		((ns1__removeInvestigation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeInvestigatorResponse:
		((ns1__removeInvestigatorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__investigatorPK:
		((ns1__investigatorPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeInvestigator:
		((ns1__removeInvestigator *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__facilityUser:
		((ns1__facilityUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse:
		((ns1__getFacilityUserByFederalIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFederalId:
		((ns1__getFacilityUserByFederalId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadDatasetResponse:
		((ns1__downloadDatasetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadDataset:
		((ns1__downloadDataset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		((ns1__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logout:
		((ns1__logout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__facilityCycle:
		((ns1__facilityCycle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listFacilityCyclesResponse:
		((ns1__listFacilityCyclesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listFacilityCycles:
		((ns1__listFacilityCycles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataFileParametersResponse:
		((ns1__addDataFileParametersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addDataFileParameters:
		((ns1__addDataFileParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeAuthorisationResponse:
		((ns1__removeAuthorisationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeAuthorisation:
		((ns1__removeAuthorisation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataFileResponse:
		((ns1__removeDataFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeDataFile:
		((ns1__removeDataFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifySampleResponse:
		((ns1__modifySampleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__modifySample:
		((ns1__modifySample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValidationException:
		((ns1__ValidationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataFileResponse:
		((ns1__createDataFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__relatedDatafilesPK:
		((ns1__relatedDatafilesPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__relatedDatafiles:
		((ns1__relatedDatafiles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datafileParameterPK:
		((ns1__datafileParameterPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datafileParameter:
		((ns1__datafileParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datafileFormatPK:
		((ns1__datafileFormatPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datafileFormat:
		((ns1__datafileFormat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__datafile:
		((ns1__datafile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDataFile:
		((ns1__createDataFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listInstrumentsResponse:
		((ns1__listInstrumentsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listInstruments:
		((ns1__listInstruments *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NoSuchObjectFoundException:
		((ns1__NoSuchObjectFoundException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InsufficientPrivilegesException:
		((ns1__InsufficientPrivilegesException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeSampleResponse:
		((ns1__removeSampleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeSample:
		((ns1__removeSample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__icatRole:
		((ns1__icatRole *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__entityPrimaryKeyBaseBean:
		((ns1__entityPrimaryKeyBaseBean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sampleParameterPK:
		((ns1__sampleParameterPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sampleParameter:
		((ns1__sampleParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__entityBaseBean:
		((ns1__entityBaseBean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sample:
		((ns1__sample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchSamplesBySampleNameResponse:
		((ns1__searchSamplesBySampleNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchSamplesBySampleName:
		((ns1__searchSamplesBySampleName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listDatasetTypesResponse:
		((ns1__listDatasetTypesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listDatasetTypes:
		((ns1__listDatasetTypes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__float:
		((xsd__float *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getICATAPIVersion:
		soap_serialize___ns1__getICATAPIVersion(soap, (const struct __ns1__getICATAPIVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__listFacilityCycles:
		soap_serialize___ns1__listFacilityCycles(soap, (const struct __ns1__listFacilityCycles *)ptr);
		break;
	case SOAP_TYPE___ns1__getFacilityUserByFederalId:
		soap_serialize___ns1__getFacilityUserByFederalId(soap, (const struct __ns1__getFacilityUserByFederalId *)ptr);
		break;
	case SOAP_TYPE___ns1__getFacilityUserByFacilityUserId:
		soap_serialize___ns1__getFacilityUserByFacilityUserId(soap, (const struct __ns1__getFacilityUserByFacilityUserId *)ptr);
		break;
	case SOAP_TYPE___ns1__searchDatasetsBySample:
		soap_serialize___ns1__searchDatasetsBySample(soap, (const struct __ns1__searchDatasetsBySample *)ptr);
		break;
	case SOAP_TYPE___ns1__checkDatasetDownloadAccess:
		soap_serialize___ns1__checkDatasetDownloadAccess(soap, (const struct __ns1__checkDatasetDownloadAccess *)ptr);
		break;
	case SOAP_TYPE___ns1__checkDatafileDownloadAccess:
		soap_serialize___ns1__checkDatafileDownloadAccess(soap, (const struct __ns1__checkDatafileDownloadAccess *)ptr);
		break;
	case SOAP_TYPE___ns1__downloadDataset:
		soap_serialize___ns1__downloadDataset(soap, (const struct __ns1__downloadDataset *)ptr);
		break;
	case SOAP_TYPE___ns1__downloadDatafiles:
		soap_serialize___ns1__downloadDatafiles(soap, (const struct __ns1__downloadDatafiles *)ptr);
		break;
	case SOAP_TYPE___ns1__downloadDatafile:
		soap_serialize___ns1__downloadDatafile(soap, (const struct __ns1__downloadDatafile *)ptr);
		break;
	case SOAP_TYPE___ns1__listParameters:
		soap_serialize___ns1__listParameters(soap, (const struct __ns1__listParameters *)ptr);
		break;
	case SOAP_TYPE___ns1__listInvestigationTypes:
		soap_serialize___ns1__listInvestigationTypes(soap, (const struct __ns1__listInvestigationTypes *)ptr);
		break;
	case SOAP_TYPE___ns1__listRoles:
		soap_serialize___ns1__listRoles(soap, (const struct __ns1__listRoles *)ptr);
		break;
	case SOAP_TYPE___ns1__listInstruments:
		soap_serialize___ns1__listInstruments(soap, (const struct __ns1__listInstruments *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserSurnamePagination:
		soap_serialize___ns1__searchByUserSurnamePagination(soap, (const struct __ns1__searchByUserSurnamePagination *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserSurname:
		soap_serialize___ns1__searchByUserSurname(soap, (const struct __ns1__searchByUserSurname *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserIDPagination:
		soap_serialize___ns1__searchByUserIDPagination(soap, (const struct __ns1__searchByUserIDPagination *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserID:
		soap_serialize___ns1__searchByUserID(soap, (const struct __ns1__searchByUserID *)ptr);
		break;
	case SOAP_TYPE___ns1__getMyInvestigationsIncludesPagination:
		soap_serialize___ns1__getMyInvestigationsIncludesPagination(soap, (const struct __ns1__getMyInvestigationsIncludesPagination *)ptr);
		break;
	case SOAP_TYPE___ns1__getMyInvestigationsIncludes:
		soap_serialize___ns1__getMyInvestigationsIncludes(soap, (const struct __ns1__getMyInvestigationsIncludes *)ptr);
		break;
	case SOAP_TYPE___ns1__getMyInvestigations:
		soap_serialize___ns1__getMyInvestigations(soap, (const struct __ns1__getMyInvestigations *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByKeywordsAll:
		soap_serialize___ns1__searchByKeywordsAll(soap, (const struct __ns1__searchByKeywordsAll *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByKeywords:
		soap_serialize___ns1__searchByKeywords(soap, (const struct __ns1__searchByKeywords *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByAdvancedPagination:
		soap_serialize___ns1__searchByAdvancedPagination(soap, (const struct __ns1__searchByAdvancedPagination *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByAdvanced:
		soap_serialize___ns1__searchByAdvanced(soap, (const struct __ns1__searchByAdvanced *)ptr);
		break;
	case SOAP_TYPE___ns1__setDataSetSample:
		soap_serialize___ns1__setDataSetSample(soap, (const struct __ns1__setDataSetSample *)ptr);
		break;
	case SOAP_TYPE___ns1__setDataSetSampleResponse:
		soap_serialize___ns1__setDataSetSampleResponse(soap, (const struct __ns1__setDataSetSampleResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSetParameter:
		soap_serialize___ns1__deleteDataSetParameter(soap, (const struct __ns1__deleteDataSetParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSetParameterResponse:
		soap_serialize___ns1__deleteDataSetParameterResponse(soap, (const struct __ns1__deleteDataSetParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSetParameter:
		soap_serialize___ns1__removeDataSetParameter(soap, (const struct __ns1__removeDataSetParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSetParameterResponse:
		soap_serialize___ns1__removeDataSetParameterResponse(soap, (const struct __ns1__removeDataSetParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSetParameter:
		soap_serialize___ns1__modifyDataSetParameter(soap, (const struct __ns1__modifyDataSetParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSetParameterResponse:
		soap_serialize___ns1__modifyDataSetParameterResponse(soap, (const struct __ns1__modifyDataSetParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__addDataSetParameters:
		soap_serialize___ns1__addDataSetParameters(soap, (const struct __ns1__addDataSetParameters *)ptr);
		break;
	case SOAP_TYPE___ns1__addDataSetParameter:
		soap_serialize___ns1__addDataSetParameter(soap, (const struct __ns1__addDataSetParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSet:
		soap_serialize___ns1__modifyDataSet(soap, (const struct __ns1__modifyDataSet *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSetResponse:
		soap_serialize___ns1__modifyDataSetResponse(soap, (const struct __ns1__modifyDataSetResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSet:
		soap_serialize___ns1__deleteDataSet(soap, (const struct __ns1__deleteDataSet *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSetResponse:
		soap_serialize___ns1__deleteDataSetResponse(soap, (const struct __ns1__deleteDataSetResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSet:
		soap_serialize___ns1__removeDataSet(soap, (const struct __ns1__removeDataSet *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSetResponse:
		soap_serialize___ns1__removeDataSetResponse(soap, (const struct __ns1__removeDataSetResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__createDataSets:
		soap_serialize___ns1__createDataSets(soap, (const struct __ns1__createDataSets *)ptr);
		break;
	case SOAP_TYPE___ns1__createDataSet:
		soap_serialize___ns1__createDataSet(soap, (const struct __ns1__createDataSet *)ptr);
		break;
	case SOAP_TYPE___ns1__getDatasets:
		soap_serialize___ns1__getDatasets(soap, (const struct __ns1__getDatasets *)ptr);
		break;
	case SOAP_TYPE___ns1__listDatasetStatus:
		soap_serialize___ns1__listDatasetStatus(soap, (const struct __ns1__listDatasetStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__listDatasetTypes:
		soap_serialize___ns1__listDatasetTypes(soap, (const struct __ns1__listDatasetTypes *)ptr);
		break;
	case SOAP_TYPE___ns1__searchSamplesBySampleName:
		soap_serialize___ns1__searchSamplesBySampleName(soap, (const struct __ns1__searchSamplesBySampleName *)ptr);
		break;
	case SOAP_TYPE___ns1__listDatafileFormats:
		soap_serialize___ns1__listDatafileFormats(soap, (const struct __ns1__listDatafileFormats *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByRunNumberPagination:
		soap_serialize___ns1__searchByRunNumberPagination(soap, (const struct __ns1__searchByRunNumberPagination *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByRunNumber:
		soap_serialize___ns1__searchByRunNumber(soap, (const struct __ns1__searchByRunNumber *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllKeywords:
		soap_serialize___ns1__getAllKeywords(soap, (const struct __ns1__getAllKeywords *)ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUserType:
		soap_serialize___ns1__getKeywordsForUserType(soap, (const struct __ns1__getKeywordsForUserType *)ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUserMax:
		soap_serialize___ns1__getKeywordsForUserMax(soap, (const struct __ns1__getKeywordsForUserMax *)ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUserStartWithMax:
		soap_serialize___ns1__getKeywordsForUserStartWithMax(soap, (const struct __ns1__getKeywordsForUserStartWithMax *)ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUser:
		soap_serialize___ns1__getKeywordsForUser(soap, (const struct __ns1__getKeywordsForUser *)ptr);
		break;
	case SOAP_TYPE___ns1__modifySampleParameter:
		soap_serialize___ns1__modifySampleParameter(soap, (const struct __ns1__modifySampleParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__modifySampleParameterResponse:
		soap_serialize___ns1__modifySampleParameterResponse(soap, (const struct __ns1__modifySampleParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteSampleParameter:
		soap_serialize___ns1__deleteSampleParameter(soap, (const struct __ns1__deleteSampleParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteSampleParameterResponse:
		soap_serialize___ns1__deleteSampleParameterResponse(soap, (const struct __ns1__deleteSampleParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeSampleParameter:
		soap_serialize___ns1__removeSampleParameter(soap, (const struct __ns1__removeSampleParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__removeSampleParameterResponse:
		soap_serialize___ns1__removeSampleParameterResponse(soap, (const struct __ns1__removeSampleParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__modifySample:
		soap_serialize___ns1__modifySample(soap, (const struct __ns1__modifySample *)ptr);
		break;
	case SOAP_TYPE___ns1__modifySampleResponse:
		soap_serialize___ns1__modifySampleResponse(soap, (const struct __ns1__modifySampleResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteSample:
		soap_serialize___ns1__deleteSample(soap, (const struct __ns1__deleteSample *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteSampleResponse:
		soap_serialize___ns1__deleteSampleResponse(soap, (const struct __ns1__deleteSampleResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeSample:
		soap_serialize___ns1__removeSample(soap, (const struct __ns1__removeSample *)ptr);
		break;
	case SOAP_TYPE___ns1__removeSampleResponse:
		soap_serialize___ns1__removeSampleResponse(soap, (const struct __ns1__removeSampleResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigator:
		soap_serialize___ns1__deleteInvestigator(soap, (const struct __ns1__deleteInvestigator *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigatorResponse:
		soap_serialize___ns1__deleteInvestigatorResponse(soap, (const struct __ns1__deleteInvestigatorResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigator:
		soap_serialize___ns1__modifyInvestigator(soap, (const struct __ns1__modifyInvestigator *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigatorResponse:
		soap_serialize___ns1__modifyInvestigatorResponse(soap, (const struct __ns1__modifyInvestigatorResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigator:
		soap_serialize___ns1__removeInvestigator(soap, (const struct __ns1__removeInvestigator *)ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigatorResponse:
		soap_serialize___ns1__removeInvestigatorResponse(soap, (const struct __ns1__removeInvestigatorResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyPublication:
		soap_serialize___ns1__modifyPublication(soap, (const struct __ns1__modifyPublication *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyPublicationResponse:
		soap_serialize___ns1__modifyPublicationResponse(soap, (const struct __ns1__modifyPublicationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deletePublication:
		soap_serialize___ns1__deletePublication(soap, (const struct __ns1__deletePublication *)ptr);
		break;
	case SOAP_TYPE___ns1__deletePublicationResponse:
		soap_serialize___ns1__deletePublicationResponse(soap, (const struct __ns1__deletePublicationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removePublication:
		soap_serialize___ns1__removePublication(soap, (const struct __ns1__removePublication *)ptr);
		break;
	case SOAP_TYPE___ns1__removePublicationResponse:
		soap_serialize___ns1__removePublicationResponse(soap, (const struct __ns1__removePublicationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteKeyword:
		soap_serialize___ns1__deleteKeyword(soap, (const struct __ns1__deleteKeyword *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteKeywordResponse:
		soap_serialize___ns1__deleteKeywordResponse(soap, (const struct __ns1__deleteKeywordResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeKeyword:
		soap_serialize___ns1__removeKeyword(soap, (const struct __ns1__removeKeyword *)ptr);
		break;
	case SOAP_TYPE___ns1__removeKeywordResponse:
		soap_serialize___ns1__removeKeywordResponse(soap, (const struct __ns1__removeKeywordResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigation:
		soap_serialize___ns1__modifyInvestigation(soap, (const struct __ns1__modifyInvestigation *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigationResponse:
		soap_serialize___ns1__modifyInvestigationResponse(soap, (const struct __ns1__modifyInvestigationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigation:
		soap_serialize___ns1__deleteInvestigation(soap, (const struct __ns1__deleteInvestigation *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigationResponse:
		soap_serialize___ns1__deleteInvestigationResponse(soap, (const struct __ns1__deleteInvestigationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigation:
		soap_serialize___ns1__removeInvestigation(soap, (const struct __ns1__removeInvestigation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigationResponse:
		soap_serialize___ns1__removeInvestigationResponse(soap, (const struct __ns1__removeInvestigationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__createInvestigation:
		soap_serialize___ns1__createInvestigation(soap, (const struct __ns1__createInvestigation *)ptr);
		break;
	case SOAP_TYPE___ns1__getInvestigationsIncludes:
		soap_serialize___ns1__getInvestigationsIncludes(soap, (const struct __ns1__getInvestigationsIncludes *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAuthorisation:
		soap_serialize___ns1__updateAuthorisation(soap, (const struct __ns1__updateAuthorisation *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAuthorisationResponse:
		soap_serialize___ns1__updateAuthorisationResponse(soap, (const struct __ns1__updateAuthorisationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeAuthorisation:
		soap_serialize___ns1__removeAuthorisation(soap, (const struct __ns1__removeAuthorisation *)ptr);
		break;
	case SOAP_TYPE___ns1__removeAuthorisationResponse:
		soap_serialize___ns1__removeAuthorisationResponse(soap, (const struct __ns1__removeAuthorisationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteAuthorisation:
		soap_serialize___ns1__deleteAuthorisation(soap, (const struct __ns1__deleteAuthorisation *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteAuthorisationResponse:
		soap_serialize___ns1__deleteAuthorisationResponse(soap, (const struct __ns1__deleteAuthorisationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__addAuthorisation:
		soap_serialize___ns1__addAuthorisation(soap, (const struct __ns1__addAuthorisation *)ptr);
		break;
	case SOAP_TYPE___ns1__getAuthorisations:
		soap_serialize___ns1__getAuthorisations(soap, (const struct __ns1__getAuthorisations *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFileParameter:
		soap_serialize___ns1__deleteDataFileParameter(soap, (const struct __ns1__deleteDataFileParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFileParameterResponse:
		soap_serialize___ns1__deleteDataFileParameterResponse(soap, (const struct __ns1__deleteDataFileParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFileParameter:
		soap_serialize___ns1__removeDataFileParameter(soap, (const struct __ns1__removeDataFileParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFileParameterResponse:
		soap_serialize___ns1__removeDataFileParameterResponse(soap, (const struct __ns1__removeDataFileParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFileParameter:
		soap_serialize___ns1__modifyDataFileParameter(soap, (const struct __ns1__modifyDataFileParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFileParameterResponse:
		soap_serialize___ns1__modifyDataFileParameterResponse(soap, (const struct __ns1__modifyDataFileParameterResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__addDataFileParameters:
		soap_serialize___ns1__addDataFileParameters(soap, (const struct __ns1__addDataFileParameters *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFile:
		soap_serialize___ns1__modifyDataFile(soap, (const struct __ns1__modifyDataFile *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFileResponse:
		soap_serialize___ns1__modifyDataFileResponse(soap, (const struct __ns1__modifyDataFileResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFile:
		soap_serialize___ns1__removeDataFile(soap, (const struct __ns1__removeDataFile *)ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFileResponse:
		soap_serialize___ns1__removeDataFileResponse(soap, (const struct __ns1__removeDataFileResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFile:
		soap_serialize___ns1__deleteDataFile(soap, (const struct __ns1__deleteDataFile *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFileResponse:
		soap_serialize___ns1__deleteDataFileResponse(soap, (const struct __ns1__deleteDataFileResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__createDataFiles:
		soap_serialize___ns1__createDataFiles(soap, (const struct __ns1__createDataFiles *)ptr);
		break;
	case SOAP_TYPE___ns1__createDataFile:
		soap_serialize___ns1__createDataFile(soap, (const struct __ns1__createDataFile *)ptr);
		break;
	case SOAP_TYPE___ns1__getDatafiles:
		soap_serialize___ns1__getDatafiles(soap, (const struct __ns1__getDatafiles *)ptr);
		break;
	case SOAP_TYPE___ns1__ingestMetadata:
		soap_serialize___ns1__ingestMetadata(soap, (const struct __ns1__ingestMetadata *)ptr);
		break;
	case SOAP_TYPE___ns1__getUserDetails:
		soap_serialize___ns1__getUserDetails(soap, (const struct __ns1__getUserDetails *)ptr);
		break;
	case SOAP_TYPE___ns1__addDataFileParameter:
		soap_serialize___ns1__addDataFileParameter(soap, (const struct __ns1__addDataFileParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__getDatafile:
		soap_serialize___ns1__getDatafile(soap, (const struct __ns1__getDatafile *)ptr);
		break;
	case SOAP_TYPE___ns1__getDatasetIncludes:
		soap_serialize___ns1__getDatasetIncludes(soap, (const struct __ns1__getDatasetIncludes *)ptr);
		break;
	case SOAP_TYPE___ns1__getDataset:
		soap_serialize___ns1__getDataset(soap, (const struct __ns1__getDataset *)ptr);
		break;
	case SOAP_TYPE___ns1__getInvestigationIncludes:
		soap_serialize___ns1__getInvestigationIncludes(soap, (const struct __ns1__getInvestigationIncludes *)ptr);
		break;
	case SOAP_TYPE___ns1__getInvestigation:
		soap_serialize___ns1__getInvestigation(soap, (const struct __ns1__getInvestigation *)ptr);
		break;
	case SOAP_TYPE___ns1__addInvestigator:
		soap_serialize___ns1__addInvestigator(soap, (const struct __ns1__addInvestigator *)ptr);
		break;
	case SOAP_TYPE___ns1__addKeyword:
		soap_serialize___ns1__addKeyword(soap, (const struct __ns1__addKeyword *)ptr);
		break;
	case SOAP_TYPE___ns1__addPublication:
		soap_serialize___ns1__addPublication(soap, (const struct __ns1__addPublication *)ptr);
		break;
	case SOAP_TYPE___ns1__addSampleParameter:
		soap_serialize___ns1__addSampleParameter(soap, (const struct __ns1__addSampleParameter *)ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		soap_serialize___ns1__logout(soap, (const struct __ns1__logout *)ptr);
		break;
	case SOAP_TYPE___ns1__addSample:
		soap_serialize___ns1__addSample(soap, (const struct __ns1__addSample *)ptr);
		break;
	case SOAP_TYPE___ns1__loginLifetime:
		soap_serialize___ns1__loginLifetime(soap, (const struct __ns1__loginLifetime *)ptr);
		break;
	case SOAP_TYPE___ns1__login:
		soap_serialize___ns1__login(soap, (const struct __ns1__login *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getICATAPIVersionResponse:
		soap_serialize_PointerTons1__getICATAPIVersionResponse(soap, (ns1__getICATAPIVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getICATAPIVersion:
		soap_serialize_PointerTons1__getICATAPIVersion(soap, (ns1__getICATAPIVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listFacilityCyclesResponse:
		soap_serialize_PointerTons1__listFacilityCyclesResponse(soap, (ns1__listFacilityCyclesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listFacilityCycles:
		soap_serialize_PointerTons1__listFacilityCycles(soap, (ns1__listFacilityCycles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getFacilityUserByFederalIdResponse:
		soap_serialize_PointerTons1__getFacilityUserByFederalIdResponse(soap, (ns1__getFacilityUserByFederalIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getFacilityUserByFederalId:
		soap_serialize_PointerTons1__getFacilityUserByFederalId(soap, (ns1__getFacilityUserByFederalId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserIdResponse:
		soap_serialize_PointerTons1__getFacilityUserByFacilityUserIdResponse(soap, (ns1__getFacilityUserByFacilityUserIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserId:
		soap_serialize_PointerTons1__getFacilityUserByFacilityUserId(soap, (ns1__getFacilityUserByFacilityUserId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchDatasetsBySampleResponse:
		soap_serialize_PointerTons1__searchDatasetsBySampleResponse(soap, (ns1__searchDatasetsBySampleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchDatasetsBySample:
		soap_serialize_PointerTons1__searchDatasetsBySample(soap, (ns1__searchDatasetsBySample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkDatasetDownloadAccessResponse:
		soap_serialize_PointerTons1__checkDatasetDownloadAccessResponse(soap, (ns1__checkDatasetDownloadAccessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkDatasetDownloadAccess:
		soap_serialize_PointerTons1__checkDatasetDownloadAccess(soap, (ns1__checkDatasetDownloadAccess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkDatafileDownloadAccessResponse:
		soap_serialize_PointerTons1__checkDatafileDownloadAccessResponse(soap, (ns1__checkDatafileDownloadAccessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkDatafileDownloadAccess:
		soap_serialize_PointerTons1__checkDatafileDownloadAccess(soap, (ns1__checkDatafileDownloadAccess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadDatasetResponse:
		soap_serialize_PointerTons1__downloadDatasetResponse(soap, (ns1__downloadDatasetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadDataset:
		soap_serialize_PointerTons1__downloadDataset(soap, (ns1__downloadDataset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadDatafilesResponse:
		soap_serialize_PointerTons1__downloadDatafilesResponse(soap, (ns1__downloadDatafilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadDatafiles:
		soap_serialize_PointerTons1__downloadDatafiles(soap, (ns1__downloadDatafiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadDatafileResponse:
		soap_serialize_PointerTons1__downloadDatafileResponse(soap, (ns1__downloadDatafileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadDatafile:
		soap_serialize_PointerTons1__downloadDatafile(soap, (ns1__downloadDatafile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listParametersResponse:
		soap_serialize_PointerTons1__listParametersResponse(soap, (ns1__listParametersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listParameters:
		soap_serialize_PointerTons1__listParameters(soap, (ns1__listParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listInvestigationTypesResponse:
		soap_serialize_PointerTons1__listInvestigationTypesResponse(soap, (ns1__listInvestigationTypesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listInvestigationTypes:
		soap_serialize_PointerTons1__listInvestigationTypes(soap, (ns1__listInvestigationTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listRolesResponse:
		soap_serialize_PointerTons1__listRolesResponse(soap, (ns1__listRolesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listRoles:
		soap_serialize_PointerTons1__listRoles(soap, (ns1__listRoles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listInstrumentsResponse:
		soap_serialize_PointerTons1__listInstrumentsResponse(soap, (ns1__listInstrumentsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listInstruments:
		soap_serialize_PointerTons1__listInstruments(soap, (ns1__listInstruments *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserSurnamePaginationResponse:
		soap_serialize_PointerTons1__searchByUserSurnamePaginationResponse(soap, (ns1__searchByUserSurnamePaginationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserSurnamePagination:
		soap_serialize_PointerTons1__searchByUserSurnamePagination(soap, (ns1__searchByUserSurnamePagination *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserSurnameResponse:
		soap_serialize_PointerTons1__searchByUserSurnameResponse(soap, (ns1__searchByUserSurnameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserSurname:
		soap_serialize_PointerTons1__searchByUserSurname(soap, (ns1__searchByUserSurname *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserIDPaginationResponse:
		soap_serialize_PointerTons1__searchByUserIDPaginationResponse(soap, (ns1__searchByUserIDPaginationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserIDPagination:
		soap_serialize_PointerTons1__searchByUserIDPagination(soap, (ns1__searchByUserIDPagination *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserIDResponse:
		soap_serialize_PointerTons1__searchByUserIDResponse(soap, (ns1__searchByUserIDResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByUserID:
		soap_serialize_PointerTons1__searchByUserID(soap, (ns1__searchByUserID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPaginationResponse:
		soap_serialize_PointerTons1__getMyInvestigationsIncludesPaginationResponse(soap, (ns1__getMyInvestigationsIncludesPaginationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPagination:
		soap_serialize_PointerTons1__getMyInvestigationsIncludesPagination(soap, (ns1__getMyInvestigationsIncludesPagination *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesResponse:
		soap_serialize_PointerTons1__getMyInvestigationsIncludesResponse(soap, (ns1__getMyInvestigationsIncludesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyInvestigationsIncludes:
		soap_serialize_PointerTons1__getMyInvestigationsIncludes(soap, (ns1__getMyInvestigationsIncludes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyInvestigationsResponse:
		soap_serialize_PointerTons1__getMyInvestigationsResponse(soap, (ns1__getMyInvestigationsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyInvestigations:
		soap_serialize_PointerTons1__getMyInvestigations(soap, (ns1__getMyInvestigations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByKeywordsAllResponse:
		soap_serialize_PointerTons1__searchByKeywordsAllResponse(soap, (ns1__searchByKeywordsAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByKeywordsAll:
		soap_serialize_PointerTons1__searchByKeywordsAll(soap, (ns1__searchByKeywordsAll *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByKeywordsResponse:
		soap_serialize_PointerTons1__searchByKeywordsResponse(soap, (ns1__searchByKeywordsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByKeywords:
		soap_serialize_PointerTons1__searchByKeywords(soap, (ns1__searchByKeywords *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByAdvancedPaginationResponse:
		soap_serialize_PointerTons1__searchByAdvancedPaginationResponse(soap, (ns1__searchByAdvancedPaginationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByAdvancedPagination:
		soap_serialize_PointerTons1__searchByAdvancedPagination(soap, (ns1__searchByAdvancedPagination *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByAdvancedResponse:
		soap_serialize_PointerTons1__searchByAdvancedResponse(soap, (ns1__searchByAdvancedResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByAdvanced:
		soap_serialize_PointerTons1__searchByAdvanced(soap, (ns1__searchByAdvanced *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setDataSetSampleResponse:
		soap_serialize_PointerTons1__setDataSetSampleResponse(soap, (ns1__setDataSetSampleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setDataSetSample:
		soap_serialize_PointerTons1__setDataSetSample(soap, (ns1__setDataSetSample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataSetParameterResponse:
		soap_serialize_PointerTons1__deleteDataSetParameterResponse(soap, (ns1__deleteDataSetParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataSetParameter:
		soap_serialize_PointerTons1__deleteDataSetParameter(soap, (ns1__deleteDataSetParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataSetParameterResponse:
		soap_serialize_PointerTons1__removeDataSetParameterResponse(soap, (ns1__removeDataSetParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataSetParameter:
		soap_serialize_PointerTons1__removeDataSetParameter(soap, (ns1__removeDataSetParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataSetParameterResponse:
		soap_serialize_PointerTons1__modifyDataSetParameterResponse(soap, (ns1__modifyDataSetParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataSetParameter:
		soap_serialize_PointerTons1__modifyDataSetParameter(soap, (ns1__modifyDataSetParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataSetParametersResponse:
		soap_serialize_PointerTons1__addDataSetParametersResponse(soap, (ns1__addDataSetParametersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataSetParameters:
		soap_serialize_PointerTons1__addDataSetParameters(soap, (ns1__addDataSetParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataSetParameterResponse:
		soap_serialize_PointerTons1__addDataSetParameterResponse(soap, (ns1__addDataSetParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataSetParameter:
		soap_serialize_PointerTons1__addDataSetParameter(soap, (ns1__addDataSetParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataSetResponse:
		soap_serialize_PointerTons1__modifyDataSetResponse(soap, (ns1__modifyDataSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataSet:
		soap_serialize_PointerTons1__modifyDataSet(soap, (ns1__modifyDataSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataSetResponse:
		soap_serialize_PointerTons1__deleteDataSetResponse(soap, (ns1__deleteDataSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataSet:
		soap_serialize_PointerTons1__deleteDataSet(soap, (ns1__deleteDataSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataSetResponse:
		soap_serialize_PointerTons1__removeDataSetResponse(soap, (ns1__removeDataSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataSet:
		soap_serialize_PointerTons1__removeDataSet(soap, (ns1__removeDataSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataSetsResponse:
		soap_serialize_PointerTons1__createDataSetsResponse(soap, (ns1__createDataSetsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataSets:
		soap_serialize_PointerTons1__createDataSets(soap, (ns1__createDataSets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataSetResponse:
		soap_serialize_PointerTons1__createDataSetResponse(soap, (ns1__createDataSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataSet:
		soap_serialize_PointerTons1__createDataSet(soap, (ns1__createDataSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatasetsResponse:
		soap_serialize_PointerTons1__getDatasetsResponse(soap, (ns1__getDatasetsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatasets:
		soap_serialize_PointerTons1__getDatasets(soap, (ns1__getDatasets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listDatasetStatusResponse:
		soap_serialize_PointerTons1__listDatasetStatusResponse(soap, (ns1__listDatasetStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listDatasetStatus:
		soap_serialize_PointerTons1__listDatasetStatus(soap, (ns1__listDatasetStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listDatasetTypesResponse:
		soap_serialize_PointerTons1__listDatasetTypesResponse(soap, (ns1__listDatasetTypesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listDatasetTypes:
		soap_serialize_PointerTons1__listDatasetTypes(soap, (ns1__listDatasetTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchSamplesBySampleNameResponse:
		soap_serialize_PointerTons1__searchSamplesBySampleNameResponse(soap, (ns1__searchSamplesBySampleNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchSamplesBySampleName:
		soap_serialize_PointerTons1__searchSamplesBySampleName(soap, (ns1__searchSamplesBySampleName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listDatafileFormatsResponse:
		soap_serialize_PointerTons1__listDatafileFormatsResponse(soap, (ns1__listDatafileFormatsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listDatafileFormats:
		soap_serialize_PointerTons1__listDatafileFormats(soap, (ns1__listDatafileFormats *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByRunNumberPaginationResponse:
		soap_serialize_PointerTons1__searchByRunNumberPaginationResponse(soap, (ns1__searchByRunNumberPaginationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByRunNumberPagination:
		soap_serialize_PointerTons1__searchByRunNumberPagination(soap, (ns1__searchByRunNumberPagination *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByRunNumberResponse:
		soap_serialize_PointerTons1__searchByRunNumberResponse(soap, (ns1__searchByRunNumberResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchByRunNumber:
		soap_serialize_PointerTons1__searchByRunNumber(soap, (ns1__searchByRunNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAllKeywordsResponse:
		soap_serialize_PointerTons1__getAllKeywordsResponse(soap, (ns1__getAllKeywordsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAllKeywords:
		soap_serialize_PointerTons1__getAllKeywords(soap, (ns1__getAllKeywords *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUserTypeResponse:
		soap_serialize_PointerTons1__getKeywordsForUserTypeResponse(soap, (ns1__getKeywordsForUserTypeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUserType:
		soap_serialize_PointerTons1__getKeywordsForUserType(soap, (ns1__getKeywordsForUserType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUserMaxResponse:
		soap_serialize_PointerTons1__getKeywordsForUserMaxResponse(soap, (ns1__getKeywordsForUserMaxResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUserMax:
		soap_serialize_PointerTons1__getKeywordsForUserMax(soap, (ns1__getKeywordsForUserMax *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMaxResponse:
		soap_serialize_PointerTons1__getKeywordsForUserStartWithMaxResponse(soap, (ns1__getKeywordsForUserStartWithMaxResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMax:
		soap_serialize_PointerTons1__getKeywordsForUserStartWithMax(soap, (ns1__getKeywordsForUserStartWithMax *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUserResponse:
		soap_serialize_PointerTons1__getKeywordsForUserResponse(soap, (ns1__getKeywordsForUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getKeywordsForUser:
		soap_serialize_PointerTons1__getKeywordsForUser(soap, (ns1__getKeywordsForUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifySampleParameterResponse:
		soap_serialize_PointerTons1__modifySampleParameterResponse(soap, (ns1__modifySampleParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifySampleParameter:
		soap_serialize_PointerTons1__modifySampleParameter(soap, (ns1__modifySampleParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteSampleParameterResponse:
		soap_serialize_PointerTons1__deleteSampleParameterResponse(soap, (ns1__deleteSampleParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteSampleParameter:
		soap_serialize_PointerTons1__deleteSampleParameter(soap, (ns1__deleteSampleParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeSampleParameterResponse:
		soap_serialize_PointerTons1__removeSampleParameterResponse(soap, (ns1__removeSampleParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeSampleParameter:
		soap_serialize_PointerTons1__removeSampleParameter(soap, (ns1__removeSampleParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifySampleResponse:
		soap_serialize_PointerTons1__modifySampleResponse(soap, (ns1__modifySampleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifySample:
		soap_serialize_PointerTons1__modifySample(soap, (ns1__modifySample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteSampleResponse:
		soap_serialize_PointerTons1__deleteSampleResponse(soap, (ns1__deleteSampleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteSample:
		soap_serialize_PointerTons1__deleteSample(soap, (ns1__deleteSample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeSampleResponse:
		soap_serialize_PointerTons1__removeSampleResponse(soap, (ns1__removeSampleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeSample:
		soap_serialize_PointerTons1__removeSample(soap, (ns1__removeSample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteInvestigatorResponse:
		soap_serialize_PointerTons1__deleteInvestigatorResponse(soap, (ns1__deleteInvestigatorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteInvestigator:
		soap_serialize_PointerTons1__deleteInvestigator(soap, (ns1__deleteInvestigator *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyInvestigatorResponse:
		soap_serialize_PointerTons1__modifyInvestigatorResponse(soap, (ns1__modifyInvestigatorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyInvestigator:
		soap_serialize_PointerTons1__modifyInvestigator(soap, (ns1__modifyInvestigator *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeInvestigatorResponse:
		soap_serialize_PointerTons1__removeInvestigatorResponse(soap, (ns1__removeInvestigatorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeInvestigator:
		soap_serialize_PointerTons1__removeInvestigator(soap, (ns1__removeInvestigator *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyPublicationResponse:
		soap_serialize_PointerTons1__modifyPublicationResponse(soap, (ns1__modifyPublicationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyPublication:
		soap_serialize_PointerTons1__modifyPublication(soap, (ns1__modifyPublication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deletePublicationResponse:
		soap_serialize_PointerTons1__deletePublicationResponse(soap, (ns1__deletePublicationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deletePublication:
		soap_serialize_PointerTons1__deletePublication(soap, (ns1__deletePublication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removePublicationResponse:
		soap_serialize_PointerTons1__removePublicationResponse(soap, (ns1__removePublicationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removePublication:
		soap_serialize_PointerTons1__removePublication(soap, (ns1__removePublication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteKeywordResponse:
		soap_serialize_PointerTons1__deleteKeywordResponse(soap, (ns1__deleteKeywordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteKeyword:
		soap_serialize_PointerTons1__deleteKeyword(soap, (ns1__deleteKeyword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeKeywordResponse:
		soap_serialize_PointerTons1__removeKeywordResponse(soap, (ns1__removeKeywordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeKeyword:
		soap_serialize_PointerTons1__removeKeyword(soap, (ns1__removeKeyword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyInvestigationResponse:
		soap_serialize_PointerTons1__modifyInvestigationResponse(soap, (ns1__modifyInvestigationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyInvestigation:
		soap_serialize_PointerTons1__modifyInvestigation(soap, (ns1__modifyInvestigation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteInvestigationResponse:
		soap_serialize_PointerTons1__deleteInvestigationResponse(soap, (ns1__deleteInvestigationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteInvestigation:
		soap_serialize_PointerTons1__deleteInvestigation(soap, (ns1__deleteInvestigation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeInvestigationResponse:
		soap_serialize_PointerTons1__removeInvestigationResponse(soap, (ns1__removeInvestigationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeInvestigation:
		soap_serialize_PointerTons1__removeInvestigation(soap, (ns1__removeInvestigation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createInvestigationResponse:
		soap_serialize_PointerTons1__createInvestigationResponse(soap, (ns1__createInvestigationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createInvestigation:
		soap_serialize_PointerTons1__createInvestigation(soap, (ns1__createInvestigation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getInvestigationsIncludesResponse:
		soap_serialize_PointerTons1__getInvestigationsIncludesResponse(soap, (ns1__getInvestigationsIncludesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getInvestigationsIncludes:
		soap_serialize_PointerTons1__getInvestigationsIncludes(soap, (ns1__getInvestigationsIncludes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateAuthorisationResponse:
		soap_serialize_PointerTons1__updateAuthorisationResponse(soap, (ns1__updateAuthorisationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateAuthorisation:
		soap_serialize_PointerTons1__updateAuthorisation(soap, (ns1__updateAuthorisation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeAuthorisationResponse:
		soap_serialize_PointerTons1__removeAuthorisationResponse(soap, (ns1__removeAuthorisationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeAuthorisation:
		soap_serialize_PointerTons1__removeAuthorisation(soap, (ns1__removeAuthorisation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteAuthorisationResponse:
		soap_serialize_PointerTons1__deleteAuthorisationResponse(soap, (ns1__deleteAuthorisationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteAuthorisation:
		soap_serialize_PointerTons1__deleteAuthorisation(soap, (ns1__deleteAuthorisation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addAuthorisationResponse:
		soap_serialize_PointerTons1__addAuthorisationResponse(soap, (ns1__addAuthorisationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addAuthorisation:
		soap_serialize_PointerTons1__addAuthorisation(soap, (ns1__addAuthorisation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAuthorisationsResponse:
		soap_serialize_PointerTons1__getAuthorisationsResponse(soap, (ns1__getAuthorisationsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAuthorisations:
		soap_serialize_PointerTons1__getAuthorisations(soap, (ns1__getAuthorisations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataFileParameterResponse:
		soap_serialize_PointerTons1__deleteDataFileParameterResponse(soap, (ns1__deleteDataFileParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataFileParameter:
		soap_serialize_PointerTons1__deleteDataFileParameter(soap, (ns1__deleteDataFileParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataFileParameterResponse:
		soap_serialize_PointerTons1__removeDataFileParameterResponse(soap, (ns1__removeDataFileParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataFileParameter:
		soap_serialize_PointerTons1__removeDataFileParameter(soap, (ns1__removeDataFileParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataFileParameterResponse:
		soap_serialize_PointerTons1__modifyDataFileParameterResponse(soap, (ns1__modifyDataFileParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataFileParameter:
		soap_serialize_PointerTons1__modifyDataFileParameter(soap, (ns1__modifyDataFileParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataFileParametersResponse:
		soap_serialize_PointerTons1__addDataFileParametersResponse(soap, (ns1__addDataFileParametersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataFileParameters:
		soap_serialize_PointerTons1__addDataFileParameters(soap, (ns1__addDataFileParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataFileResponse:
		soap_serialize_PointerTons1__modifyDataFileResponse(soap, (ns1__modifyDataFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyDataFile:
		soap_serialize_PointerTons1__modifyDataFile(soap, (ns1__modifyDataFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataFileResponse:
		soap_serialize_PointerTons1__removeDataFileResponse(soap, (ns1__removeDataFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeDataFile:
		soap_serialize_PointerTons1__removeDataFile(soap, (ns1__removeDataFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataFileResponse:
		soap_serialize_PointerTons1__deleteDataFileResponse(soap, (ns1__deleteDataFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDataFile:
		soap_serialize_PointerTons1__deleteDataFile(soap, (ns1__deleteDataFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataFilesResponse:
		soap_serialize_PointerTons1__createDataFilesResponse(soap, (ns1__createDataFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataFiles:
		soap_serialize_PointerTons1__createDataFiles(soap, (ns1__createDataFiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataFileResponse:
		soap_serialize_PointerTons1__createDataFileResponse(soap, (ns1__createDataFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDataFile:
		soap_serialize_PointerTons1__createDataFile(soap, (ns1__createDataFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatafilesResponse:
		soap_serialize_PointerTons1__getDatafilesResponse(soap, (ns1__getDatafilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatafiles:
		soap_serialize_PointerTons1__getDatafiles(soap, (ns1__getDatafiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ingestMetadataResponse:
		soap_serialize_PointerTons1__ingestMetadataResponse(soap, (ns1__ingestMetadataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ingestMetadata:
		soap_serialize_PointerTons1__ingestMetadata(soap, (ns1__ingestMetadata *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getUserDetailsResponse:
		soap_serialize_PointerTons1__getUserDetailsResponse(soap, (ns1__getUserDetailsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getUserDetails:
		soap_serialize_PointerTons1__getUserDetails(soap, (ns1__getUserDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataFileParameterResponse:
		soap_serialize_PointerTons1__addDataFileParameterResponse(soap, (ns1__addDataFileParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addDataFileParameter:
		soap_serialize_PointerTons1__addDataFileParameter(soap, (ns1__addDataFileParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatafileResponse:
		soap_serialize_PointerTons1__getDatafileResponse(soap, (ns1__getDatafileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatafile:
		soap_serialize_PointerTons1__getDatafile(soap, (ns1__getDatafile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatasetIncludesResponse:
		soap_serialize_PointerTons1__getDatasetIncludesResponse(soap, (ns1__getDatasetIncludesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatasetIncludes:
		soap_serialize_PointerTons1__getDatasetIncludes(soap, (ns1__getDatasetIncludes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDatasetResponse:
		soap_serialize_PointerTons1__getDatasetResponse(soap, (ns1__getDatasetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDataset:
		soap_serialize_PointerTons1__getDataset(soap, (ns1__getDataset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getInvestigationIncludesResponse:
		soap_serialize_PointerTons1__getInvestigationIncludesResponse(soap, (ns1__getInvestigationIncludesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getInvestigationIncludes:
		soap_serialize_PointerTons1__getInvestigationIncludes(soap, (ns1__getInvestigationIncludes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getInvestigationResponse:
		soap_serialize_PointerTons1__getInvestigationResponse(soap, (ns1__getInvestigationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getInvestigation:
		soap_serialize_PointerTons1__getInvestigation(soap, (ns1__getInvestigation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addInvestigatorResponse:
		soap_serialize_PointerTons1__addInvestigatorResponse(soap, (ns1__addInvestigatorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addInvestigator:
		soap_serialize_PointerTons1__addInvestigator(soap, (ns1__addInvestigator *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addKeywordResponse:
		soap_serialize_PointerTons1__addKeywordResponse(soap, (ns1__addKeywordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addKeyword:
		soap_serialize_PointerTons1__addKeyword(soap, (ns1__addKeyword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addPublicationResponse:
		soap_serialize_PointerTons1__addPublicationResponse(soap, (ns1__addPublicationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addPublication:
		soap_serialize_PointerTons1__addPublication(soap, (ns1__addPublication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addSampleParameterResponse:
		soap_serialize_PointerTons1__addSampleParameterResponse(soap, (ns1__addSampleParameterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addSampleParameter:
		soap_serialize_PointerTons1__addSampleParameter(soap, (ns1__addSampleParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logoutResponse:
		soap_serialize_PointerTons1__logoutResponse(soap, (ns1__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logout:
		soap_serialize_PointerTons1__logout(soap, (ns1__logout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addSampleResponse:
		soap_serialize_PointerTons1__addSampleResponse(soap, (ns1__addSampleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addSample:
		soap_serialize_PointerTons1__addSample(soap, (ns1__addSample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loginLifetimeResponse:
		soap_serialize_PointerTons1__loginLifetimeResponse(soap, (ns1__loginLifetimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loginLifetime:
		soap_serialize_PointerTons1__loginLifetime(soap, (ns1__loginLifetime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loginResponse:
		soap_serialize_PointerTons1__loginResponse(soap, (ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__login:
		soap_serialize_PointerTons1__login(soap, (ns1__login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValidationException:
		soap_serialize_PointerTons1__ValidationException(soap, (ns1__ValidationException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__SessionException:
		soap_serialize_PointerTons3__SessionException(soap, (ns3__SessionException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NoSuchUserException:
		soap_serialize_PointerTons1__NoSuchUserException(soap, (ns1__NoSuchUserException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NoSuchObjectFoundException:
		soap_serialize_PointerTons1__NoSuchObjectFoundException(soap, (ns1__NoSuchObjectFoundException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InsufficientPrivilegesException:
		soap_serialize_PointerTons1__InsufficientPrivilegesException(soap, (ns1__InsufficientPrivilegesException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ICATAPIException:
		soap_serialize_PointerTons1__ICATAPIException(soap, (ns1__ICATAPIException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__shiftPK:
		soap_serialize_PointerTons1__shiftPK(soap, (ns1__shiftPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__shift:
		soap_serialize_PointerTons1__shift(soap, (ns1__shift *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__parameterPK:
		soap_serialize_PointerTons1__parameterPK(soap, (ns1__parameterPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__relatedDatafilesPK:
		soap_serialize_PointerTons1__relatedDatafilesPK(soap, (ns1__relatedDatafilesPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datafileFormatPK:
		soap_serialize_PointerTons1__datafileFormatPK(soap, (ns1__datafileFormatPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__relatedDatafiles:
		soap_serialize_PointerTons1__relatedDatafiles(soap, (ns1__relatedDatafiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datafileInclude:
		soap_serialize_PointerTons1__datafileInclude(soap, (enum ns1__datafileInclude *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__parameter:
		soap_serialize_PointerTons1__parameter(soap, (ns1__parameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datasetInclude:
		soap_serialize_PointerTons1__datasetInclude(soap, (enum ns1__datasetInclude *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datafileFormat:
		soap_serialize_PointerTons1__datafileFormat(soap, (ns1__datafileFormat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__advancedSearchDetails:
		soap_serialize_PointerTons1__advancedSearchDetails(soap, (ns1__advancedSearchDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__keyword:
		soap_serialize_PointerTons1__keyword(soap, (ns1__keyword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__icatAuthorisation:
		soap_serialize_PointerTons1__icatAuthorisation(soap, (ns1__icatAuthorisation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__elementType:
		soap_serialize_PointerTons1__elementType(soap, (enum ns1__elementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datasetParameter:
		soap_serialize_PointerTons1__datasetParameter(soap, (ns1__datasetParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sampleParameterPK:
		soap_serialize_PointerTons1__sampleParameterPK(soap, (ns1__sampleParameterPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__investigator:
		soap_serialize_PointerTons1__investigator(soap, (ns1__investigator *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datafileParameterPK:
		soap_serialize_PointerTons1__datafileParameterPK(soap, (ns1__datafileParameterPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__publication:
		soap_serialize_PointerTons1__publication(soap, (ns1__publication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datasetParameterPK:
		soap_serialize_PointerTons1__datasetParameterPK(soap, (ns1__datasetParameterPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__investigationInclude:
		soap_serialize_PointerTons1__investigationInclude(soap, (enum ns1__investigationInclude *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__keywordDetails:
		soap_serialize_PointerTons1__keywordDetails(soap, (ns1__keywordDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__investigation:
		soap_serialize_PointerTons1__investigation(soap, (ns1__investigation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadInfo:
		soap_serialize_PointerTons1__downloadInfo(soap, (ns1__downloadInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sampleParameter:
		soap_serialize_PointerTons1__sampleParameter(soap, (ns1__sampleParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__userDetails:
		soap_serialize_PointerTons1__userDetails(soap, (ns1__userDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__keywordType:
		soap_serialize_PointerTons1__keywordType(soap, (enum ns1__keywordType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__dataset:
		soap_serialize_PointerTons1__dataset(soap, (ns1__dataset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__keywordPK:
		soap_serialize_PointerTons1__keywordPK(soap, (ns1__keywordPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__investigatorPK:
		soap_serialize_PointerTons1__investigatorPK(soap, (ns1__investigatorPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__facilityUser:
		soap_serialize_PointerTons1__facilityUser(soap, (ns1__facilityUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__facilityCycle:
		soap_serialize_PointerTons1__facilityCycle(soap, (ns1__facilityCycle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datafileParameter:
		soap_serialize_PointerTons1__datafileParameter(soap, (ns1__datafileParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__datafile:
		soap_serialize_PointerTons1__datafile(soap, (ns1__datafile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__icatRole:
		soap_serialize_PointerTons1__icatRole(soap, (ns1__icatRole *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sample:
		soap_serialize_PointerTons1__sample(soap, (ns1__sample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float:
		return (void*)soap_instantiate_xsd__float(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datafileInclude_:
		return (void*)soap_instantiate_ns1__datafileInclude_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__keywordType_:
		return (void*)soap_instantiate_ns1__keywordType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__investigationInclude_:
		return (void*)soap_instantiate_ns1__investigationInclude_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__elementType_:
		return (void*)soap_instantiate_ns1__elementType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datasetInclude_:
		return (void*)soap_instantiate_ns1__datasetInclude_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listDatasetTypes:
		return (void*)soap_instantiate_ns1__listDatasetTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listDatasetTypesResponse:
		return (void*)soap_instantiate_ns1__listDatasetTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchSamplesBySampleName:
		return (void*)soap_instantiate_ns1__searchSamplesBySampleName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchSamplesBySampleNameResponse:
		return (void*)soap_instantiate_ns1__searchSamplesBySampleNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__entityBaseBean:
		return (void*)soap_instantiate_ns1__entityBaseBean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__entityPrimaryKeyBaseBean:
		return (void*)soap_instantiate_ns1__entityPrimaryKeyBaseBean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeSample:
		return (void*)soap_instantiate_ns1__removeSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeSampleResponse:
		return (void*)soap_instantiate_ns1__removeSampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsufficientPrivilegesException:
		return (void*)soap_instantiate_ns1__InsufficientPrivilegesException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NoSuchObjectFoundException:
		return (void*)soap_instantiate_ns1__NoSuchObjectFoundException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listInstruments:
		return (void*)soap_instantiate_ns1__listInstruments(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listInstrumentsResponse:
		return (void*)soap_instantiate_ns1__listInstrumentsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataFile:
		return (void*)soap_instantiate_ns1__createDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataFileResponse:
		return (void*)soap_instantiate_ns1__createDataFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValidationException:
		return (void*)soap_instantiate_ns1__ValidationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifySample:
		return (void*)soap_instantiate_ns1__modifySample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifySampleResponse:
		return (void*)soap_instantiate_ns1__modifySampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataFile:
		return (void*)soap_instantiate_ns1__removeDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataFileResponse:
		return (void*)soap_instantiate_ns1__removeDataFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeAuthorisation:
		return (void*)soap_instantiate_ns1__removeAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeAuthorisationResponse:
		return (void*)soap_instantiate_ns1__removeAuthorisationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataFileParameters:
		return (void*)soap_instantiate_ns1__addDataFileParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataFileParametersResponse:
		return (void*)soap_instantiate_ns1__addDataFileParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listFacilityCycles:
		return (void*)soap_instantiate_ns1__listFacilityCycles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listFacilityCyclesResponse:
		return (void*)soap_instantiate_ns1__listFacilityCyclesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logout:
		return (void*)soap_instantiate_ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logoutResponse:
		return (void*)soap_instantiate_ns1__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadDataset:
		return (void*)soap_instantiate_ns1__downloadDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadDatasetResponse:
		return (void*)soap_instantiate_ns1__downloadDatasetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFacilityUserByFederalId:
		return (void*)soap_instantiate_ns1__getFacilityUserByFederalId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse:
		return (void*)soap_instantiate_ns1__getFacilityUserByFederalIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeInvestigator:
		return (void*)soap_instantiate_ns1__removeInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeInvestigatorResponse:
		return (void*)soap_instantiate_ns1__removeInvestigatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeInvestigation:
		return (void*)soap_instantiate_ns1__removeInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeInvestigationResponse:
		return (void*)soap_instantiate_ns1__removeInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeKeyword:
		return (void*)soap_instantiate_ns1__removeKeyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeKeywordResponse:
		return (void*)soap_instantiate_ns1__removeKeywordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteInvestigation:
		return (void*)soap_instantiate_ns1__deleteInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteInvestigationResponse:
		return (void*)soap_instantiate_ns1__deleteInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataSets:
		return (void*)soap_instantiate_ns1__createDataSets(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataSetsResponse:
		return (void*)soap_instantiate_ns1__createDataSetsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removePublication:
		return (void*)soap_instantiate_ns1__removePublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removePublicationResponse:
		return (void*)soap_instantiate_ns1__removePublicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllKeywords:
		return (void*)soap_instantiate_ns1__getAllKeywords(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllKeywordsResponse:
		return (void*)soap_instantiate_ns1__getAllKeywordsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetails:
		return (void*)soap_instantiate_ns1__getUserDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		return (void*)soap_instantiate_ns1__getUserDetailsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__userDetails:
		return (void*)soap_instantiate_ns1__userDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NoSuchUserException:
		return (void*)soap_instantiate_ns1__NoSuchUserException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadDatafiles:
		return (void*)soap_instantiate_ns1__downloadDatafiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadDatafilesResponse:
		return (void*)soap_instantiate_ns1__downloadDatafilesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataSet:
		return (void*)soap_instantiate_ns1__modifyDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataSetResponse:
		return (void*)soap_instantiate_ns1__modifyDataSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addSampleParameter:
		return (void*)soap_instantiate_ns1__addSampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addSampleParameterResponse:
		return (void*)soap_instantiate_ns1__addSampleParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserId:
		return (void*)soap_instantiate_ns1__getFacilityUserByFacilityUserId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse:
		return (void*)soap_instantiate_ns1__getFacilityUserByFacilityUserIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkDatafileDownloadAccess:
		return (void*)soap_instantiate_ns1__checkDatafileDownloadAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse:
		return (void*)soap_instantiate_ns1__checkDatafileDownloadAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadInfo:
		return (void*)soap_instantiate_ns1__downloadInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataFile:
		return (void*)soap_instantiate_ns1__deleteDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataFileResponse:
		return (void*)soap_instantiate_ns1__deleteDataFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserSurname:
		return (void*)soap_instantiate_ns1__searchByUserSurname(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserSurnameResponse:
		return (void*)soap_instantiate_ns1__searchByUserSurnameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserSurnamePagination:
		return (void*)soap_instantiate_ns1__searchByUserSurnamePagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse:
		return (void*)soap_instantiate_ns1__searchByUserSurnamePaginationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkDatasetDownloadAccess:
		return (void*)soap_instantiate_ns1__checkDatasetDownloadAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse:
		return (void*)soap_instantiate_ns1__checkDatasetDownloadAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByKeywords:
		return (void*)soap_instantiate_ns1__searchByKeywords(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByKeywordsResponse:
		return (void*)soap_instantiate_ns1__searchByKeywordsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByKeywordsAll:
		return (void*)soap_instantiate_ns1__searchByKeywordsAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__keywordDetails:
		return (void*)soap_instantiate_ns1__keywordDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByKeywordsAllResponse:
		return (void*)soap_instantiate_ns1__searchByKeywordsAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyInvestigations:
		return (void*)soap_instantiate_ns1__getMyInvestigations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyInvestigationsResponse:
		return (void*)soap_instantiate_ns1__getMyInvestigationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyInvestigationsIncludes:
		return (void*)soap_instantiate_ns1__getMyInvestigationsIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse:
		return (void*)soap_instantiate_ns1__getMyInvestigationsIncludesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination:
		return (void*)soap_instantiate_ns1__getMyInvestigationsIncludesPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse:
		return (void*)soap_instantiate_ns1__getMyInvestigationsIncludesPaginationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataSetParameter:
		return (void*)soap_instantiate_ns1__removeDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataSetParameterResponse:
		return (void*)soap_instantiate_ns1__removeDataSetParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyPublication:
		return (void*)soap_instantiate_ns1__modifyPublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyPublicationResponse:
		return (void*)soap_instantiate_ns1__modifyPublicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserID:
		return (void*)soap_instantiate_ns1__searchByUserID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserIDResponse:
		return (void*)soap_instantiate_ns1__searchByUserIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserIDPagination:
		return (void*)soap_instantiate_ns1__searchByUserIDPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByUserIDPaginationResponse:
		return (void*)soap_instantiate_ns1__searchByUserIDPaginationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataFileParameter:
		return (void*)soap_instantiate_ns1__removeDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataFileParameterResponse:
		return (void*)soap_instantiate_ns1__removeDataFileParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getInvestigationsIncludes:
		return (void*)soap_instantiate_ns1__getInvestigationsIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getInvestigationsIncludesResponse:
		return (void*)soap_instantiate_ns1__getInvestigationsIncludesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataSet:
		return (void*)soap_instantiate_ns1__deleteDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataSetResponse:
		return (void*)soap_instantiate_ns1__deleteDataSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatafiles:
		return (void*)soap_instantiate_ns1__getDatafiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatafilesResponse:
		return (void*)soap_instantiate_ns1__getDatafilesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getICATAPIVersion:
		return (void*)soap_instantiate_ns1__getICATAPIVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getICATAPIVersionResponse:
		return (void*)soap_instantiate_ns1__getICATAPIVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteInvestigator:
		return (void*)soap_instantiate_ns1__deleteInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteInvestigatorResponse:
		return (void*)soap_instantiate_ns1__deleteInvestigatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addInvestigator:
		return (void*)soap_instantiate_ns1__addInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addInvestigatorResponse:
		return (void*)soap_instantiate_ns1__addInvestigatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataSet:
		return (void*)soap_instantiate_ns1__createDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataSetResponse:
		return (void*)soap_instantiate_ns1__createDataSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeSampleParameter:
		return (void*)soap_instantiate_ns1__removeSampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeSampleParameterResponse:
		return (void*)soap_instantiate_ns1__removeSampleParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataSetParameter:
		return (void*)soap_instantiate_ns1__deleteDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataSetParameterResponse:
		return (void*)soap_instantiate_ns1__deleteDataSetParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setDataSetSample:
		return (void*)soap_instantiate_ns1__setDataSetSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setDataSetSampleResponse:
		return (void*)soap_instantiate_ns1__setDataSetSampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadDatafile:
		return (void*)soap_instantiate_ns1__downloadDatafile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadDatafileResponse:
		return (void*)soap_instantiate_ns1__downloadDatafileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUser:
		return (void*)soap_instantiate_ns1__getKeywordsForUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUserResponse:
		return (void*)soap_instantiate_ns1__getKeywordsForUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMax:
		return (void*)soap_instantiate_ns1__getKeywordsForUserStartWithMax(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse:
		return (void*)soap_instantiate_ns1__getKeywordsForUserStartWithMaxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUserMax:
		return (void*)soap_instantiate_ns1__getKeywordsForUserMax(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUserMaxResponse:
		return (void*)soap_instantiate_ns1__getKeywordsForUserMaxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUserType:
		return (void*)soap_instantiate_ns1__getKeywordsForUserType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getKeywordsForUserTypeResponse:
		return (void*)soap_instantiate_ns1__getKeywordsForUserTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listInvestigationTypes:
		return (void*)soap_instantiate_ns1__listInvestigationTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listInvestigationTypesResponse:
		return (void*)soap_instantiate_ns1__listInvestigationTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataSetParameter:
		return (void*)soap_instantiate_ns1__modifyDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataSetParameterResponse:
		return (void*)soap_instantiate_ns1__modifyDataSetParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataSet:
		return (void*)soap_instantiate_ns1__removeDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeDataSetResponse:
		return (void*)soap_instantiate_ns1__removeDataSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAuthorisations:
		return (void*)soap_instantiate_ns1__getAuthorisations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAuthorisationsResponse:
		return (void*)soap_instantiate_ns1__getAuthorisationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addKeyword:
		return (void*)soap_instantiate_ns1__addKeyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addKeywordResponse:
		return (void*)soap_instantiate_ns1__addKeywordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyInvestigation:
		return (void*)soap_instantiate_ns1__modifyInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyInvestigationResponse:
		return (void*)soap_instantiate_ns1__modifyInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listDatasetStatus:
		return (void*)soap_instantiate_ns1__listDatasetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listDatasetStatusResponse:
		return (void*)soap_instantiate_ns1__listDatasetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteSample:
		return (void*)soap_instantiate_ns1__deleteSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteSampleResponse:
		return (void*)soap_instantiate_ns1__deleteSampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteKeyword:
		return (void*)soap_instantiate_ns1__deleteKeyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteKeywordResponse:
		return (void*)soap_instantiate_ns1__deleteKeywordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataSetParameters:
		return (void*)soap_instantiate_ns1__addDataSetParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataSetParametersResponse:
		return (void*)soap_instantiate_ns1__addDataSetParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByRunNumber:
		return (void*)soap_instantiate_ns1__searchByRunNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByRunNumberResponse:
		return (void*)soap_instantiate_ns1__searchByRunNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByRunNumberPagination:
		return (void*)soap_instantiate_ns1__searchByRunNumberPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByRunNumberPaginationResponse:
		return (void*)soap_instantiate_ns1__searchByRunNumberPaginationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByAdvanced:
		return (void*)soap_instantiate_ns1__searchByAdvanced(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__advancedSearchDetails:
		return (void*)soap_instantiate_ns1__advancedSearchDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByAdvancedResponse:
		return (void*)soap_instantiate_ns1__searchByAdvancedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByAdvancedPagination:
		return (void*)soap_instantiate_ns1__searchByAdvancedPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchByAdvancedPaginationResponse:
		return (void*)soap_instantiate_ns1__searchByAdvancedPaginationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listDatafileFormats:
		return (void*)soap_instantiate_ns1__listDatafileFormats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listDatafileFormatsResponse:
		return (void*)soap_instantiate_ns1__listDatafileFormatsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifySampleParameter:
		return (void*)soap_instantiate_ns1__modifySampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifySampleParameterResponse:
		return (void*)soap_instantiate_ns1__modifySampleParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyInvestigator:
		return (void*)soap_instantiate_ns1__modifyInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyInvestigatorResponse:
		return (void*)soap_instantiate_ns1__modifyInvestigatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataFiles:
		return (void*)soap_instantiate_ns1__createDataFiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDataFilesResponse:
		return (void*)soap_instantiate_ns1__createDataFilesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataSetParameter:
		return (void*)soap_instantiate_ns1__addDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataSetParameterResponse:
		return (void*)soap_instantiate_ns1__addDataSetParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addAuthorisation:
		return (void*)soap_instantiate_ns1__addAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addAuthorisationResponse:
		return (void*)soap_instantiate_ns1__addAuthorisationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addSample:
		return (void*)soap_instantiate_ns1__addSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addSampleResponse:
		return (void*)soap_instantiate_ns1__addSampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deletePublication:
		return (void*)soap_instantiate_ns1__deletePublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deletePublicationResponse:
		return (void*)soap_instantiate_ns1__deletePublicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loginLifetime:
		return (void*)soap_instantiate_ns1__loginLifetime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loginLifetimeResponse:
		return (void*)soap_instantiate_ns1__loginLifetimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__login:
		return (void*)soap_instantiate_ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loginResponse:
		return (void*)soap_instantiate_ns1__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteAuthorisation:
		return (void*)soap_instantiate_ns1__deleteAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteAuthorisationResponse:
		return (void*)soap_instantiate_ns1__deleteAuthorisationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateAuthorisation:
		return (void*)soap_instantiate_ns1__updateAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateAuthorisationResponse:
		return (void*)soap_instantiate_ns1__updateAuthorisationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatasetIncludes:
		return (void*)soap_instantiate_ns1__getDatasetIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatasetIncludesResponse:
		return (void*)soap_instantiate_ns1__getDatasetIncludesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDataset:
		return (void*)soap_instantiate_ns1__getDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatasetResponse:
		return (void*)soap_instantiate_ns1__getDatasetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listRoles:
		return (void*)soap_instantiate_ns1__listRoles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listRolesResponse:
		return (void*)soap_instantiate_ns1__listRolesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ingestMetadata:
		return (void*)soap_instantiate_ns1__ingestMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ingestMetadataResponse:
		return (void*)soap_instantiate_ns1__ingestMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ICATAPIException:
		return (void*)soap_instantiate_ns1__ICATAPIException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatafile:
		return (void*)soap_instantiate_ns1__getDatafile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatafileResponse:
		return (void*)soap_instantiate_ns1__getDatafileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataFile:
		return (void*)soap_instantiate_ns1__modifyDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataFileResponse:
		return (void*)soap_instantiate_ns1__modifyDataFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getInvestigationIncludes:
		return (void*)soap_instantiate_ns1__getInvestigationIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getInvestigationIncludesResponse:
		return (void*)soap_instantiate_ns1__getInvestigationIncludesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getInvestigation:
		return (void*)soap_instantiate_ns1__getInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getInvestigationResponse:
		return (void*)soap_instantiate_ns1__getInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataFileParameter:
		return (void*)soap_instantiate_ns1__deleteDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDataFileParameterResponse:
		return (void*)soap_instantiate_ns1__deleteDataFileParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createInvestigation:
		return (void*)soap_instantiate_ns1__createInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createInvestigationResponse:
		return (void*)soap_instantiate_ns1__createInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addPublication:
		return (void*)soap_instantiate_ns1__addPublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addPublicationResponse:
		return (void*)soap_instantiate_ns1__addPublicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchDatasetsBySample:
		return (void*)soap_instantiate_ns1__searchDatasetsBySample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchDatasetsBySampleResponse:
		return (void*)soap_instantiate_ns1__searchDatasetsBySampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataFileParameter:
		return (void*)soap_instantiate_ns1__addDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDataFileParameterResponse:
		return (void*)soap_instantiate_ns1__addDataFileParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteSampleParameter:
		return (void*)soap_instantiate_ns1__deleteSampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteSampleParameterResponse:
		return (void*)soap_instantiate_ns1__deleteSampleParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataFileParameter:
		return (void*)soap_instantiate_ns1__modifyDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__modifyDataFileParameterResponse:
		return (void*)soap_instantiate_ns1__modifyDataFileParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listParameters:
		return (void*)soap_instantiate_ns1__listParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listParametersResponse:
		return (void*)soap_instantiate_ns1__listParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatasets:
		return (void*)soap_instantiate_ns1__getDatasets(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatasetsResponse:
		return (void*)soap_instantiate_ns1__getDatasetsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__SessionException:
		return (void*)soap_instantiate_ns3__SessionException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sample:
		return (void*)soap_instantiate_ns1__sample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sampleParameter:
		return (void*)soap_instantiate_ns1__sampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sampleParameterPK:
		return (void*)soap_instantiate_ns1__sampleParameterPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__icatRole:
		return (void*)soap_instantiate_ns1__icatRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datafile:
		return (void*)soap_instantiate_ns1__datafile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datafileFormat:
		return (void*)soap_instantiate_ns1__datafileFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datafileFormatPK:
		return (void*)soap_instantiate_ns1__datafileFormatPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datafileParameter:
		return (void*)soap_instantiate_ns1__datafileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datafileParameterPK:
		return (void*)soap_instantiate_ns1__datafileParameterPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__relatedDatafiles:
		return (void*)soap_instantiate_ns1__relatedDatafiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__relatedDatafilesPK:
		return (void*)soap_instantiate_ns1__relatedDatafilesPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__facilityCycle:
		return (void*)soap_instantiate_ns1__facilityCycle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__facilityUser:
		return (void*)soap_instantiate_ns1__facilityUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__investigatorPK:
		return (void*)soap_instantiate_ns1__investigatorPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__keywordPK:
		return (void*)soap_instantiate_ns1__keywordPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__dataset:
		return (void*)soap_instantiate_ns1__dataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datasetParameter:
		return (void*)soap_instantiate_ns1__datasetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__datasetParameterPK:
		return (void*)soap_instantiate_ns1__datasetParameterPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__parameter:
		return (void*)soap_instantiate_ns1__parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__parameterPK:
		return (void*)soap_instantiate_ns1__parameterPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__investigation:
		return (void*)soap_instantiate_ns1__investigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__investigator:
		return (void*)soap_instantiate_ns1__investigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__keyword:
		return (void*)soap_instantiate_ns1__keyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__publication:
		return (void*)soap_instantiate_ns1__publication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__shift:
		return (void*)soap_instantiate_ns1__shift(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__shiftPK:
		return (void*)soap_instantiate_ns1__shiftPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__icatAuthorisation:
		return (void*)soap_instantiate_ns1__icatAuthorisation(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__login:
		return (void*)soap_instantiate___ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__loginLifetime:
		return (void*)soap_instantiate___ns1__loginLifetime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addSample:
		return (void*)soap_instantiate___ns1__addSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logout:
		return (void*)soap_instantiate___ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addSampleParameter:
		return (void*)soap_instantiate___ns1__addSampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addPublication:
		return (void*)soap_instantiate___ns1__addPublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addKeyword:
		return (void*)soap_instantiate___ns1__addKeyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addInvestigator:
		return (void*)soap_instantiate___ns1__addInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getInvestigation:
		return (void*)soap_instantiate___ns1__getInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getInvestigationIncludes:
		return (void*)soap_instantiate___ns1__getInvestigationIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDataset:
		return (void*)soap_instantiate___ns1__getDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDatasetIncludes:
		return (void*)soap_instantiate___ns1__getDatasetIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDatafile:
		return (void*)soap_instantiate___ns1__getDatafile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addDataFileParameter:
		return (void*)soap_instantiate___ns1__addDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getUserDetails:
		return (void*)soap_instantiate___ns1__getUserDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ingestMetadata:
		return (void*)soap_instantiate___ns1__ingestMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDatafiles:
		return (void*)soap_instantiate___ns1__getDatafiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createDataFile:
		return (void*)soap_instantiate___ns1__createDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createDataFiles:
		return (void*)soap_instantiate___ns1__createDataFiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataFileResponse:
		return (void*)soap_instantiate___ns1__deleteDataFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataFile:
		return (void*)soap_instantiate___ns1__deleteDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataFileResponse:
		return (void*)soap_instantiate___ns1__removeDataFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataFile:
		return (void*)soap_instantiate___ns1__removeDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataFileResponse:
		return (void*)soap_instantiate___ns1__modifyDataFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataFile:
		return (void*)soap_instantiate___ns1__modifyDataFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addDataFileParameters:
		return (void*)soap_instantiate___ns1__addDataFileParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataFileParameterResponse:
		return (void*)soap_instantiate___ns1__modifyDataFileParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataFileParameter:
		return (void*)soap_instantiate___ns1__modifyDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataFileParameterResponse:
		return (void*)soap_instantiate___ns1__removeDataFileParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataFileParameter:
		return (void*)soap_instantiate___ns1__removeDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataFileParameterResponse:
		return (void*)soap_instantiate___ns1__deleteDataFileParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataFileParameter:
		return (void*)soap_instantiate___ns1__deleteDataFileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAuthorisations:
		return (void*)soap_instantiate___ns1__getAuthorisations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addAuthorisation:
		return (void*)soap_instantiate___ns1__addAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteAuthorisationResponse:
		return (void*)soap_instantiate___ns1__deleteAuthorisationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteAuthorisation:
		return (void*)soap_instantiate___ns1__deleteAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeAuthorisationResponse:
		return (void*)soap_instantiate___ns1__removeAuthorisationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeAuthorisation:
		return (void*)soap_instantiate___ns1__removeAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateAuthorisationResponse:
		return (void*)soap_instantiate___ns1__updateAuthorisationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateAuthorisation:
		return (void*)soap_instantiate___ns1__updateAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getInvestigationsIncludes:
		return (void*)soap_instantiate___ns1__getInvestigationsIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createInvestigation:
		return (void*)soap_instantiate___ns1__createInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeInvestigationResponse:
		return (void*)soap_instantiate___ns1__removeInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeInvestigation:
		return (void*)soap_instantiate___ns1__removeInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteInvestigationResponse:
		return (void*)soap_instantiate___ns1__deleteInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteInvestigation:
		return (void*)soap_instantiate___ns1__deleteInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyInvestigationResponse:
		return (void*)soap_instantiate___ns1__modifyInvestigationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyInvestigation:
		return (void*)soap_instantiate___ns1__modifyInvestigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeKeywordResponse:
		return (void*)soap_instantiate___ns1__removeKeywordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeKeyword:
		return (void*)soap_instantiate___ns1__removeKeyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteKeywordResponse:
		return (void*)soap_instantiate___ns1__deleteKeywordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteKeyword:
		return (void*)soap_instantiate___ns1__deleteKeyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removePublicationResponse:
		return (void*)soap_instantiate___ns1__removePublicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removePublication:
		return (void*)soap_instantiate___ns1__removePublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deletePublicationResponse:
		return (void*)soap_instantiate___ns1__deletePublicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deletePublication:
		return (void*)soap_instantiate___ns1__deletePublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyPublicationResponse:
		return (void*)soap_instantiate___ns1__modifyPublicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyPublication:
		return (void*)soap_instantiate___ns1__modifyPublication(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeInvestigatorResponse:
		return (void*)soap_instantiate___ns1__removeInvestigatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeInvestigator:
		return (void*)soap_instantiate___ns1__removeInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyInvestigatorResponse:
		return (void*)soap_instantiate___ns1__modifyInvestigatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyInvestigator:
		return (void*)soap_instantiate___ns1__modifyInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteInvestigatorResponse:
		return (void*)soap_instantiate___ns1__deleteInvestigatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteInvestigator:
		return (void*)soap_instantiate___ns1__deleteInvestigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeSampleResponse:
		return (void*)soap_instantiate___ns1__removeSampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeSample:
		return (void*)soap_instantiate___ns1__removeSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteSampleResponse:
		return (void*)soap_instantiate___ns1__deleteSampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteSample:
		return (void*)soap_instantiate___ns1__deleteSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifySampleResponse:
		return (void*)soap_instantiate___ns1__modifySampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifySample:
		return (void*)soap_instantiate___ns1__modifySample(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeSampleParameterResponse:
		return (void*)soap_instantiate___ns1__removeSampleParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeSampleParameter:
		return (void*)soap_instantiate___ns1__removeSampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteSampleParameterResponse:
		return (void*)soap_instantiate___ns1__deleteSampleParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteSampleParameter:
		return (void*)soap_instantiate___ns1__deleteSampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifySampleParameterResponse:
		return (void*)soap_instantiate___ns1__modifySampleParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifySampleParameter:
		return (void*)soap_instantiate___ns1__modifySampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getKeywordsForUser:
		return (void*)soap_instantiate___ns1__getKeywordsForUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getKeywordsForUserStartWithMax:
		return (void*)soap_instantiate___ns1__getKeywordsForUserStartWithMax(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getKeywordsForUserMax:
		return (void*)soap_instantiate___ns1__getKeywordsForUserMax(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getKeywordsForUserType:
		return (void*)soap_instantiate___ns1__getKeywordsForUserType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAllKeywords:
		return (void*)soap_instantiate___ns1__getAllKeywords(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByRunNumber:
		return (void*)soap_instantiate___ns1__searchByRunNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByRunNumberPagination:
		return (void*)soap_instantiate___ns1__searchByRunNumberPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listDatafileFormats:
		return (void*)soap_instantiate___ns1__listDatafileFormats(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchSamplesBySampleName:
		return (void*)soap_instantiate___ns1__searchSamplesBySampleName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listDatasetTypes:
		return (void*)soap_instantiate___ns1__listDatasetTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listDatasetStatus:
		return (void*)soap_instantiate___ns1__listDatasetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDatasets:
		return (void*)soap_instantiate___ns1__getDatasets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createDataSet:
		return (void*)soap_instantiate___ns1__createDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createDataSets:
		return (void*)soap_instantiate___ns1__createDataSets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataSetResponse:
		return (void*)soap_instantiate___ns1__removeDataSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataSet:
		return (void*)soap_instantiate___ns1__removeDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataSetResponse:
		return (void*)soap_instantiate___ns1__deleteDataSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataSet:
		return (void*)soap_instantiate___ns1__deleteDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataSetResponse:
		return (void*)soap_instantiate___ns1__modifyDataSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataSet:
		return (void*)soap_instantiate___ns1__modifyDataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addDataSetParameter:
		return (void*)soap_instantiate___ns1__addDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addDataSetParameters:
		return (void*)soap_instantiate___ns1__addDataSetParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataSetParameterResponse:
		return (void*)soap_instantiate___ns1__modifyDataSetParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__modifyDataSetParameter:
		return (void*)soap_instantiate___ns1__modifyDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataSetParameterResponse:
		return (void*)soap_instantiate___ns1__removeDataSetParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeDataSetParameter:
		return (void*)soap_instantiate___ns1__removeDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataSetParameterResponse:
		return (void*)soap_instantiate___ns1__deleteDataSetParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDataSetParameter:
		return (void*)soap_instantiate___ns1__deleteDataSetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setDataSetSampleResponse:
		return (void*)soap_instantiate___ns1__setDataSetSampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setDataSetSample:
		return (void*)soap_instantiate___ns1__setDataSetSample(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByAdvanced:
		return (void*)soap_instantiate___ns1__searchByAdvanced(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByAdvancedPagination:
		return (void*)soap_instantiate___ns1__searchByAdvancedPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByKeywords:
		return (void*)soap_instantiate___ns1__searchByKeywords(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByKeywordsAll:
		return (void*)soap_instantiate___ns1__searchByKeywordsAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMyInvestigations:
		return (void*)soap_instantiate___ns1__getMyInvestigations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMyInvestigationsIncludes:
		return (void*)soap_instantiate___ns1__getMyInvestigationsIncludes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMyInvestigationsIncludesPagination:
		return (void*)soap_instantiate___ns1__getMyInvestigationsIncludesPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByUserID:
		return (void*)soap_instantiate___ns1__searchByUserID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByUserIDPagination:
		return (void*)soap_instantiate___ns1__searchByUserIDPagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByUserSurname:
		return (void*)soap_instantiate___ns1__searchByUserSurname(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByUserSurnamePagination:
		return (void*)soap_instantiate___ns1__searchByUserSurnamePagination(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listInstruments:
		return (void*)soap_instantiate___ns1__listInstruments(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listRoles:
		return (void*)soap_instantiate___ns1__listRoles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listInvestigationTypes:
		return (void*)soap_instantiate___ns1__listInvestigationTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listParameters:
		return (void*)soap_instantiate___ns1__listParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__downloadDatafile:
		return (void*)soap_instantiate___ns1__downloadDatafile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__downloadDatafiles:
		return (void*)soap_instantiate___ns1__downloadDatafiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__downloadDataset:
		return (void*)soap_instantiate___ns1__downloadDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkDatafileDownloadAccess:
		return (void*)soap_instantiate___ns1__checkDatafileDownloadAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkDatasetDownloadAccess:
		return (void*)soap_instantiate___ns1__checkDatasetDownloadAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchDatasetsBySample:
		return (void*)soap_instantiate___ns1__searchDatasetsBySample(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getFacilityUserByFacilityUserId:
		return (void*)soap_instantiate___ns1__getFacilityUserByFacilityUserId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getFacilityUserByFederalId:
		return (void*)soap_instantiate___ns1__getFacilityUserByFederalId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listFacilityCycles:
		return (void*)soap_instantiate___ns1__listFacilityCycles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getICATAPIVersion:
		return (void*)soap_instantiate___ns1__getICATAPIVersion(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__shift:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__shift(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__publication:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__publication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__keyword:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__keyword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigator:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__investigator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__relatedDatafiles:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__sampleParameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__sampleParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__parameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatRole:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__icatRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileFormat:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__datafileFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datasetParameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__datasetParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatAuthorisation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__icatAuthorisation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafile:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__datafile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__investigation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		return (void*)soap_instantiate_std__vectorTemplateOfLONG64(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__dataset:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__dataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__facilityCycle:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__facilityCycle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileParameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__datafileParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__sample:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__sample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((xsd__anyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__anyType*)p->ptr);
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			SOAP_DELETE((xsd__boolean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__boolean*)p->ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			SOAP_DELETE((xsd__dateTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__dateTime*)p->ptr);
		break;
	case SOAP_TYPE_xsd__double:
		if (p->size < 0)
			SOAP_DELETE((xsd__double*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__double*)p->ptr);
		break;
	case SOAP_TYPE_xsd__float:
		if (p->size < 0)
			SOAP_DELETE((xsd__float*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__float*)p->ptr);
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			SOAP_DELETE((xsd__int*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__int*)p->ptr);
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			SOAP_DELETE((xsd__long*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__long*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE((xsd__string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datafileInclude_:
		if (p->size < 0)
			SOAP_DELETE((ns1__datafileInclude_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datafileInclude_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__keywordType_:
		if (p->size < 0)
			SOAP_DELETE((ns1__keywordType_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__keywordType_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__investigationInclude_:
		if (p->size < 0)
			SOAP_DELETE((ns1__investigationInclude_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__investigationInclude_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__elementType_:
		if (p->size < 0)
			SOAP_DELETE((ns1__elementType_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__elementType_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datasetInclude_:
		if (p->size < 0)
			SOAP_DELETE((ns1__datasetInclude_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datasetInclude_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listDatasetTypes:
		if (p->size < 0)
			SOAP_DELETE((ns1__listDatasetTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listDatasetTypes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listDatasetTypesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listDatasetTypesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listDatasetTypesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchSamplesBySampleName:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchSamplesBySampleName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchSamplesBySampleName*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchSamplesBySampleNameResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchSamplesBySampleNameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchSamplesBySampleNameResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__entityBaseBean:
		if (p->size < 0)
			SOAP_DELETE((ns1__entityBaseBean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__entityBaseBean*)p->ptr);
		break;
	case SOAP_TYPE_ns1__entityPrimaryKeyBaseBean:
		if (p->size < 0)
			SOAP_DELETE((ns1__entityPrimaryKeyBaseBean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__entityPrimaryKeyBaseBean*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeSample:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeSample*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeSampleResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeSampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeSampleResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__InsufficientPrivilegesException:
		if (p->size < 0)
			SOAP_DELETE((ns1__InsufficientPrivilegesException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__InsufficientPrivilegesException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__NoSuchObjectFoundException:
		if (p->size < 0)
			SOAP_DELETE((ns1__NoSuchObjectFoundException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__NoSuchObjectFoundException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listInstruments:
		if (p->size < 0)
			SOAP_DELETE((ns1__listInstruments*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listInstruments*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listInstrumentsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listInstrumentsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listInstrumentsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataFile:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataFileResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataFileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ValidationException:
		if (p->size < 0)
			SOAP_DELETE((ns1__ValidationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ValidationException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifySample:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifySample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifySample*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifySampleResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifySampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifySampleResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataFile:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataFileResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataFileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeAuthorisationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeAuthorisationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeAuthorisationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataFileParameters:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataFileParameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataFileParameters*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataFileParametersResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataFileParametersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataFileParametersResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listFacilityCycles:
		if (p->size < 0)
			SOAP_DELETE((ns1__listFacilityCycles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listFacilityCycles*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listFacilityCyclesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listFacilityCyclesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listFacilityCyclesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__logout:
		if (p->size < 0)
			SOAP_DELETE((ns1__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__logout*)p->ptr);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__logoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__logoutResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadDataset:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadDataset*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadDataset*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadDatasetResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadDatasetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadDatasetResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFederalId:
		if (p->size < 0)
			SOAP_DELETE((ns1__getFacilityUserByFederalId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getFacilityUserByFederalId*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getFacilityUserByFederalIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getFacilityUserByFederalIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeInvestigator:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeInvestigator*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeInvestigatorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeInvestigatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeInvestigatorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeInvestigation:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeInvestigation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeKeyword:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeKeyword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeKeyword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeKeywordResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeKeywordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeKeywordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteInvestigation:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteInvestigation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataSets:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataSets*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataSets*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataSetsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataSetsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataSetsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removePublication:
		if (p->size < 0)
			SOAP_DELETE((ns1__removePublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removePublication*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removePublicationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removePublicationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removePublicationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllKeywords:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAllKeywords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAllKeywords*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllKeywordsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAllKeywordsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAllKeywordsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetails:
		if (p->size < 0)
			SOAP_DELETE((ns1__getUserDetails*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getUserDetails*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getUserDetailsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getUserDetailsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__userDetails:
		if (p->size < 0)
			SOAP_DELETE((ns1__userDetails*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__userDetails*)p->ptr);
		break;
	case SOAP_TYPE_ns1__NoSuchUserException:
		if (p->size < 0)
			SOAP_DELETE((ns1__NoSuchUserException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__NoSuchUserException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadDatafiles:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadDatafiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadDatafiles*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadDatafilesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadDatafilesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadDatafilesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataSet:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataSet*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataSetResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataSetResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addSampleParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__addSampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addSampleParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addSampleParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addSampleParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addSampleParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserId:
		if (p->size < 0)
			SOAP_DELETE((ns1__getFacilityUserByFacilityUserId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getFacilityUserByFacilityUserId*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getFacilityUserByFacilityUserIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getFacilityUserByFacilityUserIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__checkDatafileDownloadAccess:
		if (p->size < 0)
			SOAP_DELETE((ns1__checkDatafileDownloadAccess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__checkDatafileDownloadAccess*)p->ptr);
		break;
	case SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__checkDatafileDownloadAccessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__checkDatafileDownloadAccessResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataFile:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataFileResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataFileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserSurname:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserSurname*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserSurname*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserSurnameResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserSurnameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserSurnameResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserSurnamePagination:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserSurnamePagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserSurnamePagination*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserSurnamePaginationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserSurnamePaginationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__checkDatasetDownloadAccess:
		if (p->size < 0)
			SOAP_DELETE((ns1__checkDatasetDownloadAccess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__checkDatasetDownloadAccess*)p->ptr);
		break;
	case SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__checkDatasetDownloadAccessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__checkDatasetDownloadAccessResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByKeywords:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByKeywords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByKeywords*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByKeywordsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByKeywordsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByKeywordsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByKeywordsAll:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByKeywordsAll*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByKeywordsAll*)p->ptr);
		break;
	case SOAP_TYPE_ns1__keywordDetails:
		if (p->size < 0)
			SOAP_DELETE((ns1__keywordDetails*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__keywordDetails*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByKeywordsAllResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByKeywordsAllResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByKeywordsAllResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyInvestigations:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyInvestigations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyInvestigations*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyInvestigationsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyInvestigationsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludes:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyInvestigationsIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyInvestigationsIncludes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyInvestigationsIncludesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyInvestigationsIncludesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyInvestigationsIncludesPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyInvestigationsIncludesPagination*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyInvestigationsIncludesPaginationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyInvestigationsIncludesPaginationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataSetParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataSetParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataSetParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyPublication:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyPublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyPublication*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyPublicationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyPublicationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyPublicationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserID:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserIDResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserIDPagination:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserIDPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserIDPagination*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByUserIDPaginationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByUserIDPaginationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByUserIDPaginationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataFileParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataFileParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataFileParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getInvestigationsIncludes:
		if (p->size < 0)
			SOAP_DELETE((ns1__getInvestigationsIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getInvestigationsIncludes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getInvestigationsIncludesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getInvestigationsIncludesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getInvestigationsIncludesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataSet:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataSet*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataSetResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataSetResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatafiles:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatafiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatafiles*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatafilesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatafilesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatafilesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getICATAPIVersion:
		if (p->size < 0)
			SOAP_DELETE((ns1__getICATAPIVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getICATAPIVersion*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getICATAPIVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getICATAPIVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getICATAPIVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteInvestigator:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteInvestigator*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteInvestigatorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteInvestigatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteInvestigatorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addInvestigator:
		if (p->size < 0)
			SOAP_DELETE((ns1__addInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addInvestigator*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addInvestigatorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addInvestigatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addInvestigatorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataSet:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataSet*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataSetResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataSetResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeSampleParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeSampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeSampleParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeSampleParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeSampleParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeSampleParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataSetParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataSetParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataSetParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setDataSetSample:
		if (p->size < 0)
			SOAP_DELETE((ns1__setDataSetSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__setDataSetSample*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setDataSetSampleResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__setDataSetSampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__setDataSetSampleResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadDatafile:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadDatafile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadDatafile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadDatafileResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadDatafileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadDatafileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUser:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMax:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUserStartWithMax*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUserStartWithMax*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUserStartWithMaxResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUserStartWithMaxResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserMax:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUserMax*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUserMax*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserMaxResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUserMaxResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUserMaxResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserType:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUserType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUserType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getKeywordsForUserTypeResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getKeywordsForUserTypeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getKeywordsForUserTypeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listInvestigationTypes:
		if (p->size < 0)
			SOAP_DELETE((ns1__listInvestigationTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listInvestigationTypes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listInvestigationTypesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listInvestigationTypesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listInvestigationTypesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataSetParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataSetParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataSetParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataSet:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataSet*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeDataSetResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeDataSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeDataSetResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAuthorisations:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAuthorisations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAuthorisations*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAuthorisationsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAuthorisationsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAuthorisationsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addKeyword:
		if (p->size < 0)
			SOAP_DELETE((ns1__addKeyword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addKeyword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addKeywordResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addKeywordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addKeywordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyInvestigation:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyInvestigation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listDatasetStatus:
		if (p->size < 0)
			SOAP_DELETE((ns1__listDatasetStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listDatasetStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listDatasetStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listDatasetStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listDatasetStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteSample:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteSample*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteSampleResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteSampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteSampleResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteKeyword:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteKeyword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteKeyword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteKeywordResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteKeywordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteKeywordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataSetParameters:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataSetParameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataSetParameters*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataSetParametersResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataSetParametersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataSetParametersResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByRunNumber:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByRunNumber*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByRunNumber*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByRunNumberResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByRunNumberResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByRunNumberResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByRunNumberPagination:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByRunNumberPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByRunNumberPagination*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByRunNumberPaginationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByRunNumberPaginationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByRunNumberPaginationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByAdvanced:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByAdvanced*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByAdvanced*)p->ptr);
		break;
	case SOAP_TYPE_ns1__advancedSearchDetails:
		if (p->size < 0)
			SOAP_DELETE((ns1__advancedSearchDetails*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__advancedSearchDetails*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByAdvancedResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByAdvancedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByAdvancedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByAdvancedPagination:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByAdvancedPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByAdvancedPagination*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchByAdvancedPaginationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchByAdvancedPaginationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchByAdvancedPaginationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listDatafileFormats:
		if (p->size < 0)
			SOAP_DELETE((ns1__listDatafileFormats*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listDatafileFormats*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listDatafileFormatsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listDatafileFormatsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listDatafileFormatsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifySampleParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifySampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifySampleParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifySampleParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifySampleParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifySampleParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyInvestigator:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyInvestigator*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyInvestigatorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyInvestigatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyInvestigatorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataFiles:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataFiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataFiles*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDataFilesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__createDataFilesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createDataFilesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataSetParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataSetParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataSetParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((ns1__addAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addAuthorisationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addAuthorisationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addAuthorisationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addSample:
		if (p->size < 0)
			SOAP_DELETE((ns1__addSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addSample*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addSampleResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addSampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addSampleResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deletePublication:
		if (p->size < 0)
			SOAP_DELETE((ns1__deletePublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deletePublication*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deletePublicationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deletePublicationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deletePublicationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loginLifetime:
		if (p->size < 0)
			SOAP_DELETE((ns1__loginLifetime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loginLifetime*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loginLifetimeResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__loginLifetimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loginLifetimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__login:
		if (p->size < 0)
			SOAP_DELETE((ns1__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__login*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__loginResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loginResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteAuthorisationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteAuthorisationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteAuthorisationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateAuthorisationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateAuthorisationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateAuthorisationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatasetIncludes:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatasetIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatasetIncludes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatasetIncludesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatasetIncludesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatasetIncludesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDataset:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDataset*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDataset*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatasetResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatasetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatasetResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listRoles:
		if (p->size < 0)
			SOAP_DELETE((ns1__listRoles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listRoles*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listRolesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listRolesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listRolesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ingestMetadata:
		if (p->size < 0)
			SOAP_DELETE((ns1__ingestMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ingestMetadata*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ingestMetadataResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__ingestMetadataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ingestMetadataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ICATAPIException:
		if (p->size < 0)
			SOAP_DELETE((ns1__ICATAPIException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ICATAPIException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatafile:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatafile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatafile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatafileResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatafileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatafileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataFile:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataFileResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataFileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getInvestigationIncludes:
		if (p->size < 0)
			SOAP_DELETE((ns1__getInvestigationIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getInvestigationIncludes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getInvestigationIncludesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getInvestigationIncludesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getInvestigationIncludesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getInvestigation:
		if (p->size < 0)
			SOAP_DELETE((ns1__getInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getInvestigation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDataFileParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteDataFileParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteDataFileParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createInvestigation:
		if (p->size < 0)
			SOAP_DELETE((ns1__createInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createInvestigation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__createInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__createInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addPublication:
		if (p->size < 0)
			SOAP_DELETE((ns1__addPublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addPublication*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addPublicationResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addPublicationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addPublicationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchDatasetsBySample:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchDatasetsBySample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchDatasetsBySample*)p->ptr);
		break;
	case SOAP_TYPE_ns1__searchDatasetsBySampleResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__searchDatasetsBySampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__searchDatasetsBySampleResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDataFileParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__addDataFileParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__addDataFileParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteSampleParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteSampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteSampleParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteSampleParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteSampleParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteSampleParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__modifyDataFileParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__modifyDataFileParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__modifyDataFileParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listParameters:
		if (p->size < 0)
			SOAP_DELETE((ns1__listParameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listParameters*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listParametersResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listParametersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listParametersResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatasets:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatasets*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatasets*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatasetsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDatasetsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDatasetsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns3__SessionException:
		if (p->size < 0)
			SOAP_DELETE((ns3__SessionException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__SessionException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sample:
		if (p->size < 0)
			SOAP_DELETE((ns1__sample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sample*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sampleParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__sampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sampleParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sampleParameterPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__sampleParameterPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sampleParameterPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__icatRole:
		if (p->size < 0)
			SOAP_DELETE((ns1__icatRole*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__icatRole*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datafile:
		if (p->size < 0)
			SOAP_DELETE((ns1__datafile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datafile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datafileFormat:
		if (p->size < 0)
			SOAP_DELETE((ns1__datafileFormat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datafileFormat*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datafileFormatPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__datafileFormatPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datafileFormatPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datafileParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__datafileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datafileParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datafileParameterPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__datafileParameterPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datafileParameterPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__relatedDatafiles:
		if (p->size < 0)
			SOAP_DELETE((ns1__relatedDatafiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__relatedDatafiles*)p->ptr);
		break;
	case SOAP_TYPE_ns1__relatedDatafilesPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__relatedDatafilesPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__relatedDatafilesPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__facilityCycle:
		if (p->size < 0)
			SOAP_DELETE((ns1__facilityCycle*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__facilityCycle*)p->ptr);
		break;
	case SOAP_TYPE_ns1__facilityUser:
		if (p->size < 0)
			SOAP_DELETE((ns1__facilityUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__facilityUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__investigatorPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__investigatorPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__investigatorPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__keywordPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__keywordPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__keywordPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__dataset:
		if (p->size < 0)
			SOAP_DELETE((ns1__dataset*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__dataset*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datasetParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__datasetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datasetParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__datasetParameterPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__datasetParameterPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__datasetParameterPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__parameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__parameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__parameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__parameterPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__parameterPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__parameterPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__investigation:
		if (p->size < 0)
			SOAP_DELETE((ns1__investigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__investigation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__investigator:
		if (p->size < 0)
			SOAP_DELETE((ns1__investigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__investigator*)p->ptr);
		break;
	case SOAP_TYPE_ns1__keyword:
		if (p->size < 0)
			SOAP_DELETE((ns1__keyword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__keyword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__publication:
		if (p->size < 0)
			SOAP_DELETE((ns1__publication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__publication*)p->ptr);
		break;
	case SOAP_TYPE_ns1__shift:
		if (p->size < 0)
			SOAP_DELETE((ns1__shift*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__shift*)p->ptr);
		break;
	case SOAP_TYPE_ns1__shiftPK:
		if (p->size < 0)
			SOAP_DELETE((ns1__shiftPK*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__shiftPK*)p->ptr);
		break;
	case SOAP_TYPE_ns1__icatAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((ns1__icatAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__icatAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE___ns1__login:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__login*)p->ptr);
		break;
	case SOAP_TYPE___ns1__loginLifetime:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__loginLifetime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__loginLifetime*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addSample:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addSample*)p->ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__logout*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addSampleParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addSampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addSampleParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addPublication:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addPublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addPublication*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addKeyword:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addKeyword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addKeyword*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addInvestigator:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addInvestigator*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getInvestigation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getInvestigation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getInvestigationIncludes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getInvestigationIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getInvestigationIncludes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDataset:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDataset*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDataset*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDatasetIncludes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDatasetIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDatasetIncludes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDatafile:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDatafile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDatafile*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getUserDetails:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getUserDetails*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getUserDetails*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ingestMetadata:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ingestMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ingestMetadata*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDatafiles:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDatafiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDatafiles*)p->ptr);
		break;
	case SOAP_TYPE___ns1__createDataFile:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__createDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__createDataFile*)p->ptr);
		break;
	case SOAP_TYPE___ns1__createDataFiles:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__createDataFiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__createDataFiles*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFileResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataFileResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFile:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataFile*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFileResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataFileResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFile:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataFile*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFileResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataFileResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFile:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataFile*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addDataFileParameters:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addDataFileParameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addDataFileParameters*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFileParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataFileParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataFileParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFileParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataFileParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataFileParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFileParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataFileParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataFileParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataFileParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataFileParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataFileParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAuthorisations:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAuthorisations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAuthorisations*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteAuthorisationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteAuthorisationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteAuthorisationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeAuthorisationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeAuthorisationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeAuthorisationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateAuthorisationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateAuthorisationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateAuthorisationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateAuthorisation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateAuthorisation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getInvestigationsIncludes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getInvestigationsIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getInvestigationsIncludes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__createInvestigation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__createInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__createInvestigation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeInvestigation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteInvestigation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyInvestigationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyInvestigationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyInvestigation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyInvestigation*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeKeywordResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeKeywordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeKeywordResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeKeyword:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeKeyword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeKeyword*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteKeywordResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteKeywordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteKeywordResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteKeyword:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteKeyword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteKeyword*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removePublicationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removePublicationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removePublicationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removePublication:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removePublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removePublication*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deletePublicationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deletePublicationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deletePublicationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deletePublication:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deletePublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deletePublication*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyPublicationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyPublicationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyPublicationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyPublication:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyPublication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyPublication*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigatorResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeInvestigatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeInvestigatorResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeInvestigator:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeInvestigator*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigatorResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyInvestigatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyInvestigatorResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyInvestigator:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyInvestigator*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigatorResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteInvestigatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteInvestigatorResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteInvestigator:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteInvestigator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteInvestigator*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeSampleResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeSampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeSampleResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeSample:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeSample*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteSampleResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteSampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteSampleResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteSample:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteSample*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifySampleResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifySampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifySampleResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifySample:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifySample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifySample*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeSampleParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeSampleParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeSampleParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeSampleParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeSampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeSampleParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteSampleParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteSampleParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteSampleParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteSampleParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteSampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteSampleParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifySampleParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifySampleParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifySampleParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifySampleParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifySampleParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifySampleParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUser:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getKeywordsForUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getKeywordsForUser*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUserStartWithMax:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getKeywordsForUserStartWithMax*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getKeywordsForUserStartWithMax*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUserMax:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getKeywordsForUserMax*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getKeywordsForUserMax*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getKeywordsForUserType:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getKeywordsForUserType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getKeywordsForUserType*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAllKeywords:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAllKeywords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAllKeywords*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByRunNumber:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByRunNumber*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByRunNumber*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByRunNumberPagination:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByRunNumberPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByRunNumberPagination*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listDatafileFormats:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listDatafileFormats*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listDatafileFormats*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchSamplesBySampleName:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchSamplesBySampleName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchSamplesBySampleName*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listDatasetTypes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listDatasetTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listDatasetTypes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listDatasetStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listDatasetStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listDatasetStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDatasets:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDatasets*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDatasets*)p->ptr);
		break;
	case SOAP_TYPE___ns1__createDataSet:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__createDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__createDataSet*)p->ptr);
		break;
	case SOAP_TYPE___ns1__createDataSets:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__createDataSets*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__createDataSets*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSetResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataSetResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSet:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataSet*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSetResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataSetResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSet:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataSet*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSetResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataSetResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSet:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataSet*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addDataSetParameters:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addDataSetParameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addDataSetParameters*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSetParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataSetParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataSetParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__modifyDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__modifyDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__modifyDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSetParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataSetParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataSetParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSetParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataSetParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataSetParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteDataSetParameter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteDataSetParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteDataSetParameter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setDataSetSampleResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setDataSetSampleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setDataSetSampleResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__setDataSetSample:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__setDataSetSample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__setDataSetSample*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByAdvanced:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByAdvanced*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByAdvanced*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByAdvancedPagination:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByAdvancedPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByAdvancedPagination*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByKeywords:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByKeywords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByKeywords*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByKeywordsAll:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByKeywordsAll*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByKeywordsAll*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMyInvestigations:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMyInvestigations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMyInvestigations*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMyInvestigationsIncludes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMyInvestigationsIncludes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMyInvestigationsIncludes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMyInvestigationsIncludesPagination:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMyInvestigationsIncludesPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMyInvestigationsIncludesPagination*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserID:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByUserID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByUserID*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserIDPagination:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByUserIDPagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByUserIDPagination*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserSurname:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByUserSurname*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByUserSurname*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchByUserSurnamePagination:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchByUserSurnamePagination*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchByUserSurnamePagination*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listInstruments:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listInstruments*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listInstruments*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listRoles:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listRoles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listRoles*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listInvestigationTypes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listInvestigationTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listInvestigationTypes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listParameters:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listParameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listParameters*)p->ptr);
		break;
	case SOAP_TYPE___ns1__downloadDatafile:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__downloadDatafile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__downloadDatafile*)p->ptr);
		break;
	case SOAP_TYPE___ns1__downloadDatafiles:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__downloadDatafiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__downloadDatafiles*)p->ptr);
		break;
	case SOAP_TYPE___ns1__downloadDataset:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__downloadDataset*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__downloadDataset*)p->ptr);
		break;
	case SOAP_TYPE___ns1__checkDatafileDownloadAccess:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__checkDatafileDownloadAccess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__checkDatafileDownloadAccess*)p->ptr);
		break;
	case SOAP_TYPE___ns1__checkDatasetDownloadAccess:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__checkDatasetDownloadAccess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__checkDatasetDownloadAccess*)p->ptr);
		break;
	case SOAP_TYPE___ns1__searchDatasetsBySample:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__searchDatasetsBySample*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__searchDatasetsBySample*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getFacilityUserByFacilityUserId:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getFacilityUserByFacilityUserId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getFacilityUserByFacilityUserId*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getFacilityUserByFederalId:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getFacilityUserByFederalId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getFacilityUserByFederalId*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listFacilityCycles:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listFacilityCycles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listFacilityCycles*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getICATAPIVersion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getICATAPIVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getICATAPIVersion*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__shift:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__shift * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__shift * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__publication:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__publication * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__publication * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__keyword:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__keyword * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__keyword * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigator:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__investigator * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__investigator * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__relatedDatafiles:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__relatedDatafiles * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__relatedDatafiles * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__sampleParameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__sampleParameter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__sampleParameter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__parameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__parameter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__parameter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatRole:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__icatRole * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__icatRole * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileFormat:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__datafileFormat * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__datafileFormat * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datasetParameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__datasetParameter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__datasetParameter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatAuthorisation:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__icatAuthorisation * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__icatAuthorisation * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafile:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__datafile * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__datafile * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigation:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__investigation * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__investigation * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<xsd__anyType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<xsd__anyType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		if (p->size < 0)
			SOAP_DELETE((std::vector<LONG64 >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<LONG64 >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__dataset:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__dataset * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__dataset * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__facilityCycle:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__facilityCycle * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__facilityCycle * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileParameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__datafileParameter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__datafileParameter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__sample:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__sample * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__sample * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__shift:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__shift * >*)p)[len] = *(ns1__shift **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__publication:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__publication * >*)p)[len] = *(ns1__publication **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__keyword:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__keyword * >*)p)[len] = *(ns1__keyword **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigator:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__investigator * >*)p)[len] = *(ns1__investigator **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__relatedDatafiles:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__relatedDatafiles * >*)p)[len] = *(ns1__relatedDatafiles **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__sampleParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__sampleParameter * >*)p)[len] = *(ns1__sampleParameter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__parameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__parameter * >*)p)[len] = *(ns1__parameter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatRole:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__icatRole * >*)p)[len] = *(ns1__icatRole **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileFormat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__datafileFormat * >*)p)[len] = *(ns1__datafileFormat **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datasetParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__datasetParameter * >*)p)[len] = *(ns1__datasetParameter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatAuthorisation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__icatAuthorisation * >*)p)[len] = *(ns1__icatAuthorisation **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__datafile * >*)p)[len] = *(ns1__datafile **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__investigation * >*)p)[len] = *(ns1__investigation **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<xsd__anyType * >*)p)[len] = *(xsd__anyType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<LONG64 >*)p)[len] = *(LONG64 *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__dataset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__dataset * >*)p)[len] = *(ns1__dataset **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__facilityCycle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__facilityCycle * >*)p)[len] = *(ns1__facilityCycle **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__datafileParameter * >*)p)[len] = *(ns1__datafileParameter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__sample:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__sample * >*)p)[len] = *(ns1__sample **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__datasetInclude(struct soap *soap, enum ns1__datasetInclude *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__datasetInclude
	*a = SOAP_DEFAULT_ns1__datasetInclude;
#else
	*a = (enum ns1__datasetInclude)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__datasetInclude[] =
{	{ (long)ns1__datasetInclude__DATASET_USCOREAND_USCOREDATAFILES_USCOREONLY, "DATASET_AND_DATAFILES_ONLY" },
	{ (long)ns1__datasetInclude__DATASET_USCOREPARAMETERS_USCOREONLY, "DATASET_PARAMETERS_ONLY" },
	{ (long)ns1__datasetInclude__DATASET_USCOREDATAFILES_USCOREAND_USCOREPARAMETERS, "DATASET_DATAFILES_AND_PARAMETERS" },
	{ (long)ns1__datasetInclude__NONE, "NONE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__datasetInclude2s(struct soap *soap, enum ns1__datasetInclude n)
{	const char *s = soap_code_str(soap_codes_ns1__datasetInclude, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datasetInclude(struct soap *soap, const char *tag, int id, const enum ns1__datasetInclude *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datasetInclude), type) || soap_send(soap, soap_ns1__datasetInclude2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__datasetInclude(struct soap *soap, const char *s, enum ns1__datasetInclude *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__datasetInclude, s);
	if (map)
		*a = (enum ns1__datasetInclude)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__datasetInclude)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__datasetInclude * SOAP_FMAC4 soap_in_ns1__datasetInclude(struct soap *soap, const char *tag, enum ns1__datasetInclude *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__datasetInclude *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datasetInclude, sizeof(enum ns1__datasetInclude), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__datasetInclude(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__datasetInclude *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datasetInclude, 0, sizeof(enum ns1__datasetInclude), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__datasetInclude(struct soap *soap, const enum ns1__datasetInclude *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__datasetInclude);
	if (soap_out_ns1__datasetInclude(soap, tag?tag:"ns1:datasetInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__datasetInclude * SOAP_FMAC4 soap_get_ns1__datasetInclude(struct soap *soap, enum ns1__datasetInclude *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datasetInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__elementType(struct soap *soap, enum ns1__elementType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__elementType
	*a = SOAP_DEFAULT_ns1__elementType;
#else
	*a = (enum ns1__elementType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__elementType[] =
{	{ (long)ns1__elementType__STUDY, "STUDY" },
	{ (long)ns1__elementType__INVESTIGATION, "INVESTIGATION" },
	{ (long)ns1__elementType__INVESTIGATOR, "INVESTIGATOR" },
	{ (long)ns1__elementType__KEYWORD, "KEYWORD" },
	{ (long)ns1__elementType__SAMPLE, "SAMPLE" },
	{ (long)ns1__elementType__SAMPLE_USCOREPARAMETER, "SAMPLE_PARAMETER" },
	{ (long)ns1__elementType__PUBLICATION, "PUBLICATION" },
	{ (long)ns1__elementType__DATASET, "DATASET" },
	{ (long)ns1__elementType__DATASET_USCOREPARAMETER, "DATASET_PARAMETER" },
	{ (long)ns1__elementType__DATAFILE, "DATAFILE" },
	{ (long)ns1__elementType__DATAFILE_USCOREPARAMETER, "DATAFILE_PARAMETER" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__elementType2s(struct soap *soap, enum ns1__elementType n)
{	const char *s = soap_code_str(soap_codes_ns1__elementType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__elementType(struct soap *soap, const char *tag, int id, const enum ns1__elementType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__elementType), type) || soap_send(soap, soap_ns1__elementType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__elementType(struct soap *soap, const char *s, enum ns1__elementType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__elementType, s);
	if (map)
		*a = (enum ns1__elementType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__elementType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__elementType * SOAP_FMAC4 soap_in_ns1__elementType(struct soap *soap, const char *tag, enum ns1__elementType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__elementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__elementType, sizeof(enum ns1__elementType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__elementType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__elementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__elementType, 0, sizeof(enum ns1__elementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__elementType(struct soap *soap, const enum ns1__elementType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__elementType);
	if (soap_out_ns1__elementType(soap, tag?tag:"ns1:elementType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__elementType * SOAP_FMAC4 soap_get_ns1__elementType(struct soap *soap, enum ns1__elementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__elementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__investigationInclude(struct soap *soap, enum ns1__investigationInclude *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__investigationInclude
	*a = SOAP_DEFAULT_ns1__investigationInclude;
#else
	*a = (enum ns1__investigationInclude)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__investigationInclude[] =
{	{ (long)ns1__investigationInclude__INVESTIGATORS_USCOREONLY, "INVESTIGATORS_ONLY" },
	{ (long)ns1__investigationInclude__KEYWORDS_USCOREONLY, "KEYWORDS_ONLY" },
	{ (long)ns1__investigationInclude__PUBLICATIONS_USCOREONLY, "PUBLICATIONS_ONLY" },
	{ (long)ns1__investigationInclude__INVESTIGATORS_USCOREAND_USCOREKEYWORDS, "INVESTIGATORS_AND_KEYWORDS" },
	{ (long)ns1__investigationInclude__INVESTIGATORS_USCOREAND_USCORESHIFTS, "INVESTIGATORS_AND_SHIFTS" },
	{ (long)ns1__investigationInclude__INVESTIGATORS_USCORESHIFTS_USCOREAND_USCORESAMPLES, "INVESTIGATORS_SHIFTS_AND_SAMPLES" },
	{ (long)ns1__investigationInclude__INVESTIGATORS_USCORESHIFTS_USCORESAMPLES_USCOREAND_USCOREPUBLICATIONS, "INVESTIGATORS_SHIFTS_SAMPLES_AND_PUBLICATIONS" },
	{ (long)ns1__investigationInclude__DATASETS_USCOREONLY, "DATASETS_ONLY" },
	{ (long)ns1__investigationInclude__DATASETS_USCOREAND_USCOREDATASET_USCOREPARAMETERS_USCOREONLY, "DATASETS_AND_DATASET_PARAMETERS_ONLY" },
	{ (long)ns1__investigationInclude__DATASETS_USCOREAND_USCOREDATAFILES, "DATASETS_AND_DATAFILES" },
	{ (long)ns1__investigationInclude__DATASETS_USCOREDATAFILES_USCOREAND_USCOREPARAMETERS, "DATASETS_DATAFILES_AND_PARAMETERS" },
	{ (long)ns1__investigationInclude__SAMPLES_USCOREONLY, "SAMPLES_ONLY" },
	{ (long)ns1__investigationInclude__ROLE_USCOREONLY, "ROLE_ONLY" },
	{ (long)ns1__investigationInclude__SHIFT_USCOREONLY, "SHIFT_ONLY" },
	{ (long)ns1__investigationInclude__ALL, "ALL" },
	{ (long)ns1__investigationInclude__NONE, "NONE" },
	{ (long)ns1__investigationInclude__ALL_USCOREEXCEPT_USCOREDATASETS_USCOREAND_USCOREDATAFILES, "ALL_EXCEPT_DATASETS_AND_DATAFILES" },
	{ (long)ns1__investigationInclude__ALL_USCOREEXCEPT_USCOREDATASETS_USCOREDATAFILES_USCOREAND_USCOREROLES, "ALL_EXCEPT_DATASETS_DATAFILES_AND_ROLES" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__investigationInclude2s(struct soap *soap, enum ns1__investigationInclude n)
{	const char *s = soap_code_str(soap_codes_ns1__investigationInclude, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigationInclude(struct soap *soap, const char *tag, int id, const enum ns1__investigationInclude *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__investigationInclude), type) || soap_send(soap, soap_ns1__investigationInclude2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__investigationInclude(struct soap *soap, const char *s, enum ns1__investigationInclude *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__investigationInclude, s);
	if (map)
		*a = (enum ns1__investigationInclude)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 17)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__investigationInclude)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__investigationInclude * SOAP_FMAC4 soap_in_ns1__investigationInclude(struct soap *soap, const char *tag, enum ns1__investigationInclude *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__investigationInclude *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__investigationInclude, sizeof(enum ns1__investigationInclude), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__investigationInclude(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__investigationInclude *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__investigationInclude, 0, sizeof(enum ns1__investigationInclude), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__investigationInclude(struct soap *soap, const enum ns1__investigationInclude *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__investigationInclude);
	if (soap_out_ns1__investigationInclude(soap, tag?tag:"ns1:investigationInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__investigationInclude * SOAP_FMAC4 soap_get_ns1__investigationInclude(struct soap *soap, enum ns1__investigationInclude *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__investigationInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__keywordType(struct soap *soap, enum ns1__keywordType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__keywordType
	*a = SOAP_DEFAULT_ns1__keywordType;
#else
	*a = (enum ns1__keywordType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__keywordType[] =
{	{ (long)ns1__keywordType__ALL, "ALL" },
	{ (long)ns1__keywordType__ALPHA_USCORENUMERIC, "ALPHA_NUMERIC" },
	{ (long)ns1__keywordType__ALPHA, "ALPHA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__keywordType2s(struct soap *soap, enum ns1__keywordType n)
{	const char *s = soap_code_str(soap_codes_ns1__keywordType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__keywordType(struct soap *soap, const char *tag, int id, const enum ns1__keywordType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__keywordType), type) || soap_send(soap, soap_ns1__keywordType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__keywordType(struct soap *soap, const char *s, enum ns1__keywordType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__keywordType, s);
	if (map)
		*a = (enum ns1__keywordType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__keywordType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__keywordType * SOAP_FMAC4 soap_in_ns1__keywordType(struct soap *soap, const char *tag, enum ns1__keywordType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__keywordType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__keywordType, sizeof(enum ns1__keywordType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__keywordType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__keywordType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__keywordType, 0, sizeof(enum ns1__keywordType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__keywordType(struct soap *soap, const enum ns1__keywordType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__keywordType);
	if (soap_out_ns1__keywordType(soap, tag?tag:"ns1:keywordType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__keywordType * SOAP_FMAC4 soap_get_ns1__keywordType(struct soap *soap, enum ns1__keywordType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__keywordType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__datafileInclude(struct soap *soap, enum ns1__datafileInclude *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__datafileInclude
	*a = SOAP_DEFAULT_ns1__datafileInclude;
#else
	*a = (enum ns1__datafileInclude)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__datafileInclude[] =
{	{ (long)ns1__datafileInclude__DATAFILE_USCOREPARAMETERS, "DATAFILE_PARAMETERS" },
	{ (long)ns1__datafileInclude__RELATED_USCOREDATAFILES, "RELATED_DATAFILES" },
	{ (long)ns1__datafileInclude__ALL, "ALL" },
	{ (long)ns1__datafileInclude__NONE, "NONE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__datafileInclude2s(struct soap *soap, enum ns1__datafileInclude n)
{	const char *s = soap_code_str(soap_codes_ns1__datafileInclude, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileInclude(struct soap *soap, const char *tag, int id, const enum ns1__datafileInclude *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datafileInclude), type) || soap_send(soap, soap_ns1__datafileInclude2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__datafileInclude(struct soap *soap, const char *s, enum ns1__datafileInclude *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__datafileInclude, s);
	if (map)
		*a = (enum ns1__datafileInclude)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__datafileInclude)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__datafileInclude * SOAP_FMAC4 soap_in_ns1__datafileInclude(struct soap *soap, const char *tag, enum ns1__datafileInclude *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__datafileInclude *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datafileInclude, sizeof(enum ns1__datafileInclude), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__datafileInclude(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__datafileInclude *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datafileInclude, 0, sizeof(enum ns1__datafileInclude), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__datafileInclude(struct soap *soap, const enum ns1__datafileInclude *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__datafileInclude);
	if (soap_out_ns1__datafileInclude(soap, tag?tag:"ns1:datafileInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__datafileInclude * SOAP_FMAC4 soap_get_ns1__datafileInclude(struct soap *soap, enum ns1__datafileInclude *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datafileInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__datasetInclude_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__datasetInclude(soap, &this->ns1__datasetInclude_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datasetInclude_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__datasetInclude_::__item, SOAP_TYPE_ns1__datasetInclude);
	/* transient soap skipped */
}

int ns1__datasetInclude_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datasetInclude_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datasetInclude_(struct soap *soap, const char *tag, int id, const ns1__datasetInclude_ *a, const char *type)
{
	return soap_out_ns1__datasetInclude(soap, tag, id, &(a->ns1__datasetInclude_::__item), "ns1:datasetInclude");
}

void *ns1__datasetInclude_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datasetInclude_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datasetInclude_ * SOAP_FMAC4 soap_in_ns1__datasetInclude_(struct soap *soap, const char *tag, ns1__datasetInclude_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__datasetInclude_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datasetInclude_, sizeof(ns1__datasetInclude_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datasetInclude_)
			return (ns1__datasetInclude_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__datasetInclude(soap, tag, &(a->ns1__datasetInclude_::__item), "ns1:datasetInclude"))
		return NULL;
	return a;
}

int ns1__datasetInclude_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datasetInclude_);
	if (this->soap_out(soap, tag?tag:"ns1:datasetInclude", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datasetInclude_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datasetInclude_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datasetInclude_ * SOAP_FMAC4 soap_get_ns1__datasetInclude_(struct soap *soap, ns1__datasetInclude_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datasetInclude_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datasetInclude_ * SOAP_FMAC2 soap_instantiate_ns1__datasetInclude_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datasetInclude_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datasetInclude_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datasetInclude_);
		if (size)
			*size = sizeof(ns1__datasetInclude_);
		((ns1__datasetInclude_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datasetInclude_[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datasetInclude_);
		for (int i = 0; i < n; i++)
			((ns1__datasetInclude_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datasetInclude_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datasetInclude_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datasetInclude_ %p -> %p\n", q, p));
	*(ns1__datasetInclude_*)p = *(ns1__datasetInclude_*)q;
}

void ns1__elementType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__elementType(soap, &this->ns1__elementType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__elementType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__elementType_::__item, SOAP_TYPE_ns1__elementType);
	/* transient soap skipped */
}

int ns1__elementType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__elementType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__elementType_(struct soap *soap, const char *tag, int id, const ns1__elementType_ *a, const char *type)
{
	return soap_out_ns1__elementType(soap, tag, id, &(a->ns1__elementType_::__item), "ns1:elementType");
}

void *ns1__elementType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__elementType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__elementType_ * SOAP_FMAC4 soap_in_ns1__elementType_(struct soap *soap, const char *tag, ns1__elementType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__elementType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__elementType_, sizeof(ns1__elementType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__elementType_)
			return (ns1__elementType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__elementType(soap, tag, &(a->ns1__elementType_::__item), "ns1:elementType"))
		return NULL;
	return a;
}

int ns1__elementType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__elementType_);
	if (this->soap_out(soap, tag?tag:"ns1:elementType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__elementType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__elementType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__elementType_ * SOAP_FMAC4 soap_get_ns1__elementType_(struct soap *soap, ns1__elementType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__elementType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__elementType_ * SOAP_FMAC2 soap_instantiate_ns1__elementType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__elementType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__elementType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__elementType_);
		if (size)
			*size = sizeof(ns1__elementType_);
		((ns1__elementType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__elementType_[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__elementType_);
		for (int i = 0; i < n; i++)
			((ns1__elementType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__elementType_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__elementType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__elementType_ %p -> %p\n", q, p));
	*(ns1__elementType_*)p = *(ns1__elementType_*)q;
}

void ns1__investigationInclude_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__investigationInclude(soap, &this->ns1__investigationInclude_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__investigationInclude_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__investigationInclude_::__item, SOAP_TYPE_ns1__investigationInclude);
	/* transient soap skipped */
}

int ns1__investigationInclude_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__investigationInclude_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigationInclude_(struct soap *soap, const char *tag, int id, const ns1__investigationInclude_ *a, const char *type)
{
	return soap_out_ns1__investigationInclude(soap, tag, id, &(a->ns1__investigationInclude_::__item), "ns1:investigationInclude");
}

void *ns1__investigationInclude_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__investigationInclude_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigationInclude_ * SOAP_FMAC4 soap_in_ns1__investigationInclude_(struct soap *soap, const char *tag, ns1__investigationInclude_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__investigationInclude_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__investigationInclude_, sizeof(ns1__investigationInclude_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__investigationInclude_)
			return (ns1__investigationInclude_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__investigationInclude(soap, tag, &(a->ns1__investigationInclude_::__item), "ns1:investigationInclude"))
		return NULL;
	return a;
}

int ns1__investigationInclude_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__investigationInclude_);
	if (this->soap_out(soap, tag?tag:"ns1:investigationInclude", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__investigationInclude_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__investigationInclude_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigationInclude_ * SOAP_FMAC4 soap_get_ns1__investigationInclude_(struct soap *soap, ns1__investigationInclude_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__investigationInclude_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__investigationInclude_ * SOAP_FMAC2 soap_instantiate_ns1__investigationInclude_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigationInclude_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__investigationInclude_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigationInclude_);
		if (size)
			*size = sizeof(ns1__investigationInclude_);
		((ns1__investigationInclude_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigationInclude_[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__investigationInclude_);
		for (int i = 0; i < n; i++)
			((ns1__investigationInclude_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__investigationInclude_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigationInclude_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigationInclude_ %p -> %p\n", q, p));
	*(ns1__investigationInclude_*)p = *(ns1__investigationInclude_*)q;
}

void ns1__keywordType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__keywordType(soap, &this->ns1__keywordType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__keywordType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__keywordType_::__item, SOAP_TYPE_ns1__keywordType);
	/* transient soap skipped */
}

int ns1__keywordType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__keywordType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__keywordType_(struct soap *soap, const char *tag, int id, const ns1__keywordType_ *a, const char *type)
{
	return soap_out_ns1__keywordType(soap, tag, id, &(a->ns1__keywordType_::__item), "ns1:keywordType");
}

void *ns1__keywordType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__keywordType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__keywordType_ * SOAP_FMAC4 soap_in_ns1__keywordType_(struct soap *soap, const char *tag, ns1__keywordType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__keywordType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__keywordType_, sizeof(ns1__keywordType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__keywordType_)
			return (ns1__keywordType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__keywordType(soap, tag, &(a->ns1__keywordType_::__item), "ns1:keywordType"))
		return NULL;
	return a;
}

int ns1__keywordType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__keywordType_);
	if (this->soap_out(soap, tag?tag:"ns1:keywordType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__keywordType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__keywordType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__keywordType_ * SOAP_FMAC4 soap_get_ns1__keywordType_(struct soap *soap, ns1__keywordType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__keywordType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__keywordType_ * SOAP_FMAC2 soap_instantiate_ns1__keywordType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__keywordType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__keywordType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__keywordType_);
		if (size)
			*size = sizeof(ns1__keywordType_);
		((ns1__keywordType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__keywordType_[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__keywordType_);
		for (int i = 0; i < n; i++)
			((ns1__keywordType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__keywordType_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__keywordType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__keywordType_ %p -> %p\n", q, p));
	*(ns1__keywordType_*)p = *(ns1__keywordType_*)q;
}

void ns1__datafileInclude_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__datafileInclude(soap, &this->ns1__datafileInclude_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datafileInclude_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__datafileInclude_::__item, SOAP_TYPE_ns1__datafileInclude);
	/* transient soap skipped */
}

int ns1__datafileInclude_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datafileInclude_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileInclude_(struct soap *soap, const char *tag, int id, const ns1__datafileInclude_ *a, const char *type)
{
	return soap_out_ns1__datafileInclude(soap, tag, id, &(a->ns1__datafileInclude_::__item), "ns1:datafileInclude");
}

void *ns1__datafileInclude_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datafileInclude_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafileInclude_ * SOAP_FMAC4 soap_in_ns1__datafileInclude_(struct soap *soap, const char *tag, ns1__datafileInclude_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__datafileInclude_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datafileInclude_, sizeof(ns1__datafileInclude_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datafileInclude_)
			return (ns1__datafileInclude_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__datafileInclude(soap, tag, &(a->ns1__datafileInclude_::__item), "ns1:datafileInclude"))
		return NULL;
	return a;
}

int ns1__datafileInclude_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datafileInclude_);
	if (this->soap_out(soap, tag?tag:"ns1:datafileInclude", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datafileInclude_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datafileInclude_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafileInclude_ * SOAP_FMAC4 soap_get_ns1__datafileInclude_(struct soap *soap, ns1__datafileInclude_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datafileInclude_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datafileInclude_ * SOAP_FMAC2 soap_instantiate_ns1__datafileInclude_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafileInclude_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datafileInclude_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileInclude_);
		if (size)
			*size = sizeof(ns1__datafileInclude_);
		((ns1__datafileInclude_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileInclude_[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datafileInclude_);
		for (int i = 0; i < n; i++)
			((ns1__datafileInclude_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datafileInclude_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafileInclude_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafileInclude_ %p -> %p\n", q, p));
	*(ns1__datafileInclude_*)p = *(ns1__datafileInclude_*)q;
}

void ns3__SessionException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__SessionException::message = NULL;
	this->ns3__SessionException::stackTraceAsString = NULL;
	this->ns3__SessionException::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns3__SessionException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns3__SessionException::message);
	soap_serialize_PointerTostd__string(soap, &this->ns3__SessionException::stackTraceAsString);
	soap_serialize_PointerTostd__string(soap, &this->ns3__SessionException::uniqueId);
	/* transient soap skipped */
}

int ns3__SessionException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SessionException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SessionException(struct soap *soap, const char *tag, int id, const ns3__SessionException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SessionException), "ns3:SessionException"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns3__SessionException::message), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stackTraceAsString", -1, &(a->ns3__SessionException::stackTraceAsString), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns3__SessionException::uniqueId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__SessionException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SessionException(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SessionException * SOAP_FMAC4 soap_in_ns3__SessionException(struct soap *soap, const char *tag, ns3__SessionException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SessionException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SessionException, sizeof(ns3__SessionException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__SessionException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__SessionException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_stackTraceAsString1 = 1;
	size_t soap_flag_uniqueId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->ns3__SessionException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_stackTraceAsString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stackTraceAsString", &(a->ns3__SessionException::stackTraceAsString), "xsd:string"))
				{	soap_flag_stackTraceAsString1--;
					continue;
				}
			if (soap_flag_uniqueId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns3__SessionException::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__SessionException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SessionException, 0, sizeof(ns3__SessionException), 0, soap_copy_ns3__SessionException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__SessionException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__SessionException);
	if (this->soap_out(soap, tag?tag:"ns3:SessionException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__SessionException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SessionException(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SessionException * SOAP_FMAC4 soap_get_ns3__SessionException(struct soap *soap, ns3__SessionException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SessionException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__SessionException * SOAP_FMAC2 soap_instantiate_ns3__SessionException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__SessionException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__SessionException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__SessionException);
		if (size)
			*size = sizeof(ns3__SessionException);
		((ns3__SessionException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__SessionException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__SessionException);
		for (int i = 0; i < n; i++)
			((ns3__SessionException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__SessionException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__SessionException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__SessionException %p -> %p\n", q, p));
	*(ns3__SessionException*)p = *(ns3__SessionException*)q;
}

void ns1__getDatasetsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__getDatasetsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatasetsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__getDatasetsResponse::return_);
	/* transient soap skipped */
}

int ns1__getDatasetsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatasetsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatasetsResponse(struct soap *soap, const char *tag, int id, const ns1__getDatasetsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatasetsResponse), "ns1:getDatasetsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "return", -1, &(a->ns1__getDatasetsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatasetsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatasetsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatasetsResponse * SOAP_FMAC4 soap_in_ns1__getDatasetsResponse(struct soap *soap, const char *tag, ns1__getDatasetsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatasetsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatasetsResponse, sizeof(ns1__getDatasetsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatasetsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatasetsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "return", &(a->ns1__getDatasetsResponse::return_), "ns1:dataset"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatasetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatasetsResponse, 0, sizeof(ns1__getDatasetsResponse), 0, soap_copy_ns1__getDatasetsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatasetsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatasetsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDatasetsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatasetsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatasetsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatasetsResponse * SOAP_FMAC4 soap_get_ns1__getDatasetsResponse(struct soap *soap, ns1__getDatasetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatasetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatasetsResponse * SOAP_FMAC2 soap_instantiate_ns1__getDatasetsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatasetsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatasetsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetsResponse);
		if (size)
			*size = sizeof(ns1__getDatasetsResponse);
		((ns1__getDatasetsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatasetsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getDatasetsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatasetsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatasetsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatasetsResponse %p -> %p\n", q, p));
	*(ns1__getDatasetsResponse*)p = *(ns1__getDatasetsResponse*)q;
}

void ns1__getDatasets::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDatasets::sessionId = NULL;
	soap_default_std__vectorTemplateOfLONG64(soap, &this->ns1__getDatasets::datasetIds);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatasets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDatasets::sessionId);
	soap_serialize_std__vectorTemplateOfLONG64(soap, &this->ns1__getDatasets::datasetIds);
	/* transient soap skipped */
}

int ns1__getDatasets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatasets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatasets(struct soap *soap, const char *tag, int id, const ns1__getDatasets *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatasets), "ns1:getDatasets"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getDatasets::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfLONG64(soap, "datasetIds", -1, &(a->ns1__getDatasets::datasetIds), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatasets::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatasets(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatasets * SOAP_FMAC4 soap_in_ns1__getDatasets(struct soap *soap, const char *tag, ns1__getDatasets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatasets *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatasets, sizeof(ns1__getDatasets), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatasets)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatasets *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getDatasets::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "datasetIds", &(a->ns1__getDatasets::datasetIds), "xsd:long"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatasets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatasets, 0, sizeof(ns1__getDatasets), 0, soap_copy_ns1__getDatasets);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatasets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatasets);
	if (this->soap_out(soap, tag?tag:"ns1:getDatasets", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatasets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatasets(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatasets * SOAP_FMAC4 soap_get_ns1__getDatasets(struct soap *soap, ns1__getDatasets *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatasets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatasets * SOAP_FMAC2 soap_instantiate_ns1__getDatasets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatasets(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatasets, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasets);
		if (size)
			*size = sizeof(ns1__getDatasets);
		((ns1__getDatasets*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasets[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatasets);
		for (int i = 0; i < n; i++)
			((ns1__getDatasets*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatasets*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatasets(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatasets %p -> %p\n", q, p));
	*(ns1__getDatasets*)p = *(ns1__getDatasets*)q;
}

void ns1__listParametersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__parameter(soap, &this->ns1__listParametersResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listParametersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__parameter(soap, &this->ns1__listParametersResponse::return_);
	/* transient soap skipped */
}

int ns1__listParametersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listParametersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listParametersResponse(struct soap *soap, const char *tag, int id, const ns1__listParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listParametersResponse), "ns1:listParametersResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__parameter(soap, "return", -1, &(a->ns1__listParametersResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listParametersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listParametersResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listParametersResponse * SOAP_FMAC4 soap_in_ns1__listParametersResponse(struct soap *soap, const char *tag, ns1__listParametersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listParametersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listParametersResponse, sizeof(ns1__listParametersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listParametersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listParametersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__parameter(soap, "return", &(a->ns1__listParametersResponse::return_), "ns1:parameter"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listParametersResponse, 0, sizeof(ns1__listParametersResponse), 0, soap_copy_ns1__listParametersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listParametersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listParametersResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listParametersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listParametersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listParametersResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listParametersResponse * SOAP_FMAC4 soap_get_ns1__listParametersResponse(struct soap *soap, ns1__listParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listParametersResponse * SOAP_FMAC2 soap_instantiate_ns1__listParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listParametersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listParametersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listParametersResponse);
		if (size)
			*size = sizeof(ns1__listParametersResponse);
		((ns1__listParametersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listParametersResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listParametersResponse);
		for (int i = 0; i < n; i++)
			((ns1__listParametersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listParametersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listParametersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listParametersResponse %p -> %p\n", q, p));
	*(ns1__listParametersResponse*)p = *(ns1__listParametersResponse*)q;
}

void ns1__listParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listParameters::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listParameters::sessionId);
	/* transient soap skipped */
}

int ns1__listParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listParameters(struct soap *soap, const char *tag, int id, const ns1__listParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listParameters), "ns1:listParameters"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listParameters::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listParameters * SOAP_FMAC4 soap_in_ns1__listParameters(struct soap *soap, const char *tag, ns1__listParameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listParameters, sizeof(ns1__listParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listParameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listParameters *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listParameters::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listParameters, 0, sizeof(ns1__listParameters), 0, soap_copy_ns1__listParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listParameters);
	if (this->soap_out(soap, tag?tag:"ns1:listParameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listParameters * SOAP_FMAC4 soap_get_ns1__listParameters(struct soap *soap, ns1__listParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listParameters * SOAP_FMAC2 soap_instantiate_ns1__listParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listParameters);
		if (size)
			*size = sizeof(ns1__listParameters);
		((ns1__listParameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listParameters[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listParameters);
		for (int i = 0; i < n; i++)
			((ns1__listParameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listParameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listParameters %p -> %p\n", q, p));
	*(ns1__listParameters*)p = *(ns1__listParameters*)q;
}

void ns1__modifyDataFileParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataFileParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifyDataFileParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataFileParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataFileParameterResponse(struct soap *soap, const char *tag, int id, const ns1__modifyDataFileParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifyDataFileParameterResponse");
}

void *ns1__modifyDataFileParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataFileParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataFileParameterResponse * SOAP_FMAC4 soap_in_ns1__modifyDataFileParameterResponse(struct soap *soap, const char *tag, ns1__modifyDataFileParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifyDataFileParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataFileParameterResponse, sizeof(ns1__modifyDataFileParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataFileParameterResponse)
			return (ns1__modifyDataFileParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifyDataFileParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataFileParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataFileParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataFileParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataFileParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataFileParameterResponse * SOAP_FMAC4 soap_get_ns1__modifyDataFileParameterResponse(struct soap *soap, ns1__modifyDataFileParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataFileParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__modifyDataFileParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataFileParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataFileParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameterResponse);
		if (size)
			*size = sizeof(ns1__modifyDataFileParameterResponse);
		((ns1__modifyDataFileParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataFileParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataFileParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataFileParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataFileParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataFileParameterResponse %p -> %p\n", q, p));
	*(ns1__modifyDataFileParameterResponse*)p = *(ns1__modifyDataFileParameterResponse*)q;
}

void ns1__modifyDataFileParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifyDataFileParameter::sessionId = NULL;
	this->ns1__modifyDataFileParameter::dataFileParameter = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataFileParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifyDataFileParameter::sessionId);
	soap_serialize_PointerTons1__datafileParameter(soap, &this->ns1__modifyDataFileParameter::dataFileParameter);
	/* transient soap skipped */
}

int ns1__modifyDataFileParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataFileParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataFileParameter(struct soap *soap, const char *tag, int id, const ns1__modifyDataFileParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyDataFileParameter), "ns1:modifyDataFileParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifyDataFileParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileParameter(soap, "dataFileParameter", -1, &(a->ns1__modifyDataFileParameter::dataFileParameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifyDataFileParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataFileParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataFileParameter * SOAP_FMAC4 soap_in_ns1__modifyDataFileParameter(struct soap *soap, const char *tag, ns1__modifyDataFileParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifyDataFileParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataFileParameter, sizeof(ns1__modifyDataFileParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataFileParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifyDataFileParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataFileParameter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifyDataFileParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataFileParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileParameter(soap, "dataFileParameter", &(a->ns1__modifyDataFileParameter::dataFileParameter), "ns1:datafileParameter"))
				{	soap_flag_dataFileParameter1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifyDataFileParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyDataFileParameter, 0, sizeof(ns1__modifyDataFileParameter), 0, soap_copy_ns1__modifyDataFileParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifyDataFileParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataFileParameter);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataFileParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataFileParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataFileParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataFileParameter * SOAP_FMAC4 soap_get_ns1__modifyDataFileParameter(struct soap *soap, ns1__modifyDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataFileParameter * SOAP_FMAC2 soap_instantiate_ns1__modifyDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameter);
		if (size)
			*size = sizeof(ns1__modifyDataFileParameter);
		((ns1__modifyDataFileParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataFileParameter);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataFileParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataFileParameter %p -> %p\n", q, p));
	*(ns1__modifyDataFileParameter*)p = *(ns1__modifyDataFileParameter*)q;
}

void ns1__deleteSampleParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteSampleParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteSampleParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteSampleParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteSampleParameterResponse(struct soap *soap, const char *tag, int id, const ns1__deleteSampleParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteSampleParameterResponse");
}

void *ns1__deleteSampleParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteSampleParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteSampleParameterResponse * SOAP_FMAC4 soap_in_ns1__deleteSampleParameterResponse(struct soap *soap, const char *tag, ns1__deleteSampleParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteSampleParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteSampleParameterResponse, sizeof(ns1__deleteSampleParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteSampleParameterResponse)
			return (ns1__deleteSampleParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteSampleParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteSampleParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteSampleParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteSampleParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteSampleParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteSampleParameterResponse * SOAP_FMAC4 soap_get_ns1__deleteSampleParameterResponse(struct soap *soap, ns1__deleteSampleParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteSampleParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteSampleParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteSampleParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteSampleParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameterResponse);
		if (size)
			*size = sizeof(ns1__deleteSampleParameterResponse);
		((ns1__deleteSampleParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteSampleParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteSampleParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteSampleParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteSampleParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteSampleParameterResponse %p -> %p\n", q, p));
	*(ns1__deleteSampleParameterResponse*)p = *(ns1__deleteSampleParameterResponse*)q;
}

void ns1__deleteSampleParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteSampleParameter::sessionId = NULL;
	this->ns1__deleteSampleParameter::sampleParameterPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteSampleParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteSampleParameter::sessionId);
	soap_serialize_PointerTons1__sampleParameterPK(soap, &this->ns1__deleteSampleParameter::sampleParameterPK);
	/* transient soap skipped */
}

int ns1__deleteSampleParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteSampleParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteSampleParameter(struct soap *soap, const char *tag, int id, const ns1__deleteSampleParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteSampleParameter), "ns1:deleteSampleParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteSampleParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__sampleParameterPK(soap, "sampleParameterPK", -1, &(a->ns1__deleteSampleParameter::sampleParameterPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteSampleParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteSampleParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteSampleParameter * SOAP_FMAC4 soap_in_ns1__deleteSampleParameter(struct soap *soap, const char *tag, ns1__deleteSampleParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteSampleParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteSampleParameter, sizeof(ns1__deleteSampleParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteSampleParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteSampleParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleParameterPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteSampleParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sampleParameterPK(soap, "sampleParameterPK", &(a->ns1__deleteSampleParameter::sampleParameterPK), "ns1:sampleParameterPK"))
				{	soap_flag_sampleParameterPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteSampleParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteSampleParameter, 0, sizeof(ns1__deleteSampleParameter), 0, soap_copy_ns1__deleteSampleParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteSampleParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteSampleParameter);
	if (this->soap_out(soap, tag?tag:"ns1:deleteSampleParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteSampleParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteSampleParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteSampleParameter * SOAP_FMAC4 soap_get_ns1__deleteSampleParameter(struct soap *soap, ns1__deleteSampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteSampleParameter * SOAP_FMAC2 soap_instantiate_ns1__deleteSampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteSampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteSampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameter);
		if (size)
			*size = sizeof(ns1__deleteSampleParameter);
		((ns1__deleteSampleParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteSampleParameter);
		for (int i = 0; i < n; i++)
			((ns1__deleteSampleParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteSampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteSampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteSampleParameter %p -> %p\n", q, p));
	*(ns1__deleteSampleParameter*)p = *(ns1__deleteSampleParameter*)q;
}

void ns1__addDataFileParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addDataFileParameterResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataFileParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__datafileParameter(soap, &this->ns1__addDataFileParameterResponse::return_);
	/* transient soap skipped */
}

int ns1__addDataFileParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataFileParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataFileParameterResponse(struct soap *soap, const char *tag, int id, const ns1__addDataFileParameterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataFileParameterResponse), "ns1:addDataFileParameterResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__datafileParameter(soap, "return", -1, &(a->ns1__addDataFileParameterResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataFileParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataFileParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataFileParameterResponse * SOAP_FMAC4 soap_in_ns1__addDataFileParameterResponse(struct soap *soap, const char *tag, ns1__addDataFileParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataFileParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataFileParameterResponse, sizeof(ns1__addDataFileParameterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataFileParameterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataFileParameterResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileParameter(soap, "return", &(a->ns1__addDataFileParameterResponse::return_), "ns1:datafileParameter"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataFileParameterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataFileParameterResponse, 0, sizeof(ns1__addDataFileParameterResponse), 0, soap_copy_ns1__addDataFileParameterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataFileParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataFileParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addDataFileParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataFileParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataFileParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataFileParameterResponse * SOAP_FMAC4 soap_get_ns1__addDataFileParameterResponse(struct soap *soap, ns1__addDataFileParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataFileParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__addDataFileParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataFileParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataFileParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameterResponse);
		if (size)
			*size = sizeof(ns1__addDataFileParameterResponse);
		((ns1__addDataFileParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataFileParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__addDataFileParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataFileParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataFileParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataFileParameterResponse %p -> %p\n", q, p));
	*(ns1__addDataFileParameterResponse*)p = *(ns1__addDataFileParameterResponse*)q;
}

void ns1__addDataFileParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addDataFileParameter::sessionId = NULL;
	this->ns1__addDataFileParameter::dataFileParameter = NULL;
	this->ns1__addDataFileParameter::datafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataFileParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addDataFileParameter::sessionId);
	soap_serialize_PointerTons1__datafileParameter(soap, &this->ns1__addDataFileParameter::dataFileParameter);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addDataFileParameter::datafileId);
	/* transient soap skipped */
}

int ns1__addDataFileParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataFileParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataFileParameter(struct soap *soap, const char *tag, int id, const ns1__addDataFileParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataFileParameter), "ns1:addDataFileParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addDataFileParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileParameter(soap, "dataFileParameter", -1, &(a->ns1__addDataFileParameter::dataFileParameter), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__addDataFileParameter::datafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataFileParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataFileParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataFileParameter * SOAP_FMAC4 soap_in_ns1__addDataFileParameter(struct soap *soap, const char *tag, ns1__addDataFileParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataFileParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataFileParameter, sizeof(ns1__addDataFileParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataFileParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataFileParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataFileParameter1 = 1;
	size_t soap_flag_datafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addDataFileParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataFileParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileParameter(soap, "dataFileParameter", &(a->ns1__addDataFileParameter::dataFileParameter), "ns1:datafileParameter"))
				{	soap_flag_dataFileParameter1--;
					continue;
				}
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__addDataFileParameter::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataFileParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataFileParameter, 0, sizeof(ns1__addDataFileParameter), 0, soap_copy_ns1__addDataFileParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataFileParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataFileParameter);
	if (this->soap_out(soap, tag?tag:"ns1:addDataFileParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataFileParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataFileParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataFileParameter * SOAP_FMAC4 soap_get_ns1__addDataFileParameter(struct soap *soap, ns1__addDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataFileParameter * SOAP_FMAC2 soap_instantiate_ns1__addDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameter);
		if (size)
			*size = sizeof(ns1__addDataFileParameter);
		((ns1__addDataFileParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataFileParameter);
		for (int i = 0; i < n; i++)
			((ns1__addDataFileParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataFileParameter %p -> %p\n", q, p));
	*(ns1__addDataFileParameter*)p = *(ns1__addDataFileParameter*)q;
}

void ns1__searchDatasetsBySampleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__searchDatasetsBySampleResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchDatasetsBySampleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__searchDatasetsBySampleResponse::return_);
	/* transient soap skipped */
}

int ns1__searchDatasetsBySampleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchDatasetsBySampleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchDatasetsBySampleResponse(struct soap *soap, const char *tag, int id, const ns1__searchDatasetsBySampleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchDatasetsBySampleResponse), "ns1:searchDatasetsBySampleResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "return", -1, &(a->ns1__searchDatasetsBySampleResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchDatasetsBySampleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchDatasetsBySampleResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchDatasetsBySampleResponse * SOAP_FMAC4 soap_in_ns1__searchDatasetsBySampleResponse(struct soap *soap, const char *tag, ns1__searchDatasetsBySampleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchDatasetsBySampleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchDatasetsBySampleResponse, sizeof(ns1__searchDatasetsBySampleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchDatasetsBySampleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchDatasetsBySampleResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "return", &(a->ns1__searchDatasetsBySampleResponse::return_), "ns1:dataset"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchDatasetsBySampleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchDatasetsBySampleResponse, 0, sizeof(ns1__searchDatasetsBySampleResponse), 0, soap_copy_ns1__searchDatasetsBySampleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchDatasetsBySampleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchDatasetsBySampleResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchDatasetsBySampleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchDatasetsBySampleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchDatasetsBySampleResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchDatasetsBySampleResponse * SOAP_FMAC4 soap_get_ns1__searchDatasetsBySampleResponse(struct soap *soap, ns1__searchDatasetsBySampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchDatasetsBySampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchDatasetsBySampleResponse * SOAP_FMAC2 soap_instantiate_ns1__searchDatasetsBySampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchDatasetsBySampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchDatasetsBySampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySampleResponse);
		if (size)
			*size = sizeof(ns1__searchDatasetsBySampleResponse);
		((ns1__searchDatasetsBySampleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchDatasetsBySampleResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchDatasetsBySampleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchDatasetsBySampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchDatasetsBySampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchDatasetsBySampleResponse %p -> %p\n", q, p));
	*(ns1__searchDatasetsBySampleResponse*)p = *(ns1__searchDatasetsBySampleResponse*)q;
}

void ns1__searchDatasetsBySample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchDatasetsBySample::sessionId = NULL;
	this->ns1__searchDatasetsBySample::sample = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchDatasetsBySample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchDatasetsBySample::sessionId);
	soap_serialize_PointerTons1__sample(soap, &this->ns1__searchDatasetsBySample::sample);
	/* transient soap skipped */
}

int ns1__searchDatasetsBySample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchDatasetsBySample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchDatasetsBySample(struct soap *soap, const char *tag, int id, const ns1__searchDatasetsBySample *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchDatasetsBySample), "ns1:searchDatasetsBySample"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchDatasetsBySample::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__sample(soap, "sample", -1, &(a->ns1__searchDatasetsBySample::sample), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchDatasetsBySample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchDatasetsBySample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchDatasetsBySample * SOAP_FMAC4 soap_in_ns1__searchDatasetsBySample(struct soap *soap, const char *tag, ns1__searchDatasetsBySample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchDatasetsBySample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchDatasetsBySample, sizeof(ns1__searchDatasetsBySample), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchDatasetsBySample)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchDatasetsBySample *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sample1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchDatasetsBySample::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sample1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sample(soap, "sample", &(a->ns1__searchDatasetsBySample::sample), "ns1:sample"))
				{	soap_flag_sample1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchDatasetsBySample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchDatasetsBySample, 0, sizeof(ns1__searchDatasetsBySample), 0, soap_copy_ns1__searchDatasetsBySample);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchDatasetsBySample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchDatasetsBySample);
	if (this->soap_out(soap, tag?tag:"ns1:searchDatasetsBySample", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchDatasetsBySample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchDatasetsBySample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchDatasetsBySample * SOAP_FMAC4 soap_get_ns1__searchDatasetsBySample(struct soap *soap, ns1__searchDatasetsBySample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchDatasetsBySample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchDatasetsBySample * SOAP_FMAC2 soap_instantiate_ns1__searchDatasetsBySample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchDatasetsBySample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchDatasetsBySample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySample);
		if (size)
			*size = sizeof(ns1__searchDatasetsBySample);
		((ns1__searchDatasetsBySample*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchDatasetsBySample);
		for (int i = 0; i < n; i++)
			((ns1__searchDatasetsBySample*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchDatasetsBySample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchDatasetsBySample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchDatasetsBySample %p -> %p\n", q, p));
	*(ns1__searchDatasetsBySample*)p = *(ns1__searchDatasetsBySample*)q;
}

void ns1__addPublicationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addPublicationResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addPublicationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__publication(soap, &this->ns1__addPublicationResponse::return_);
	/* transient soap skipped */
}

int ns1__addPublicationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addPublicationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addPublicationResponse(struct soap *soap, const char *tag, int id, const ns1__addPublicationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addPublicationResponse), "ns1:addPublicationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__publication(soap, "return", -1, &(a->ns1__addPublicationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addPublicationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addPublicationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addPublicationResponse * SOAP_FMAC4 soap_in_ns1__addPublicationResponse(struct soap *soap, const char *tag, ns1__addPublicationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addPublicationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addPublicationResponse, sizeof(ns1__addPublicationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addPublicationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addPublicationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__publication(soap, "return", &(a->ns1__addPublicationResponse::return_), "ns1:publication"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addPublicationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addPublicationResponse, 0, sizeof(ns1__addPublicationResponse), 0, soap_copy_ns1__addPublicationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addPublicationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addPublicationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addPublicationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addPublicationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addPublicationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addPublicationResponse * SOAP_FMAC4 soap_get_ns1__addPublicationResponse(struct soap *soap, ns1__addPublicationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addPublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addPublicationResponse * SOAP_FMAC2 soap_instantiate_ns1__addPublicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addPublicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addPublicationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addPublicationResponse);
		if (size)
			*size = sizeof(ns1__addPublicationResponse);
		((ns1__addPublicationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addPublicationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addPublicationResponse);
		for (int i = 0; i < n; i++)
			((ns1__addPublicationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addPublicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addPublicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addPublicationResponse %p -> %p\n", q, p));
	*(ns1__addPublicationResponse*)p = *(ns1__addPublicationResponse*)q;
}

void ns1__addPublication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addPublication::sessionId = NULL;
	this->ns1__addPublication::publication = NULL;
	this->ns1__addPublication::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addPublication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addPublication::sessionId);
	soap_serialize_PointerTons1__publication(soap, &this->ns1__addPublication::publication);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addPublication::investigationId);
	/* transient soap skipped */
}

int ns1__addPublication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addPublication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addPublication(struct soap *soap, const char *tag, int id, const ns1__addPublication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addPublication), "ns1:addPublication"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addPublication::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__publication(soap, "publication", -1, &(a->ns1__addPublication::publication), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__addPublication::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addPublication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addPublication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addPublication * SOAP_FMAC4 soap_in_ns1__addPublication(struct soap *soap, const char *tag, ns1__addPublication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addPublication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addPublication, sizeof(ns1__addPublication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addPublication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addPublication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_publication1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addPublication::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_publication1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__publication(soap, "publication", &(a->ns1__addPublication::publication), "ns1:publication"))
				{	soap_flag_publication1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__addPublication::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addPublication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addPublication, 0, sizeof(ns1__addPublication), 0, soap_copy_ns1__addPublication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addPublication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addPublication);
	if (this->soap_out(soap, tag?tag:"ns1:addPublication", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addPublication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addPublication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addPublication * SOAP_FMAC4 soap_get_ns1__addPublication(struct soap *soap, ns1__addPublication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addPublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addPublication * SOAP_FMAC2 soap_instantiate_ns1__addPublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addPublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addPublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addPublication);
		if (size)
			*size = sizeof(ns1__addPublication);
		((ns1__addPublication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addPublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addPublication);
		for (int i = 0; i < n; i++)
			((ns1__addPublication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addPublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addPublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addPublication %p -> %p\n", q, p));
	*(ns1__addPublication*)p = *(ns1__addPublication*)q;
}

void ns1__createInvestigationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createInvestigationResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createInvestigationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__investigation(soap, &this->ns1__createInvestigationResponse::return_);
	/* transient soap skipped */
}

int ns1__createInvestigationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createInvestigationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createInvestigationResponse(struct soap *soap, const char *tag, int id, const ns1__createInvestigationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createInvestigationResponse), "ns1:createInvestigationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__investigation(soap, "return", -1, &(a->ns1__createInvestigationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createInvestigationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createInvestigationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createInvestigationResponse * SOAP_FMAC4 soap_in_ns1__createInvestigationResponse(struct soap *soap, const char *tag, ns1__createInvestigationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createInvestigationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createInvestigationResponse, sizeof(ns1__createInvestigationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createInvestigationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createInvestigationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigation(soap, "return", &(a->ns1__createInvestigationResponse::return_), "ns1:investigation"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createInvestigationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createInvestigationResponse, 0, sizeof(ns1__createInvestigationResponse), 0, soap_copy_ns1__createInvestigationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createInvestigationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createInvestigationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:createInvestigationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createInvestigationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createInvestigationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createInvestigationResponse * SOAP_FMAC4 soap_get_ns1__createInvestigationResponse(struct soap *soap, ns1__createInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createInvestigationResponse * SOAP_FMAC2 soap_instantiate_ns1__createInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigationResponse);
		if (size)
			*size = sizeof(ns1__createInvestigationResponse);
		((ns1__createInvestigationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createInvestigationResponse);
		for (int i = 0; i < n; i++)
			((ns1__createInvestigationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createInvestigationResponse %p -> %p\n", q, p));
	*(ns1__createInvestigationResponse*)p = *(ns1__createInvestigationResponse*)q;
}

void ns1__createInvestigation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createInvestigation::sessionId = NULL;
	this->ns1__createInvestigation::investigation = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createInvestigation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__createInvestigation::sessionId);
	soap_serialize_PointerTons1__investigation(soap, &this->ns1__createInvestigation::investigation);
	/* transient soap skipped */
}

int ns1__createInvestigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createInvestigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createInvestigation(struct soap *soap, const char *tag, int id, const ns1__createInvestigation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createInvestigation), "ns1:createInvestigation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__createInvestigation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__createInvestigation::investigation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createInvestigation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createInvestigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createInvestigation * SOAP_FMAC4 soap_in_ns1__createInvestigation(struct soap *soap, const char *tag, ns1__createInvestigation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createInvestigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createInvestigation, sizeof(ns1__createInvestigation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createInvestigation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createInvestigation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__createInvestigation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__createInvestigation::investigation), "ns1:investigation"))
				{	soap_flag_investigation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createInvestigation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createInvestigation, 0, sizeof(ns1__createInvestigation), 0, soap_copy_ns1__createInvestigation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createInvestigation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createInvestigation);
	if (this->soap_out(soap, tag?tag:"ns1:createInvestigation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createInvestigation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createInvestigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createInvestigation * SOAP_FMAC4 soap_get_ns1__createInvestigation(struct soap *soap, ns1__createInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createInvestigation * SOAP_FMAC2 soap_instantiate_ns1__createInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigation);
		if (size)
			*size = sizeof(ns1__createInvestigation);
		((ns1__createInvestigation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createInvestigation);
		for (int i = 0; i < n; i++)
			((ns1__createInvestigation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createInvestigation %p -> %p\n", q, p));
	*(ns1__createInvestigation*)p = *(ns1__createInvestigation*)q;
}

void ns1__deleteDataFileParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataFileParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteDataFileParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataFileParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataFileParameterResponse(struct soap *soap, const char *tag, int id, const ns1__deleteDataFileParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteDataFileParameterResponse");
}

void *ns1__deleteDataFileParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataFileParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataFileParameterResponse * SOAP_FMAC4 soap_in_ns1__deleteDataFileParameterResponse(struct soap *soap, const char *tag, ns1__deleteDataFileParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteDataFileParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataFileParameterResponse, sizeof(ns1__deleteDataFileParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataFileParameterResponse)
			return (ns1__deleteDataFileParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteDataFileParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataFileParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataFileParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataFileParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataFileParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataFileParameterResponse * SOAP_FMAC4 soap_get_ns1__deleteDataFileParameterResponse(struct soap *soap, ns1__deleteDataFileParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataFileParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteDataFileParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataFileParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataFileParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameterResponse);
		if (size)
			*size = sizeof(ns1__deleteDataFileParameterResponse);
		((ns1__deleteDataFileParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataFileParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataFileParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataFileParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataFileParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataFileParameterResponse %p -> %p\n", q, p));
	*(ns1__deleteDataFileParameterResponse*)p = *(ns1__deleteDataFileParameterResponse*)q;
}

void ns1__deleteDataFileParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteDataFileParameter::sessionId = NULL;
	this->ns1__deleteDataFileParameter::datafileParameterPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataFileParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteDataFileParameter::sessionId);
	soap_serialize_PointerTons1__datafileParameterPK(soap, &this->ns1__deleteDataFileParameter::datafileParameterPK);
	/* transient soap skipped */
}

int ns1__deleteDataFileParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataFileParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataFileParameter(struct soap *soap, const char *tag, int id, const ns1__deleteDataFileParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDataFileParameter), "ns1:deleteDataFileParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteDataFileParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileParameterPK(soap, "datafileParameterPK", -1, &(a->ns1__deleteDataFileParameter::datafileParameterPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteDataFileParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataFileParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataFileParameter * SOAP_FMAC4 soap_in_ns1__deleteDataFileParameter(struct soap *soap, const char *tag, ns1__deleteDataFileParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteDataFileParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataFileParameter, sizeof(ns1__deleteDataFileParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataFileParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteDataFileParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datafileParameterPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteDataFileParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datafileParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileParameterPK(soap, "datafileParameterPK", &(a->ns1__deleteDataFileParameter::datafileParameterPK), "ns1:datafileParameterPK"))
				{	soap_flag_datafileParameterPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteDataFileParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDataFileParameter, 0, sizeof(ns1__deleteDataFileParameter), 0, soap_copy_ns1__deleteDataFileParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteDataFileParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataFileParameter);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataFileParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataFileParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataFileParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataFileParameter * SOAP_FMAC4 soap_get_ns1__deleteDataFileParameter(struct soap *soap, ns1__deleteDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataFileParameter * SOAP_FMAC2 soap_instantiate_ns1__deleteDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameter);
		if (size)
			*size = sizeof(ns1__deleteDataFileParameter);
		((ns1__deleteDataFileParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataFileParameter);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataFileParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataFileParameter %p -> %p\n", q, p));
	*(ns1__deleteDataFileParameter*)p = *(ns1__deleteDataFileParameter*)q;
}

void ns1__getInvestigationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getInvestigationResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getInvestigationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__investigation(soap, &this->ns1__getInvestigationResponse::return_);
	/* transient soap skipped */
}

int ns1__getInvestigationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getInvestigationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getInvestigationResponse(struct soap *soap, const char *tag, int id, const ns1__getInvestigationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getInvestigationResponse), "ns1:getInvestigationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__investigation(soap, "return", -1, &(a->ns1__getInvestigationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getInvestigationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getInvestigationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getInvestigationResponse * SOAP_FMAC4 soap_in_ns1__getInvestigationResponse(struct soap *soap, const char *tag, ns1__getInvestigationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getInvestigationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getInvestigationResponse, sizeof(ns1__getInvestigationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getInvestigationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getInvestigationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigation(soap, "return", &(a->ns1__getInvestigationResponse::return_), "ns1:investigation"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getInvestigationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getInvestigationResponse, 0, sizeof(ns1__getInvestigationResponse), 0, soap_copy_ns1__getInvestigationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getInvestigationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getInvestigationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getInvestigationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getInvestigationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getInvestigationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getInvestigationResponse * SOAP_FMAC4 soap_get_ns1__getInvestigationResponse(struct soap *soap, ns1__getInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getInvestigationResponse * SOAP_FMAC2 soap_instantiate_ns1__getInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationResponse);
		if (size)
			*size = sizeof(ns1__getInvestigationResponse);
		((ns1__getInvestigationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getInvestigationResponse);
		for (int i = 0; i < n; i++)
			((ns1__getInvestigationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getInvestigationResponse %p -> %p\n", q, p));
	*(ns1__getInvestigationResponse*)p = *(ns1__getInvestigationResponse*)q;
}

void ns1__getInvestigation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getInvestigation::sessionId = NULL;
	this->ns1__getInvestigation::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getInvestigation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getInvestigation::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getInvestigation::investigationId);
	/* transient soap skipped */
}

int ns1__getInvestigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getInvestigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getInvestigation(struct soap *soap, const char *tag, int id, const ns1__getInvestigation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getInvestigation), "ns1:getInvestigation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getInvestigation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__getInvestigation::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getInvestigation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getInvestigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getInvestigation * SOAP_FMAC4 soap_in_ns1__getInvestigation(struct soap *soap, const char *tag, ns1__getInvestigation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getInvestigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getInvestigation, sizeof(ns1__getInvestigation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getInvestigation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getInvestigation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getInvestigation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__getInvestigation::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getInvestigation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getInvestigation, 0, sizeof(ns1__getInvestigation), 0, soap_copy_ns1__getInvestigation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getInvestigation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getInvestigation);
	if (this->soap_out(soap, tag?tag:"ns1:getInvestigation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getInvestigation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getInvestigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getInvestigation * SOAP_FMAC4 soap_get_ns1__getInvestigation(struct soap *soap, ns1__getInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getInvestigation * SOAP_FMAC2 soap_instantiate_ns1__getInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigation);
		if (size)
			*size = sizeof(ns1__getInvestigation);
		((ns1__getInvestigation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getInvestigation);
		for (int i = 0; i < n; i++)
			((ns1__getInvestigation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getInvestigation %p -> %p\n", q, p));
	*(ns1__getInvestigation*)p = *(ns1__getInvestigation*)q;
}

void ns1__getInvestigationIncludesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getInvestigationIncludesResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getInvestigationIncludesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__investigation(soap, &this->ns1__getInvestigationIncludesResponse::return_);
	/* transient soap skipped */
}

int ns1__getInvestigationIncludesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getInvestigationIncludesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getInvestigationIncludesResponse(struct soap *soap, const char *tag, int id, const ns1__getInvestigationIncludesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getInvestigationIncludesResponse), "ns1:getInvestigationIncludesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__investigation(soap, "return", -1, &(a->ns1__getInvestigationIncludesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getInvestigationIncludesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getInvestigationIncludesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getInvestigationIncludesResponse * SOAP_FMAC4 soap_in_ns1__getInvestigationIncludesResponse(struct soap *soap, const char *tag, ns1__getInvestigationIncludesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getInvestigationIncludesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getInvestigationIncludesResponse, sizeof(ns1__getInvestigationIncludesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getInvestigationIncludesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getInvestigationIncludesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigation(soap, "return", &(a->ns1__getInvestigationIncludesResponse::return_), "ns1:investigation"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getInvestigationIncludesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getInvestigationIncludesResponse, 0, sizeof(ns1__getInvestigationIncludesResponse), 0, soap_copy_ns1__getInvestigationIncludesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getInvestigationIncludesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getInvestigationIncludesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getInvestigationIncludesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getInvestigationIncludesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getInvestigationIncludesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getInvestigationIncludesResponse * SOAP_FMAC4 soap_get_ns1__getInvestigationIncludesResponse(struct soap *soap, ns1__getInvestigationIncludesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getInvestigationIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getInvestigationIncludesResponse * SOAP_FMAC2 soap_instantiate_ns1__getInvestigationIncludesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getInvestigationIncludesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getInvestigationIncludesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludesResponse);
		if (size)
			*size = sizeof(ns1__getInvestigationIncludesResponse);
		((ns1__getInvestigationIncludesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getInvestigationIncludesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getInvestigationIncludesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getInvestigationIncludesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getInvestigationIncludesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getInvestigationIncludesResponse %p -> %p\n", q, p));
	*(ns1__getInvestigationIncludesResponse*)p = *(ns1__getInvestigationIncludesResponse*)q;
}

void ns1__getInvestigationIncludes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getInvestigationIncludes::sessionId = NULL;
	this->ns1__getInvestigationIncludes::investigationId = NULL;
	this->ns1__getInvestigationIncludes::investigationInclude = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getInvestigationIncludes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getInvestigationIncludes::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getInvestigationIncludes::investigationId);
	soap_serialize_PointerTons1__investigationInclude(soap, &this->ns1__getInvestigationIncludes::investigationInclude);
	/* transient soap skipped */
}

int ns1__getInvestigationIncludes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getInvestigationIncludes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getInvestigationIncludes(struct soap *soap, const char *tag, int id, const ns1__getInvestigationIncludes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getInvestigationIncludes), "ns1:getInvestigationIncludes"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getInvestigationIncludes::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__getInvestigationIncludes::investigationId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigationInclude(soap, "investigationInclude", -1, &(a->ns1__getInvestigationIncludes::investigationInclude), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getInvestigationIncludes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getInvestigationIncludes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getInvestigationIncludes * SOAP_FMAC4 soap_in_ns1__getInvestigationIncludes(struct soap *soap, const char *tag, ns1__getInvestigationIncludes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getInvestigationIncludes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getInvestigationIncludes, sizeof(ns1__getInvestigationIncludes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getInvestigationIncludes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getInvestigationIncludes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigationId1 = 1;
	size_t soap_flag_investigationInclude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getInvestigationIncludes::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__getInvestigationIncludes::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag_investigationInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigationInclude(soap, "investigationInclude", &(a->ns1__getInvestigationIncludes::investigationInclude), "ns1:investigationInclude"))
				{	soap_flag_investigationInclude1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getInvestigationIncludes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getInvestigationIncludes, 0, sizeof(ns1__getInvestigationIncludes), 0, soap_copy_ns1__getInvestigationIncludes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getInvestigationIncludes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getInvestigationIncludes);
	if (this->soap_out(soap, tag?tag:"ns1:getInvestigationIncludes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getInvestigationIncludes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getInvestigationIncludes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getInvestigationIncludes * SOAP_FMAC4 soap_get_ns1__getInvestigationIncludes(struct soap *soap, ns1__getInvestigationIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getInvestigationIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getInvestigationIncludes * SOAP_FMAC2 soap_instantiate_ns1__getInvestigationIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getInvestigationIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getInvestigationIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludes);
		if (size)
			*size = sizeof(ns1__getInvestigationIncludes);
		((ns1__getInvestigationIncludes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getInvestigationIncludes);
		for (int i = 0; i < n; i++)
			((ns1__getInvestigationIncludes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getInvestigationIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getInvestigationIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getInvestigationIncludes %p -> %p\n", q, p));
	*(ns1__getInvestigationIncludes*)p = *(ns1__getInvestigationIncludes*)q;
}

void ns1__modifyDataFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifyDataFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataFileResponse(struct soap *soap, const char *tag, int id, const ns1__modifyDataFileResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifyDataFileResponse");
}

void *ns1__modifyDataFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataFileResponse * SOAP_FMAC4 soap_in_ns1__modifyDataFileResponse(struct soap *soap, const char *tag, ns1__modifyDataFileResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifyDataFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataFileResponse, sizeof(ns1__modifyDataFileResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataFileResponse)
			return (ns1__modifyDataFileResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifyDataFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataFileResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataFileResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataFileResponse * SOAP_FMAC4 soap_get_ns1__modifyDataFileResponse(struct soap *soap, ns1__modifyDataFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataFileResponse * SOAP_FMAC2 soap_instantiate_ns1__modifyDataFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileResponse);
		if (size)
			*size = sizeof(ns1__modifyDataFileResponse);
		((ns1__modifyDataFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataFileResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataFileResponse %p -> %p\n", q, p));
	*(ns1__modifyDataFileResponse*)p = *(ns1__modifyDataFileResponse*)q;
}

void ns1__modifyDataFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifyDataFile::sessionId = NULL;
	this->ns1__modifyDataFile::dataFile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifyDataFile::sessionId);
	soap_serialize_PointerTons1__datafile(soap, &this->ns1__modifyDataFile::dataFile);
	/* transient soap skipped */
}

int ns1__modifyDataFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataFile(struct soap *soap, const char *tag, int id, const ns1__modifyDataFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyDataFile), "ns1:modifyDataFile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifyDataFile::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafile(soap, "dataFile", -1, &(a->ns1__modifyDataFile::dataFile), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifyDataFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataFile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataFile * SOAP_FMAC4 soap_in_ns1__modifyDataFile(struct soap *soap, const char *tag, ns1__modifyDataFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifyDataFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataFile, sizeof(ns1__modifyDataFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifyDataFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifyDataFile::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataFile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafile(soap, "dataFile", &(a->ns1__modifyDataFile::dataFile), "ns1:datafile"))
				{	soap_flag_dataFile1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifyDataFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyDataFile, 0, sizeof(ns1__modifyDataFile), 0, soap_copy_ns1__modifyDataFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifyDataFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataFile);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataFile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataFile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataFile * SOAP_FMAC4 soap_get_ns1__modifyDataFile(struct soap *soap, ns1__modifyDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataFile * SOAP_FMAC2 soap_instantiate_ns1__modifyDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFile);
		if (size)
			*size = sizeof(ns1__modifyDataFile);
		((ns1__modifyDataFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataFile);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataFile %p -> %p\n", q, p));
	*(ns1__modifyDataFile*)p = *(ns1__modifyDataFile*)q;
}

void ns1__getDatafileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDatafileResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatafileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__datafile(soap, &this->ns1__getDatafileResponse::return_);
	/* transient soap skipped */
}

int ns1__getDatafileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatafileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatafileResponse(struct soap *soap, const char *tag, int id, const ns1__getDatafileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatafileResponse), "ns1:getDatafileResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__datafile(soap, "return", -1, &(a->ns1__getDatafileResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatafileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatafileResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatafileResponse * SOAP_FMAC4 soap_in_ns1__getDatafileResponse(struct soap *soap, const char *tag, ns1__getDatafileResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatafileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatafileResponse, sizeof(ns1__getDatafileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatafileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatafileResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafile(soap, "return", &(a->ns1__getDatafileResponse::return_), "ns1:datafile"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatafileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatafileResponse, 0, sizeof(ns1__getDatafileResponse), 0, soap_copy_ns1__getDatafileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatafileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatafileResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDatafileResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatafileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatafileResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatafileResponse * SOAP_FMAC4 soap_get_ns1__getDatafileResponse(struct soap *soap, ns1__getDatafileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatafileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatafileResponse * SOAP_FMAC2 soap_instantiate_ns1__getDatafileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatafileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatafileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafileResponse);
		if (size)
			*size = sizeof(ns1__getDatafileResponse);
		((ns1__getDatafileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatafileResponse);
		for (int i = 0; i < n; i++)
			((ns1__getDatafileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatafileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatafileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatafileResponse %p -> %p\n", q, p));
	*(ns1__getDatafileResponse*)p = *(ns1__getDatafileResponse*)q;
}

void ns1__getDatafile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDatafile::sessionId = NULL;
	this->ns1__getDatafile::datafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatafile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDatafile::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getDatafile::datafileId);
	/* transient soap skipped */
}

int ns1__getDatafile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatafile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatafile(struct soap *soap, const char *tag, int id, const ns1__getDatafile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatafile), "ns1:getDatafile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getDatafile::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__getDatafile::datafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatafile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatafile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatafile * SOAP_FMAC4 soap_in_ns1__getDatafile(struct soap *soap, const char *tag, ns1__getDatafile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatafile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatafile, sizeof(ns1__getDatafile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatafile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatafile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getDatafile::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__getDatafile::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatafile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatafile, 0, sizeof(ns1__getDatafile), 0, soap_copy_ns1__getDatafile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatafile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatafile);
	if (this->soap_out(soap, tag?tag:"ns1:getDatafile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatafile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatafile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatafile * SOAP_FMAC4 soap_get_ns1__getDatafile(struct soap *soap, ns1__getDatafile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatafile * SOAP_FMAC2 soap_instantiate_ns1__getDatafile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatafile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatafile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafile);
		if (size)
			*size = sizeof(ns1__getDatafile);
		((ns1__getDatafile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatafile);
		for (int i = 0; i < n; i++)
			((ns1__getDatafile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatafile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatafile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatafile %p -> %p\n", q, p));
	*(ns1__getDatafile*)p = *(ns1__getDatafile*)q;
}

void ns1__ICATAPIException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ICATAPIException::message = NULL;
	this->ns1__ICATAPIException::stackTraceAsString = NULL;
	this->ns1__ICATAPIException::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ICATAPIException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ICATAPIException::message);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ICATAPIException::stackTraceAsString);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ICATAPIException::uniqueId);
	/* transient soap skipped */
}

int ns1__ICATAPIException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ICATAPIException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ICATAPIException(struct soap *soap, const char *tag, int id, const ns1__ICATAPIException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ICATAPIException), "ns1:ICATAPIException"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns1__ICATAPIException::message), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stackTraceAsString", -1, &(a->ns1__ICATAPIException::stackTraceAsString), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__ICATAPIException::uniqueId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ICATAPIException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ICATAPIException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ICATAPIException * SOAP_FMAC4 soap_in_ns1__ICATAPIException(struct soap *soap, const char *tag, ns1__ICATAPIException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ICATAPIException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ICATAPIException, sizeof(ns1__ICATAPIException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ICATAPIException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ICATAPIException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_stackTraceAsString1 = 1;
	size_t soap_flag_uniqueId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->ns1__ICATAPIException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_stackTraceAsString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stackTraceAsString", &(a->ns1__ICATAPIException::stackTraceAsString), "xsd:string"))
				{	soap_flag_stackTraceAsString1--;
					continue;
				}
			if (soap_flag_uniqueId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__ICATAPIException::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ICATAPIException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ICATAPIException, 0, sizeof(ns1__ICATAPIException), 0, soap_copy_ns1__ICATAPIException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ICATAPIException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ICATAPIException);
	if (this->soap_out(soap, tag?tag:"ns1:ICATAPIException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ICATAPIException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ICATAPIException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ICATAPIException * SOAP_FMAC4 soap_get_ns1__ICATAPIException(struct soap *soap, ns1__ICATAPIException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ICATAPIException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ICATAPIException * SOAP_FMAC2 soap_instantiate_ns1__ICATAPIException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ICATAPIException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ICATAPIException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ICATAPIException);
		if (size)
			*size = sizeof(ns1__ICATAPIException);
		((ns1__ICATAPIException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ICATAPIException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ICATAPIException);
		for (int i = 0; i < n; i++)
			((ns1__ICATAPIException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ICATAPIException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ICATAPIException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ICATAPIException %p -> %p\n", q, p));
	*(ns1__ICATAPIException*)p = *(ns1__ICATAPIException*)q;
}

void ns1__ingestMetadataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfLONG64(soap, &this->ns1__ingestMetadataResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ingestMetadataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfLONG64(soap, &this->ns1__ingestMetadataResponse::return_);
	/* transient soap skipped */
}

int ns1__ingestMetadataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ingestMetadataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ingestMetadataResponse(struct soap *soap, const char *tag, int id, const ns1__ingestMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ingestMetadataResponse), "ns1:ingestMetadataResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfLONG64(soap, "return", -1, &(a->ns1__ingestMetadataResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ingestMetadataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ingestMetadataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ingestMetadataResponse * SOAP_FMAC4 soap_in_ns1__ingestMetadataResponse(struct soap *soap, const char *tag, ns1__ingestMetadataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ingestMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ingestMetadataResponse, sizeof(ns1__ingestMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ingestMetadataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ingestMetadataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "return", &(a->ns1__ingestMetadataResponse::return_), "xsd:long"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ingestMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ingestMetadataResponse, 0, sizeof(ns1__ingestMetadataResponse), 0, soap_copy_ns1__ingestMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ingestMetadataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ingestMetadataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ingestMetadataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ingestMetadataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ingestMetadataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ingestMetadataResponse * SOAP_FMAC4 soap_get_ns1__ingestMetadataResponse(struct soap *soap, ns1__ingestMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ingestMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ingestMetadataResponse * SOAP_FMAC2 soap_instantiate_ns1__ingestMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ingestMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ingestMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadataResponse);
		if (size)
			*size = sizeof(ns1__ingestMetadataResponse);
		((ns1__ingestMetadataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ingestMetadataResponse);
		for (int i = 0; i < n; i++)
			((ns1__ingestMetadataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ingestMetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ingestMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ingestMetadataResponse %p -> %p\n", q, p));
	*(ns1__ingestMetadataResponse*)p = *(ns1__ingestMetadataResponse*)q;
}

void ns1__ingestMetadata::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ingestMetadata::sessionId = NULL;
	this->ns1__ingestMetadata::xml = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ingestMetadata::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ingestMetadata::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ingestMetadata::xml);
	/* transient soap skipped */
}

int ns1__ingestMetadata::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ingestMetadata(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ingestMetadata(struct soap *soap, const char *tag, int id, const ns1__ingestMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ingestMetadata), "ns1:ingestMetadata"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__ingestMetadata::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "xml", -1, &(a->ns1__ingestMetadata::xml), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ingestMetadata::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ingestMetadata(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ingestMetadata * SOAP_FMAC4 soap_in_ns1__ingestMetadata(struct soap *soap, const char *tag, ns1__ingestMetadata *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ingestMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ingestMetadata, sizeof(ns1__ingestMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ingestMetadata)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ingestMetadata *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_xml1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__ingestMetadata::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_xml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "xml", &(a->ns1__ingestMetadata::xml), "xsd:string"))
				{	soap_flag_xml1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ingestMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ingestMetadata, 0, sizeof(ns1__ingestMetadata), 0, soap_copy_ns1__ingestMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ingestMetadata::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ingestMetadata);
	if (this->soap_out(soap, tag?tag:"ns1:ingestMetadata", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ingestMetadata::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ingestMetadata(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ingestMetadata * SOAP_FMAC4 soap_get_ns1__ingestMetadata(struct soap *soap, ns1__ingestMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ingestMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ingestMetadata * SOAP_FMAC2 soap_instantiate_ns1__ingestMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ingestMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ingestMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadata);
		if (size)
			*size = sizeof(ns1__ingestMetadata);
		((ns1__ingestMetadata*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ingestMetadata);
		for (int i = 0; i < n; i++)
			((ns1__ingestMetadata*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ingestMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ingestMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ingestMetadata %p -> %p\n", q, p));
	*(ns1__ingestMetadata*)p = *(ns1__ingestMetadata*)q;
}

void ns1__listRolesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__icatRole(soap, &this->ns1__listRolesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listRolesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__icatRole(soap, &this->ns1__listRolesResponse::return_);
	/* transient soap skipped */
}

int ns1__listRolesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listRolesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listRolesResponse(struct soap *soap, const char *tag, int id, const ns1__listRolesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listRolesResponse), "ns1:listRolesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__icatRole(soap, "return", -1, &(a->ns1__listRolesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listRolesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listRolesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listRolesResponse * SOAP_FMAC4 soap_in_ns1__listRolesResponse(struct soap *soap, const char *tag, ns1__listRolesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listRolesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listRolesResponse, sizeof(ns1__listRolesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listRolesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listRolesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__icatRole(soap, "return", &(a->ns1__listRolesResponse::return_), "ns1:icatRole"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listRolesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listRolesResponse, 0, sizeof(ns1__listRolesResponse), 0, soap_copy_ns1__listRolesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listRolesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listRolesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listRolesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listRolesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listRolesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listRolesResponse * SOAP_FMAC4 soap_get_ns1__listRolesResponse(struct soap *soap, ns1__listRolesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listRolesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listRolesResponse * SOAP_FMAC2 soap_instantiate_ns1__listRolesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listRolesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listRolesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listRolesResponse);
		if (size)
			*size = sizeof(ns1__listRolesResponse);
		((ns1__listRolesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listRolesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listRolesResponse);
		for (int i = 0; i < n; i++)
			((ns1__listRolesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listRolesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listRolesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listRolesResponse %p -> %p\n", q, p));
	*(ns1__listRolesResponse*)p = *(ns1__listRolesResponse*)q;
}

void ns1__listRoles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listRoles::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listRoles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listRoles::sessionId);
	/* transient soap skipped */
}

int ns1__listRoles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listRoles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listRoles(struct soap *soap, const char *tag, int id, const ns1__listRoles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listRoles), "ns1:listRoles"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listRoles::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listRoles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listRoles(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listRoles * SOAP_FMAC4 soap_in_ns1__listRoles(struct soap *soap, const char *tag, ns1__listRoles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listRoles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listRoles, sizeof(ns1__listRoles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listRoles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listRoles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listRoles::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listRoles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listRoles, 0, sizeof(ns1__listRoles), 0, soap_copy_ns1__listRoles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listRoles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listRoles);
	if (this->soap_out(soap, tag?tag:"ns1:listRoles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listRoles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listRoles(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listRoles * SOAP_FMAC4 soap_get_ns1__listRoles(struct soap *soap, ns1__listRoles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listRoles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listRoles * SOAP_FMAC2 soap_instantiate_ns1__listRoles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listRoles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listRoles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listRoles);
		if (size)
			*size = sizeof(ns1__listRoles);
		((ns1__listRoles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listRoles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listRoles);
		for (int i = 0; i < n; i++)
			((ns1__listRoles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listRoles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listRoles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listRoles %p -> %p\n", q, p));
	*(ns1__listRoles*)p = *(ns1__listRoles*)q;
}

void ns1__getDatasetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDatasetResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatasetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__dataset(soap, &this->ns1__getDatasetResponse::return_);
	/* transient soap skipped */
}

int ns1__getDatasetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatasetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatasetResponse(struct soap *soap, const char *tag, int id, const ns1__getDatasetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatasetResponse), "ns1:getDatasetResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__dataset(soap, "return", -1, &(a->ns1__getDatasetResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatasetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatasetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatasetResponse * SOAP_FMAC4 soap_in_ns1__getDatasetResponse(struct soap *soap, const char *tag, ns1__getDatasetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatasetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatasetResponse, sizeof(ns1__getDatasetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatasetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatasetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dataset(soap, "return", &(a->ns1__getDatasetResponse::return_), "ns1:dataset"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatasetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatasetResponse, 0, sizeof(ns1__getDatasetResponse), 0, soap_copy_ns1__getDatasetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatasetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatasetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDatasetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatasetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatasetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatasetResponse * SOAP_FMAC4 soap_get_ns1__getDatasetResponse(struct soap *soap, ns1__getDatasetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatasetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatasetResponse * SOAP_FMAC2 soap_instantiate_ns1__getDatasetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatasetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatasetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetResponse);
		if (size)
			*size = sizeof(ns1__getDatasetResponse);
		((ns1__getDatasetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatasetResponse);
		for (int i = 0; i < n; i++)
			((ns1__getDatasetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatasetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatasetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatasetResponse %p -> %p\n", q, p));
	*(ns1__getDatasetResponse*)p = *(ns1__getDatasetResponse*)q;
}

void ns1__getDataset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDataset::sessionId = NULL;
	this->ns1__getDataset::datasetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDataset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDataset::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getDataset::datasetId);
	/* transient soap skipped */
}

int ns1__getDataset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDataset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDataset(struct soap *soap, const char *tag, int id, const ns1__getDataset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDataset), "ns1:getDataset"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getDataset::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__getDataset::datasetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDataset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDataset(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDataset * SOAP_FMAC4 soap_in_ns1__getDataset(struct soap *soap, const char *tag, ns1__getDataset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDataset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDataset, sizeof(ns1__getDataset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDataset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDataset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getDataset::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__getDataset::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDataset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDataset, 0, sizeof(ns1__getDataset), 0, soap_copy_ns1__getDataset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDataset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDataset);
	if (this->soap_out(soap, tag?tag:"ns1:getDataset", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDataset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDataset(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDataset * SOAP_FMAC4 soap_get_ns1__getDataset(struct soap *soap, ns1__getDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDataset * SOAP_FMAC2 soap_instantiate_ns1__getDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDataset);
		if (size)
			*size = sizeof(ns1__getDataset);
		((ns1__getDataset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDataset[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDataset);
		for (int i = 0; i < n; i++)
			((ns1__getDataset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDataset %p -> %p\n", q, p));
	*(ns1__getDataset*)p = *(ns1__getDataset*)q;
}

void ns1__getDatasetIncludesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDatasetIncludesResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatasetIncludesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__dataset(soap, &this->ns1__getDatasetIncludesResponse::return_);
	/* transient soap skipped */
}

int ns1__getDatasetIncludesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatasetIncludesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatasetIncludesResponse(struct soap *soap, const char *tag, int id, const ns1__getDatasetIncludesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatasetIncludesResponse), "ns1:getDatasetIncludesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__dataset(soap, "return", -1, &(a->ns1__getDatasetIncludesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatasetIncludesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatasetIncludesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatasetIncludesResponse * SOAP_FMAC4 soap_in_ns1__getDatasetIncludesResponse(struct soap *soap, const char *tag, ns1__getDatasetIncludesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatasetIncludesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatasetIncludesResponse, sizeof(ns1__getDatasetIncludesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatasetIncludesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatasetIncludesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dataset(soap, "return", &(a->ns1__getDatasetIncludesResponse::return_), "ns1:dataset"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatasetIncludesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatasetIncludesResponse, 0, sizeof(ns1__getDatasetIncludesResponse), 0, soap_copy_ns1__getDatasetIncludesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatasetIncludesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatasetIncludesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDatasetIncludesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatasetIncludesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatasetIncludesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatasetIncludesResponse * SOAP_FMAC4 soap_get_ns1__getDatasetIncludesResponse(struct soap *soap, ns1__getDatasetIncludesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatasetIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatasetIncludesResponse * SOAP_FMAC2 soap_instantiate_ns1__getDatasetIncludesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatasetIncludesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatasetIncludesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludesResponse);
		if (size)
			*size = sizeof(ns1__getDatasetIncludesResponse);
		((ns1__getDatasetIncludesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatasetIncludesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getDatasetIncludesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatasetIncludesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatasetIncludesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatasetIncludesResponse %p -> %p\n", q, p));
	*(ns1__getDatasetIncludesResponse*)p = *(ns1__getDatasetIncludesResponse*)q;
}

void ns1__getDatasetIncludes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDatasetIncludes::sessionId = NULL;
	this->ns1__getDatasetIncludes::datasetId = NULL;
	this->ns1__getDatasetIncludes::datasetInclude = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatasetIncludes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDatasetIncludes::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getDatasetIncludes::datasetId);
	soap_serialize_PointerTons1__datasetInclude(soap, &this->ns1__getDatasetIncludes::datasetInclude);
	/* transient soap skipped */
}

int ns1__getDatasetIncludes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatasetIncludes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatasetIncludes(struct soap *soap, const char *tag, int id, const ns1__getDatasetIncludes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatasetIncludes), "ns1:getDatasetIncludes"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getDatasetIncludes::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__getDatasetIncludes::datasetId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datasetInclude(soap, "datasetInclude", -1, &(a->ns1__getDatasetIncludes::datasetInclude), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatasetIncludes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatasetIncludes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatasetIncludes * SOAP_FMAC4 soap_in_ns1__getDatasetIncludes(struct soap *soap, const char *tag, ns1__getDatasetIncludes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatasetIncludes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatasetIncludes, sizeof(ns1__getDatasetIncludes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatasetIncludes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatasetIncludes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetId1 = 1;
	size_t soap_flag_datasetInclude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getDatasetIncludes::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__getDatasetIncludes::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag_datasetInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datasetInclude(soap, "datasetInclude", &(a->ns1__getDatasetIncludes::datasetInclude), "ns1:datasetInclude"))
				{	soap_flag_datasetInclude1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatasetIncludes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatasetIncludes, 0, sizeof(ns1__getDatasetIncludes), 0, soap_copy_ns1__getDatasetIncludes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatasetIncludes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatasetIncludes);
	if (this->soap_out(soap, tag?tag:"ns1:getDatasetIncludes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatasetIncludes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatasetIncludes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatasetIncludes * SOAP_FMAC4 soap_get_ns1__getDatasetIncludes(struct soap *soap, ns1__getDatasetIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatasetIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatasetIncludes * SOAP_FMAC2 soap_instantiate_ns1__getDatasetIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatasetIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatasetIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludes);
		if (size)
			*size = sizeof(ns1__getDatasetIncludes);
		((ns1__getDatasetIncludes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatasetIncludes);
		for (int i = 0; i < n; i++)
			((ns1__getDatasetIncludes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatasetIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatasetIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatasetIncludes %p -> %p\n", q, p));
	*(ns1__getDatasetIncludes*)p = *(ns1__getDatasetIncludes*)q;
}

void ns1__updateAuthorisationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__updateAuthorisationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__updateAuthorisationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateAuthorisationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateAuthorisationResponse(struct soap *soap, const char *tag, int id, const ns1__updateAuthorisationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:updateAuthorisationResponse");
}

void *ns1__updateAuthorisationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateAuthorisationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateAuthorisationResponse * SOAP_FMAC4 soap_in_ns1__updateAuthorisationResponse(struct soap *soap, const char *tag, ns1__updateAuthorisationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__updateAuthorisationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateAuthorisationResponse, sizeof(ns1__updateAuthorisationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateAuthorisationResponse)
			return (ns1__updateAuthorisationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__updateAuthorisationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateAuthorisationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateAuthorisationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateAuthorisationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateAuthorisationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateAuthorisationResponse * SOAP_FMAC4 soap_get_ns1__updateAuthorisationResponse(struct soap *soap, ns1__updateAuthorisationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateAuthorisationResponse * SOAP_FMAC2 soap_instantiate_ns1__updateAuthorisationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateAuthorisationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateAuthorisationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisationResponse);
		if (size)
			*size = sizeof(ns1__updateAuthorisationResponse);
		((ns1__updateAuthorisationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateAuthorisationResponse);
		for (int i = 0; i < n; i++)
			((ns1__updateAuthorisationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateAuthorisationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateAuthorisationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateAuthorisationResponse %p -> %p\n", q, p));
	*(ns1__updateAuthorisationResponse*)p = *(ns1__updateAuthorisationResponse*)q;
}

void ns1__updateAuthorisation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateAuthorisation::sessionId = NULL;
	this->ns1__updateAuthorisation::toChangetoRole = NULL;
	this->ns1__updateAuthorisation::authorisationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__updateAuthorisation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__updateAuthorisation::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__updateAuthorisation::toChangetoRole);
	soap_serialize_PointerToLONG64(soap, &this->ns1__updateAuthorisation::authorisationId);
	/* transient soap skipped */
}

int ns1__updateAuthorisation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateAuthorisation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateAuthorisation(struct soap *soap, const char *tag, int id, const ns1__updateAuthorisation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateAuthorisation), "ns1:updateAuthorisation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__updateAuthorisation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "toChangetoRole", -1, &(a->ns1__updateAuthorisation::toChangetoRole), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "authorisationId", -1, &(a->ns1__updateAuthorisation::authorisationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__updateAuthorisation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateAuthorisation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateAuthorisation * SOAP_FMAC4 soap_in_ns1__updateAuthorisation(struct soap *soap, const char *tag, ns1__updateAuthorisation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateAuthorisation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateAuthorisation, sizeof(ns1__updateAuthorisation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateAuthorisation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateAuthorisation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_toChangetoRole1 = 1;
	size_t soap_flag_authorisationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__updateAuthorisation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_toChangetoRole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "toChangetoRole", &(a->ns1__updateAuthorisation::toChangetoRole), "xsd:string"))
				{	soap_flag_toChangetoRole1--;
					continue;
				}
			if (soap_flag_authorisationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "authorisationId", &(a->ns1__updateAuthorisation::authorisationId), "xsd:long"))
				{	soap_flag_authorisationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateAuthorisation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateAuthorisation, 0, sizeof(ns1__updateAuthorisation), 0, soap_copy_ns1__updateAuthorisation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__updateAuthorisation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateAuthorisation);
	if (this->soap_out(soap, tag?tag:"ns1:updateAuthorisation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateAuthorisation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateAuthorisation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateAuthorisation * SOAP_FMAC4 soap_get_ns1__updateAuthorisation(struct soap *soap, ns1__updateAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateAuthorisation * SOAP_FMAC2 soap_instantiate_ns1__updateAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisation);
		if (size)
			*size = sizeof(ns1__updateAuthorisation);
		((ns1__updateAuthorisation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateAuthorisation);
		for (int i = 0; i < n; i++)
			((ns1__updateAuthorisation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateAuthorisation %p -> %p\n", q, p));
	*(ns1__updateAuthorisation*)p = *(ns1__updateAuthorisation*)q;
}

void ns1__deleteAuthorisationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteAuthorisationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteAuthorisationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteAuthorisationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteAuthorisationResponse(struct soap *soap, const char *tag, int id, const ns1__deleteAuthorisationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteAuthorisationResponse");
}

void *ns1__deleteAuthorisationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteAuthorisationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteAuthorisationResponse * SOAP_FMAC4 soap_in_ns1__deleteAuthorisationResponse(struct soap *soap, const char *tag, ns1__deleteAuthorisationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteAuthorisationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteAuthorisationResponse, sizeof(ns1__deleteAuthorisationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteAuthorisationResponse)
			return (ns1__deleteAuthorisationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteAuthorisationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteAuthorisationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteAuthorisationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteAuthorisationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteAuthorisationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteAuthorisationResponse * SOAP_FMAC4 soap_get_ns1__deleteAuthorisationResponse(struct soap *soap, ns1__deleteAuthorisationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteAuthorisationResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteAuthorisationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteAuthorisationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteAuthorisationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisationResponse);
		if (size)
			*size = sizeof(ns1__deleteAuthorisationResponse);
		((ns1__deleteAuthorisationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteAuthorisationResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteAuthorisationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteAuthorisationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteAuthorisationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteAuthorisationResponse %p -> %p\n", q, p));
	*(ns1__deleteAuthorisationResponse*)p = *(ns1__deleteAuthorisationResponse*)q;
}

void ns1__deleteAuthorisation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteAuthorisation::sessionId = NULL;
	this->ns1__deleteAuthorisation::authorisationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteAuthorisation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteAuthorisation::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__deleteAuthorisation::authorisationId);
	/* transient soap skipped */
}

int ns1__deleteAuthorisation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteAuthorisation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteAuthorisation(struct soap *soap, const char *tag, int id, const ns1__deleteAuthorisation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteAuthorisation), "ns1:deleteAuthorisation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteAuthorisation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "authorisationId", -1, &(a->ns1__deleteAuthorisation::authorisationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteAuthorisation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteAuthorisation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteAuthorisation * SOAP_FMAC4 soap_in_ns1__deleteAuthorisation(struct soap *soap, const char *tag, ns1__deleteAuthorisation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteAuthorisation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteAuthorisation, sizeof(ns1__deleteAuthorisation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteAuthorisation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteAuthorisation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_authorisationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteAuthorisation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_authorisationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "authorisationId", &(a->ns1__deleteAuthorisation::authorisationId), "xsd:long"))
				{	soap_flag_authorisationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteAuthorisation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteAuthorisation, 0, sizeof(ns1__deleteAuthorisation), 0, soap_copy_ns1__deleteAuthorisation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteAuthorisation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteAuthorisation);
	if (this->soap_out(soap, tag?tag:"ns1:deleteAuthorisation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteAuthorisation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteAuthorisation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteAuthorisation * SOAP_FMAC4 soap_get_ns1__deleteAuthorisation(struct soap *soap, ns1__deleteAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteAuthorisation * SOAP_FMAC2 soap_instantiate_ns1__deleteAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisation);
		if (size)
			*size = sizeof(ns1__deleteAuthorisation);
		((ns1__deleteAuthorisation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteAuthorisation);
		for (int i = 0; i < n; i++)
			((ns1__deleteAuthorisation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteAuthorisation %p -> %p\n", q, p));
	*(ns1__deleteAuthorisation*)p = *(ns1__deleteAuthorisation*)q;
}

void ns1__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__loginResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__loginResponse::return_);
	/* transient soap skipped */
}

int ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginResponse(struct soap *soap, const char *tag, int id, const ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loginResponse), "ns1:loginResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__loginResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loginResponse * SOAP_FMAC4 soap_in_ns1__loginResponse(struct soap *soap, const char *tag, ns1__loginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loginResponse, sizeof(ns1__loginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__loginResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loginResponse, 0, sizeof(ns1__loginResponse), 0, soap_copy_ns1__loginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__loginResponse);
	if (this->soap_out(soap, tag?tag:"ns1:loginResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loginResponse * SOAP_FMAC4 soap_get_ns1__loginResponse(struct soap *soap, ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loginResponse * SOAP_FMAC2 soap_instantiate_ns1__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loginResponse);
		if (size)
			*size = sizeof(ns1__loginResponse);
		((ns1__loginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__loginResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__loginResponse);
		for (int i = 0; i < n; i++)
			((ns1__loginResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__loginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loginResponse %p -> %p\n", q, p));
	*(ns1__loginResponse*)p = *(ns1__loginResponse*)q;
}

void ns1__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__login::username = NULL;
	this->ns1__login::password = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__login::username);
	soap_serialize_PointerTostd__string(soap, &this->ns1__login::password);
	/* transient soap skipped */
}

int ns1__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__login(struct soap *soap, const char *tag, int id, const ns1__login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__login), "ns1:login"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "username", -1, &(a->ns1__login::username), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->ns1__login::password), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__login(soap, tag, this, type);
}

SOAP_FMAC3 ns1__login * SOAP_FMAC4 soap_in_ns1__login(struct soap *soap, const char *tag, ns1__login *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__login, sizeof(ns1__login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__login)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__login *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "username", &(a->ns1__login::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->ns1__login::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__login, 0, sizeof(ns1__login), 0, soap_copy_ns1__login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__login);
	if (this->soap_out(soap, tag?tag:"ns1:login", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__login(soap, this, tag, type);
}

SOAP_FMAC3 ns1__login * SOAP_FMAC4 soap_get_ns1__login(struct soap *soap, ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__login * SOAP_FMAC2 soap_instantiate_ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__login);
		if (size)
			*size = sizeof(ns1__login);
		((ns1__login*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__login[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__login);
		for (int i = 0; i < n; i++)
			((ns1__login*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__login %p -> %p\n", q, p));
	*(ns1__login*)p = *(ns1__login*)q;
}

void ns1__loginLifetimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__loginLifetimeResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__loginLifetimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__loginLifetimeResponse::return_);
	/* transient soap skipped */
}

int ns1__loginLifetimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loginLifetimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginLifetimeResponse(struct soap *soap, const char *tag, int id, const ns1__loginLifetimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loginLifetimeResponse), "ns1:loginLifetimeResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__loginLifetimeResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__loginLifetimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loginLifetimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loginLifetimeResponse * SOAP_FMAC4 soap_in_ns1__loginLifetimeResponse(struct soap *soap, const char *tag, ns1__loginLifetimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loginLifetimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loginLifetimeResponse, sizeof(ns1__loginLifetimeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loginLifetimeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loginLifetimeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__loginLifetimeResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loginLifetimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loginLifetimeResponse, 0, sizeof(ns1__loginLifetimeResponse), 0, soap_copy_ns1__loginLifetimeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__loginLifetimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__loginLifetimeResponse);
	if (this->soap_out(soap, tag?tag:"ns1:loginLifetimeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loginLifetimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loginLifetimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loginLifetimeResponse * SOAP_FMAC4 soap_get_ns1__loginLifetimeResponse(struct soap *soap, ns1__loginLifetimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loginLifetimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loginLifetimeResponse * SOAP_FMAC2 soap_instantiate_ns1__loginLifetimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loginLifetimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loginLifetimeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetimeResponse);
		if (size)
			*size = sizeof(ns1__loginLifetimeResponse);
		((ns1__loginLifetimeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetimeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__loginLifetimeResponse);
		for (int i = 0; i < n; i++)
			((ns1__loginLifetimeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__loginLifetimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loginLifetimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loginLifetimeResponse %p -> %p\n", q, p));
	*(ns1__loginLifetimeResponse*)p = *(ns1__loginLifetimeResponse*)q;
}

void ns1__loginLifetime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__loginLifetime::username = NULL;
	this->ns1__loginLifetime::password = NULL;
	soap_default_int(soap, &this->ns1__loginLifetime::lifetime);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__loginLifetime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__loginLifetime::username);
	soap_serialize_PointerTostd__string(soap, &this->ns1__loginLifetime::password);
	soap_embedded(soap, &this->ns1__loginLifetime::lifetime, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__loginLifetime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loginLifetime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginLifetime(struct soap *soap, const char *tag, int id, const ns1__loginLifetime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loginLifetime), "ns1:loginLifetime"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "username", -1, &(a->ns1__loginLifetime::username), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->ns1__loginLifetime::password), ""))
		return soap->error;
	if (soap_out_int(soap, "lifetime", -1, &(a->ns1__loginLifetime::lifetime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__loginLifetime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loginLifetime(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loginLifetime * SOAP_FMAC4 soap_in_ns1__loginLifetime(struct soap *soap, const char *tag, ns1__loginLifetime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loginLifetime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loginLifetime, sizeof(ns1__loginLifetime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loginLifetime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loginLifetime *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_lifetime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "username", &(a->ns1__loginLifetime::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->ns1__loginLifetime::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_lifetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lifetime", &(a->ns1__loginLifetime::lifetime), "xsd:int"))
				{	soap_flag_lifetime1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loginLifetime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loginLifetime, 0, sizeof(ns1__loginLifetime), 0, soap_copy_ns1__loginLifetime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lifetime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__loginLifetime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__loginLifetime);
	if (this->soap_out(soap, tag?tag:"ns1:loginLifetime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loginLifetime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loginLifetime(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loginLifetime * SOAP_FMAC4 soap_get_ns1__loginLifetime(struct soap *soap, ns1__loginLifetime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loginLifetime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loginLifetime * SOAP_FMAC2 soap_instantiate_ns1__loginLifetime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loginLifetime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loginLifetime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetime);
		if (size)
			*size = sizeof(ns1__loginLifetime);
		((ns1__loginLifetime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__loginLifetime);
		for (int i = 0; i < n; i++)
			((ns1__loginLifetime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__loginLifetime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loginLifetime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loginLifetime %p -> %p\n", q, p));
	*(ns1__loginLifetime*)p = *(ns1__loginLifetime*)q;
}

void ns1__deletePublicationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deletePublicationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deletePublicationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deletePublicationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deletePublicationResponse(struct soap *soap, const char *tag, int id, const ns1__deletePublicationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deletePublicationResponse");
}

void *ns1__deletePublicationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deletePublicationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deletePublicationResponse * SOAP_FMAC4 soap_in_ns1__deletePublicationResponse(struct soap *soap, const char *tag, ns1__deletePublicationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deletePublicationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deletePublicationResponse, sizeof(ns1__deletePublicationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deletePublicationResponse)
			return (ns1__deletePublicationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deletePublicationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deletePublicationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deletePublicationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deletePublicationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deletePublicationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deletePublicationResponse * SOAP_FMAC4 soap_get_ns1__deletePublicationResponse(struct soap *soap, ns1__deletePublicationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deletePublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deletePublicationResponse * SOAP_FMAC2 soap_instantiate_ns1__deletePublicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deletePublicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deletePublicationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublicationResponse);
		if (size)
			*size = sizeof(ns1__deletePublicationResponse);
		((ns1__deletePublicationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublicationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deletePublicationResponse);
		for (int i = 0; i < n; i++)
			((ns1__deletePublicationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deletePublicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deletePublicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deletePublicationResponse %p -> %p\n", q, p));
	*(ns1__deletePublicationResponse*)p = *(ns1__deletePublicationResponse*)q;
}

void ns1__deletePublication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deletePublication::sessionId = NULL;
	this->ns1__deletePublication::publicationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deletePublication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deletePublication::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__deletePublication::publicationId);
	/* transient soap skipped */
}

int ns1__deletePublication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deletePublication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deletePublication(struct soap *soap, const char *tag, int id, const ns1__deletePublication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deletePublication), "ns1:deletePublication"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deletePublication::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "publicationId", -1, &(a->ns1__deletePublication::publicationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deletePublication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deletePublication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deletePublication * SOAP_FMAC4 soap_in_ns1__deletePublication(struct soap *soap, const char *tag, ns1__deletePublication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deletePublication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deletePublication, sizeof(ns1__deletePublication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deletePublication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deletePublication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_publicationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deletePublication::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_publicationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "publicationId", &(a->ns1__deletePublication::publicationId), "xsd:long"))
				{	soap_flag_publicationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deletePublication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deletePublication, 0, sizeof(ns1__deletePublication), 0, soap_copy_ns1__deletePublication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deletePublication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deletePublication);
	if (this->soap_out(soap, tag?tag:"ns1:deletePublication", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deletePublication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deletePublication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deletePublication * SOAP_FMAC4 soap_get_ns1__deletePublication(struct soap *soap, ns1__deletePublication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deletePublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deletePublication * SOAP_FMAC2 soap_instantiate_ns1__deletePublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deletePublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deletePublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublication);
		if (size)
			*size = sizeof(ns1__deletePublication);
		((ns1__deletePublication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deletePublication);
		for (int i = 0; i < n; i++)
			((ns1__deletePublication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deletePublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deletePublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deletePublication %p -> %p\n", q, p));
	*(ns1__deletePublication*)p = *(ns1__deletePublication*)q;
}

void ns1__addSampleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addSampleResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addSampleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sample(soap, &this->ns1__addSampleResponse::return_);
	/* transient soap skipped */
}

int ns1__addSampleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addSampleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addSampleResponse(struct soap *soap, const char *tag, int id, const ns1__addSampleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addSampleResponse), "ns1:addSampleResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__sample(soap, "return", -1, &(a->ns1__addSampleResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addSampleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addSampleResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addSampleResponse * SOAP_FMAC4 soap_in_ns1__addSampleResponse(struct soap *soap, const char *tag, ns1__addSampleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addSampleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addSampleResponse, sizeof(ns1__addSampleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addSampleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addSampleResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sample(soap, "return", &(a->ns1__addSampleResponse::return_), "ns1:sample"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addSampleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addSampleResponse, 0, sizeof(ns1__addSampleResponse), 0, soap_copy_ns1__addSampleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addSampleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addSampleResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addSampleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addSampleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addSampleResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addSampleResponse * SOAP_FMAC4 soap_get_ns1__addSampleResponse(struct soap *soap, ns1__addSampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addSampleResponse * SOAP_FMAC2 soap_instantiate_ns1__addSampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addSampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addSampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleResponse);
		if (size)
			*size = sizeof(ns1__addSampleResponse);
		((ns1__addSampleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addSampleResponse);
		for (int i = 0; i < n; i++)
			((ns1__addSampleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addSampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addSampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addSampleResponse %p -> %p\n", q, p));
	*(ns1__addSampleResponse*)p = *(ns1__addSampleResponse*)q;
}

void ns1__addSample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addSample::sessionId = NULL;
	this->ns1__addSample::sample = NULL;
	this->ns1__addSample::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addSample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addSample::sessionId);
	soap_serialize_PointerTons1__sample(soap, &this->ns1__addSample::sample);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addSample::investigationId);
	/* transient soap skipped */
}

int ns1__addSample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addSample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addSample(struct soap *soap, const char *tag, int id, const ns1__addSample *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addSample), "ns1:addSample"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addSample::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__sample(soap, "sample", -1, &(a->ns1__addSample::sample), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__addSample::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addSample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addSample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addSample * SOAP_FMAC4 soap_in_ns1__addSample(struct soap *soap, const char *tag, ns1__addSample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addSample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addSample, sizeof(ns1__addSample), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addSample)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addSample *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sample1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addSample::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sample1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sample(soap, "sample", &(a->ns1__addSample::sample), "ns1:sample"))
				{	soap_flag_sample1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__addSample::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addSample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addSample, 0, sizeof(ns1__addSample), 0, soap_copy_ns1__addSample);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addSample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addSample);
	if (this->soap_out(soap, tag?tag:"ns1:addSample", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addSample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addSample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addSample * SOAP_FMAC4 soap_get_ns1__addSample(struct soap *soap, ns1__addSample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addSample * SOAP_FMAC2 soap_instantiate_ns1__addSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSample);
		if (size)
			*size = sizeof(ns1__addSample);
		((ns1__addSample*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addSample);
		for (int i = 0; i < n; i++)
			((ns1__addSample*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addSample %p -> %p\n", q, p));
	*(ns1__addSample*)p = *(ns1__addSample*)q;
}

void ns1__addAuthorisationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addAuthorisationResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addAuthorisationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__icatAuthorisation(soap, &this->ns1__addAuthorisationResponse::return_);
	/* transient soap skipped */
}

int ns1__addAuthorisationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addAuthorisationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addAuthorisationResponse(struct soap *soap, const char *tag, int id, const ns1__addAuthorisationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addAuthorisationResponse), "ns1:addAuthorisationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__icatAuthorisation(soap, "return", -1, &(a->ns1__addAuthorisationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addAuthorisationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addAuthorisationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addAuthorisationResponse * SOAP_FMAC4 soap_in_ns1__addAuthorisationResponse(struct soap *soap, const char *tag, ns1__addAuthorisationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addAuthorisationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addAuthorisationResponse, sizeof(ns1__addAuthorisationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addAuthorisationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addAuthorisationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatAuthorisation(soap, "return", &(a->ns1__addAuthorisationResponse::return_), "ns1:icatAuthorisation"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addAuthorisationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addAuthorisationResponse, 0, sizeof(ns1__addAuthorisationResponse), 0, soap_copy_ns1__addAuthorisationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addAuthorisationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addAuthorisationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addAuthorisationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addAuthorisationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addAuthorisationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addAuthorisationResponse * SOAP_FMAC4 soap_get_ns1__addAuthorisationResponse(struct soap *soap, ns1__addAuthorisationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addAuthorisationResponse * SOAP_FMAC2 soap_instantiate_ns1__addAuthorisationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addAuthorisationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addAuthorisationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisationResponse);
		if (size)
			*size = sizeof(ns1__addAuthorisationResponse);
		((ns1__addAuthorisationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addAuthorisationResponse);
		for (int i = 0; i < n; i++)
			((ns1__addAuthorisationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addAuthorisationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addAuthorisationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addAuthorisationResponse %p -> %p\n", q, p));
	*(ns1__addAuthorisationResponse*)p = *(ns1__addAuthorisationResponse*)q;
}

void ns1__addAuthorisation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addAuthorisation::sessionId = NULL;
	this->ns1__addAuthorisation::toAddFedId = NULL;
	this->ns1__addAuthorisation::toAddRole = NULL;
	this->ns1__addAuthorisation::elementId = NULL;
	this->ns1__addAuthorisation::elementType = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addAuthorisation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addAuthorisation::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__addAuthorisation::toAddFedId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__addAuthorisation::toAddRole);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addAuthorisation::elementId);
	soap_serialize_PointerTons1__elementType(soap, &this->ns1__addAuthorisation::elementType);
	/* transient soap skipped */
}

int ns1__addAuthorisation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addAuthorisation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addAuthorisation(struct soap *soap, const char *tag, int id, const ns1__addAuthorisation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addAuthorisation), "ns1:addAuthorisation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addAuthorisation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "toAddFedId", -1, &(a->ns1__addAuthorisation::toAddFedId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "toAddRole", -1, &(a->ns1__addAuthorisation::toAddRole), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "elementId", -1, &(a->ns1__addAuthorisation::elementId), ""))
		return soap->error;
	if (soap_out_PointerTons1__elementType(soap, "elementType", -1, &(a->ns1__addAuthorisation::elementType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addAuthorisation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addAuthorisation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addAuthorisation * SOAP_FMAC4 soap_in_ns1__addAuthorisation(struct soap *soap, const char *tag, ns1__addAuthorisation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addAuthorisation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addAuthorisation, sizeof(ns1__addAuthorisation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addAuthorisation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addAuthorisation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_toAddFedId1 = 1;
	size_t soap_flag_toAddRole1 = 1;
	size_t soap_flag_elementId1 = 1;
	size_t soap_flag_elementType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addAuthorisation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_toAddFedId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "toAddFedId", &(a->ns1__addAuthorisation::toAddFedId), "xsd:string"))
				{	soap_flag_toAddFedId1--;
					continue;
				}
			if (soap_flag_toAddRole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "toAddRole", &(a->ns1__addAuthorisation::toAddRole), "xsd:string"))
				{	soap_flag_toAddRole1--;
					continue;
				}
			if (soap_flag_elementId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "elementId", &(a->ns1__addAuthorisation::elementId), "xsd:long"))
				{	soap_flag_elementId1--;
					continue;
				}
			if (soap_flag_elementType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__elementType(soap, "elementType", &(a->ns1__addAuthorisation::elementType), "ns1:elementType"))
				{	soap_flag_elementType1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addAuthorisation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addAuthorisation, 0, sizeof(ns1__addAuthorisation), 0, soap_copy_ns1__addAuthorisation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addAuthorisation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addAuthorisation);
	if (this->soap_out(soap, tag?tag:"ns1:addAuthorisation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addAuthorisation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addAuthorisation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addAuthorisation * SOAP_FMAC4 soap_get_ns1__addAuthorisation(struct soap *soap, ns1__addAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addAuthorisation * SOAP_FMAC2 soap_instantiate_ns1__addAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisation);
		if (size)
			*size = sizeof(ns1__addAuthorisation);
		((ns1__addAuthorisation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addAuthorisation);
		for (int i = 0; i < n; i++)
			((ns1__addAuthorisation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addAuthorisation %p -> %p\n", q, p));
	*(ns1__addAuthorisation*)p = *(ns1__addAuthorisation*)q;
}

void ns1__addDataSetParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addDataSetParameterResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataSetParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__datasetParameter(soap, &this->ns1__addDataSetParameterResponse::return_);
	/* transient soap skipped */
}

int ns1__addDataSetParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataSetParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataSetParameterResponse(struct soap *soap, const char *tag, int id, const ns1__addDataSetParameterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataSetParameterResponse), "ns1:addDataSetParameterResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__datasetParameter(soap, "return", -1, &(a->ns1__addDataSetParameterResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataSetParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataSetParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataSetParameterResponse * SOAP_FMAC4 soap_in_ns1__addDataSetParameterResponse(struct soap *soap, const char *tag, ns1__addDataSetParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataSetParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataSetParameterResponse, sizeof(ns1__addDataSetParameterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataSetParameterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataSetParameterResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datasetParameter(soap, "return", &(a->ns1__addDataSetParameterResponse::return_), "ns1:datasetParameter"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataSetParameterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataSetParameterResponse, 0, sizeof(ns1__addDataSetParameterResponse), 0, soap_copy_ns1__addDataSetParameterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataSetParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataSetParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addDataSetParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataSetParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataSetParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataSetParameterResponse * SOAP_FMAC4 soap_get_ns1__addDataSetParameterResponse(struct soap *soap, ns1__addDataSetParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataSetParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__addDataSetParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataSetParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataSetParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameterResponse);
		if (size)
			*size = sizeof(ns1__addDataSetParameterResponse);
		((ns1__addDataSetParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataSetParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__addDataSetParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataSetParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataSetParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataSetParameterResponse %p -> %p\n", q, p));
	*(ns1__addDataSetParameterResponse*)p = *(ns1__addDataSetParameterResponse*)q;
}

void ns1__addDataSetParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addDataSetParameter::sessionId = NULL;
	this->ns1__addDataSetParameter::dataSetParameter = NULL;
	this->ns1__addDataSetParameter::datasetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataSetParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addDataSetParameter::sessionId);
	soap_serialize_PointerTons1__datasetParameter(soap, &this->ns1__addDataSetParameter::dataSetParameter);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addDataSetParameter::datasetId);
	/* transient soap skipped */
}

int ns1__addDataSetParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataSetParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataSetParameter(struct soap *soap, const char *tag, int id, const ns1__addDataSetParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataSetParameter), "ns1:addDataSetParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addDataSetParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datasetParameter(soap, "dataSetParameter", -1, &(a->ns1__addDataSetParameter::dataSetParameter), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__addDataSetParameter::datasetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataSetParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataSetParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataSetParameter * SOAP_FMAC4 soap_in_ns1__addDataSetParameter(struct soap *soap, const char *tag, ns1__addDataSetParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataSetParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataSetParameter, sizeof(ns1__addDataSetParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataSetParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataSetParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataSetParameter1 = 1;
	size_t soap_flag_datasetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addDataSetParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataSetParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datasetParameter(soap, "dataSetParameter", &(a->ns1__addDataSetParameter::dataSetParameter), "ns1:datasetParameter"))
				{	soap_flag_dataSetParameter1--;
					continue;
				}
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__addDataSetParameter::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataSetParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataSetParameter, 0, sizeof(ns1__addDataSetParameter), 0, soap_copy_ns1__addDataSetParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataSetParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataSetParameter);
	if (this->soap_out(soap, tag?tag:"ns1:addDataSetParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataSetParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataSetParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataSetParameter * SOAP_FMAC4 soap_get_ns1__addDataSetParameter(struct soap *soap, ns1__addDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataSetParameter * SOAP_FMAC2 soap_instantiate_ns1__addDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameter);
		if (size)
			*size = sizeof(ns1__addDataSetParameter);
		((ns1__addDataSetParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataSetParameter);
		for (int i = 0; i < n; i++)
			((ns1__addDataSetParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataSetParameter %p -> %p\n", q, p));
	*(ns1__addDataSetParameter*)p = *(ns1__addDataSetParameter*)q;
}

void ns1__createDataFilesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__createDataFilesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataFilesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__createDataFilesResponse::return_);
	/* transient soap skipped */
}

int ns1__createDataFilesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataFilesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataFilesResponse(struct soap *soap, const char *tag, int id, const ns1__createDataFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataFilesResponse), "ns1:createDataFilesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "return", -1, &(a->ns1__createDataFilesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataFilesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataFilesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataFilesResponse * SOAP_FMAC4 soap_in_ns1__createDataFilesResponse(struct soap *soap, const char *tag, ns1__createDataFilesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataFilesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataFilesResponse, sizeof(ns1__createDataFilesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataFilesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataFilesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "return", &(a->ns1__createDataFilesResponse::return_), "ns1:datafile"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataFilesResponse, 0, sizeof(ns1__createDataFilesResponse), 0, soap_copy_ns1__createDataFilesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataFilesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataFilesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:createDataFilesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataFilesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataFilesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataFilesResponse * SOAP_FMAC4 soap_get_ns1__createDataFilesResponse(struct soap *soap, ns1__createDataFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataFilesResponse * SOAP_FMAC2 soap_instantiate_ns1__createDataFilesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataFilesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataFilesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFilesResponse);
		if (size)
			*size = sizeof(ns1__createDataFilesResponse);
		((ns1__createDataFilesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFilesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataFilesResponse);
		for (int i = 0; i < n; i++)
			((ns1__createDataFilesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataFilesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataFilesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataFilesResponse %p -> %p\n", q, p));
	*(ns1__createDataFilesResponse*)p = *(ns1__createDataFilesResponse*)q;
}

void ns1__createDataFiles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDataFiles::sessionId = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__createDataFiles::dataFiles);
	this->ns1__createDataFiles::datasetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataFiles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__createDataFiles::sessionId);
	soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__createDataFiles::dataFiles);
	soap_serialize_PointerToLONG64(soap, &this->ns1__createDataFiles::datasetId);
	/* transient soap skipped */
}

int ns1__createDataFiles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataFiles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataFiles(struct soap *soap, const char *tag, int id, const ns1__createDataFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataFiles), "ns1:createDataFiles"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__createDataFiles::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "dataFiles", -1, &(a->ns1__createDataFiles::dataFiles), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__createDataFiles::datasetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataFiles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataFiles(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataFiles * SOAP_FMAC4 soap_in_ns1__createDataFiles(struct soap *soap, const char *tag, ns1__createDataFiles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataFiles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataFiles, sizeof(ns1__createDataFiles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataFiles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataFiles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__createDataFiles::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "dataFiles", &(a->ns1__createDataFiles::dataFiles), "ns1:datafile"))
					continue;
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__createDataFiles::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataFiles, 0, sizeof(ns1__createDataFiles), 0, soap_copy_ns1__createDataFiles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataFiles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataFiles);
	if (this->soap_out(soap, tag?tag:"ns1:createDataFiles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataFiles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataFiles(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataFiles * SOAP_FMAC4 soap_get_ns1__createDataFiles(struct soap *soap, ns1__createDataFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataFiles * SOAP_FMAC2 soap_instantiate_ns1__createDataFiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataFiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataFiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFiles);
		if (size)
			*size = sizeof(ns1__createDataFiles);
		((ns1__createDataFiles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataFiles);
		for (int i = 0; i < n; i++)
			((ns1__createDataFiles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataFiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataFiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataFiles %p -> %p\n", q, p));
	*(ns1__createDataFiles*)p = *(ns1__createDataFiles*)q;
}

void ns1__modifyInvestigatorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyInvestigatorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifyInvestigatorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyInvestigatorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyInvestigatorResponse(struct soap *soap, const char *tag, int id, const ns1__modifyInvestigatorResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifyInvestigatorResponse");
}

void *ns1__modifyInvestigatorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyInvestigatorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyInvestigatorResponse * SOAP_FMAC4 soap_in_ns1__modifyInvestigatorResponse(struct soap *soap, const char *tag, ns1__modifyInvestigatorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifyInvestigatorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyInvestigatorResponse, sizeof(ns1__modifyInvestigatorResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyInvestigatorResponse)
			return (ns1__modifyInvestigatorResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifyInvestigatorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyInvestigatorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifyInvestigatorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyInvestigatorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyInvestigatorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyInvestigatorResponse * SOAP_FMAC4 soap_get_ns1__modifyInvestigatorResponse(struct soap *soap, ns1__modifyInvestigatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyInvestigatorResponse * SOAP_FMAC2 soap_instantiate_ns1__modifyInvestigatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyInvestigatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyInvestigatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigatorResponse);
		if (size)
			*size = sizeof(ns1__modifyInvestigatorResponse);
		((ns1__modifyInvestigatorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigatorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyInvestigatorResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifyInvestigatorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyInvestigatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyInvestigatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyInvestigatorResponse %p -> %p\n", q, p));
	*(ns1__modifyInvestigatorResponse*)p = *(ns1__modifyInvestigatorResponse*)q;
}

void ns1__modifyInvestigator::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifyInvestigator::sessionId = NULL;
	this->ns1__modifyInvestigator::investigator = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyInvestigator::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifyInvestigator::sessionId);
	soap_serialize_PointerTons1__investigator(soap, &this->ns1__modifyInvestigator::investigator);
	/* transient soap skipped */
}

int ns1__modifyInvestigator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyInvestigator(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyInvestigator(struct soap *soap, const char *tag, int id, const ns1__modifyInvestigator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyInvestigator), "ns1:modifyInvestigator"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifyInvestigator::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigator(soap, "investigator", -1, &(a->ns1__modifyInvestigator::investigator), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifyInvestigator::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyInvestigator(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyInvestigator * SOAP_FMAC4 soap_in_ns1__modifyInvestigator(struct soap *soap, const char *tag, ns1__modifyInvestigator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifyInvestigator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyInvestigator, sizeof(ns1__modifyInvestigator), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyInvestigator)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifyInvestigator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifyInvestigator::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigator(soap, "investigator", &(a->ns1__modifyInvestigator::investigator), "ns1:investigator"))
				{	soap_flag_investigator1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifyInvestigator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyInvestigator, 0, sizeof(ns1__modifyInvestigator), 0, soap_copy_ns1__modifyInvestigator);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifyInvestigator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyInvestigator);
	if (this->soap_out(soap, tag?tag:"ns1:modifyInvestigator", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyInvestigator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyInvestigator(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyInvestigator * SOAP_FMAC4 soap_get_ns1__modifyInvestigator(struct soap *soap, ns1__modifyInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyInvestigator * SOAP_FMAC2 soap_instantiate_ns1__modifyInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigator);
		if (size)
			*size = sizeof(ns1__modifyInvestigator);
		((ns1__modifyInvestigator*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyInvestigator);
		for (int i = 0; i < n; i++)
			((ns1__modifyInvestigator*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyInvestigator %p -> %p\n", q, p));
	*(ns1__modifyInvestigator*)p = *(ns1__modifyInvestigator*)q;
}

void ns1__modifySampleParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifySampleParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifySampleParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifySampleParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifySampleParameterResponse(struct soap *soap, const char *tag, int id, const ns1__modifySampleParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifySampleParameterResponse");
}

void *ns1__modifySampleParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifySampleParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifySampleParameterResponse * SOAP_FMAC4 soap_in_ns1__modifySampleParameterResponse(struct soap *soap, const char *tag, ns1__modifySampleParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifySampleParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifySampleParameterResponse, sizeof(ns1__modifySampleParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifySampleParameterResponse)
			return (ns1__modifySampleParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifySampleParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifySampleParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifySampleParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifySampleParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifySampleParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifySampleParameterResponse * SOAP_FMAC4 soap_get_ns1__modifySampleParameterResponse(struct soap *soap, ns1__modifySampleParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifySampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifySampleParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__modifySampleParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifySampleParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifySampleParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameterResponse);
		if (size)
			*size = sizeof(ns1__modifySampleParameterResponse);
		((ns1__modifySampleParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifySampleParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifySampleParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifySampleParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifySampleParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifySampleParameterResponse %p -> %p\n", q, p));
	*(ns1__modifySampleParameterResponse*)p = *(ns1__modifySampleParameterResponse*)q;
}

void ns1__modifySampleParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifySampleParameter::sessionId = NULL;
	this->ns1__modifySampleParameter::sampleParameter = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifySampleParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifySampleParameter::sessionId);
	soap_serialize_PointerTons1__sampleParameter(soap, &this->ns1__modifySampleParameter::sampleParameter);
	/* transient soap skipped */
}

int ns1__modifySampleParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifySampleParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifySampleParameter(struct soap *soap, const char *tag, int id, const ns1__modifySampleParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifySampleParameter), "ns1:modifySampleParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifySampleParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__sampleParameter(soap, "sampleParameter", -1, &(a->ns1__modifySampleParameter::sampleParameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifySampleParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifySampleParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifySampleParameter * SOAP_FMAC4 soap_in_ns1__modifySampleParameter(struct soap *soap, const char *tag, ns1__modifySampleParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifySampleParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifySampleParameter, sizeof(ns1__modifySampleParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifySampleParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifySampleParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleParameter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifySampleParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sampleParameter(soap, "sampleParameter", &(a->ns1__modifySampleParameter::sampleParameter), "ns1:sampleParameter"))
				{	soap_flag_sampleParameter1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifySampleParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifySampleParameter, 0, sizeof(ns1__modifySampleParameter), 0, soap_copy_ns1__modifySampleParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifySampleParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifySampleParameter);
	if (this->soap_out(soap, tag?tag:"ns1:modifySampleParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifySampleParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifySampleParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifySampleParameter * SOAP_FMAC4 soap_get_ns1__modifySampleParameter(struct soap *soap, ns1__modifySampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifySampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifySampleParameter * SOAP_FMAC2 soap_instantiate_ns1__modifySampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifySampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifySampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameter);
		if (size)
			*size = sizeof(ns1__modifySampleParameter);
		((ns1__modifySampleParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifySampleParameter);
		for (int i = 0; i < n; i++)
			((ns1__modifySampleParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifySampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifySampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifySampleParameter %p -> %p\n", q, p));
	*(ns1__modifySampleParameter*)p = *(ns1__modifySampleParameter*)q;
}

void ns1__listDatafileFormatsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datafileFormat(soap, &this->ns1__listDatafileFormatsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listDatafileFormatsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datafileFormat(soap, &this->ns1__listDatafileFormatsResponse::return_);
	/* transient soap skipped */
}

int ns1__listDatafileFormatsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listDatafileFormatsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listDatafileFormatsResponse(struct soap *soap, const char *tag, int id, const ns1__listDatafileFormatsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listDatafileFormatsResponse), "ns1:listDatafileFormatsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__datafileFormat(soap, "return", -1, &(a->ns1__listDatafileFormatsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listDatafileFormatsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listDatafileFormatsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listDatafileFormatsResponse * SOAP_FMAC4 soap_in_ns1__listDatafileFormatsResponse(struct soap *soap, const char *tag, ns1__listDatafileFormatsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listDatafileFormatsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listDatafileFormatsResponse, sizeof(ns1__listDatafileFormatsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listDatafileFormatsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listDatafileFormatsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafileFormat(soap, "return", &(a->ns1__listDatafileFormatsResponse::return_), "ns1:datafileFormat"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listDatafileFormatsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listDatafileFormatsResponse, 0, sizeof(ns1__listDatafileFormatsResponse), 0, soap_copy_ns1__listDatafileFormatsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listDatafileFormatsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listDatafileFormatsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listDatafileFormatsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listDatafileFormatsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listDatafileFormatsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listDatafileFormatsResponse * SOAP_FMAC4 soap_get_ns1__listDatafileFormatsResponse(struct soap *soap, ns1__listDatafileFormatsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listDatafileFormatsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listDatafileFormatsResponse * SOAP_FMAC2 soap_instantiate_ns1__listDatafileFormatsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listDatafileFormatsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listDatafileFormatsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormatsResponse);
		if (size)
			*size = sizeof(ns1__listDatafileFormatsResponse);
		((ns1__listDatafileFormatsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormatsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listDatafileFormatsResponse);
		for (int i = 0; i < n; i++)
			((ns1__listDatafileFormatsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listDatafileFormatsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listDatafileFormatsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listDatafileFormatsResponse %p -> %p\n", q, p));
	*(ns1__listDatafileFormatsResponse*)p = *(ns1__listDatafileFormatsResponse*)q;
}

void ns1__listDatafileFormats::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listDatafileFormats::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listDatafileFormats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listDatafileFormats::sessionId);
	/* transient soap skipped */
}

int ns1__listDatafileFormats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listDatafileFormats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listDatafileFormats(struct soap *soap, const char *tag, int id, const ns1__listDatafileFormats *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listDatafileFormats), "ns1:listDatafileFormats"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listDatafileFormats::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listDatafileFormats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listDatafileFormats(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listDatafileFormats * SOAP_FMAC4 soap_in_ns1__listDatafileFormats(struct soap *soap, const char *tag, ns1__listDatafileFormats *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listDatafileFormats *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listDatafileFormats, sizeof(ns1__listDatafileFormats), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listDatafileFormats)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listDatafileFormats *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listDatafileFormats::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listDatafileFormats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listDatafileFormats, 0, sizeof(ns1__listDatafileFormats), 0, soap_copy_ns1__listDatafileFormats);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listDatafileFormats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listDatafileFormats);
	if (this->soap_out(soap, tag?tag:"ns1:listDatafileFormats", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listDatafileFormats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listDatafileFormats(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listDatafileFormats * SOAP_FMAC4 soap_get_ns1__listDatafileFormats(struct soap *soap, ns1__listDatafileFormats *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listDatafileFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listDatafileFormats * SOAP_FMAC2 soap_instantiate_ns1__listDatafileFormats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listDatafileFormats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listDatafileFormats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormats);
		if (size)
			*size = sizeof(ns1__listDatafileFormats);
		((ns1__listDatafileFormats*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormats[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listDatafileFormats);
		for (int i = 0; i < n; i++)
			((ns1__listDatafileFormats*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listDatafileFormats*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listDatafileFormats(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listDatafileFormats %p -> %p\n", q, p));
	*(ns1__listDatafileFormats*)p = *(ns1__listDatafileFormats*)q;
}

void ns1__searchByAdvancedPaginationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByAdvancedPaginationResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByAdvancedPaginationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByAdvancedPaginationResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByAdvancedPaginationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByAdvancedPaginationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByAdvancedPaginationResponse(struct soap *soap, const char *tag, int id, const ns1__searchByAdvancedPaginationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse), "ns1:searchByAdvancedPaginationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByAdvancedPaginationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByAdvancedPaginationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByAdvancedPaginationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByAdvancedPaginationResponse * SOAP_FMAC4 soap_in_ns1__searchByAdvancedPaginationResponse(struct soap *soap, const char *tag, ns1__searchByAdvancedPaginationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByAdvancedPaginationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse, sizeof(ns1__searchByAdvancedPaginationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByAdvancedPaginationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByAdvancedPaginationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByAdvancedPaginationResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByAdvancedPaginationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse, 0, sizeof(ns1__searchByAdvancedPaginationResponse), 0, soap_copy_ns1__searchByAdvancedPaginationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByAdvancedPaginationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByAdvancedPaginationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByAdvancedPaginationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByAdvancedPaginationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByAdvancedPaginationResponse * SOAP_FMAC4 soap_get_ns1__searchByAdvancedPaginationResponse(struct soap *soap, ns1__searchByAdvancedPaginationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByAdvancedPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByAdvancedPaginationResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByAdvancedPaginationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByAdvancedPaginationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPaginationResponse);
		if (size)
			*size = sizeof(ns1__searchByAdvancedPaginationResponse);
		((ns1__searchByAdvancedPaginationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPaginationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByAdvancedPaginationResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByAdvancedPaginationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByAdvancedPaginationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByAdvancedPaginationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByAdvancedPaginationResponse %p -> %p\n", q, p));
	*(ns1__searchByAdvancedPaginationResponse*)p = *(ns1__searchByAdvancedPaginationResponse*)q;
}

void ns1__searchByAdvancedPagination::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByAdvancedPagination::sessionId = NULL;
	this->ns1__searchByAdvancedPagination::advancedSearchDetails = NULL;
	soap_default_int(soap, &this->ns1__searchByAdvancedPagination::startIndex);
	soap_default_int(soap, &this->ns1__searchByAdvancedPagination::numberOfResults);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByAdvancedPagination::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByAdvancedPagination::sessionId);
	soap_serialize_PointerTons1__advancedSearchDetails(soap, &this->ns1__searchByAdvancedPagination::advancedSearchDetails);
	soap_embedded(soap, &this->ns1__searchByAdvancedPagination::startIndex, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__searchByAdvancedPagination::numberOfResults, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__searchByAdvancedPagination::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByAdvancedPagination(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByAdvancedPagination(struct soap *soap, const char *tag, int id, const ns1__searchByAdvancedPagination *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByAdvancedPagination), "ns1:searchByAdvancedPagination"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByAdvancedPagination::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__advancedSearchDetails(soap, "advancedSearchDetails", -1, &(a->ns1__searchByAdvancedPagination::advancedSearchDetails), ""))
		return soap->error;
	if (soap_out_int(soap, "startIndex", -1, &(a->ns1__searchByAdvancedPagination::startIndex), ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfResults", -1, &(a->ns1__searchByAdvancedPagination::numberOfResults), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByAdvancedPagination::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByAdvancedPagination(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByAdvancedPagination * SOAP_FMAC4 soap_in_ns1__searchByAdvancedPagination(struct soap *soap, const char *tag, ns1__searchByAdvancedPagination *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByAdvancedPagination *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByAdvancedPagination, sizeof(ns1__searchByAdvancedPagination), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByAdvancedPagination)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByAdvancedPagination *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_advancedSearchDetails1 = 1;
	size_t soap_flag_startIndex1 = 1;
	size_t soap_flag_numberOfResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByAdvancedPagination::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_advancedSearchDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__advancedSearchDetails(soap, "advancedSearchDetails", &(a->ns1__searchByAdvancedPagination::advancedSearchDetails), "ns1:advancedSearchDetails"))
				{	soap_flag_advancedSearchDetails1--;
					continue;
				}
			if (soap_flag_startIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startIndex", &(a->ns1__searchByAdvancedPagination::startIndex), "xsd:int"))
				{	soap_flag_startIndex1--;
					continue;
				}
			if (soap_flag_numberOfResults1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfResults", &(a->ns1__searchByAdvancedPagination::numberOfResults), "xsd:int"))
				{	soap_flag_numberOfResults1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByAdvancedPagination *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByAdvancedPagination, 0, sizeof(ns1__searchByAdvancedPagination), 0, soap_copy_ns1__searchByAdvancedPagination);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startIndex1 > 0 || soap_flag_numberOfResults1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__searchByAdvancedPagination::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByAdvancedPagination);
	if (this->soap_out(soap, tag?tag:"ns1:searchByAdvancedPagination", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByAdvancedPagination::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByAdvancedPagination(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByAdvancedPagination * SOAP_FMAC4 soap_get_ns1__searchByAdvancedPagination(struct soap *soap, ns1__searchByAdvancedPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByAdvancedPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByAdvancedPagination * SOAP_FMAC2 soap_instantiate_ns1__searchByAdvancedPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByAdvancedPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByAdvancedPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPagination);
		if (size)
			*size = sizeof(ns1__searchByAdvancedPagination);
		((ns1__searchByAdvancedPagination*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByAdvancedPagination);
		for (int i = 0; i < n; i++)
			((ns1__searchByAdvancedPagination*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByAdvancedPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByAdvancedPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByAdvancedPagination %p -> %p\n", q, p));
	*(ns1__searchByAdvancedPagination*)p = *(ns1__searchByAdvancedPagination*)q;
}

void ns1__searchByAdvancedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByAdvancedResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByAdvancedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByAdvancedResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByAdvancedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByAdvancedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByAdvancedResponse(struct soap *soap, const char *tag, int id, const ns1__searchByAdvancedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByAdvancedResponse), "ns1:searchByAdvancedResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByAdvancedResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByAdvancedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByAdvancedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByAdvancedResponse * SOAP_FMAC4 soap_in_ns1__searchByAdvancedResponse(struct soap *soap, const char *tag, ns1__searchByAdvancedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByAdvancedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByAdvancedResponse, sizeof(ns1__searchByAdvancedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByAdvancedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByAdvancedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByAdvancedResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByAdvancedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByAdvancedResponse, 0, sizeof(ns1__searchByAdvancedResponse), 0, soap_copy_ns1__searchByAdvancedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByAdvancedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByAdvancedResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByAdvancedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByAdvancedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByAdvancedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByAdvancedResponse * SOAP_FMAC4 soap_get_ns1__searchByAdvancedResponse(struct soap *soap, ns1__searchByAdvancedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByAdvancedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByAdvancedResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByAdvancedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByAdvancedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByAdvancedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedResponse);
		if (size)
			*size = sizeof(ns1__searchByAdvancedResponse);
		((ns1__searchByAdvancedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByAdvancedResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByAdvancedResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByAdvancedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByAdvancedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByAdvancedResponse %p -> %p\n", q, p));
	*(ns1__searchByAdvancedResponse*)p = *(ns1__searchByAdvancedResponse*)q;
}

void ns1__advancedSearchDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__advancedSearchDetails::backCatalogueInvestigatorString = NULL;
	soap_default_bool(soap, &this->ns1__advancedSearchDetails::caseSensitive);
	this->ns1__advancedSearchDetails::datafileName = NULL;
	this->ns1__advancedSearchDetails::dateRangeEnd = NULL;
	this->ns1__advancedSearchDetails::dateRangeStart = NULL;
	this->ns1__advancedSearchDetails::experimentNumber = NULL;
	this->ns1__advancedSearchDetails::grantId = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__advancedSearchDetails::instruments);
	this->ns1__advancedSearchDetails::investigationAbstract = NULL;
	this->ns1__advancedSearchDetails::investigationInclude = NULL;
	this->ns1__advancedSearchDetails::investigationName = NULL;
	this->ns1__advancedSearchDetails::investigationType = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__advancedSearchDetails::investigators);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__advancedSearchDetails::keywords);
	this->ns1__advancedSearchDetails::runEnd = NULL;
	this->ns1__advancedSearchDetails::runStart = NULL;
	this->ns1__advancedSearchDetails::sampleName = NULL;
	this->ns1__advancedSearchDetails::visitId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__advancedSearchDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::backCatalogueInvestigatorString);
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::datafileName);
	soap_serialize_PointerTotime(soap, &this->ns1__advancedSearchDetails::dateRangeEnd);
	soap_serialize_PointerTotime(soap, &this->ns1__advancedSearchDetails::dateRangeStart);
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::experimentNumber);
	soap_serialize_PointerToLONG64(soap, &this->ns1__advancedSearchDetails::grantId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__advancedSearchDetails::instruments);
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::investigationAbstract);
	soap_serialize_PointerTons1__investigationInclude(soap, &this->ns1__advancedSearchDetails::investigationInclude);
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::investigationName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::investigationType);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__advancedSearchDetails::investigators);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__advancedSearchDetails::keywords);
	soap_serialize_PointerTodouble(soap, &this->ns1__advancedSearchDetails::runEnd);
	soap_serialize_PointerTodouble(soap, &this->ns1__advancedSearchDetails::runStart);
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::sampleName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__advancedSearchDetails::visitId);
	/* transient soap skipped */
}

int ns1__advancedSearchDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__advancedSearchDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__advancedSearchDetails(struct soap *soap, const char *tag, int id, const ns1__advancedSearchDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__advancedSearchDetails), "ns1:advancedSearchDetails"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "backCatalogueInvestigatorString", -1, &(a->ns1__advancedSearchDetails::backCatalogueInvestigatorString), ""))
		return soap->error;
	if (soap_out_bool(soap, "caseSensitive", -1, &(a->ns1__advancedSearchDetails::caseSensitive), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "datafileName", -1, &(a->ns1__advancedSearchDetails::datafileName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "dateRangeEnd", -1, &(a->ns1__advancedSearchDetails::dateRangeEnd), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "dateRangeStart", -1, &(a->ns1__advancedSearchDetails::dateRangeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "experimentNumber", -1, &(a->ns1__advancedSearchDetails::experimentNumber), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "grantId", -1, &(a->ns1__advancedSearchDetails::grantId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "instruments", -1, &(a->ns1__advancedSearchDetails::instruments), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "investigationAbstract", -1, &(a->ns1__advancedSearchDetails::investigationAbstract), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigationInclude(soap, "investigationInclude", -1, &(a->ns1__advancedSearchDetails::investigationInclude), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "investigationName", -1, &(a->ns1__advancedSearchDetails::investigationName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "investigationType", -1, &(a->ns1__advancedSearchDetails::investigationType), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "investigators", -1, &(a->ns1__advancedSearchDetails::investigators), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "keywords", -1, &(a->ns1__advancedSearchDetails::keywords), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "runEnd", -1, &(a->ns1__advancedSearchDetails::runEnd), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "runStart", -1, &(a->ns1__advancedSearchDetails::runStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sampleName", -1, &(a->ns1__advancedSearchDetails::sampleName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "visitId", -1, &(a->ns1__advancedSearchDetails::visitId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__advancedSearchDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__advancedSearchDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__advancedSearchDetails * SOAP_FMAC4 soap_in_ns1__advancedSearchDetails(struct soap *soap, const char *tag, ns1__advancedSearchDetails *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__advancedSearchDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__advancedSearchDetails, sizeof(ns1__advancedSearchDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__advancedSearchDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__advancedSearchDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_backCatalogueInvestigatorString1 = 1;
	size_t soap_flag_caseSensitive1 = 1;
	size_t soap_flag_datafileName1 = 1;
	size_t soap_flag_dateRangeEnd1 = 1;
	size_t soap_flag_dateRangeStart1 = 1;
	size_t soap_flag_experimentNumber1 = 1;
	size_t soap_flag_grantId1 = 1;
	size_t soap_flag_investigationAbstract1 = 1;
	size_t soap_flag_investigationInclude1 = 1;
	size_t soap_flag_investigationName1 = 1;
	size_t soap_flag_investigationType1 = 1;
	size_t soap_flag_runEnd1 = 1;
	size_t soap_flag_runStart1 = 1;
	size_t soap_flag_sampleName1 = 1;
	size_t soap_flag_visitId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_backCatalogueInvestigatorString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "backCatalogueInvestigatorString", &(a->ns1__advancedSearchDetails::backCatalogueInvestigatorString), "xsd:string"))
				{	soap_flag_backCatalogueInvestigatorString1--;
					continue;
				}
			if (soap_flag_caseSensitive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "caseSensitive", &(a->ns1__advancedSearchDetails::caseSensitive), "xsd:boolean"))
				{	soap_flag_caseSensitive1--;
					continue;
				}
			if (soap_flag_datafileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "datafileName", &(a->ns1__advancedSearchDetails::datafileName), "xsd:string"))
				{	soap_flag_datafileName1--;
					continue;
				}
			if (soap_flag_dateRangeEnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "dateRangeEnd", &(a->ns1__advancedSearchDetails::dateRangeEnd), "xsd:dateTime"))
				{	soap_flag_dateRangeEnd1--;
					continue;
				}
			if (soap_flag_dateRangeStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "dateRangeStart", &(a->ns1__advancedSearchDetails::dateRangeStart), "xsd:dateTime"))
				{	soap_flag_dateRangeStart1--;
					continue;
				}
			if (soap_flag_experimentNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "experimentNumber", &(a->ns1__advancedSearchDetails::experimentNumber), "xsd:string"))
				{	soap_flag_experimentNumber1--;
					continue;
				}
			if (soap_flag_grantId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "grantId", &(a->ns1__advancedSearchDetails::grantId), "xsd:long"))
				{	soap_flag_grantId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "instruments", &(a->ns1__advancedSearchDetails::instruments), "xsd:string"))
					continue;
			if (soap_flag_investigationAbstract1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "investigationAbstract", &(a->ns1__advancedSearchDetails::investigationAbstract), "xsd:string"))
				{	soap_flag_investigationAbstract1--;
					continue;
				}
			if (soap_flag_investigationInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigationInclude(soap, "investigationInclude", &(a->ns1__advancedSearchDetails::investigationInclude), "ns1:investigationInclude"))
				{	soap_flag_investigationInclude1--;
					continue;
				}
			if (soap_flag_investigationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "investigationName", &(a->ns1__advancedSearchDetails::investigationName), "xsd:string"))
				{	soap_flag_investigationName1--;
					continue;
				}
			if (soap_flag_investigationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "investigationType", &(a->ns1__advancedSearchDetails::investigationType), "xsd:string"))
				{	soap_flag_investigationType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "investigators", &(a->ns1__advancedSearchDetails::investigators), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "keywords", &(a->ns1__advancedSearchDetails::keywords), "xsd:string"))
					continue;
			if (soap_flag_runEnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "runEnd", &(a->ns1__advancedSearchDetails::runEnd), "xsd:double"))
				{	soap_flag_runEnd1--;
					continue;
				}
			if (soap_flag_runStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "runStart", &(a->ns1__advancedSearchDetails::runStart), "xsd:double"))
				{	soap_flag_runStart1--;
					continue;
				}
			if (soap_flag_sampleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sampleName", &(a->ns1__advancedSearchDetails::sampleName), "xsd:string"))
				{	soap_flag_sampleName1--;
					continue;
				}
			if (soap_flag_visitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "visitId", &(a->ns1__advancedSearchDetails::visitId), "xsd:string"))
				{	soap_flag_visitId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__advancedSearchDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__advancedSearchDetails, 0, sizeof(ns1__advancedSearchDetails), 0, soap_copy_ns1__advancedSearchDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_caseSensitive1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__advancedSearchDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__advancedSearchDetails);
	if (this->soap_out(soap, tag?tag:"ns1:advancedSearchDetails", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__advancedSearchDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__advancedSearchDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__advancedSearchDetails * SOAP_FMAC4 soap_get_ns1__advancedSearchDetails(struct soap *soap, ns1__advancedSearchDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__advancedSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__advancedSearchDetails * SOAP_FMAC2 soap_instantiate_ns1__advancedSearchDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__advancedSearchDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__advancedSearchDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__advancedSearchDetails);
		if (size)
			*size = sizeof(ns1__advancedSearchDetails);
		((ns1__advancedSearchDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__advancedSearchDetails[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__advancedSearchDetails);
		for (int i = 0; i < n; i++)
			((ns1__advancedSearchDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__advancedSearchDetails*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__advancedSearchDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__advancedSearchDetails %p -> %p\n", q, p));
	*(ns1__advancedSearchDetails*)p = *(ns1__advancedSearchDetails*)q;
}

void ns1__searchByAdvanced::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByAdvanced::sessionId = NULL;
	this->ns1__searchByAdvanced::advancedSearchDetails = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByAdvanced::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByAdvanced::sessionId);
	soap_serialize_PointerTons1__advancedSearchDetails(soap, &this->ns1__searchByAdvanced::advancedSearchDetails);
	/* transient soap skipped */
}

int ns1__searchByAdvanced::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByAdvanced(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByAdvanced(struct soap *soap, const char *tag, int id, const ns1__searchByAdvanced *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByAdvanced), "ns1:searchByAdvanced"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByAdvanced::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__advancedSearchDetails(soap, "advancedSearchDetails", -1, &(a->ns1__searchByAdvanced::advancedSearchDetails), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByAdvanced::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByAdvanced(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByAdvanced * SOAP_FMAC4 soap_in_ns1__searchByAdvanced(struct soap *soap, const char *tag, ns1__searchByAdvanced *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByAdvanced *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByAdvanced, sizeof(ns1__searchByAdvanced), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByAdvanced)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByAdvanced *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_advancedSearchDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByAdvanced::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_advancedSearchDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__advancedSearchDetails(soap, "advancedSearchDetails", &(a->ns1__searchByAdvanced::advancedSearchDetails), "ns1:advancedSearchDetails"))
				{	soap_flag_advancedSearchDetails1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByAdvanced *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByAdvanced, 0, sizeof(ns1__searchByAdvanced), 0, soap_copy_ns1__searchByAdvanced);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByAdvanced::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByAdvanced);
	if (this->soap_out(soap, tag?tag:"ns1:searchByAdvanced", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByAdvanced::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByAdvanced(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByAdvanced * SOAP_FMAC4 soap_get_ns1__searchByAdvanced(struct soap *soap, ns1__searchByAdvanced *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByAdvanced(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByAdvanced * SOAP_FMAC2 soap_instantiate_ns1__searchByAdvanced(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByAdvanced(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByAdvanced, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvanced);
		if (size)
			*size = sizeof(ns1__searchByAdvanced);
		((ns1__searchByAdvanced*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvanced[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByAdvanced);
		for (int i = 0; i < n; i++)
			((ns1__searchByAdvanced*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByAdvanced*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByAdvanced(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByAdvanced %p -> %p\n", q, p));
	*(ns1__searchByAdvanced*)p = *(ns1__searchByAdvanced*)q;
}

void ns1__searchByRunNumberPaginationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__searchByRunNumberPaginationResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByRunNumberPaginationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__searchByRunNumberPaginationResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByRunNumberPaginationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByRunNumberPaginationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByRunNumberPaginationResponse(struct soap *soap, const char *tag, int id, const ns1__searchByRunNumberPaginationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse), "ns1:searchByRunNumberPaginationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "return", -1, &(a->ns1__searchByRunNumberPaginationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByRunNumberPaginationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByRunNumberPaginationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByRunNumberPaginationResponse * SOAP_FMAC4 soap_in_ns1__searchByRunNumberPaginationResponse(struct soap *soap, const char *tag, ns1__searchByRunNumberPaginationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByRunNumberPaginationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse, sizeof(ns1__searchByRunNumberPaginationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByRunNumberPaginationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByRunNumberPaginationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "return", &(a->ns1__searchByRunNumberPaginationResponse::return_), "ns1:datafile"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByRunNumberPaginationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse, 0, sizeof(ns1__searchByRunNumberPaginationResponse), 0, soap_copy_ns1__searchByRunNumberPaginationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByRunNumberPaginationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByRunNumberPaginationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByRunNumberPaginationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByRunNumberPaginationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByRunNumberPaginationResponse * SOAP_FMAC4 soap_get_ns1__searchByRunNumberPaginationResponse(struct soap *soap, ns1__searchByRunNumberPaginationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByRunNumberPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByRunNumberPaginationResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByRunNumberPaginationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByRunNumberPaginationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPaginationResponse);
		if (size)
			*size = sizeof(ns1__searchByRunNumberPaginationResponse);
		((ns1__searchByRunNumberPaginationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPaginationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByRunNumberPaginationResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByRunNumberPaginationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByRunNumberPaginationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByRunNumberPaginationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByRunNumberPaginationResponse %p -> %p\n", q, p));
	*(ns1__searchByRunNumberPaginationResponse*)p = *(ns1__searchByRunNumberPaginationResponse*)q;
}

void ns1__searchByRunNumberPagination::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByRunNumberPagination::sessionId = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__searchByRunNumberPagination::instruments);
	soap_default_float(soap, &this->ns1__searchByRunNumberPagination::startRun);
	soap_default_float(soap, &this->ns1__searchByRunNumberPagination::endRun);
	soap_default_int(soap, &this->ns1__searchByRunNumberPagination::startIndex);
	soap_default_int(soap, &this->ns1__searchByRunNumberPagination::numberOfResults);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByRunNumberPagination::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByRunNumberPagination::sessionId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__searchByRunNumberPagination::instruments);
	soap_embedded(soap, &this->ns1__searchByRunNumberPagination::startIndex, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__searchByRunNumberPagination::numberOfResults, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__searchByRunNumberPagination::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByRunNumberPagination(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByRunNumberPagination(struct soap *soap, const char *tag, int id, const ns1__searchByRunNumberPagination *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByRunNumberPagination), "ns1:searchByRunNumberPagination"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByRunNumberPagination::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "instruments", -1, &(a->ns1__searchByRunNumberPagination::instruments), ""))
		return soap->error;
	if (soap_out_float(soap, "startRun", -1, &(a->ns1__searchByRunNumberPagination::startRun), ""))
		return soap->error;
	if (soap_out_float(soap, "endRun", -1, &(a->ns1__searchByRunNumberPagination::endRun), ""))
		return soap->error;
	if (soap_out_int(soap, "startIndex", -1, &(a->ns1__searchByRunNumberPagination::startIndex), ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfResults", -1, &(a->ns1__searchByRunNumberPagination::numberOfResults), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByRunNumberPagination::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByRunNumberPagination(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByRunNumberPagination * SOAP_FMAC4 soap_in_ns1__searchByRunNumberPagination(struct soap *soap, const char *tag, ns1__searchByRunNumberPagination *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByRunNumberPagination *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByRunNumberPagination, sizeof(ns1__searchByRunNumberPagination), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByRunNumberPagination)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByRunNumberPagination *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_startRun1 = 1;
	size_t soap_flag_endRun1 = 1;
	size_t soap_flag_startIndex1 = 1;
	size_t soap_flag_numberOfResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByRunNumberPagination::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "instruments", &(a->ns1__searchByRunNumberPagination::instruments), "xsd:string"))
					continue;
			if (soap_flag_startRun1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "startRun", &(a->ns1__searchByRunNumberPagination::startRun), "xsd:float"))
				{	soap_flag_startRun1--;
					continue;
				}
			if (soap_flag_endRun1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "endRun", &(a->ns1__searchByRunNumberPagination::endRun), "xsd:float"))
				{	soap_flag_endRun1--;
					continue;
				}
			if (soap_flag_startIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startIndex", &(a->ns1__searchByRunNumberPagination::startIndex), "xsd:int"))
				{	soap_flag_startIndex1--;
					continue;
				}
			if (soap_flag_numberOfResults1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfResults", &(a->ns1__searchByRunNumberPagination::numberOfResults), "xsd:int"))
				{	soap_flag_numberOfResults1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByRunNumberPagination *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByRunNumberPagination, 0, sizeof(ns1__searchByRunNumberPagination), 0, soap_copy_ns1__searchByRunNumberPagination);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startRun1 > 0 || soap_flag_endRun1 > 0 || soap_flag_startIndex1 > 0 || soap_flag_numberOfResults1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__searchByRunNumberPagination::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByRunNumberPagination);
	if (this->soap_out(soap, tag?tag:"ns1:searchByRunNumberPagination", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByRunNumberPagination::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByRunNumberPagination(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByRunNumberPagination * SOAP_FMAC4 soap_get_ns1__searchByRunNumberPagination(struct soap *soap, ns1__searchByRunNumberPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByRunNumberPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByRunNumberPagination * SOAP_FMAC2 soap_instantiate_ns1__searchByRunNumberPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByRunNumberPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByRunNumberPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPagination);
		if (size)
			*size = sizeof(ns1__searchByRunNumberPagination);
		((ns1__searchByRunNumberPagination*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByRunNumberPagination);
		for (int i = 0; i < n; i++)
			((ns1__searchByRunNumberPagination*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByRunNumberPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByRunNumberPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByRunNumberPagination %p -> %p\n", q, p));
	*(ns1__searchByRunNumberPagination*)p = *(ns1__searchByRunNumberPagination*)q;
}

void ns1__searchByRunNumberResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__searchByRunNumberResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByRunNumberResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__searchByRunNumberResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByRunNumberResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByRunNumberResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByRunNumberResponse(struct soap *soap, const char *tag, int id, const ns1__searchByRunNumberResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByRunNumberResponse), "ns1:searchByRunNumberResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "return", -1, &(a->ns1__searchByRunNumberResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByRunNumberResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByRunNumberResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByRunNumberResponse * SOAP_FMAC4 soap_in_ns1__searchByRunNumberResponse(struct soap *soap, const char *tag, ns1__searchByRunNumberResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByRunNumberResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByRunNumberResponse, sizeof(ns1__searchByRunNumberResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByRunNumberResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByRunNumberResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "return", &(a->ns1__searchByRunNumberResponse::return_), "ns1:datafile"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByRunNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByRunNumberResponse, 0, sizeof(ns1__searchByRunNumberResponse), 0, soap_copy_ns1__searchByRunNumberResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByRunNumberResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByRunNumberResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByRunNumberResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByRunNumberResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByRunNumberResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByRunNumberResponse * SOAP_FMAC4 soap_get_ns1__searchByRunNumberResponse(struct soap *soap, ns1__searchByRunNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByRunNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByRunNumberResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByRunNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByRunNumberResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByRunNumberResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberResponse);
		if (size)
			*size = sizeof(ns1__searchByRunNumberResponse);
		((ns1__searchByRunNumberResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByRunNumberResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByRunNumberResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByRunNumberResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByRunNumberResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByRunNumberResponse %p -> %p\n", q, p));
	*(ns1__searchByRunNumberResponse*)p = *(ns1__searchByRunNumberResponse*)q;
}

void ns1__searchByRunNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByRunNumber::sessionId = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__searchByRunNumber::instruments);
	soap_default_float(soap, &this->ns1__searchByRunNumber::startRun);
	soap_default_float(soap, &this->ns1__searchByRunNumber::endRun);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByRunNumber::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByRunNumber::sessionId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__searchByRunNumber::instruments);
	/* transient soap skipped */
}

int ns1__searchByRunNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByRunNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByRunNumber(struct soap *soap, const char *tag, int id, const ns1__searchByRunNumber *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByRunNumber), "ns1:searchByRunNumber"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByRunNumber::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "instruments", -1, &(a->ns1__searchByRunNumber::instruments), ""))
		return soap->error;
	if (soap_out_float(soap, "startRun", -1, &(a->ns1__searchByRunNumber::startRun), ""))
		return soap->error;
	if (soap_out_float(soap, "endRun", -1, &(a->ns1__searchByRunNumber::endRun), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByRunNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByRunNumber(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByRunNumber * SOAP_FMAC4 soap_in_ns1__searchByRunNumber(struct soap *soap, const char *tag, ns1__searchByRunNumber *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByRunNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByRunNumber, sizeof(ns1__searchByRunNumber), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByRunNumber)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByRunNumber *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_startRun1 = 1;
	size_t soap_flag_endRun1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByRunNumber::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "instruments", &(a->ns1__searchByRunNumber::instruments), "xsd:string"))
					continue;
			if (soap_flag_startRun1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "startRun", &(a->ns1__searchByRunNumber::startRun), "xsd:float"))
				{	soap_flag_startRun1--;
					continue;
				}
			if (soap_flag_endRun1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "endRun", &(a->ns1__searchByRunNumber::endRun), "xsd:float"))
				{	soap_flag_endRun1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByRunNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByRunNumber, 0, sizeof(ns1__searchByRunNumber), 0, soap_copy_ns1__searchByRunNumber);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startRun1 > 0 || soap_flag_endRun1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__searchByRunNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByRunNumber);
	if (this->soap_out(soap, tag?tag:"ns1:searchByRunNumber", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByRunNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByRunNumber(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByRunNumber * SOAP_FMAC4 soap_get_ns1__searchByRunNumber(struct soap *soap, ns1__searchByRunNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByRunNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByRunNumber * SOAP_FMAC2 soap_instantiate_ns1__searchByRunNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByRunNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByRunNumber, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumber);
		if (size)
			*size = sizeof(ns1__searchByRunNumber);
		((ns1__searchByRunNumber*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumber[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByRunNumber);
		for (int i = 0; i < n; i++)
			((ns1__searchByRunNumber*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByRunNumber*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByRunNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByRunNumber %p -> %p\n", q, p));
	*(ns1__searchByRunNumber*)p = *(ns1__searchByRunNumber*)q;
}

void ns1__addDataSetParametersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__addDataSetParametersResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataSetParametersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__addDataSetParametersResponse::return_);
	/* transient soap skipped */
}

int ns1__addDataSetParametersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataSetParametersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataSetParametersResponse(struct soap *soap, const char *tag, int id, const ns1__addDataSetParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataSetParametersResponse), "ns1:addDataSetParametersResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "return", -1, &(a->ns1__addDataSetParametersResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataSetParametersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataSetParametersResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataSetParametersResponse * SOAP_FMAC4 soap_in_ns1__addDataSetParametersResponse(struct soap *soap, const char *tag, ns1__addDataSetParametersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataSetParametersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataSetParametersResponse, sizeof(ns1__addDataSetParametersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataSetParametersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataSetParametersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "return", &(a->ns1__addDataSetParametersResponse::return_), "ns1:datasetParameter"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataSetParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataSetParametersResponse, 0, sizeof(ns1__addDataSetParametersResponse), 0, soap_copy_ns1__addDataSetParametersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataSetParametersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataSetParametersResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addDataSetParametersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataSetParametersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataSetParametersResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataSetParametersResponse * SOAP_FMAC4 soap_get_ns1__addDataSetParametersResponse(struct soap *soap, ns1__addDataSetParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataSetParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataSetParametersResponse * SOAP_FMAC2 soap_instantiate_ns1__addDataSetParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataSetParametersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataSetParametersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParametersResponse);
		if (size)
			*size = sizeof(ns1__addDataSetParametersResponse);
		((ns1__addDataSetParametersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParametersResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataSetParametersResponse);
		for (int i = 0; i < n; i++)
			((ns1__addDataSetParametersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataSetParametersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataSetParametersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataSetParametersResponse %p -> %p\n", q, p));
	*(ns1__addDataSetParametersResponse*)p = *(ns1__addDataSetParametersResponse*)q;
}

void ns1__addDataSetParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addDataSetParameters::sessionId = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__addDataSetParameters::dataSetParameters);
	this->ns1__addDataSetParameters::datasetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataSetParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addDataSetParameters::sessionId);
	soap_serialize_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__addDataSetParameters::dataSetParameters);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addDataSetParameters::datasetId);
	/* transient soap skipped */
}

int ns1__addDataSetParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataSetParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataSetParameters(struct soap *soap, const char *tag, int id, const ns1__addDataSetParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataSetParameters), "ns1:addDataSetParameters"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addDataSetParameters::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "dataSetParameters", -1, &(a->ns1__addDataSetParameters::dataSetParameters), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__addDataSetParameters::datasetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataSetParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataSetParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataSetParameters * SOAP_FMAC4 soap_in_ns1__addDataSetParameters(struct soap *soap, const char *tag, ns1__addDataSetParameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataSetParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataSetParameters, sizeof(ns1__addDataSetParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataSetParameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataSetParameters *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addDataSetParameters::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "dataSetParameters", &(a->ns1__addDataSetParameters::dataSetParameters), "ns1:datasetParameter"))
					continue;
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__addDataSetParameters::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataSetParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataSetParameters, 0, sizeof(ns1__addDataSetParameters), 0, soap_copy_ns1__addDataSetParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataSetParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataSetParameters);
	if (this->soap_out(soap, tag?tag:"ns1:addDataSetParameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataSetParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataSetParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataSetParameters * SOAP_FMAC4 soap_get_ns1__addDataSetParameters(struct soap *soap, ns1__addDataSetParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataSetParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataSetParameters * SOAP_FMAC2 soap_instantiate_ns1__addDataSetParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataSetParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataSetParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameters);
		if (size)
			*size = sizeof(ns1__addDataSetParameters);
		((ns1__addDataSetParameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameters[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataSetParameters);
		for (int i = 0; i < n; i++)
			((ns1__addDataSetParameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataSetParameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataSetParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataSetParameters %p -> %p\n", q, p));
	*(ns1__addDataSetParameters*)p = *(ns1__addDataSetParameters*)q;
}

void ns1__deleteKeywordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteKeywordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteKeywordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteKeywordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteKeywordResponse(struct soap *soap, const char *tag, int id, const ns1__deleteKeywordResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteKeywordResponse");
}

void *ns1__deleteKeywordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteKeywordResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteKeywordResponse * SOAP_FMAC4 soap_in_ns1__deleteKeywordResponse(struct soap *soap, const char *tag, ns1__deleteKeywordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteKeywordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteKeywordResponse, sizeof(ns1__deleteKeywordResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteKeywordResponse)
			return (ns1__deleteKeywordResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteKeywordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteKeywordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteKeywordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteKeywordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteKeywordResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteKeywordResponse * SOAP_FMAC4 soap_get_ns1__deleteKeywordResponse(struct soap *soap, ns1__deleteKeywordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteKeywordResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteKeywordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteKeywordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteKeywordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeywordResponse);
		if (size)
			*size = sizeof(ns1__deleteKeywordResponse);
		((ns1__deleteKeywordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeywordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteKeywordResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteKeywordResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteKeywordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteKeywordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteKeywordResponse %p -> %p\n", q, p));
	*(ns1__deleteKeywordResponse*)p = *(ns1__deleteKeywordResponse*)q;
}

void ns1__deleteKeyword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteKeyword::sessionId = NULL;
	this->ns1__deleteKeyword::keywordPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteKeyword::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteKeyword::sessionId);
	soap_serialize_PointerTons1__keywordPK(soap, &this->ns1__deleteKeyword::keywordPK);
	/* transient soap skipped */
}

int ns1__deleteKeyword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteKeyword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteKeyword(struct soap *soap, const char *tag, int id, const ns1__deleteKeyword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteKeyword), "ns1:deleteKeyword"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteKeyword::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__keywordPK(soap, "keywordPK", -1, &(a->ns1__deleteKeyword::keywordPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteKeyword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteKeyword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteKeyword * SOAP_FMAC4 soap_in_ns1__deleteKeyword(struct soap *soap, const char *tag, ns1__deleteKeyword *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteKeyword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteKeyword, sizeof(ns1__deleteKeyword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteKeyword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteKeyword *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_keywordPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteKeyword::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_keywordPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keywordPK(soap, "keywordPK", &(a->ns1__deleteKeyword::keywordPK), "ns1:keywordPK"))
				{	soap_flag_keywordPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteKeyword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteKeyword, 0, sizeof(ns1__deleteKeyword), 0, soap_copy_ns1__deleteKeyword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteKeyword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteKeyword);
	if (this->soap_out(soap, tag?tag:"ns1:deleteKeyword", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteKeyword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteKeyword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteKeyword * SOAP_FMAC4 soap_get_ns1__deleteKeyword(struct soap *soap, ns1__deleteKeyword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteKeyword * SOAP_FMAC2 soap_instantiate_ns1__deleteKeyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteKeyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteKeyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeyword);
		if (size)
			*size = sizeof(ns1__deleteKeyword);
		((ns1__deleteKeyword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeyword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteKeyword);
		for (int i = 0; i < n; i++)
			((ns1__deleteKeyword*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteKeyword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteKeyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteKeyword %p -> %p\n", q, p));
	*(ns1__deleteKeyword*)p = *(ns1__deleteKeyword*)q;
}

void ns1__deleteSampleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteSampleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteSampleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteSampleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteSampleResponse(struct soap *soap, const char *tag, int id, const ns1__deleteSampleResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteSampleResponse");
}

void *ns1__deleteSampleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteSampleResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteSampleResponse * SOAP_FMAC4 soap_in_ns1__deleteSampleResponse(struct soap *soap, const char *tag, ns1__deleteSampleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteSampleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteSampleResponse, sizeof(ns1__deleteSampleResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteSampleResponse)
			return (ns1__deleteSampleResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteSampleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteSampleResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteSampleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteSampleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteSampleResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteSampleResponse * SOAP_FMAC4 soap_get_ns1__deleteSampleResponse(struct soap *soap, ns1__deleteSampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteSampleResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteSampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteSampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteSampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleResponse);
		if (size)
			*size = sizeof(ns1__deleteSampleResponse);
		((ns1__deleteSampleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteSampleResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteSampleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteSampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteSampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteSampleResponse %p -> %p\n", q, p));
	*(ns1__deleteSampleResponse*)p = *(ns1__deleteSampleResponse*)q;
}

void ns1__deleteSample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteSample::sessionId = NULL;
	this->ns1__deleteSample::sampleId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteSample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteSample::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__deleteSample::sampleId);
	/* transient soap skipped */
}

int ns1__deleteSample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteSample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteSample(struct soap *soap, const char *tag, int id, const ns1__deleteSample *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteSample), "ns1:deleteSample"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteSample::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "sampleId", -1, &(a->ns1__deleteSample::sampleId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteSample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteSample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteSample * SOAP_FMAC4 soap_in_ns1__deleteSample(struct soap *soap, const char *tag, ns1__deleteSample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteSample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteSample, sizeof(ns1__deleteSample), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteSample)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteSample *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteSample::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "sampleId", &(a->ns1__deleteSample::sampleId), "xsd:long"))
				{	soap_flag_sampleId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteSample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteSample, 0, sizeof(ns1__deleteSample), 0, soap_copy_ns1__deleteSample);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteSample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteSample);
	if (this->soap_out(soap, tag?tag:"ns1:deleteSample", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteSample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteSample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteSample * SOAP_FMAC4 soap_get_ns1__deleteSample(struct soap *soap, ns1__deleteSample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteSample * SOAP_FMAC2 soap_instantiate_ns1__deleteSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSample);
		if (size)
			*size = sizeof(ns1__deleteSample);
		((ns1__deleteSample*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteSample);
		for (int i = 0; i < n; i++)
			((ns1__deleteSample*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteSample %p -> %p\n", q, p));
	*(ns1__deleteSample*)p = *(ns1__deleteSample*)q;
}

void ns1__listDatasetStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__listDatasetStatusResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listDatasetStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__listDatasetStatusResponse::return_);
	/* transient soap skipped */
}

int ns1__listDatasetStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listDatasetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listDatasetStatusResponse(struct soap *soap, const char *tag, int id, const ns1__listDatasetStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listDatasetStatusResponse), "ns1:listDatasetStatusResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__listDatasetStatusResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listDatasetStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listDatasetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listDatasetStatusResponse * SOAP_FMAC4 soap_in_ns1__listDatasetStatusResponse(struct soap *soap, const char *tag, ns1__listDatasetStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listDatasetStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listDatasetStatusResponse, sizeof(ns1__listDatasetStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listDatasetStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listDatasetStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__listDatasetStatusResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listDatasetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listDatasetStatusResponse, 0, sizeof(ns1__listDatasetStatusResponse), 0, soap_copy_ns1__listDatasetStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listDatasetStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listDatasetStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listDatasetStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listDatasetStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listDatasetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listDatasetStatusResponse * SOAP_FMAC4 soap_get_ns1__listDatasetStatusResponse(struct soap *soap, ns1__listDatasetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listDatasetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listDatasetStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__listDatasetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listDatasetStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listDatasetStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatusResponse);
		if (size)
			*size = sizeof(ns1__listDatasetStatusResponse);
		((ns1__listDatasetStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listDatasetStatusResponse);
		for (int i = 0; i < n; i++)
			((ns1__listDatasetStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listDatasetStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listDatasetStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listDatasetStatusResponse %p -> %p\n", q, p));
	*(ns1__listDatasetStatusResponse*)p = *(ns1__listDatasetStatusResponse*)q;
}

void ns1__listDatasetStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listDatasetStatus::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listDatasetStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listDatasetStatus::sessionId);
	/* transient soap skipped */
}

int ns1__listDatasetStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listDatasetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listDatasetStatus(struct soap *soap, const char *tag, int id, const ns1__listDatasetStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listDatasetStatus), "ns1:listDatasetStatus"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listDatasetStatus::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listDatasetStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listDatasetStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listDatasetStatus * SOAP_FMAC4 soap_in_ns1__listDatasetStatus(struct soap *soap, const char *tag, ns1__listDatasetStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listDatasetStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listDatasetStatus, sizeof(ns1__listDatasetStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listDatasetStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listDatasetStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listDatasetStatus::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listDatasetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listDatasetStatus, 0, sizeof(ns1__listDatasetStatus), 0, soap_copy_ns1__listDatasetStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listDatasetStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listDatasetStatus);
	if (this->soap_out(soap, tag?tag:"ns1:listDatasetStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listDatasetStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listDatasetStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listDatasetStatus * SOAP_FMAC4 soap_get_ns1__listDatasetStatus(struct soap *soap, ns1__listDatasetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listDatasetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listDatasetStatus * SOAP_FMAC2 soap_instantiate_ns1__listDatasetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listDatasetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listDatasetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatus);
		if (size)
			*size = sizeof(ns1__listDatasetStatus);
		((ns1__listDatasetStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listDatasetStatus);
		for (int i = 0; i < n; i++)
			((ns1__listDatasetStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listDatasetStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listDatasetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listDatasetStatus %p -> %p\n", q, p));
	*(ns1__listDatasetStatus*)p = *(ns1__listDatasetStatus*)q;
}

void ns1__modifyInvestigationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyInvestigationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifyInvestigationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyInvestigationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyInvestigationResponse(struct soap *soap, const char *tag, int id, const ns1__modifyInvestigationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifyInvestigationResponse");
}

void *ns1__modifyInvestigationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyInvestigationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyInvestigationResponse * SOAP_FMAC4 soap_in_ns1__modifyInvestigationResponse(struct soap *soap, const char *tag, ns1__modifyInvestigationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifyInvestigationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyInvestigationResponse, sizeof(ns1__modifyInvestigationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyInvestigationResponse)
			return (ns1__modifyInvestigationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifyInvestigationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyInvestigationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifyInvestigationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyInvestigationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyInvestigationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyInvestigationResponse * SOAP_FMAC4 soap_get_ns1__modifyInvestigationResponse(struct soap *soap, ns1__modifyInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyInvestigationResponse * SOAP_FMAC2 soap_instantiate_ns1__modifyInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigationResponse);
		if (size)
			*size = sizeof(ns1__modifyInvestigationResponse);
		((ns1__modifyInvestigationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyInvestigationResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifyInvestigationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyInvestigationResponse %p -> %p\n", q, p));
	*(ns1__modifyInvestigationResponse*)p = *(ns1__modifyInvestigationResponse*)q;
}

void ns1__modifyInvestigation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifyInvestigation::sessionId = NULL;
	this->ns1__modifyInvestigation::investigaion = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyInvestigation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifyInvestigation::sessionId);
	soap_serialize_PointerTons1__investigation(soap, &this->ns1__modifyInvestigation::investigaion);
	/* transient soap skipped */
}

int ns1__modifyInvestigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyInvestigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyInvestigation(struct soap *soap, const char *tag, int id, const ns1__modifyInvestigation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyInvestigation), "ns1:modifyInvestigation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifyInvestigation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigation(soap, "investigaion", -1, &(a->ns1__modifyInvestigation::investigaion), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifyInvestigation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyInvestigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyInvestigation * SOAP_FMAC4 soap_in_ns1__modifyInvestigation(struct soap *soap, const char *tag, ns1__modifyInvestigation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifyInvestigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyInvestigation, sizeof(ns1__modifyInvestigation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyInvestigation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifyInvestigation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigaion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifyInvestigation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigaion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigation(soap, "investigaion", &(a->ns1__modifyInvestigation::investigaion), "ns1:investigation"))
				{	soap_flag_investigaion1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifyInvestigation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyInvestigation, 0, sizeof(ns1__modifyInvestigation), 0, soap_copy_ns1__modifyInvestigation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifyInvestigation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyInvestigation);
	if (this->soap_out(soap, tag?tag:"ns1:modifyInvestigation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyInvestigation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyInvestigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyInvestigation * SOAP_FMAC4 soap_get_ns1__modifyInvestigation(struct soap *soap, ns1__modifyInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyInvestigation * SOAP_FMAC2 soap_instantiate_ns1__modifyInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigation);
		if (size)
			*size = sizeof(ns1__modifyInvestigation);
		((ns1__modifyInvestigation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyInvestigation);
		for (int i = 0; i < n; i++)
			((ns1__modifyInvestigation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyInvestigation %p -> %p\n", q, p));
	*(ns1__modifyInvestigation*)p = *(ns1__modifyInvestigation*)q;
}

void ns1__addKeywordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addKeywordResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addKeywordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__keyword(soap, &this->ns1__addKeywordResponse::return_);
	/* transient soap skipped */
}

int ns1__addKeywordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addKeywordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addKeywordResponse(struct soap *soap, const char *tag, int id, const ns1__addKeywordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addKeywordResponse), "ns1:addKeywordResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__keyword(soap, "return", -1, &(a->ns1__addKeywordResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addKeywordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addKeywordResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addKeywordResponse * SOAP_FMAC4 soap_in_ns1__addKeywordResponse(struct soap *soap, const char *tag, ns1__addKeywordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addKeywordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addKeywordResponse, sizeof(ns1__addKeywordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addKeywordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addKeywordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keyword(soap, "return", &(a->ns1__addKeywordResponse::return_), "ns1:keyword"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addKeywordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addKeywordResponse, 0, sizeof(ns1__addKeywordResponse), 0, soap_copy_ns1__addKeywordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addKeywordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addKeywordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addKeywordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addKeywordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addKeywordResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addKeywordResponse * SOAP_FMAC4 soap_get_ns1__addKeywordResponse(struct soap *soap, ns1__addKeywordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addKeywordResponse * SOAP_FMAC2 soap_instantiate_ns1__addKeywordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addKeywordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addKeywordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addKeywordResponse);
		if (size)
			*size = sizeof(ns1__addKeywordResponse);
		((ns1__addKeywordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addKeywordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addKeywordResponse);
		for (int i = 0; i < n; i++)
			((ns1__addKeywordResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addKeywordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addKeywordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addKeywordResponse %p -> %p\n", q, p));
	*(ns1__addKeywordResponse*)p = *(ns1__addKeywordResponse*)q;
}

void ns1__addKeyword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addKeyword::sessionId = NULL;
	this->ns1__addKeyword::keyword = NULL;
	this->ns1__addKeyword::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addKeyword::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addKeyword::sessionId);
	soap_serialize_PointerTons1__keyword(soap, &this->ns1__addKeyword::keyword);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addKeyword::investigationId);
	/* transient soap skipped */
}

int ns1__addKeyword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addKeyword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addKeyword(struct soap *soap, const char *tag, int id, const ns1__addKeyword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addKeyword), "ns1:addKeyword"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addKeyword::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__keyword(soap, "keyword", -1, &(a->ns1__addKeyword::keyword), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__addKeyword::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addKeyword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addKeyword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addKeyword * SOAP_FMAC4 soap_in_ns1__addKeyword(struct soap *soap, const char *tag, ns1__addKeyword *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addKeyword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addKeyword, sizeof(ns1__addKeyword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addKeyword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addKeyword *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addKeyword::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_keyword1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keyword(soap, "keyword", &(a->ns1__addKeyword::keyword), "ns1:keyword"))
				{	soap_flag_keyword1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__addKeyword::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addKeyword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addKeyword, 0, sizeof(ns1__addKeyword), 0, soap_copy_ns1__addKeyword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addKeyword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addKeyword);
	if (this->soap_out(soap, tag?tag:"ns1:addKeyword", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addKeyword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addKeyword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addKeyword * SOAP_FMAC4 soap_get_ns1__addKeyword(struct soap *soap, ns1__addKeyword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addKeyword * SOAP_FMAC2 soap_instantiate_ns1__addKeyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addKeyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addKeyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addKeyword);
		if (size)
			*size = sizeof(ns1__addKeyword);
		((ns1__addKeyword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addKeyword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addKeyword);
		for (int i = 0; i < n; i++)
			((ns1__addKeyword*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addKeyword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addKeyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addKeyword %p -> %p\n", q, p));
	*(ns1__addKeyword*)p = *(ns1__addKeyword*)q;
}

void ns1__icatAuthorisation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__icatAuthorisation::elementId = NULL;
	this->ns1__icatAuthorisation::elementType = NULL;
	this->ns1__icatAuthorisation::role = NULL;
	this->ns1__icatAuthorisation::userChildRecord = NULL;
	this->ns1__icatAuthorisation::userId = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__icatAuthorisation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__icatAuthorisation::elementId);
	soap_serialize_PointerTons1__elementType(soap, &this->ns1__icatAuthorisation::elementType);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__icatAuthorisation::role);
	soap_serialize_PointerToLONG64(soap, &this->ns1__icatAuthorisation::userChildRecord);
	soap_serialize_PointerTostd__string(soap, &this->ns1__icatAuthorisation::userId);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__icatAuthorisation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__icatAuthorisation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__icatAuthorisation(struct soap *soap, const char *tag, int id, const ns1__icatAuthorisation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__icatAuthorisation), "ns1:icatAuthorisation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "elementId", -1, &(a->ns1__icatAuthorisation::elementId), ""))
		return soap->error;
	if (soap_out_PointerTons1__elementType(soap, "elementType", -1, &(a->ns1__icatAuthorisation::elementType), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "role", -1, &(a->ns1__icatAuthorisation::role), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "userChildRecord", -1, &(a->ns1__icatAuthorisation::userChildRecord), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userId", -1, &(a->ns1__icatAuthorisation::userId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__icatAuthorisation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__icatAuthorisation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__icatAuthorisation * SOAP_FMAC4 soap_in_ns1__icatAuthorisation(struct soap *soap, const char *tag, ns1__icatAuthorisation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__icatAuthorisation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__icatAuthorisation, sizeof(ns1__icatAuthorisation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__icatAuthorisation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__icatAuthorisation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_elementId1 = 1;
	size_t soap_flag_elementType1 = 1;
	size_t soap_flag_role1 = 1;
	size_t soap_flag_userChildRecord1 = 1;
	size_t soap_flag_userId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_elementId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "elementId", &(a->ns1__icatAuthorisation::elementId), "xsd:long"))
				{	soap_flag_elementId1--;
					continue;
				}
			if (soap_flag_elementType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__elementType(soap, "elementType", &(a->ns1__icatAuthorisation::elementType), "ns1:elementType"))
				{	soap_flag_elementType1--;
					continue;
				}
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "role", &(a->ns1__icatAuthorisation::role), "ns1:icatRole"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag_userChildRecord1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "userChildRecord", &(a->ns1__icatAuthorisation::userChildRecord), "xsd:long"))
				{	soap_flag_userChildRecord1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userId", &(a->ns1__icatAuthorisation::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__icatAuthorisation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__icatAuthorisation, 0, sizeof(ns1__icatAuthorisation), 0, soap_copy_ns1__icatAuthorisation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__icatAuthorisation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__icatAuthorisation);
	if (this->soap_out(soap, tag?tag:"ns1:icatAuthorisation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__icatAuthorisation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__icatAuthorisation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__icatAuthorisation * SOAP_FMAC4 soap_get_ns1__icatAuthorisation(struct soap *soap, ns1__icatAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__icatAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__icatAuthorisation * SOAP_FMAC2 soap_instantiate_ns1__icatAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__icatAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__icatAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__icatAuthorisation);
		if (size)
			*size = sizeof(ns1__icatAuthorisation);
		((ns1__icatAuthorisation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__icatAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__icatAuthorisation);
		for (int i = 0; i < n; i++)
			((ns1__icatAuthorisation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__icatAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__icatAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__icatAuthorisation %p -> %p\n", q, p));
	*(ns1__icatAuthorisation*)p = *(ns1__icatAuthorisation*)q;
}

void ns1__getAuthorisationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__icatAuthorisation(soap, &this->ns1__getAuthorisationsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getAuthorisationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__icatAuthorisation(soap, &this->ns1__getAuthorisationsResponse::return_);
	/* transient soap skipped */
}

int ns1__getAuthorisationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAuthorisationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAuthorisationsResponse(struct soap *soap, const char *tag, int id, const ns1__getAuthorisationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAuthorisationsResponse), "ns1:getAuthorisationsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__icatAuthorisation(soap, "return", -1, &(a->ns1__getAuthorisationsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getAuthorisationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAuthorisationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAuthorisationsResponse * SOAP_FMAC4 soap_in_ns1__getAuthorisationsResponse(struct soap *soap, const char *tag, ns1__getAuthorisationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAuthorisationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAuthorisationsResponse, sizeof(ns1__getAuthorisationsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAuthorisationsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAuthorisationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__icatAuthorisation(soap, "return", &(a->ns1__getAuthorisationsResponse::return_), "ns1:icatAuthorisation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAuthorisationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAuthorisationsResponse, 0, sizeof(ns1__getAuthorisationsResponse), 0, soap_copy_ns1__getAuthorisationsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAuthorisationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAuthorisationsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAuthorisationsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAuthorisationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAuthorisationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAuthorisationsResponse * SOAP_FMAC4 soap_get_ns1__getAuthorisationsResponse(struct soap *soap, ns1__getAuthorisationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAuthorisationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAuthorisationsResponse * SOAP_FMAC2 soap_instantiate_ns1__getAuthorisationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAuthorisationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAuthorisationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisationsResponse);
		if (size)
			*size = sizeof(ns1__getAuthorisationsResponse);
		((ns1__getAuthorisationsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisationsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAuthorisationsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getAuthorisationsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAuthorisationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAuthorisationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAuthorisationsResponse %p -> %p\n", q, p));
	*(ns1__getAuthorisationsResponse*)p = *(ns1__getAuthorisationsResponse*)q;
}

void ns1__getAuthorisations::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getAuthorisations::sessionId = NULL;
	this->ns1__getAuthorisations::elementId = NULL;
	this->ns1__getAuthorisations::elementType = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getAuthorisations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAuthorisations::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getAuthorisations::elementId);
	soap_serialize_PointerTons1__elementType(soap, &this->ns1__getAuthorisations::elementType);
	/* transient soap skipped */
}

int ns1__getAuthorisations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAuthorisations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAuthorisations(struct soap *soap, const char *tag, int id, const ns1__getAuthorisations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAuthorisations), "ns1:getAuthorisations"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getAuthorisations::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "elementId", -1, &(a->ns1__getAuthorisations::elementId), ""))
		return soap->error;
	if (soap_out_PointerTons1__elementType(soap, "elementType", -1, &(a->ns1__getAuthorisations::elementType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getAuthorisations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAuthorisations(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAuthorisations * SOAP_FMAC4 soap_in_ns1__getAuthorisations(struct soap *soap, const char *tag, ns1__getAuthorisations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAuthorisations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAuthorisations, sizeof(ns1__getAuthorisations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAuthorisations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAuthorisations *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_elementId1 = 1;
	size_t soap_flag_elementType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getAuthorisations::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_elementId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "elementId", &(a->ns1__getAuthorisations::elementId), "xsd:long"))
				{	soap_flag_elementId1--;
					continue;
				}
			if (soap_flag_elementType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__elementType(soap, "elementType", &(a->ns1__getAuthorisations::elementType), "ns1:elementType"))
				{	soap_flag_elementType1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAuthorisations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAuthorisations, 0, sizeof(ns1__getAuthorisations), 0, soap_copy_ns1__getAuthorisations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAuthorisations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAuthorisations);
	if (this->soap_out(soap, tag?tag:"ns1:getAuthorisations", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAuthorisations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAuthorisations(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAuthorisations * SOAP_FMAC4 soap_get_ns1__getAuthorisations(struct soap *soap, ns1__getAuthorisations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAuthorisations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAuthorisations * SOAP_FMAC2 soap_instantiate_ns1__getAuthorisations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAuthorisations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAuthorisations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisations);
		if (size)
			*size = sizeof(ns1__getAuthorisations);
		((ns1__getAuthorisations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAuthorisations);
		for (int i = 0; i < n; i++)
			((ns1__getAuthorisations*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAuthorisations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAuthorisations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAuthorisations %p -> %p\n", q, p));
	*(ns1__getAuthorisations*)p = *(ns1__getAuthorisations*)q;
}

void ns1__removeDataSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeDataSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataSetResponse(struct soap *soap, const char *tag, int id, const ns1__removeDataSetResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeDataSetResponse");
}

void *ns1__removeDataSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataSetResponse * SOAP_FMAC4 soap_in_ns1__removeDataSetResponse(struct soap *soap, const char *tag, ns1__removeDataSetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeDataSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataSetResponse, sizeof(ns1__removeDataSetResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataSetResponse)
			return (ns1__removeDataSetResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeDataSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataSetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataSetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataSetResponse * SOAP_FMAC4 soap_get_ns1__removeDataSetResponse(struct soap *soap, ns1__removeDataSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataSetResponse * SOAP_FMAC2 soap_instantiate_ns1__removeDataSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetResponse);
		if (size)
			*size = sizeof(ns1__removeDataSetResponse);
		((ns1__removeDataSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataSetResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeDataSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataSetResponse %p -> %p\n", q, p));
	*(ns1__removeDataSetResponse*)p = *(ns1__removeDataSetResponse*)q;
}

void ns1__removeDataSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeDataSet::sessionId = NULL;
	this->ns1__removeDataSet::dataSetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeDataSet::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__removeDataSet::dataSetId);
	/* transient soap skipped */
}

int ns1__removeDataSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataSet(struct soap *soap, const char *tag, int id, const ns1__removeDataSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeDataSet), "ns1:removeDataSet"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeDataSet::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "dataSetId", -1, &(a->ns1__removeDataSet::dataSetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeDataSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataSet * SOAP_FMAC4 soap_in_ns1__removeDataSet(struct soap *soap, const char *tag, ns1__removeDataSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeDataSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataSet, sizeof(ns1__removeDataSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeDataSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataSetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeDataSet::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataSetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "dataSetId", &(a->ns1__removeDataSet::dataSetId), "xsd:long"))
				{	soap_flag_dataSetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeDataSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeDataSet, 0, sizeof(ns1__removeDataSet), 0, soap_copy_ns1__removeDataSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeDataSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataSet);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataSet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataSet * SOAP_FMAC4 soap_get_ns1__removeDataSet(struct soap *soap, ns1__removeDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataSet * SOAP_FMAC2 soap_instantiate_ns1__removeDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSet);
		if (size)
			*size = sizeof(ns1__removeDataSet);
		((ns1__removeDataSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataSet);
		for (int i = 0; i < n; i++)
			((ns1__removeDataSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataSet %p -> %p\n", q, p));
	*(ns1__removeDataSet*)p = *(ns1__removeDataSet*)q;
}

void ns1__modifyDataSetParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataSetParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifyDataSetParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataSetParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataSetParameterResponse(struct soap *soap, const char *tag, int id, const ns1__modifyDataSetParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifyDataSetParameterResponse");
}

void *ns1__modifyDataSetParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataSetParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataSetParameterResponse * SOAP_FMAC4 soap_in_ns1__modifyDataSetParameterResponse(struct soap *soap, const char *tag, ns1__modifyDataSetParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifyDataSetParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataSetParameterResponse, sizeof(ns1__modifyDataSetParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataSetParameterResponse)
			return (ns1__modifyDataSetParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifyDataSetParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataSetParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataSetParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataSetParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataSetParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataSetParameterResponse * SOAP_FMAC4 soap_get_ns1__modifyDataSetParameterResponse(struct soap *soap, ns1__modifyDataSetParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataSetParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__modifyDataSetParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataSetParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataSetParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameterResponse);
		if (size)
			*size = sizeof(ns1__modifyDataSetParameterResponse);
		((ns1__modifyDataSetParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataSetParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataSetParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataSetParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataSetParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataSetParameterResponse %p -> %p\n", q, p));
	*(ns1__modifyDataSetParameterResponse*)p = *(ns1__modifyDataSetParameterResponse*)q;
}

void ns1__modifyDataSetParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifyDataSetParameter::sessionId = NULL;
	this->ns1__modifyDataSetParameter::dataSetParameter = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataSetParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifyDataSetParameter::sessionId);
	soap_serialize_PointerTons1__datasetParameter(soap, &this->ns1__modifyDataSetParameter::dataSetParameter);
	/* transient soap skipped */
}

int ns1__modifyDataSetParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataSetParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataSetParameter(struct soap *soap, const char *tag, int id, const ns1__modifyDataSetParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyDataSetParameter), "ns1:modifyDataSetParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifyDataSetParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datasetParameter(soap, "dataSetParameter", -1, &(a->ns1__modifyDataSetParameter::dataSetParameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifyDataSetParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataSetParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataSetParameter * SOAP_FMAC4 soap_in_ns1__modifyDataSetParameter(struct soap *soap, const char *tag, ns1__modifyDataSetParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifyDataSetParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataSetParameter, sizeof(ns1__modifyDataSetParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataSetParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifyDataSetParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataSetParameter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifyDataSetParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataSetParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datasetParameter(soap, "dataSetParameter", &(a->ns1__modifyDataSetParameter::dataSetParameter), "ns1:datasetParameter"))
				{	soap_flag_dataSetParameter1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifyDataSetParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyDataSetParameter, 0, sizeof(ns1__modifyDataSetParameter), 0, soap_copy_ns1__modifyDataSetParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifyDataSetParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataSetParameter);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataSetParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataSetParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataSetParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataSetParameter * SOAP_FMAC4 soap_get_ns1__modifyDataSetParameter(struct soap *soap, ns1__modifyDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataSetParameter * SOAP_FMAC2 soap_instantiate_ns1__modifyDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameter);
		if (size)
			*size = sizeof(ns1__modifyDataSetParameter);
		((ns1__modifyDataSetParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataSetParameter);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataSetParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataSetParameter %p -> %p\n", q, p));
	*(ns1__modifyDataSetParameter*)p = *(ns1__modifyDataSetParameter*)q;
}

void ns1__listInvestigationTypesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__listInvestigationTypesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listInvestigationTypesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__listInvestigationTypesResponse::return_);
	/* transient soap skipped */
}

int ns1__listInvestigationTypesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listInvestigationTypesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listInvestigationTypesResponse(struct soap *soap, const char *tag, int id, const ns1__listInvestigationTypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listInvestigationTypesResponse), "ns1:listInvestigationTypesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__listInvestigationTypesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listInvestigationTypesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listInvestigationTypesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listInvestigationTypesResponse * SOAP_FMAC4 soap_in_ns1__listInvestigationTypesResponse(struct soap *soap, const char *tag, ns1__listInvestigationTypesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listInvestigationTypesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listInvestigationTypesResponse, sizeof(ns1__listInvestigationTypesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listInvestigationTypesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listInvestigationTypesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__listInvestigationTypesResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listInvestigationTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listInvestigationTypesResponse, 0, sizeof(ns1__listInvestigationTypesResponse), 0, soap_copy_ns1__listInvestigationTypesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listInvestigationTypesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listInvestigationTypesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listInvestigationTypesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listInvestigationTypesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listInvestigationTypesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listInvestigationTypesResponse * SOAP_FMAC4 soap_get_ns1__listInvestigationTypesResponse(struct soap *soap, ns1__listInvestigationTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listInvestigationTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listInvestigationTypesResponse * SOAP_FMAC2 soap_instantiate_ns1__listInvestigationTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listInvestigationTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listInvestigationTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypesResponse);
		if (size)
			*size = sizeof(ns1__listInvestigationTypesResponse);
		((ns1__listInvestigationTypesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listInvestigationTypesResponse);
		for (int i = 0; i < n; i++)
			((ns1__listInvestigationTypesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listInvestigationTypesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listInvestigationTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listInvestigationTypesResponse %p -> %p\n", q, p));
	*(ns1__listInvestigationTypesResponse*)p = *(ns1__listInvestigationTypesResponse*)q;
}

void ns1__listInvestigationTypes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listInvestigationTypes::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listInvestigationTypes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listInvestigationTypes::sessionId);
	/* transient soap skipped */
}

int ns1__listInvestigationTypes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listInvestigationTypes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listInvestigationTypes(struct soap *soap, const char *tag, int id, const ns1__listInvestigationTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listInvestigationTypes), "ns1:listInvestigationTypes"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listInvestigationTypes::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listInvestigationTypes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listInvestigationTypes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listInvestigationTypes * SOAP_FMAC4 soap_in_ns1__listInvestigationTypes(struct soap *soap, const char *tag, ns1__listInvestigationTypes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listInvestigationTypes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listInvestigationTypes, sizeof(ns1__listInvestigationTypes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listInvestigationTypes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listInvestigationTypes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listInvestigationTypes::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listInvestigationTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listInvestigationTypes, 0, sizeof(ns1__listInvestigationTypes), 0, soap_copy_ns1__listInvestigationTypes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listInvestigationTypes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listInvestigationTypes);
	if (this->soap_out(soap, tag?tag:"ns1:listInvestigationTypes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listInvestigationTypes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listInvestigationTypes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listInvestigationTypes * SOAP_FMAC4 soap_get_ns1__listInvestigationTypes(struct soap *soap, ns1__listInvestigationTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listInvestigationTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listInvestigationTypes * SOAP_FMAC2 soap_instantiate_ns1__listInvestigationTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listInvestigationTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listInvestigationTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypes);
		if (size)
			*size = sizeof(ns1__listInvestigationTypes);
		((ns1__listInvestigationTypes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listInvestigationTypes);
		for (int i = 0; i < n; i++)
			((ns1__listInvestigationTypes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listInvestigationTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listInvestigationTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listInvestigationTypes %p -> %p\n", q, p));
	*(ns1__listInvestigationTypes*)p = *(ns1__listInvestigationTypes*)q;
}

void ns1__getKeywordsForUserTypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserTypeResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUserTypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserTypeResponse::return_);
	/* transient soap skipped */
}

int ns1__getKeywordsForUserTypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUserTypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUserTypeResponse(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUserTypeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse), "ns1:getKeywordsForUserTypeResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getKeywordsForUserTypeResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUserTypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUserTypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserTypeResponse * SOAP_FMAC4 soap_in_ns1__getKeywordsForUserTypeResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserTypeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUserTypeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse, sizeof(ns1__getKeywordsForUserTypeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUserTypeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUserTypeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getKeywordsForUserTypeResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUserTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse, 0, sizeof(ns1__getKeywordsForUserTypeResponse), 0, soap_copy_ns1__getKeywordsForUserTypeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getKeywordsForUserTypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUserTypeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUserTypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUserTypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserTypeResponse * SOAP_FMAC4 soap_get_ns1__getKeywordsForUserTypeResponse(struct soap *soap, ns1__getKeywordsForUserTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUserTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUserTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUserTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUserTypeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserTypeResponse);
		if (size)
			*size = sizeof(ns1__getKeywordsForUserTypeResponse);
		((ns1__getKeywordsForUserTypeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserTypeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUserTypeResponse);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUserTypeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUserTypeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUserTypeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUserTypeResponse %p -> %p\n", q, p));
	*(ns1__getKeywordsForUserTypeResponse*)p = *(ns1__getKeywordsForUserTypeResponse*)q;
}

void ns1__getKeywordsForUserType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getKeywordsForUserType::sessionId = NULL;
	this->ns1__getKeywordsForUserType::keywordType = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUserType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getKeywordsForUserType::sessionId);
	soap_serialize_PointerTons1__keywordType(soap, &this->ns1__getKeywordsForUserType::keywordType);
	/* transient soap skipped */
}

int ns1__getKeywordsForUserType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUserType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUserType(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUserType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUserType), "ns1:getKeywordsForUserType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getKeywordsForUserType::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__keywordType(soap, "keywordType", -1, &(a->ns1__getKeywordsForUserType::keywordType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUserType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUserType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserType * SOAP_FMAC4 soap_in_ns1__getKeywordsForUserType(struct soap *soap, const char *tag, ns1__getKeywordsForUserType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUserType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUserType, sizeof(ns1__getKeywordsForUserType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUserType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUserType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_keywordType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getKeywordsForUserType::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_keywordType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keywordType(soap, "keywordType", &(a->ns1__getKeywordsForUserType::keywordType), "ns1:keywordType"))
				{	soap_flag_keywordType1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUserType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUserType, 0, sizeof(ns1__getKeywordsForUserType), 0, soap_copy_ns1__getKeywordsForUserType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getKeywordsForUserType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUserType);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUserType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUserType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUserType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserType * SOAP_FMAC4 soap_get_ns1__getKeywordsForUserType(struct soap *soap, ns1__getKeywordsForUserType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUserType * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUserType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUserType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUserType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserType);
		if (size)
			*size = sizeof(ns1__getKeywordsForUserType);
		((ns1__getKeywordsForUserType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUserType);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUserType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUserType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUserType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUserType %p -> %p\n", q, p));
	*(ns1__getKeywordsForUserType*)p = *(ns1__getKeywordsForUserType*)q;
}

void ns1__getKeywordsForUserMaxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserMaxResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUserMaxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserMaxResponse::return_);
	/* transient soap skipped */
}

int ns1__getKeywordsForUserMaxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUserMaxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUserMaxResponse(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUserMaxResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse), "ns1:getKeywordsForUserMaxResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getKeywordsForUserMaxResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUserMaxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUserMaxResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserMaxResponse * SOAP_FMAC4 soap_in_ns1__getKeywordsForUserMaxResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserMaxResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUserMaxResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse, sizeof(ns1__getKeywordsForUserMaxResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUserMaxResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUserMaxResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getKeywordsForUserMaxResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUserMaxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse, 0, sizeof(ns1__getKeywordsForUserMaxResponse), 0, soap_copy_ns1__getKeywordsForUserMaxResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getKeywordsForUserMaxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUserMaxResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUserMaxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUserMaxResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserMaxResponse * SOAP_FMAC4 soap_get_ns1__getKeywordsForUserMaxResponse(struct soap *soap, ns1__getKeywordsForUserMaxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUserMaxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUserMaxResponse * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUserMaxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUserMaxResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMaxResponse);
		if (size)
			*size = sizeof(ns1__getKeywordsForUserMaxResponse);
		((ns1__getKeywordsForUserMaxResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMaxResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUserMaxResponse);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUserMaxResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUserMaxResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUserMaxResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUserMaxResponse %p -> %p\n", q, p));
	*(ns1__getKeywordsForUserMaxResponse*)p = *(ns1__getKeywordsForUserMaxResponse*)q;
}

void ns1__getKeywordsForUserMax::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getKeywordsForUserMax::sessionId = NULL;
	soap_default_int(soap, &this->ns1__getKeywordsForUserMax::numberReturned);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUserMax::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getKeywordsForUserMax::sessionId);
	soap_embedded(soap, &this->ns1__getKeywordsForUserMax::numberReturned, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__getKeywordsForUserMax::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUserMax(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUserMax(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUserMax *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUserMax), "ns1:getKeywordsForUserMax"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getKeywordsForUserMax::sessionId), ""))
		return soap->error;
	if (soap_out_int(soap, "numberReturned", -1, &(a->ns1__getKeywordsForUserMax::numberReturned), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUserMax::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUserMax(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserMax * SOAP_FMAC4 soap_in_ns1__getKeywordsForUserMax(struct soap *soap, const char *tag, ns1__getKeywordsForUserMax *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUserMax *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUserMax, sizeof(ns1__getKeywordsForUserMax), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUserMax)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUserMax *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_numberReturned1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getKeywordsForUserMax::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_numberReturned1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberReturned", &(a->ns1__getKeywordsForUserMax::numberReturned), "xsd:int"))
				{	soap_flag_numberReturned1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUserMax *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUserMax, 0, sizeof(ns1__getKeywordsForUserMax), 0, soap_copy_ns1__getKeywordsForUserMax);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numberReturned1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getKeywordsForUserMax::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUserMax);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUserMax", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUserMax::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUserMax(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserMax * SOAP_FMAC4 soap_get_ns1__getKeywordsForUserMax(struct soap *soap, ns1__getKeywordsForUserMax *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUserMax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUserMax * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUserMax(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUserMax(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUserMax, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMax);
		if (size)
			*size = sizeof(ns1__getKeywordsForUserMax);
		((ns1__getKeywordsForUserMax*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMax[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUserMax);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUserMax*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUserMax*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUserMax(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUserMax %p -> %p\n", q, p));
	*(ns1__getKeywordsForUserMax*)p = *(ns1__getKeywordsForUserMax*)q;
}

void ns1__getKeywordsForUserStartWithMaxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserStartWithMaxResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUserStartWithMaxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserStartWithMaxResponse::return_);
	/* transient soap skipped */
}

int ns1__getKeywordsForUserStartWithMaxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUserStartWithMaxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUserStartWithMaxResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse), "ns1:getKeywordsForUserStartWithMaxResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getKeywordsForUserStartWithMaxResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUserStartWithMaxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUserStartWithMaxResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMaxResponse * SOAP_FMAC4 soap_in_ns1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserStartWithMaxResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUserStartWithMaxResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse, sizeof(ns1__getKeywordsForUserStartWithMaxResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUserStartWithMaxResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getKeywordsForUserStartWithMaxResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUserStartWithMaxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse, 0, sizeof(ns1__getKeywordsForUserStartWithMaxResponse), 0, soap_copy_ns1__getKeywordsForUserStartWithMaxResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getKeywordsForUserStartWithMaxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUserStartWithMaxResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUserStartWithMaxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUserStartWithMaxResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMaxResponse * SOAP_FMAC4 soap_get_ns1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, ns1__getKeywordsForUserStartWithMaxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUserStartWithMaxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUserStartWithMaxResponse * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUserStartWithMaxResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMaxResponse);
		if (size)
			*size = sizeof(ns1__getKeywordsForUserStartWithMaxResponse);
		((ns1__getKeywordsForUserStartWithMaxResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMaxResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUserStartWithMaxResponse);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUserStartWithMaxResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUserStartWithMaxResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUserStartWithMaxResponse %p -> %p\n", q, p));
	*(ns1__getKeywordsForUserStartWithMaxResponse*)p = *(ns1__getKeywordsForUserStartWithMaxResponse*)q;
}

void ns1__getKeywordsForUserStartWithMax::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getKeywordsForUserStartWithMax::sessionId = NULL;
	this->ns1__getKeywordsForUserStartWithMax::startKeyword = NULL;
	soap_default_int(soap, &this->ns1__getKeywordsForUserStartWithMax::numberReturned);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUserStartWithMax::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getKeywordsForUserStartWithMax::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getKeywordsForUserStartWithMax::startKeyword);
	soap_embedded(soap, &this->ns1__getKeywordsForUserStartWithMax::numberReturned, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__getKeywordsForUserStartWithMax::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUserStartWithMax(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUserStartWithMax(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUserStartWithMax *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax), "ns1:getKeywordsForUserStartWithMax"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getKeywordsForUserStartWithMax::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "startKeyword", -1, &(a->ns1__getKeywordsForUserStartWithMax::startKeyword), ""))
		return soap->error;
	if (soap_out_int(soap, "numberReturned", -1, &(a->ns1__getKeywordsForUserStartWithMax::numberReturned), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUserStartWithMax::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUserStartWithMax(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMax * SOAP_FMAC4 soap_in_ns1__getKeywordsForUserStartWithMax(struct soap *soap, const char *tag, ns1__getKeywordsForUserStartWithMax *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUserStartWithMax *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax, sizeof(ns1__getKeywordsForUserStartWithMax), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUserStartWithMax)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUserStartWithMax *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_startKeyword1 = 1;
	size_t soap_flag_numberReturned1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getKeywordsForUserStartWithMax::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_startKeyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "startKeyword", &(a->ns1__getKeywordsForUserStartWithMax::startKeyword), "xsd:string"))
				{	soap_flag_startKeyword1--;
					continue;
				}
			if (soap_flag_numberReturned1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberReturned", &(a->ns1__getKeywordsForUserStartWithMax::numberReturned), "xsd:int"))
				{	soap_flag_numberReturned1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUserStartWithMax *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax, 0, sizeof(ns1__getKeywordsForUserStartWithMax), 0, soap_copy_ns1__getKeywordsForUserStartWithMax);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numberReturned1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getKeywordsForUserStartWithMax::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUserStartWithMax", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUserStartWithMax::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUserStartWithMax(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMax * SOAP_FMAC4 soap_get_ns1__getKeywordsForUserStartWithMax(struct soap *soap, ns1__getKeywordsForUserStartWithMax *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUserStartWithMax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUserStartWithMax * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUserStartWithMax(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUserStartWithMax(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMax);
		if (size)
			*size = sizeof(ns1__getKeywordsForUserStartWithMax);
		((ns1__getKeywordsForUserStartWithMax*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMax[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUserStartWithMax);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUserStartWithMax*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUserStartWithMax*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUserStartWithMax(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUserStartWithMax %p -> %p\n", q, p));
	*(ns1__getKeywordsForUserStartWithMax*)p = *(ns1__getKeywordsForUserStartWithMax*)q;
}

void ns1__getKeywordsForUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getKeywordsForUserResponse::return_);
	/* transient soap skipped */
}

int ns1__getKeywordsForUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUserResponse(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUserResponse), "ns1:getKeywordsForUserResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getKeywordsForUserResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserResponse * SOAP_FMAC4 soap_in_ns1__getKeywordsForUserResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUserResponse, sizeof(ns1__getKeywordsForUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getKeywordsForUserResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUserResponse, 0, sizeof(ns1__getKeywordsForUserResponse), 0, soap_copy_ns1__getKeywordsForUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getKeywordsForUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUserResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserResponse * SOAP_FMAC4 soap_get_ns1__getKeywordsForUserResponse(struct soap *soap, ns1__getKeywordsForUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUserResponse * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserResponse);
		if (size)
			*size = sizeof(ns1__getKeywordsForUserResponse);
		((ns1__getKeywordsForUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUserResponse);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUserResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUserResponse %p -> %p\n", q, p));
	*(ns1__getKeywordsForUserResponse*)p = *(ns1__getKeywordsForUserResponse*)q;
}

void ns1__getKeywordsForUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getKeywordsForUser::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getKeywordsForUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getKeywordsForUser::sessionId);
	/* transient soap skipped */
}

int ns1__getKeywordsForUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getKeywordsForUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getKeywordsForUser(struct soap *soap, const char *tag, int id, const ns1__getKeywordsForUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getKeywordsForUser), "ns1:getKeywordsForUser"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getKeywordsForUser::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getKeywordsForUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getKeywordsForUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getKeywordsForUser * SOAP_FMAC4 soap_in_ns1__getKeywordsForUser(struct soap *soap, const char *tag, ns1__getKeywordsForUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getKeywordsForUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getKeywordsForUser, sizeof(ns1__getKeywordsForUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getKeywordsForUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getKeywordsForUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getKeywordsForUser::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getKeywordsForUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getKeywordsForUser, 0, sizeof(ns1__getKeywordsForUser), 0, soap_copy_ns1__getKeywordsForUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getKeywordsForUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getKeywordsForUser);
	if (this->soap_out(soap, tag?tag:"ns1:getKeywordsForUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getKeywordsForUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getKeywordsForUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getKeywordsForUser * SOAP_FMAC4 soap_get_ns1__getKeywordsForUser(struct soap *soap, ns1__getKeywordsForUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getKeywordsForUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getKeywordsForUser * SOAP_FMAC2 soap_instantiate_ns1__getKeywordsForUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getKeywordsForUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getKeywordsForUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUser);
		if (size)
			*size = sizeof(ns1__getKeywordsForUser);
		((ns1__getKeywordsForUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getKeywordsForUser);
		for (int i = 0; i < n; i++)
			((ns1__getKeywordsForUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getKeywordsForUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getKeywordsForUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getKeywordsForUser %p -> %p\n", q, p));
	*(ns1__getKeywordsForUser*)p = *(ns1__getKeywordsForUser*)q;
}

void ns1__downloadDatafileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadDatafileResponse::URL = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__downloadDatafileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadDatafileResponse::URL);
	/* transient soap skipped */
}

int ns1__downloadDatafileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadDatafileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadDatafileResponse(struct soap *soap, const char *tag, int id, const ns1__downloadDatafileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadDatafileResponse), "ns1:downloadDatafileResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "URL", -1, &(a->ns1__downloadDatafileResponse::URL), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadDatafileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadDatafileResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadDatafileResponse * SOAP_FMAC4 soap_in_ns1__downloadDatafileResponse(struct soap *soap, const char *tag, ns1__downloadDatafileResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadDatafileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadDatafileResponse, sizeof(ns1__downloadDatafileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadDatafileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadDatafileResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_URL1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_URL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "URL", &(a->ns1__downloadDatafileResponse::URL), "xsd:string"))
				{	soap_flag_URL1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadDatafileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadDatafileResponse, 0, sizeof(ns1__downloadDatafileResponse), 0, soap_copy_ns1__downloadDatafileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__downloadDatafileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadDatafileResponse);
	if (this->soap_out(soap, tag?tag:"ns1:downloadDatafileResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadDatafileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadDatafileResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadDatafileResponse * SOAP_FMAC4 soap_get_ns1__downloadDatafileResponse(struct soap *soap, ns1__downloadDatafileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadDatafileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadDatafileResponse * SOAP_FMAC2 soap_instantiate_ns1__downloadDatafileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadDatafileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadDatafileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafileResponse);
		if (size)
			*size = sizeof(ns1__downloadDatafileResponse);
		((ns1__downloadDatafileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadDatafileResponse);
		for (int i = 0; i < n; i++)
			((ns1__downloadDatafileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadDatafileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadDatafileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadDatafileResponse %p -> %p\n", q, p));
	*(ns1__downloadDatafileResponse*)p = *(ns1__downloadDatafileResponse*)q;
}

void ns1__downloadDatafile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadDatafile::sessionId = NULL;
	this->ns1__downloadDatafile::datafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__downloadDatafile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadDatafile::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__downloadDatafile::datafileId);
	/* transient soap skipped */
}

int ns1__downloadDatafile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadDatafile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadDatafile(struct soap *soap, const char *tag, int id, const ns1__downloadDatafile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadDatafile), "ns1:downloadDatafile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__downloadDatafile::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__downloadDatafile::datafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadDatafile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadDatafile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadDatafile * SOAP_FMAC4 soap_in_ns1__downloadDatafile(struct soap *soap, const char *tag, ns1__downloadDatafile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadDatafile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadDatafile, sizeof(ns1__downloadDatafile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadDatafile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadDatafile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__downloadDatafile::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__downloadDatafile::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadDatafile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadDatafile, 0, sizeof(ns1__downloadDatafile), 0, soap_copy_ns1__downloadDatafile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__downloadDatafile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadDatafile);
	if (this->soap_out(soap, tag?tag:"ns1:downloadDatafile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadDatafile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadDatafile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadDatafile * SOAP_FMAC4 soap_get_ns1__downloadDatafile(struct soap *soap, ns1__downloadDatafile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadDatafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadDatafile * SOAP_FMAC2 soap_instantiate_ns1__downloadDatafile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadDatafile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadDatafile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafile);
		if (size)
			*size = sizeof(ns1__downloadDatafile);
		((ns1__downloadDatafile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadDatafile);
		for (int i = 0; i < n; i++)
			((ns1__downloadDatafile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadDatafile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadDatafile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadDatafile %p -> %p\n", q, p));
	*(ns1__downloadDatafile*)p = *(ns1__downloadDatafile*)q;
}

void ns1__setDataSetSampleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__setDataSetSampleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setDataSetSampleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setDataSetSampleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setDataSetSampleResponse(struct soap *soap, const char *tag, int id, const ns1__setDataSetSampleResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:setDataSetSampleResponse");
}

void *ns1__setDataSetSampleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setDataSetSampleResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setDataSetSampleResponse * SOAP_FMAC4 soap_in_ns1__setDataSetSampleResponse(struct soap *soap, const char *tag, ns1__setDataSetSampleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__setDataSetSampleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setDataSetSampleResponse, sizeof(ns1__setDataSetSampleResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setDataSetSampleResponse)
			return (ns1__setDataSetSampleResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__setDataSetSampleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setDataSetSampleResponse);
	if (this->soap_out(soap, tag?tag:"ns1:setDataSetSampleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__setDataSetSampleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setDataSetSampleResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setDataSetSampleResponse * SOAP_FMAC4 soap_get_ns1__setDataSetSampleResponse(struct soap *soap, ns1__setDataSetSampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setDataSetSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__setDataSetSampleResponse * SOAP_FMAC2 soap_instantiate_ns1__setDataSetSampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setDataSetSampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setDataSetSampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSampleResponse);
		if (size)
			*size = sizeof(ns1__setDataSetSampleResponse);
		((ns1__setDataSetSampleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setDataSetSampleResponse);
		for (int i = 0; i < n; i++)
			((ns1__setDataSetSampleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setDataSetSampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setDataSetSampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setDataSetSampleResponse %p -> %p\n", q, p));
	*(ns1__setDataSetSampleResponse*)p = *(ns1__setDataSetSampleResponse*)q;
}

void ns1__setDataSetSample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__setDataSetSample::sessionId = NULL;
	this->ns1__setDataSetSample::sampleId = NULL;
	this->ns1__setDataSetSample::datafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__setDataSetSample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__setDataSetSample::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__setDataSetSample::sampleId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__setDataSetSample::datafileId);
	/* transient soap skipped */
}

int ns1__setDataSetSample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setDataSetSample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setDataSetSample(struct soap *soap, const char *tag, int id, const ns1__setDataSetSample *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setDataSetSample), "ns1:setDataSetSample"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__setDataSetSample::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "sampleId", -1, &(a->ns1__setDataSetSample::sampleId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__setDataSetSample::datafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__setDataSetSample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setDataSetSample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setDataSetSample * SOAP_FMAC4 soap_in_ns1__setDataSetSample(struct soap *soap, const char *tag, ns1__setDataSetSample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setDataSetSample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setDataSetSample, sizeof(ns1__setDataSetSample), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setDataSetSample)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setDataSetSample *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleId1 = 1;
	size_t soap_flag_datafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__setDataSetSample::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "sampleId", &(a->ns1__setDataSetSample::sampleId), "xsd:long"))
				{	soap_flag_sampleId1--;
					continue;
				}
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__setDataSetSample::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setDataSetSample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setDataSetSample, 0, sizeof(ns1__setDataSetSample), 0, soap_copy_ns1__setDataSetSample);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__setDataSetSample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setDataSetSample);
	if (this->soap_out(soap, tag?tag:"ns1:setDataSetSample", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__setDataSetSample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setDataSetSample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setDataSetSample * SOAP_FMAC4 soap_get_ns1__setDataSetSample(struct soap *soap, ns1__setDataSetSample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setDataSetSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__setDataSetSample * SOAP_FMAC2 soap_instantiate_ns1__setDataSetSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setDataSetSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setDataSetSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSample);
		if (size)
			*size = sizeof(ns1__setDataSetSample);
		((ns1__setDataSetSample*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setDataSetSample);
		for (int i = 0; i < n; i++)
			((ns1__setDataSetSample*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setDataSetSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setDataSetSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setDataSetSample %p -> %p\n", q, p));
	*(ns1__setDataSetSample*)p = *(ns1__setDataSetSample*)q;
}

void ns1__deleteDataSetParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataSetParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteDataSetParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataSetParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataSetParameterResponse(struct soap *soap, const char *tag, int id, const ns1__deleteDataSetParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteDataSetParameterResponse");
}

void *ns1__deleteDataSetParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataSetParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataSetParameterResponse * SOAP_FMAC4 soap_in_ns1__deleteDataSetParameterResponse(struct soap *soap, const char *tag, ns1__deleteDataSetParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteDataSetParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataSetParameterResponse, sizeof(ns1__deleteDataSetParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataSetParameterResponse)
			return (ns1__deleteDataSetParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteDataSetParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataSetParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataSetParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataSetParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataSetParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataSetParameterResponse * SOAP_FMAC4 soap_get_ns1__deleteDataSetParameterResponse(struct soap *soap, ns1__deleteDataSetParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataSetParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteDataSetParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataSetParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataSetParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameterResponse);
		if (size)
			*size = sizeof(ns1__deleteDataSetParameterResponse);
		((ns1__deleteDataSetParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataSetParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataSetParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataSetParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataSetParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataSetParameterResponse %p -> %p\n", q, p));
	*(ns1__deleteDataSetParameterResponse*)p = *(ns1__deleteDataSetParameterResponse*)q;
}

void ns1__deleteDataSetParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteDataSetParameter::sessionId = NULL;
	this->ns1__deleteDataSetParameter::datasetParameterPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataSetParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteDataSetParameter::sessionId);
	soap_serialize_PointerTons1__datasetParameterPK(soap, &this->ns1__deleteDataSetParameter::datasetParameterPK);
	/* transient soap skipped */
}

int ns1__deleteDataSetParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataSetParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataSetParameter(struct soap *soap, const char *tag, int id, const ns1__deleteDataSetParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDataSetParameter), "ns1:deleteDataSetParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteDataSetParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datasetParameterPK(soap, "datasetParameterPK", -1, &(a->ns1__deleteDataSetParameter::datasetParameterPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteDataSetParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataSetParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataSetParameter * SOAP_FMAC4 soap_in_ns1__deleteDataSetParameter(struct soap *soap, const char *tag, ns1__deleteDataSetParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteDataSetParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataSetParameter, sizeof(ns1__deleteDataSetParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataSetParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteDataSetParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetParameterPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteDataSetParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datasetParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datasetParameterPK(soap, "datasetParameterPK", &(a->ns1__deleteDataSetParameter::datasetParameterPK), "ns1:datasetParameterPK"))
				{	soap_flag_datasetParameterPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteDataSetParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDataSetParameter, 0, sizeof(ns1__deleteDataSetParameter), 0, soap_copy_ns1__deleteDataSetParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteDataSetParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataSetParameter);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataSetParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataSetParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataSetParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataSetParameter * SOAP_FMAC4 soap_get_ns1__deleteDataSetParameter(struct soap *soap, ns1__deleteDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataSetParameter * SOAP_FMAC2 soap_instantiate_ns1__deleteDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameter);
		if (size)
			*size = sizeof(ns1__deleteDataSetParameter);
		((ns1__deleteDataSetParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataSetParameter);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataSetParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataSetParameter %p -> %p\n", q, p));
	*(ns1__deleteDataSetParameter*)p = *(ns1__deleteDataSetParameter*)q;
}

void ns1__removeSampleParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeSampleParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeSampleParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeSampleParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeSampleParameterResponse(struct soap *soap, const char *tag, int id, const ns1__removeSampleParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeSampleParameterResponse");
}

void *ns1__removeSampleParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeSampleParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeSampleParameterResponse * SOAP_FMAC4 soap_in_ns1__removeSampleParameterResponse(struct soap *soap, const char *tag, ns1__removeSampleParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeSampleParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeSampleParameterResponse, sizeof(ns1__removeSampleParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeSampleParameterResponse)
			return (ns1__removeSampleParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeSampleParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeSampleParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeSampleParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeSampleParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeSampleParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeSampleParameterResponse * SOAP_FMAC4 soap_get_ns1__removeSampleParameterResponse(struct soap *soap, ns1__removeSampleParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeSampleParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__removeSampleParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeSampleParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeSampleParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameterResponse);
		if (size)
			*size = sizeof(ns1__removeSampleParameterResponse);
		((ns1__removeSampleParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeSampleParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeSampleParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeSampleParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeSampleParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeSampleParameterResponse %p -> %p\n", q, p));
	*(ns1__removeSampleParameterResponse*)p = *(ns1__removeSampleParameterResponse*)q;
}

void ns1__removeSampleParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeSampleParameter::sessionId = NULL;
	this->ns1__removeSampleParameter::sampleParameterPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeSampleParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeSampleParameter::sessionId);
	soap_serialize_PointerTons1__sampleParameterPK(soap, &this->ns1__removeSampleParameter::sampleParameterPK);
	/* transient soap skipped */
}

int ns1__removeSampleParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeSampleParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeSampleParameter(struct soap *soap, const char *tag, int id, const ns1__removeSampleParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeSampleParameter), "ns1:removeSampleParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeSampleParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__sampleParameterPK(soap, "sampleParameterPK", -1, &(a->ns1__removeSampleParameter::sampleParameterPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeSampleParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeSampleParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeSampleParameter * SOAP_FMAC4 soap_in_ns1__removeSampleParameter(struct soap *soap, const char *tag, ns1__removeSampleParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeSampleParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeSampleParameter, sizeof(ns1__removeSampleParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeSampleParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeSampleParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleParameterPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeSampleParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sampleParameterPK(soap, "sampleParameterPK", &(a->ns1__removeSampleParameter::sampleParameterPK), "ns1:sampleParameterPK"))
				{	soap_flag_sampleParameterPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeSampleParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeSampleParameter, 0, sizeof(ns1__removeSampleParameter), 0, soap_copy_ns1__removeSampleParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeSampleParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeSampleParameter);
	if (this->soap_out(soap, tag?tag:"ns1:removeSampleParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeSampleParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeSampleParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeSampleParameter * SOAP_FMAC4 soap_get_ns1__removeSampleParameter(struct soap *soap, ns1__removeSampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeSampleParameter * SOAP_FMAC2 soap_instantiate_ns1__removeSampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeSampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeSampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameter);
		if (size)
			*size = sizeof(ns1__removeSampleParameter);
		((ns1__removeSampleParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeSampleParameter);
		for (int i = 0; i < n; i++)
			((ns1__removeSampleParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeSampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeSampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeSampleParameter %p -> %p\n", q, p));
	*(ns1__removeSampleParameter*)p = *(ns1__removeSampleParameter*)q;
}

void ns1__createDataSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDataSetResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__dataset(soap, &this->ns1__createDataSetResponse::return_);
	/* transient soap skipped */
}

int ns1__createDataSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataSetResponse(struct soap *soap, const char *tag, int id, const ns1__createDataSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataSetResponse), "ns1:createDataSetResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__dataset(soap, "return", -1, &(a->ns1__createDataSetResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataSetResponse * SOAP_FMAC4 soap_in_ns1__createDataSetResponse(struct soap *soap, const char *tag, ns1__createDataSetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataSetResponse, sizeof(ns1__createDataSetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataSetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataSetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dataset(soap, "return", &(a->ns1__createDataSetResponse::return_), "ns1:dataset"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataSetResponse, 0, sizeof(ns1__createDataSetResponse), 0, soap_copy_ns1__createDataSetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataSetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:createDataSetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataSetResponse * SOAP_FMAC4 soap_get_ns1__createDataSetResponse(struct soap *soap, ns1__createDataSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataSetResponse * SOAP_FMAC2 soap_instantiate_ns1__createDataSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetResponse);
		if (size)
			*size = sizeof(ns1__createDataSetResponse);
		((ns1__createDataSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataSetResponse);
		for (int i = 0; i < n; i++)
			((ns1__createDataSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataSetResponse %p -> %p\n", q, p));
	*(ns1__createDataSetResponse*)p = *(ns1__createDataSetResponse*)q;
}

void ns1__createDataSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDataSet::sessionId = NULL;
	this->ns1__createDataSet::dataSet = NULL;
	this->ns1__createDataSet::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__createDataSet::sessionId);
	soap_serialize_PointerTons1__dataset(soap, &this->ns1__createDataSet::dataSet);
	soap_serialize_PointerToLONG64(soap, &this->ns1__createDataSet::investigationId);
	/* transient soap skipped */
}

int ns1__createDataSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataSet(struct soap *soap, const char *tag, int id, const ns1__createDataSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataSet), "ns1:createDataSet"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__createDataSet::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__dataset(soap, "dataSet", -1, &(a->ns1__createDataSet::dataSet), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__createDataSet::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataSet * SOAP_FMAC4 soap_in_ns1__createDataSet(struct soap *soap, const char *tag, ns1__createDataSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataSet, sizeof(ns1__createDataSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataSet1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__createDataSet::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dataset(soap, "dataSet", &(a->ns1__createDataSet::dataSet), "ns1:dataset"))
				{	soap_flag_dataSet1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__createDataSet::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataSet, 0, sizeof(ns1__createDataSet), 0, soap_copy_ns1__createDataSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataSet);
	if (this->soap_out(soap, tag?tag:"ns1:createDataSet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataSet * SOAP_FMAC4 soap_get_ns1__createDataSet(struct soap *soap, ns1__createDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataSet * SOAP_FMAC2 soap_instantiate_ns1__createDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSet);
		if (size)
			*size = sizeof(ns1__createDataSet);
		((ns1__createDataSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataSet);
		for (int i = 0; i < n; i++)
			((ns1__createDataSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataSet %p -> %p\n", q, p));
	*(ns1__createDataSet*)p = *(ns1__createDataSet*)q;
}

void ns1__addInvestigatorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addInvestigatorResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addInvestigatorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__investigator(soap, &this->ns1__addInvestigatorResponse::return_);
	/* transient soap skipped */
}

int ns1__addInvestigatorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addInvestigatorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addInvestigatorResponse(struct soap *soap, const char *tag, int id, const ns1__addInvestigatorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addInvestigatorResponse), "ns1:addInvestigatorResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__investigator(soap, "return", -1, &(a->ns1__addInvestigatorResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addInvestigatorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addInvestigatorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addInvestigatorResponse * SOAP_FMAC4 soap_in_ns1__addInvestigatorResponse(struct soap *soap, const char *tag, ns1__addInvestigatorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addInvestigatorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addInvestigatorResponse, sizeof(ns1__addInvestigatorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addInvestigatorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addInvestigatorResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigator(soap, "return", &(a->ns1__addInvestigatorResponse::return_), "ns1:investigator"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addInvestigatorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addInvestigatorResponse, 0, sizeof(ns1__addInvestigatorResponse), 0, soap_copy_ns1__addInvestigatorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addInvestigatorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addInvestigatorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addInvestigatorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addInvestigatorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addInvestigatorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addInvestigatorResponse * SOAP_FMAC4 soap_get_ns1__addInvestigatorResponse(struct soap *soap, ns1__addInvestigatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addInvestigatorResponse * SOAP_FMAC2 soap_instantiate_ns1__addInvestigatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addInvestigatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addInvestigatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigatorResponse);
		if (size)
			*size = sizeof(ns1__addInvestigatorResponse);
		((ns1__addInvestigatorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigatorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addInvestigatorResponse);
		for (int i = 0; i < n; i++)
			((ns1__addInvestigatorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addInvestigatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addInvestigatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addInvestigatorResponse %p -> %p\n", q, p));
	*(ns1__addInvestigatorResponse*)p = *(ns1__addInvestigatorResponse*)q;
}

void ns1__addInvestigator::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addInvestigator::sessionId = NULL;
	this->ns1__addInvestigator::investigator = NULL;
	this->ns1__addInvestigator::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addInvestigator::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addInvestigator::sessionId);
	soap_serialize_PointerTons1__investigator(soap, &this->ns1__addInvestigator::investigator);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addInvestigator::investigationId);
	/* transient soap skipped */
}

int ns1__addInvestigator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addInvestigator(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addInvestigator(struct soap *soap, const char *tag, int id, const ns1__addInvestigator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addInvestigator), "ns1:addInvestigator"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addInvestigator::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigator(soap, "investigator", -1, &(a->ns1__addInvestigator::investigator), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__addInvestigator::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addInvestigator::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addInvestigator(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addInvestigator * SOAP_FMAC4 soap_in_ns1__addInvestigator(struct soap *soap, const char *tag, ns1__addInvestigator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addInvestigator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addInvestigator, sizeof(ns1__addInvestigator), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addInvestigator)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addInvestigator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigator1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addInvestigator::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigator(soap, "investigator", &(a->ns1__addInvestigator::investigator), "ns1:investigator"))
				{	soap_flag_investigator1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__addInvestigator::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addInvestigator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addInvestigator, 0, sizeof(ns1__addInvestigator), 0, soap_copy_ns1__addInvestigator);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addInvestigator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addInvestigator);
	if (this->soap_out(soap, tag?tag:"ns1:addInvestigator", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addInvestigator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addInvestigator(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addInvestigator * SOAP_FMAC4 soap_get_ns1__addInvestigator(struct soap *soap, ns1__addInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addInvestigator * SOAP_FMAC2 soap_instantiate_ns1__addInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigator);
		if (size)
			*size = sizeof(ns1__addInvestigator);
		((ns1__addInvestigator*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addInvestigator);
		for (int i = 0; i < n; i++)
			((ns1__addInvestigator*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addInvestigator %p -> %p\n", q, p));
	*(ns1__addInvestigator*)p = *(ns1__addInvestigator*)q;
}

void ns1__deleteInvestigatorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteInvestigatorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteInvestigatorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteInvestigatorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteInvestigatorResponse(struct soap *soap, const char *tag, int id, const ns1__deleteInvestigatorResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteInvestigatorResponse");
}

void *ns1__deleteInvestigatorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteInvestigatorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteInvestigatorResponse * SOAP_FMAC4 soap_in_ns1__deleteInvestigatorResponse(struct soap *soap, const char *tag, ns1__deleteInvestigatorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteInvestigatorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteInvestigatorResponse, sizeof(ns1__deleteInvestigatorResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteInvestigatorResponse)
			return (ns1__deleteInvestigatorResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteInvestigatorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteInvestigatorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteInvestigatorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteInvestigatorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteInvestigatorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteInvestigatorResponse * SOAP_FMAC4 soap_get_ns1__deleteInvestigatorResponse(struct soap *soap, ns1__deleteInvestigatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteInvestigatorResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteInvestigatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteInvestigatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteInvestigatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigatorResponse);
		if (size)
			*size = sizeof(ns1__deleteInvestigatorResponse);
		((ns1__deleteInvestigatorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigatorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteInvestigatorResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteInvestigatorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteInvestigatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteInvestigatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteInvestigatorResponse %p -> %p\n", q, p));
	*(ns1__deleteInvestigatorResponse*)p = *(ns1__deleteInvestigatorResponse*)q;
}

void ns1__deleteInvestigator::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteInvestigator::sessionId = NULL;
	this->ns1__deleteInvestigator::investigatorPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteInvestigator::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteInvestigator::sessionId);
	soap_serialize_PointerTons1__investigatorPK(soap, &this->ns1__deleteInvestigator::investigatorPK);
	/* transient soap skipped */
}

int ns1__deleteInvestigator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteInvestigator(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteInvestigator(struct soap *soap, const char *tag, int id, const ns1__deleteInvestigator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteInvestigator), "ns1:deleteInvestigator"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteInvestigator::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigatorPK(soap, "investigatorPK", -1, &(a->ns1__deleteInvestigator::investigatorPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteInvestigator::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteInvestigator(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteInvestigator * SOAP_FMAC4 soap_in_ns1__deleteInvestigator(struct soap *soap, const char *tag, ns1__deleteInvestigator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteInvestigator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteInvestigator, sizeof(ns1__deleteInvestigator), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteInvestigator)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteInvestigator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigatorPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteInvestigator::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigatorPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigatorPK(soap, "investigatorPK", &(a->ns1__deleteInvestigator::investigatorPK), "ns1:investigatorPK"))
				{	soap_flag_investigatorPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteInvestigator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteInvestigator, 0, sizeof(ns1__deleteInvestigator), 0, soap_copy_ns1__deleteInvestigator);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteInvestigator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteInvestigator);
	if (this->soap_out(soap, tag?tag:"ns1:deleteInvestigator", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteInvestigator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteInvestigator(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteInvestigator * SOAP_FMAC4 soap_get_ns1__deleteInvestigator(struct soap *soap, ns1__deleteInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteInvestigator * SOAP_FMAC2 soap_instantiate_ns1__deleteInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigator);
		if (size)
			*size = sizeof(ns1__deleteInvestigator);
		((ns1__deleteInvestigator*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteInvestigator);
		for (int i = 0; i < n; i++)
			((ns1__deleteInvestigator*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteInvestigator %p -> %p\n", q, p));
	*(ns1__deleteInvestigator*)p = *(ns1__deleteInvestigator*)q;
}

void ns1__getICATAPIVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getICATAPIVersionResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getICATAPIVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getICATAPIVersionResponse::return_);
	/* transient soap skipped */
}

int ns1__getICATAPIVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getICATAPIVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getICATAPIVersionResponse(struct soap *soap, const char *tag, int id, const ns1__getICATAPIVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getICATAPIVersionResponse), "ns1:getICATAPIVersionResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getICATAPIVersionResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getICATAPIVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getICATAPIVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getICATAPIVersionResponse * SOAP_FMAC4 soap_in_ns1__getICATAPIVersionResponse(struct soap *soap, const char *tag, ns1__getICATAPIVersionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getICATAPIVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getICATAPIVersionResponse, sizeof(ns1__getICATAPIVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getICATAPIVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getICATAPIVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getICATAPIVersionResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getICATAPIVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getICATAPIVersionResponse, 0, sizeof(ns1__getICATAPIVersionResponse), 0, soap_copy_ns1__getICATAPIVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getICATAPIVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getICATAPIVersionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getICATAPIVersionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getICATAPIVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getICATAPIVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getICATAPIVersionResponse * SOAP_FMAC4 soap_get_ns1__getICATAPIVersionResponse(struct soap *soap, ns1__getICATAPIVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getICATAPIVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getICATAPIVersionResponse * SOAP_FMAC2 soap_instantiate_ns1__getICATAPIVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getICATAPIVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getICATAPIVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersionResponse);
		if (size)
			*size = sizeof(ns1__getICATAPIVersionResponse);
		((ns1__getICATAPIVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getICATAPIVersionResponse);
		for (int i = 0; i < n; i++)
			((ns1__getICATAPIVersionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getICATAPIVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getICATAPIVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getICATAPIVersionResponse %p -> %p\n", q, p));
	*(ns1__getICATAPIVersionResponse*)p = *(ns1__getICATAPIVersionResponse*)q;
}

void ns1__getICATAPIVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getICATAPIVersion::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getICATAPIVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getICATAPIVersion::sessionId);
	/* transient soap skipped */
}

int ns1__getICATAPIVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getICATAPIVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getICATAPIVersion(struct soap *soap, const char *tag, int id, const ns1__getICATAPIVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getICATAPIVersion), "ns1:getICATAPIVersion"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getICATAPIVersion::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getICATAPIVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getICATAPIVersion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getICATAPIVersion * SOAP_FMAC4 soap_in_ns1__getICATAPIVersion(struct soap *soap, const char *tag, ns1__getICATAPIVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getICATAPIVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getICATAPIVersion, sizeof(ns1__getICATAPIVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getICATAPIVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getICATAPIVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getICATAPIVersion::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getICATAPIVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getICATAPIVersion, 0, sizeof(ns1__getICATAPIVersion), 0, soap_copy_ns1__getICATAPIVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getICATAPIVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getICATAPIVersion);
	if (this->soap_out(soap, tag?tag:"ns1:getICATAPIVersion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getICATAPIVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getICATAPIVersion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getICATAPIVersion * SOAP_FMAC4 soap_get_ns1__getICATAPIVersion(struct soap *soap, ns1__getICATAPIVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getICATAPIVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getICATAPIVersion * SOAP_FMAC2 soap_instantiate_ns1__getICATAPIVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getICATAPIVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getICATAPIVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersion);
		if (size)
			*size = sizeof(ns1__getICATAPIVersion);
		((ns1__getICATAPIVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getICATAPIVersion);
		for (int i = 0; i < n; i++)
			((ns1__getICATAPIVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getICATAPIVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getICATAPIVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getICATAPIVersion %p -> %p\n", q, p));
	*(ns1__getICATAPIVersion*)p = *(ns1__getICATAPIVersion*)q;
}

void ns1__getDatafilesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__getDatafilesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatafilesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__getDatafilesResponse::return_);
	/* transient soap skipped */
}

int ns1__getDatafilesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatafilesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatafilesResponse(struct soap *soap, const char *tag, int id, const ns1__getDatafilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatafilesResponse), "ns1:getDatafilesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "return", -1, &(a->ns1__getDatafilesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatafilesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatafilesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatafilesResponse * SOAP_FMAC4 soap_in_ns1__getDatafilesResponse(struct soap *soap, const char *tag, ns1__getDatafilesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatafilesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatafilesResponse, sizeof(ns1__getDatafilesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatafilesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatafilesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "return", &(a->ns1__getDatafilesResponse::return_), "ns1:datafile"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatafilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatafilesResponse, 0, sizeof(ns1__getDatafilesResponse), 0, soap_copy_ns1__getDatafilesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatafilesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatafilesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDatafilesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatafilesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatafilesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatafilesResponse * SOAP_FMAC4 soap_get_ns1__getDatafilesResponse(struct soap *soap, ns1__getDatafilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatafilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatafilesResponse * SOAP_FMAC2 soap_instantiate_ns1__getDatafilesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatafilesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatafilesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafilesResponse);
		if (size)
			*size = sizeof(ns1__getDatafilesResponse);
		((ns1__getDatafilesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafilesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatafilesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getDatafilesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatafilesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatafilesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatafilesResponse %p -> %p\n", q, p));
	*(ns1__getDatafilesResponse*)p = *(ns1__getDatafilesResponse*)q;
}

void ns1__getDatafiles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDatafiles::sessionId = NULL;
	soap_default_std__vectorTemplateOfLONG64(soap, &this->ns1__getDatafiles::datafileIds);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getDatafiles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDatafiles::sessionId);
	soap_serialize_std__vectorTemplateOfLONG64(soap, &this->ns1__getDatafiles::datafileIds);
	/* transient soap skipped */
}

int ns1__getDatafiles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDatafiles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatafiles(struct soap *soap, const char *tag, int id, const ns1__getDatafiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatafiles), "ns1:getDatafiles"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getDatafiles::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfLONG64(soap, "datafileIds", -1, &(a->ns1__getDatafiles::datafileIds), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getDatafiles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDatafiles(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDatafiles * SOAP_FMAC4 soap_in_ns1__getDatafiles(struct soap *soap, const char *tag, ns1__getDatafiles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDatafiles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatafiles, sizeof(ns1__getDatafiles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDatafiles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDatafiles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getDatafiles::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "datafileIds", &(a->ns1__getDatafiles::datafileIds), "xsd:long"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDatafiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatafiles, 0, sizeof(ns1__getDatafiles), 0, soap_copy_ns1__getDatafiles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDatafiles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDatafiles);
	if (this->soap_out(soap, tag?tag:"ns1:getDatafiles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDatafiles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDatafiles(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDatafiles * SOAP_FMAC4 soap_get_ns1__getDatafiles(struct soap *soap, ns1__getDatafiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDatafiles * SOAP_FMAC2 soap_instantiate_ns1__getDatafiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatafiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatafiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafiles);
		if (size)
			*size = sizeof(ns1__getDatafiles);
		((ns1__getDatafiles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDatafiles);
		for (int i = 0; i < n; i++)
			((ns1__getDatafiles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDatafiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatafiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDatafiles %p -> %p\n", q, p));
	*(ns1__getDatafiles*)p = *(ns1__getDatafiles*)q;
}

void ns1__deleteDataSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteDataSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataSetResponse(struct soap *soap, const char *tag, int id, const ns1__deleteDataSetResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteDataSetResponse");
}

void *ns1__deleteDataSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataSetResponse * SOAP_FMAC4 soap_in_ns1__deleteDataSetResponse(struct soap *soap, const char *tag, ns1__deleteDataSetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteDataSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataSetResponse, sizeof(ns1__deleteDataSetResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataSetResponse)
			return (ns1__deleteDataSetResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteDataSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataSetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataSetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataSetResponse * SOAP_FMAC4 soap_get_ns1__deleteDataSetResponse(struct soap *soap, ns1__deleteDataSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataSetResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteDataSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetResponse);
		if (size)
			*size = sizeof(ns1__deleteDataSetResponse);
		((ns1__deleteDataSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataSetResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataSetResponse %p -> %p\n", q, p));
	*(ns1__deleteDataSetResponse*)p = *(ns1__deleteDataSetResponse*)q;
}

void ns1__deleteDataSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteDataSet::sessionId = NULL;
	this->ns1__deleteDataSet::dataSetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteDataSet::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__deleteDataSet::dataSetId);
	/* transient soap skipped */
}

int ns1__deleteDataSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataSet(struct soap *soap, const char *tag, int id, const ns1__deleteDataSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDataSet), "ns1:deleteDataSet"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteDataSet::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "dataSetId", -1, &(a->ns1__deleteDataSet::dataSetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteDataSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataSet * SOAP_FMAC4 soap_in_ns1__deleteDataSet(struct soap *soap, const char *tag, ns1__deleteDataSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteDataSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataSet, sizeof(ns1__deleteDataSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteDataSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataSetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteDataSet::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataSetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "dataSetId", &(a->ns1__deleteDataSet::dataSetId), "xsd:long"))
				{	soap_flag_dataSetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteDataSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDataSet, 0, sizeof(ns1__deleteDataSet), 0, soap_copy_ns1__deleteDataSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteDataSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataSet);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataSet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataSet * SOAP_FMAC4 soap_get_ns1__deleteDataSet(struct soap *soap, ns1__deleteDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataSet * SOAP_FMAC2 soap_instantiate_ns1__deleteDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSet);
		if (size)
			*size = sizeof(ns1__deleteDataSet);
		((ns1__deleteDataSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataSet);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataSet %p -> %p\n", q, p));
	*(ns1__deleteDataSet*)p = *(ns1__deleteDataSet*)q;
}

void ns1__getInvestigationsIncludesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getInvestigationsIncludesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getInvestigationsIncludesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getInvestigationsIncludesResponse::return_);
	/* transient soap skipped */
}

int ns1__getInvestigationsIncludesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getInvestigationsIncludesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getInvestigationsIncludesResponse(struct soap *soap, const char *tag, int id, const ns1__getInvestigationsIncludesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getInvestigationsIncludesResponse), "ns1:getInvestigationsIncludesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__getInvestigationsIncludesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getInvestigationsIncludesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getInvestigationsIncludesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getInvestigationsIncludesResponse * SOAP_FMAC4 soap_in_ns1__getInvestigationsIncludesResponse(struct soap *soap, const char *tag, ns1__getInvestigationsIncludesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getInvestigationsIncludesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getInvestigationsIncludesResponse, sizeof(ns1__getInvestigationsIncludesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getInvestigationsIncludesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getInvestigationsIncludesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__getInvestigationsIncludesResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getInvestigationsIncludesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getInvestigationsIncludesResponse, 0, sizeof(ns1__getInvestigationsIncludesResponse), 0, soap_copy_ns1__getInvestigationsIncludesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getInvestigationsIncludesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getInvestigationsIncludesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getInvestigationsIncludesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getInvestigationsIncludesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getInvestigationsIncludesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getInvestigationsIncludesResponse * SOAP_FMAC4 soap_get_ns1__getInvestigationsIncludesResponse(struct soap *soap, ns1__getInvestigationsIncludesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getInvestigationsIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getInvestigationsIncludesResponse * SOAP_FMAC2 soap_instantiate_ns1__getInvestigationsIncludesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getInvestigationsIncludesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getInvestigationsIncludesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludesResponse);
		if (size)
			*size = sizeof(ns1__getInvestigationsIncludesResponse);
		((ns1__getInvestigationsIncludesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getInvestigationsIncludesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getInvestigationsIncludesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getInvestigationsIncludesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getInvestigationsIncludesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getInvestigationsIncludesResponse %p -> %p\n", q, p));
	*(ns1__getInvestigationsIncludesResponse*)p = *(ns1__getInvestigationsIncludesResponse*)q;
}

void ns1__getInvestigationsIncludes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getInvestigationsIncludes::userId = NULL;
	soap_default_std__vectorTemplateOfLONG64(soap, &this->ns1__getInvestigationsIncludes::investigationIds);
	this->ns1__getInvestigationsIncludes::investigationInclude = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getInvestigationsIncludes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getInvestigationsIncludes::userId);
	soap_serialize_std__vectorTemplateOfLONG64(soap, &this->ns1__getInvestigationsIncludes::investigationIds);
	soap_serialize_PointerTons1__investigationInclude(soap, &this->ns1__getInvestigationsIncludes::investigationInclude);
	/* transient soap skipped */
}

int ns1__getInvestigationsIncludes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getInvestigationsIncludes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getInvestigationsIncludes(struct soap *soap, const char *tag, int id, const ns1__getInvestigationsIncludes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getInvestigationsIncludes), "ns1:getInvestigationsIncludes"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "userId", -1, &(a->ns1__getInvestigationsIncludes::userId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfLONG64(soap, "investigationIds", -1, &(a->ns1__getInvestigationsIncludes::investigationIds), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigationInclude(soap, "investigationInclude", -1, &(a->ns1__getInvestigationsIncludes::investigationInclude), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getInvestigationsIncludes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getInvestigationsIncludes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getInvestigationsIncludes * SOAP_FMAC4 soap_in_ns1__getInvestigationsIncludes(struct soap *soap, const char *tag, ns1__getInvestigationsIncludes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getInvestigationsIncludes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getInvestigationsIncludes, sizeof(ns1__getInvestigationsIncludes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getInvestigationsIncludes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getInvestigationsIncludes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_investigationInclude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userId", &(a->ns1__getInvestigationsIncludes::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "investigationIds", &(a->ns1__getInvestigationsIncludes::investigationIds), "xsd:long"))
					continue;
			if (soap_flag_investigationInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigationInclude(soap, "investigationInclude", &(a->ns1__getInvestigationsIncludes::investigationInclude), "ns1:investigationInclude"))
				{	soap_flag_investigationInclude1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getInvestigationsIncludes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getInvestigationsIncludes, 0, sizeof(ns1__getInvestigationsIncludes), 0, soap_copy_ns1__getInvestigationsIncludes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getInvestigationsIncludes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getInvestigationsIncludes);
	if (this->soap_out(soap, tag?tag:"ns1:getInvestigationsIncludes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getInvestigationsIncludes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getInvestigationsIncludes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getInvestigationsIncludes * SOAP_FMAC4 soap_get_ns1__getInvestigationsIncludes(struct soap *soap, ns1__getInvestigationsIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getInvestigationsIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getInvestigationsIncludes * SOAP_FMAC2 soap_instantiate_ns1__getInvestigationsIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getInvestigationsIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getInvestigationsIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludes);
		if (size)
			*size = sizeof(ns1__getInvestigationsIncludes);
		((ns1__getInvestigationsIncludes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getInvestigationsIncludes);
		for (int i = 0; i < n; i++)
			((ns1__getInvestigationsIncludes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getInvestigationsIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getInvestigationsIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getInvestigationsIncludes %p -> %p\n", q, p));
	*(ns1__getInvestigationsIncludes*)p = *(ns1__getInvestigationsIncludes*)q;
}

void ns1__removeDataFileParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataFileParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeDataFileParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataFileParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataFileParameterResponse(struct soap *soap, const char *tag, int id, const ns1__removeDataFileParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeDataFileParameterResponse");
}

void *ns1__removeDataFileParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataFileParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataFileParameterResponse * SOAP_FMAC4 soap_in_ns1__removeDataFileParameterResponse(struct soap *soap, const char *tag, ns1__removeDataFileParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeDataFileParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataFileParameterResponse, sizeof(ns1__removeDataFileParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataFileParameterResponse)
			return (ns1__removeDataFileParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeDataFileParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataFileParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataFileParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataFileParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataFileParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataFileParameterResponse * SOAP_FMAC4 soap_get_ns1__removeDataFileParameterResponse(struct soap *soap, ns1__removeDataFileParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataFileParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__removeDataFileParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataFileParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataFileParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameterResponse);
		if (size)
			*size = sizeof(ns1__removeDataFileParameterResponse);
		((ns1__removeDataFileParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataFileParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeDataFileParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataFileParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataFileParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataFileParameterResponse %p -> %p\n", q, p));
	*(ns1__removeDataFileParameterResponse*)p = *(ns1__removeDataFileParameterResponse*)q;
}

void ns1__removeDataFileParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeDataFileParameter::sessionId = NULL;
	this->ns1__removeDataFileParameter::datafileParameterPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataFileParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeDataFileParameter::sessionId);
	soap_serialize_PointerTons1__datafileParameterPK(soap, &this->ns1__removeDataFileParameter::datafileParameterPK);
	/* transient soap skipped */
}

int ns1__removeDataFileParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataFileParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataFileParameter(struct soap *soap, const char *tag, int id, const ns1__removeDataFileParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeDataFileParameter), "ns1:removeDataFileParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeDataFileParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileParameterPK(soap, "datafileParameterPK", -1, &(a->ns1__removeDataFileParameter::datafileParameterPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeDataFileParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataFileParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataFileParameter * SOAP_FMAC4 soap_in_ns1__removeDataFileParameter(struct soap *soap, const char *tag, ns1__removeDataFileParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeDataFileParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataFileParameter, sizeof(ns1__removeDataFileParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataFileParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeDataFileParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datafileParameterPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeDataFileParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datafileParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileParameterPK(soap, "datafileParameterPK", &(a->ns1__removeDataFileParameter::datafileParameterPK), "ns1:datafileParameterPK"))
				{	soap_flag_datafileParameterPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeDataFileParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeDataFileParameter, 0, sizeof(ns1__removeDataFileParameter), 0, soap_copy_ns1__removeDataFileParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeDataFileParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataFileParameter);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataFileParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataFileParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataFileParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataFileParameter * SOAP_FMAC4 soap_get_ns1__removeDataFileParameter(struct soap *soap, ns1__removeDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataFileParameter * SOAP_FMAC2 soap_instantiate_ns1__removeDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameter);
		if (size)
			*size = sizeof(ns1__removeDataFileParameter);
		((ns1__removeDataFileParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataFileParameter);
		for (int i = 0; i < n; i++)
			((ns1__removeDataFileParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataFileParameter %p -> %p\n", q, p));
	*(ns1__removeDataFileParameter*)p = *(ns1__removeDataFileParameter*)q;
}

void ns1__searchByUserIDPaginationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserIDPaginationResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserIDPaginationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserIDPaginationResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByUserIDPaginationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserIDPaginationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserIDPaginationResponse(struct soap *soap, const char *tag, int id, const ns1__searchByUserIDPaginationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserIDPaginationResponse), "ns1:searchByUserIDPaginationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByUserIDPaginationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserIDPaginationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserIDPaginationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserIDPaginationResponse * SOAP_FMAC4 soap_in_ns1__searchByUserIDPaginationResponse(struct soap *soap, const char *tag, ns1__searchByUserIDPaginationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserIDPaginationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserIDPaginationResponse, sizeof(ns1__searchByUserIDPaginationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserIDPaginationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserIDPaginationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByUserIDPaginationResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserIDPaginationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserIDPaginationResponse, 0, sizeof(ns1__searchByUserIDPaginationResponse), 0, soap_copy_ns1__searchByUserIDPaginationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByUserIDPaginationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserIDPaginationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserIDPaginationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserIDPaginationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserIDPaginationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserIDPaginationResponse * SOAP_FMAC4 soap_get_ns1__searchByUserIDPaginationResponse(struct soap *soap, ns1__searchByUserIDPaginationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserIDPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserIDPaginationResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByUserIDPaginationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserIDPaginationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserIDPaginationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPaginationResponse);
		if (size)
			*size = sizeof(ns1__searchByUserIDPaginationResponse);
		((ns1__searchByUserIDPaginationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPaginationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserIDPaginationResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserIDPaginationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserIDPaginationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserIDPaginationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserIDPaginationResponse %p -> %p\n", q, p));
	*(ns1__searchByUserIDPaginationResponse*)p = *(ns1__searchByUserIDPaginationResponse*)q;
}

void ns1__searchByUserIDPagination::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByUserIDPagination::sessionId = NULL;
	this->ns1__searchByUserIDPagination::userSearch = NULL;
	soap_default_int(soap, &this->ns1__searchByUserIDPagination::startIndex);
	soap_default_int(soap, &this->ns1__searchByUserIDPagination::numberOfResults);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserIDPagination::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserIDPagination::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserIDPagination::userSearch);
	soap_embedded(soap, &this->ns1__searchByUserIDPagination::startIndex, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__searchByUserIDPagination::numberOfResults, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__searchByUserIDPagination::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserIDPagination(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserIDPagination(struct soap *soap, const char *tag, int id, const ns1__searchByUserIDPagination *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserIDPagination), "ns1:searchByUserIDPagination"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByUserIDPagination::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userSearch", -1, &(a->ns1__searchByUserIDPagination::userSearch), ""))
		return soap->error;
	if (soap_out_int(soap, "startIndex", -1, &(a->ns1__searchByUserIDPagination::startIndex), ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfResults", -1, &(a->ns1__searchByUserIDPagination::numberOfResults), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserIDPagination::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserIDPagination(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserIDPagination * SOAP_FMAC4 soap_in_ns1__searchByUserIDPagination(struct soap *soap, const char *tag, ns1__searchByUserIDPagination *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserIDPagination *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserIDPagination, sizeof(ns1__searchByUserIDPagination), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserIDPagination)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserIDPagination *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_userSearch1 = 1;
	size_t soap_flag_startIndex1 = 1;
	size_t soap_flag_numberOfResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByUserIDPagination::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_userSearch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userSearch", &(a->ns1__searchByUserIDPagination::userSearch), "xsd:string"))
				{	soap_flag_userSearch1--;
					continue;
				}
			if (soap_flag_startIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startIndex", &(a->ns1__searchByUserIDPagination::startIndex), "xsd:int"))
				{	soap_flag_startIndex1--;
					continue;
				}
			if (soap_flag_numberOfResults1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfResults", &(a->ns1__searchByUserIDPagination::numberOfResults), "xsd:int"))
				{	soap_flag_numberOfResults1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserIDPagination *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserIDPagination, 0, sizeof(ns1__searchByUserIDPagination), 0, soap_copy_ns1__searchByUserIDPagination);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startIndex1 > 0 || soap_flag_numberOfResults1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__searchByUserIDPagination::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserIDPagination);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserIDPagination", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserIDPagination::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserIDPagination(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserIDPagination * SOAP_FMAC4 soap_get_ns1__searchByUserIDPagination(struct soap *soap, ns1__searchByUserIDPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserIDPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserIDPagination * SOAP_FMAC2 soap_instantiate_ns1__searchByUserIDPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserIDPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserIDPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPagination);
		if (size)
			*size = sizeof(ns1__searchByUserIDPagination);
		((ns1__searchByUserIDPagination*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserIDPagination);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserIDPagination*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserIDPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserIDPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserIDPagination %p -> %p\n", q, p));
	*(ns1__searchByUserIDPagination*)p = *(ns1__searchByUserIDPagination*)q;
}

void ns1__searchByUserIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserIDResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserIDResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByUserIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserIDResponse(struct soap *soap, const char *tag, int id, const ns1__searchByUserIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserIDResponse), "ns1:searchByUserIDResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByUserIDResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserIDResponse * SOAP_FMAC4 soap_in_ns1__searchByUserIDResponse(struct soap *soap, const char *tag, ns1__searchByUserIDResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserIDResponse, sizeof(ns1__searchByUserIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByUserIDResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserIDResponse, 0, sizeof(ns1__searchByUserIDResponse), 0, soap_copy_ns1__searchByUserIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByUserIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserIDResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserIDResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserIDResponse * SOAP_FMAC4 soap_get_ns1__searchByUserIDResponse(struct soap *soap, ns1__searchByUserIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserIDResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByUserIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDResponse);
		if (size)
			*size = sizeof(ns1__searchByUserIDResponse);
		((ns1__searchByUserIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserIDResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserIDResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserIDResponse %p -> %p\n", q, p));
	*(ns1__searchByUserIDResponse*)p = *(ns1__searchByUserIDResponse*)q;
}

void ns1__searchByUserID::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByUserID::sessionId = NULL;
	this->ns1__searchByUserID::userSearch = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserID::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserID::userSearch);
	/* transient soap skipped */
}

int ns1__searchByUserID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserID(struct soap *soap, const char *tag, int id, const ns1__searchByUserID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserID), "ns1:searchByUserID"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByUserID::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userSearch", -1, &(a->ns1__searchByUserID::userSearch), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserID(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserID * SOAP_FMAC4 soap_in_ns1__searchByUserID(struct soap *soap, const char *tag, ns1__searchByUserID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserID, sizeof(ns1__searchByUserID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserID *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_userSearch1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByUserID::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_userSearch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userSearch", &(a->ns1__searchByUserID::userSearch), "xsd:string"))
				{	soap_flag_userSearch1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserID, 0, sizeof(ns1__searchByUserID), 0, soap_copy_ns1__searchByUserID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByUserID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserID);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserID(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserID * SOAP_FMAC4 soap_get_ns1__searchByUserID(struct soap *soap, ns1__searchByUserID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserID * SOAP_FMAC2 soap_instantiate_ns1__searchByUserID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserID);
		if (size)
			*size = sizeof(ns1__searchByUserID);
		((ns1__searchByUserID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserID);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserID*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserID %p -> %p\n", q, p));
	*(ns1__searchByUserID*)p = *(ns1__searchByUserID*)q;
}

void ns1__modifyPublicationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyPublicationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifyPublicationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyPublicationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyPublicationResponse(struct soap *soap, const char *tag, int id, const ns1__modifyPublicationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifyPublicationResponse");
}

void *ns1__modifyPublicationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyPublicationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyPublicationResponse * SOAP_FMAC4 soap_in_ns1__modifyPublicationResponse(struct soap *soap, const char *tag, ns1__modifyPublicationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifyPublicationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyPublicationResponse, sizeof(ns1__modifyPublicationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyPublicationResponse)
			return (ns1__modifyPublicationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifyPublicationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyPublicationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifyPublicationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyPublicationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyPublicationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyPublicationResponse * SOAP_FMAC4 soap_get_ns1__modifyPublicationResponse(struct soap *soap, ns1__modifyPublicationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyPublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyPublicationResponse * SOAP_FMAC2 soap_instantiate_ns1__modifyPublicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyPublicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyPublicationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublicationResponse);
		if (size)
			*size = sizeof(ns1__modifyPublicationResponse);
		((ns1__modifyPublicationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublicationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyPublicationResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifyPublicationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyPublicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyPublicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyPublicationResponse %p -> %p\n", q, p));
	*(ns1__modifyPublicationResponse*)p = *(ns1__modifyPublicationResponse*)q;
}

void ns1__modifyPublication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifyPublication::sessionId = NULL;
	this->ns1__modifyPublication::publication = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyPublication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifyPublication::sessionId);
	soap_serialize_PointerTons1__publication(soap, &this->ns1__modifyPublication::publication);
	/* transient soap skipped */
}

int ns1__modifyPublication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyPublication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyPublication(struct soap *soap, const char *tag, int id, const ns1__modifyPublication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyPublication), "ns1:modifyPublication"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifyPublication::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__publication(soap, "publication", -1, &(a->ns1__modifyPublication::publication), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifyPublication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyPublication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyPublication * SOAP_FMAC4 soap_in_ns1__modifyPublication(struct soap *soap, const char *tag, ns1__modifyPublication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifyPublication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyPublication, sizeof(ns1__modifyPublication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyPublication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifyPublication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_publication1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifyPublication::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_publication1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__publication(soap, "publication", &(a->ns1__modifyPublication::publication), "ns1:publication"))
				{	soap_flag_publication1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifyPublication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyPublication, 0, sizeof(ns1__modifyPublication), 0, soap_copy_ns1__modifyPublication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifyPublication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyPublication);
	if (this->soap_out(soap, tag?tag:"ns1:modifyPublication", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyPublication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyPublication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyPublication * SOAP_FMAC4 soap_get_ns1__modifyPublication(struct soap *soap, ns1__modifyPublication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyPublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyPublication * SOAP_FMAC2 soap_instantiate_ns1__modifyPublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyPublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyPublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublication);
		if (size)
			*size = sizeof(ns1__modifyPublication);
		((ns1__modifyPublication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyPublication);
		for (int i = 0; i < n; i++)
			((ns1__modifyPublication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyPublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyPublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyPublication %p -> %p\n", q, p));
	*(ns1__modifyPublication*)p = *(ns1__modifyPublication*)q;
}

void ns1__removeDataSetParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataSetParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeDataSetParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataSetParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataSetParameterResponse(struct soap *soap, const char *tag, int id, const ns1__removeDataSetParameterResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeDataSetParameterResponse");
}

void *ns1__removeDataSetParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataSetParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataSetParameterResponse * SOAP_FMAC4 soap_in_ns1__removeDataSetParameterResponse(struct soap *soap, const char *tag, ns1__removeDataSetParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeDataSetParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataSetParameterResponse, sizeof(ns1__removeDataSetParameterResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataSetParameterResponse)
			return (ns1__removeDataSetParameterResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeDataSetParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataSetParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataSetParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataSetParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataSetParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataSetParameterResponse * SOAP_FMAC4 soap_get_ns1__removeDataSetParameterResponse(struct soap *soap, ns1__removeDataSetParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataSetParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__removeDataSetParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataSetParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataSetParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameterResponse);
		if (size)
			*size = sizeof(ns1__removeDataSetParameterResponse);
		((ns1__removeDataSetParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataSetParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeDataSetParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataSetParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataSetParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataSetParameterResponse %p -> %p\n", q, p));
	*(ns1__removeDataSetParameterResponse*)p = *(ns1__removeDataSetParameterResponse*)q;
}

void ns1__removeDataSetParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeDataSetParameter::sessionId = NULL;
	this->ns1__removeDataSetParameter::datasetParameterPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataSetParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeDataSetParameter::sessionId);
	soap_serialize_PointerTons1__datasetParameterPK(soap, &this->ns1__removeDataSetParameter::datasetParameterPK);
	/* transient soap skipped */
}

int ns1__removeDataSetParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataSetParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataSetParameter(struct soap *soap, const char *tag, int id, const ns1__removeDataSetParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeDataSetParameter), "ns1:removeDataSetParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeDataSetParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datasetParameterPK(soap, "datasetParameterPK", -1, &(a->ns1__removeDataSetParameter::datasetParameterPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeDataSetParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataSetParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataSetParameter * SOAP_FMAC4 soap_in_ns1__removeDataSetParameter(struct soap *soap, const char *tag, ns1__removeDataSetParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeDataSetParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataSetParameter, sizeof(ns1__removeDataSetParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataSetParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeDataSetParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetParameterPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeDataSetParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datasetParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datasetParameterPK(soap, "datasetParameterPK", &(a->ns1__removeDataSetParameter::datasetParameterPK), "ns1:datasetParameterPK"))
				{	soap_flag_datasetParameterPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeDataSetParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeDataSetParameter, 0, sizeof(ns1__removeDataSetParameter), 0, soap_copy_ns1__removeDataSetParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeDataSetParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataSetParameter);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataSetParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataSetParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataSetParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataSetParameter * SOAP_FMAC4 soap_get_ns1__removeDataSetParameter(struct soap *soap, ns1__removeDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataSetParameter * SOAP_FMAC2 soap_instantiate_ns1__removeDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameter);
		if (size)
			*size = sizeof(ns1__removeDataSetParameter);
		((ns1__removeDataSetParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataSetParameter);
		for (int i = 0; i < n; i++)
			((ns1__removeDataSetParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataSetParameter %p -> %p\n", q, p));
	*(ns1__removeDataSetParameter*)p = *(ns1__removeDataSetParameter*)q;
}

void ns1__getMyInvestigationsIncludesPaginationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getMyInvestigationsIncludesPaginationResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getMyInvestigationsIncludesPaginationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getMyInvestigationsIncludesPaginationResponse::return_);
	/* transient soap skipped */
}

int ns1__getMyInvestigationsIncludesPaginationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyInvestigationsIncludesPaginationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, const char *tag, int id, const ns1__getMyInvestigationsIncludesPaginationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse), "ns1:getMyInvestigationsIncludesPaginationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__getMyInvestigationsIncludesPaginationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyInvestigationsIncludesPaginationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyInvestigationsIncludesPaginationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPaginationResponse * SOAP_FMAC4 soap_in_ns1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludesPaginationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyInvestigationsIncludesPaginationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse, sizeof(ns1__getMyInvestigationsIncludesPaginationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyInvestigationsIncludesPaginationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__getMyInvestigationsIncludesPaginationResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyInvestigationsIncludesPaginationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse, 0, sizeof(ns1__getMyInvestigationsIncludesPaginationResponse), 0, soap_copy_ns1__getMyInvestigationsIncludesPaginationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMyInvestigationsIncludesPaginationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getMyInvestigationsIncludesPaginationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyInvestigationsIncludesPaginationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyInvestigationsIncludesPaginationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPaginationResponse * SOAP_FMAC4 soap_get_ns1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, ns1__getMyInvestigationsIncludesPaginationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyInvestigationsIncludesPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyInvestigationsIncludesPaginationResponse * SOAP_FMAC2 soap_instantiate_ns1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyInvestigationsIncludesPaginationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPaginationResponse);
		if (size)
			*size = sizeof(ns1__getMyInvestigationsIncludesPaginationResponse);
		((ns1__getMyInvestigationsIncludesPaginationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPaginationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMyInvestigationsIncludesPaginationResponse);
		for (int i = 0; i < n; i++)
			((ns1__getMyInvestigationsIncludesPaginationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMyInvestigationsIncludesPaginationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyInvestigationsIncludesPaginationResponse %p -> %p\n", q, p));
	*(ns1__getMyInvestigationsIncludesPaginationResponse*)p = *(ns1__getMyInvestigationsIncludesPaginationResponse*)q;
}

void ns1__getMyInvestigationsIncludesPagination::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getMyInvestigationsIncludesPagination::sessionId = NULL;
	this->ns1__getMyInvestigationsIncludesPagination::investigationInclude = NULL;
	soap_default_int(soap, &this->ns1__getMyInvestigationsIncludesPagination::startIndex);
	soap_default_int(soap, &this->ns1__getMyInvestigationsIncludesPagination::numberOfResults);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getMyInvestigationsIncludesPagination::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getMyInvestigationsIncludesPagination::sessionId);
	soap_serialize_PointerTons1__investigationInclude(soap, &this->ns1__getMyInvestigationsIncludesPagination::investigationInclude);
	soap_embedded(soap, &this->ns1__getMyInvestigationsIncludesPagination::startIndex, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__getMyInvestigationsIncludesPagination::numberOfResults, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__getMyInvestigationsIncludesPagination::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyInvestigationsIncludesPagination(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyInvestigationsIncludesPagination(struct soap *soap, const char *tag, int id, const ns1__getMyInvestigationsIncludesPagination *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination), "ns1:getMyInvestigationsIncludesPagination"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getMyInvestigationsIncludesPagination::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigationInclude(soap, "investigationInclude", -1, &(a->ns1__getMyInvestigationsIncludesPagination::investigationInclude), ""))
		return soap->error;
	if (soap_out_int(soap, "startIndex", -1, &(a->ns1__getMyInvestigationsIncludesPagination::startIndex), ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfResults", -1, &(a->ns1__getMyInvestigationsIncludesPagination::numberOfResults), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyInvestigationsIncludesPagination::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyInvestigationsIncludesPagination(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPagination * SOAP_FMAC4 soap_in_ns1__getMyInvestigationsIncludesPagination(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludesPagination *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyInvestigationsIncludesPagination *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination, sizeof(ns1__getMyInvestigationsIncludesPagination), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyInvestigationsIncludesPagination *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigationInclude1 = 1;
	size_t soap_flag_startIndex1 = 1;
	size_t soap_flag_numberOfResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getMyInvestigationsIncludesPagination::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigationInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigationInclude(soap, "investigationInclude", &(a->ns1__getMyInvestigationsIncludesPagination::investigationInclude), "ns1:investigationInclude"))
				{	soap_flag_investigationInclude1--;
					continue;
				}
			if (soap_flag_startIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startIndex", &(a->ns1__getMyInvestigationsIncludesPagination::startIndex), "xsd:int"))
				{	soap_flag_startIndex1--;
					continue;
				}
			if (soap_flag_numberOfResults1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfResults", &(a->ns1__getMyInvestigationsIncludesPagination::numberOfResults), "xsd:int"))
				{	soap_flag_numberOfResults1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyInvestigationsIncludesPagination *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination, 0, sizeof(ns1__getMyInvestigationsIncludesPagination), 0, soap_copy_ns1__getMyInvestigationsIncludesPagination);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startIndex1 > 0 || soap_flag_numberOfResults1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getMyInvestigationsIncludesPagination::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination);
	if (this->soap_out(soap, tag?tag:"ns1:getMyInvestigationsIncludesPagination", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyInvestigationsIncludesPagination::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyInvestigationsIncludesPagination(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPagination * SOAP_FMAC4 soap_get_ns1__getMyInvestigationsIncludesPagination(struct soap *soap, ns1__getMyInvestigationsIncludesPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyInvestigationsIncludesPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyInvestigationsIncludesPagination * SOAP_FMAC2 soap_instantiate_ns1__getMyInvestigationsIncludesPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyInvestigationsIncludesPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPagination);
		if (size)
			*size = sizeof(ns1__getMyInvestigationsIncludesPagination);
		((ns1__getMyInvestigationsIncludesPagination*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMyInvestigationsIncludesPagination);
		for (int i = 0; i < n; i++)
			((ns1__getMyInvestigationsIncludesPagination*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMyInvestigationsIncludesPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyInvestigationsIncludesPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyInvestigationsIncludesPagination %p -> %p\n", q, p));
	*(ns1__getMyInvestigationsIncludesPagination*)p = *(ns1__getMyInvestigationsIncludesPagination*)q;
}

void ns1__getMyInvestigationsIncludesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getMyInvestigationsIncludesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getMyInvestigationsIncludesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getMyInvestigationsIncludesResponse::return_);
	/* transient soap skipped */
}

int ns1__getMyInvestigationsIncludesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyInvestigationsIncludesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyInvestigationsIncludesResponse(struct soap *soap, const char *tag, int id, const ns1__getMyInvestigationsIncludesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse), "ns1:getMyInvestigationsIncludesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__getMyInvestigationsIncludesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyInvestigationsIncludesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyInvestigationsIncludesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesResponse * SOAP_FMAC4 soap_in_ns1__getMyInvestigationsIncludesResponse(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyInvestigationsIncludesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse, sizeof(ns1__getMyInvestigationsIncludesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyInvestigationsIncludesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__getMyInvestigationsIncludesResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyInvestigationsIncludesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse, 0, sizeof(ns1__getMyInvestigationsIncludesResponse), 0, soap_copy_ns1__getMyInvestigationsIncludesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMyInvestigationsIncludesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getMyInvestigationsIncludesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyInvestigationsIncludesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyInvestigationsIncludesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesResponse * SOAP_FMAC4 soap_get_ns1__getMyInvestigationsIncludesResponse(struct soap *soap, ns1__getMyInvestigationsIncludesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyInvestigationsIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyInvestigationsIncludesResponse * SOAP_FMAC2 soap_instantiate_ns1__getMyInvestigationsIncludesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyInvestigationsIncludesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesResponse);
		if (size)
			*size = sizeof(ns1__getMyInvestigationsIncludesResponse);
		((ns1__getMyInvestigationsIncludesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMyInvestigationsIncludesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getMyInvestigationsIncludesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMyInvestigationsIncludesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyInvestigationsIncludesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyInvestigationsIncludesResponse %p -> %p\n", q, p));
	*(ns1__getMyInvestigationsIncludesResponse*)p = *(ns1__getMyInvestigationsIncludesResponse*)q;
}

void ns1__getMyInvestigationsIncludes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getMyInvestigationsIncludes::sessionId = NULL;
	this->ns1__getMyInvestigationsIncludes::investigationInclude = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getMyInvestigationsIncludes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getMyInvestigationsIncludes::sessionId);
	soap_serialize_PointerTons1__investigationInclude(soap, &this->ns1__getMyInvestigationsIncludes::investigationInclude);
	/* transient soap skipped */
}

int ns1__getMyInvestigationsIncludes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyInvestigationsIncludes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyInvestigationsIncludes(struct soap *soap, const char *tag, int id, const ns1__getMyInvestigationsIncludes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludes), "ns1:getMyInvestigationsIncludes"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getMyInvestigationsIncludes::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigationInclude(soap, "investigationInclude", -1, &(a->ns1__getMyInvestigationsIncludes::investigationInclude), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyInvestigationsIncludes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyInvestigationsIncludes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludes * SOAP_FMAC4 soap_in_ns1__getMyInvestigationsIncludes(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyInvestigationsIncludes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyInvestigationsIncludes, sizeof(ns1__getMyInvestigationsIncludes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyInvestigationsIncludes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyInvestigationsIncludes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigationInclude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getMyInvestigationsIncludes::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigationInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigationInclude(soap, "investigationInclude", &(a->ns1__getMyInvestigationsIncludes::investigationInclude), "ns1:investigationInclude"))
				{	soap_flag_investigationInclude1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyInvestigationsIncludes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyInvestigationsIncludes, 0, sizeof(ns1__getMyInvestigationsIncludes), 0, soap_copy_ns1__getMyInvestigationsIncludes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMyInvestigationsIncludes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyInvestigationsIncludes);
	if (this->soap_out(soap, tag?tag:"ns1:getMyInvestigationsIncludes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyInvestigationsIncludes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyInvestigationsIncludes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludes * SOAP_FMAC4 soap_get_ns1__getMyInvestigationsIncludes(struct soap *soap, ns1__getMyInvestigationsIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyInvestigationsIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyInvestigationsIncludes * SOAP_FMAC2 soap_instantiate_ns1__getMyInvestigationsIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyInvestigationsIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyInvestigationsIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludes);
		if (size)
			*size = sizeof(ns1__getMyInvestigationsIncludes);
		((ns1__getMyInvestigationsIncludes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMyInvestigationsIncludes);
		for (int i = 0; i < n; i++)
			((ns1__getMyInvestigationsIncludes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMyInvestigationsIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyInvestigationsIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyInvestigationsIncludes %p -> %p\n", q, p));
	*(ns1__getMyInvestigationsIncludes*)p = *(ns1__getMyInvestigationsIncludes*)q;
}

void ns1__getMyInvestigationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getMyInvestigationsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getMyInvestigationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__getMyInvestigationsResponse::return_);
	/* transient soap skipped */
}

int ns1__getMyInvestigationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyInvestigationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyInvestigationsResponse(struct soap *soap, const char *tag, int id, const ns1__getMyInvestigationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyInvestigationsResponse), "ns1:getMyInvestigationsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__getMyInvestigationsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyInvestigationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyInvestigationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsResponse * SOAP_FMAC4 soap_in_ns1__getMyInvestigationsResponse(struct soap *soap, const char *tag, ns1__getMyInvestigationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyInvestigationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyInvestigationsResponse, sizeof(ns1__getMyInvestigationsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyInvestigationsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyInvestigationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__getMyInvestigationsResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyInvestigationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyInvestigationsResponse, 0, sizeof(ns1__getMyInvestigationsResponse), 0, soap_copy_ns1__getMyInvestigationsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMyInvestigationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyInvestigationsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getMyInvestigationsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyInvestigationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyInvestigationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsResponse * SOAP_FMAC4 soap_get_ns1__getMyInvestigationsResponse(struct soap *soap, ns1__getMyInvestigationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyInvestigationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyInvestigationsResponse * SOAP_FMAC2 soap_instantiate_ns1__getMyInvestigationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyInvestigationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyInvestigationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsResponse);
		if (size)
			*size = sizeof(ns1__getMyInvestigationsResponse);
		((ns1__getMyInvestigationsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMyInvestigationsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getMyInvestigationsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMyInvestigationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyInvestigationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyInvestigationsResponse %p -> %p\n", q, p));
	*(ns1__getMyInvestigationsResponse*)p = *(ns1__getMyInvestigationsResponse*)q;
}

void ns1__getMyInvestigations::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getMyInvestigations::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getMyInvestigations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getMyInvestigations::sessionId);
	/* transient soap skipped */
}

int ns1__getMyInvestigations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyInvestigations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyInvestigations(struct soap *soap, const char *tag, int id, const ns1__getMyInvestigations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyInvestigations), "ns1:getMyInvestigations"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getMyInvestigations::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyInvestigations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyInvestigations(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyInvestigations * SOAP_FMAC4 soap_in_ns1__getMyInvestigations(struct soap *soap, const char *tag, ns1__getMyInvestigations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyInvestigations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyInvestigations, sizeof(ns1__getMyInvestigations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyInvestigations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyInvestigations *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getMyInvestigations::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyInvestigations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyInvestigations, 0, sizeof(ns1__getMyInvestigations), 0, soap_copy_ns1__getMyInvestigations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMyInvestigations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyInvestigations);
	if (this->soap_out(soap, tag?tag:"ns1:getMyInvestigations", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyInvestigations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyInvestigations(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyInvestigations * SOAP_FMAC4 soap_get_ns1__getMyInvestigations(struct soap *soap, ns1__getMyInvestigations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyInvestigations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyInvestigations * SOAP_FMAC2 soap_instantiate_ns1__getMyInvestigations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyInvestigations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyInvestigations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigations);
		if (size)
			*size = sizeof(ns1__getMyInvestigations);
		((ns1__getMyInvestigations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMyInvestigations);
		for (int i = 0; i < n; i++)
			((ns1__getMyInvestigations*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMyInvestigations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyInvestigations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyInvestigations %p -> %p\n", q, p));
	*(ns1__getMyInvestigations*)p = *(ns1__getMyInvestigations*)q;
}

void ns1__searchByKeywordsAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByKeywordsAllResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByKeywordsAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByKeywordsAllResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByKeywordsAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByKeywordsAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByKeywordsAllResponse(struct soap *soap, const char *tag, int id, const ns1__searchByKeywordsAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByKeywordsAllResponse), "ns1:searchByKeywordsAllResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByKeywordsAllResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByKeywordsAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByKeywordsAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByKeywordsAllResponse * SOAP_FMAC4 soap_in_ns1__searchByKeywordsAllResponse(struct soap *soap, const char *tag, ns1__searchByKeywordsAllResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByKeywordsAllResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByKeywordsAllResponse, sizeof(ns1__searchByKeywordsAllResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByKeywordsAllResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByKeywordsAllResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByKeywordsAllResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByKeywordsAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByKeywordsAllResponse, 0, sizeof(ns1__searchByKeywordsAllResponse), 0, soap_copy_ns1__searchByKeywordsAllResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByKeywordsAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByKeywordsAllResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByKeywordsAllResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByKeywordsAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByKeywordsAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByKeywordsAllResponse * SOAP_FMAC4 soap_get_ns1__searchByKeywordsAllResponse(struct soap *soap, ns1__searchByKeywordsAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByKeywordsAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByKeywordsAllResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByKeywordsAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByKeywordsAllResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByKeywordsAllResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAllResponse);
		if (size)
			*size = sizeof(ns1__searchByKeywordsAllResponse);
		((ns1__searchByKeywordsAllResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAllResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByKeywordsAllResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByKeywordsAllResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByKeywordsAllResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByKeywordsAllResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByKeywordsAllResponse %p -> %p\n", q, p));
	*(ns1__searchByKeywordsAllResponse*)p = *(ns1__searchByKeywordsAllResponse*)q;
}

void ns1__keywordDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__keywordDetails::caseSensitive);
	this->ns1__keywordDetails::investigationInclude = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__keywordDetails::keywords);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__keywordDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__investigationInclude(soap, &this->ns1__keywordDetails::investigationInclude);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__keywordDetails::keywords);
	/* transient soap skipped */
}

int ns1__keywordDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__keywordDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__keywordDetails(struct soap *soap, const char *tag, int id, const ns1__keywordDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__keywordDetails), "ns1:keywordDetails"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "caseSensitive", -1, &(a->ns1__keywordDetails::caseSensitive), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigationInclude(soap, "investigationInclude", -1, &(a->ns1__keywordDetails::investigationInclude), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "keywords", -1, &(a->ns1__keywordDetails::keywords), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__keywordDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__keywordDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__keywordDetails * SOAP_FMAC4 soap_in_ns1__keywordDetails(struct soap *soap, const char *tag, ns1__keywordDetails *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__keywordDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__keywordDetails, sizeof(ns1__keywordDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__keywordDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__keywordDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_caseSensitive1 = 1;
	size_t soap_flag_investigationInclude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_caseSensitive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "caseSensitive", &(a->ns1__keywordDetails::caseSensitive), "xsd:boolean"))
				{	soap_flag_caseSensitive1--;
					continue;
				}
			if (soap_flag_investigationInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigationInclude(soap, "investigationInclude", &(a->ns1__keywordDetails::investigationInclude), "ns1:investigationInclude"))
				{	soap_flag_investigationInclude1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "keywords", &(a->ns1__keywordDetails::keywords), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__keywordDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__keywordDetails, 0, sizeof(ns1__keywordDetails), 0, soap_copy_ns1__keywordDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_caseSensitive1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__keywordDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__keywordDetails);
	if (this->soap_out(soap, tag?tag:"ns1:keywordDetails", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__keywordDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__keywordDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__keywordDetails * SOAP_FMAC4 soap_get_ns1__keywordDetails(struct soap *soap, ns1__keywordDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__keywordDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__keywordDetails * SOAP_FMAC2 soap_instantiate_ns1__keywordDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__keywordDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__keywordDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__keywordDetails);
		if (size)
			*size = sizeof(ns1__keywordDetails);
		((ns1__keywordDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__keywordDetails[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__keywordDetails);
		for (int i = 0; i < n; i++)
			((ns1__keywordDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__keywordDetails*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__keywordDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__keywordDetails %p -> %p\n", q, p));
	*(ns1__keywordDetails*)p = *(ns1__keywordDetails*)q;
}

void ns1__searchByKeywordsAll::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByKeywordsAll::sessionId = NULL;
	this->ns1__searchByKeywordsAll::keywordDetails = NULL;
	soap_default_int(soap, &this->ns1__searchByKeywordsAll::startIndex);
	soap_default_int(soap, &this->ns1__searchByKeywordsAll::numberOfResults);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByKeywordsAll::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByKeywordsAll::sessionId);
	soap_serialize_PointerTons1__keywordDetails(soap, &this->ns1__searchByKeywordsAll::keywordDetails);
	soap_embedded(soap, &this->ns1__searchByKeywordsAll::startIndex, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__searchByKeywordsAll::numberOfResults, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__searchByKeywordsAll::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByKeywordsAll(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByKeywordsAll(struct soap *soap, const char *tag, int id, const ns1__searchByKeywordsAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByKeywordsAll), "ns1:searchByKeywordsAll"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByKeywordsAll::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__keywordDetails(soap, "keywordDetails", -1, &(a->ns1__searchByKeywordsAll::keywordDetails), ""))
		return soap->error;
	if (soap_out_int(soap, "startIndex", -1, &(a->ns1__searchByKeywordsAll::startIndex), ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfResults", -1, &(a->ns1__searchByKeywordsAll::numberOfResults), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByKeywordsAll::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByKeywordsAll(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByKeywordsAll * SOAP_FMAC4 soap_in_ns1__searchByKeywordsAll(struct soap *soap, const char *tag, ns1__searchByKeywordsAll *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByKeywordsAll *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByKeywordsAll, sizeof(ns1__searchByKeywordsAll), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByKeywordsAll)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByKeywordsAll *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_keywordDetails1 = 1;
	size_t soap_flag_startIndex1 = 1;
	size_t soap_flag_numberOfResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByKeywordsAll::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_keywordDetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keywordDetails(soap, "keywordDetails", &(a->ns1__searchByKeywordsAll::keywordDetails), "ns1:keywordDetails"))
				{	soap_flag_keywordDetails1--;
					continue;
				}
			if (soap_flag_startIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startIndex", &(a->ns1__searchByKeywordsAll::startIndex), "xsd:int"))
				{	soap_flag_startIndex1--;
					continue;
				}
			if (soap_flag_numberOfResults1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfResults", &(a->ns1__searchByKeywordsAll::numberOfResults), "xsd:int"))
				{	soap_flag_numberOfResults1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByKeywordsAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByKeywordsAll, 0, sizeof(ns1__searchByKeywordsAll), 0, soap_copy_ns1__searchByKeywordsAll);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startIndex1 > 0 || soap_flag_numberOfResults1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__searchByKeywordsAll::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByKeywordsAll);
	if (this->soap_out(soap, tag?tag:"ns1:searchByKeywordsAll", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByKeywordsAll::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByKeywordsAll(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByKeywordsAll * SOAP_FMAC4 soap_get_ns1__searchByKeywordsAll(struct soap *soap, ns1__searchByKeywordsAll *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByKeywordsAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByKeywordsAll * SOAP_FMAC2 soap_instantiate_ns1__searchByKeywordsAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByKeywordsAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByKeywordsAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAll);
		if (size)
			*size = sizeof(ns1__searchByKeywordsAll);
		((ns1__searchByKeywordsAll*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAll[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByKeywordsAll);
		for (int i = 0; i < n; i++)
			((ns1__searchByKeywordsAll*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByKeywordsAll*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByKeywordsAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByKeywordsAll %p -> %p\n", q, p));
	*(ns1__searchByKeywordsAll*)p = *(ns1__searchByKeywordsAll*)q;
}

void ns1__searchByKeywordsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByKeywordsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByKeywordsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByKeywordsResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByKeywordsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByKeywordsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByKeywordsResponse(struct soap *soap, const char *tag, int id, const ns1__searchByKeywordsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByKeywordsResponse), "ns1:searchByKeywordsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByKeywordsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByKeywordsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByKeywordsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByKeywordsResponse * SOAP_FMAC4 soap_in_ns1__searchByKeywordsResponse(struct soap *soap, const char *tag, ns1__searchByKeywordsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByKeywordsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByKeywordsResponse, sizeof(ns1__searchByKeywordsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByKeywordsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByKeywordsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByKeywordsResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByKeywordsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByKeywordsResponse, 0, sizeof(ns1__searchByKeywordsResponse), 0, soap_copy_ns1__searchByKeywordsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByKeywordsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByKeywordsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByKeywordsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByKeywordsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByKeywordsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByKeywordsResponse * SOAP_FMAC4 soap_get_ns1__searchByKeywordsResponse(struct soap *soap, ns1__searchByKeywordsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByKeywordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByKeywordsResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByKeywordsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByKeywordsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByKeywordsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsResponse);
		if (size)
			*size = sizeof(ns1__searchByKeywordsResponse);
		((ns1__searchByKeywordsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByKeywordsResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByKeywordsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByKeywordsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByKeywordsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByKeywordsResponse %p -> %p\n", q, p));
	*(ns1__searchByKeywordsResponse*)p = *(ns1__searchByKeywordsResponse*)q;
}

void ns1__searchByKeywords::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByKeywords::sessionId = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__searchByKeywords::keywords);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByKeywords::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByKeywords::sessionId);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__searchByKeywords::keywords);
	/* transient soap skipped */
}

int ns1__searchByKeywords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByKeywords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByKeywords(struct soap *soap, const char *tag, int id, const ns1__searchByKeywords *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByKeywords), "ns1:searchByKeywords"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByKeywords::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "keywords", -1, &(a->ns1__searchByKeywords::keywords), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByKeywords::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByKeywords(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByKeywords * SOAP_FMAC4 soap_in_ns1__searchByKeywords(struct soap *soap, const char *tag, ns1__searchByKeywords *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByKeywords *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByKeywords, sizeof(ns1__searchByKeywords), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByKeywords)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByKeywords *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByKeywords::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "keywords", &(a->ns1__searchByKeywords::keywords), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByKeywords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByKeywords, 0, sizeof(ns1__searchByKeywords), 0, soap_copy_ns1__searchByKeywords);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByKeywords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByKeywords);
	if (this->soap_out(soap, tag?tag:"ns1:searchByKeywords", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByKeywords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByKeywords(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByKeywords * SOAP_FMAC4 soap_get_ns1__searchByKeywords(struct soap *soap, ns1__searchByKeywords *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByKeywords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByKeywords * SOAP_FMAC2 soap_instantiate_ns1__searchByKeywords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByKeywords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByKeywords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywords);
		if (size)
			*size = sizeof(ns1__searchByKeywords);
		((ns1__searchByKeywords*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywords[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByKeywords);
		for (int i = 0; i < n; i++)
			((ns1__searchByKeywords*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByKeywords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByKeywords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByKeywords %p -> %p\n", q, p));
	*(ns1__searchByKeywords*)p = *(ns1__searchByKeywords*)q;
}

void ns1__checkDatasetDownloadAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkDatasetDownloadAccessResponse::downloadInfo = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__checkDatasetDownloadAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__downloadInfo(soap, &this->ns1__checkDatasetDownloadAccessResponse::downloadInfo);
	/* transient soap skipped */
}

int ns1__checkDatasetDownloadAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkDatasetDownloadAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkDatasetDownloadAccessResponse(struct soap *soap, const char *tag, int id, const ns1__checkDatasetDownloadAccessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse), "ns1:checkDatasetDownloadAccessResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__downloadInfo(soap, "downloadInfo", -1, &(a->ns1__checkDatasetDownloadAccessResponse::downloadInfo), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__checkDatasetDownloadAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkDatasetDownloadAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccessResponse * SOAP_FMAC4 soap_in_ns1__checkDatasetDownloadAccessResponse(struct soap *soap, const char *tag, ns1__checkDatasetDownloadAccessResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkDatasetDownloadAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse, sizeof(ns1__checkDatasetDownloadAccessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkDatasetDownloadAccessResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_downloadInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_downloadInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__downloadInfo(soap, "downloadInfo", &(a->ns1__checkDatasetDownloadAccessResponse::downloadInfo), "ns1:downloadInfo"))
				{	soap_flag_downloadInfo1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkDatasetDownloadAccessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse, 0, sizeof(ns1__checkDatasetDownloadAccessResponse), 0, soap_copy_ns1__checkDatasetDownloadAccessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__checkDatasetDownloadAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse);
	if (this->soap_out(soap, tag?tag:"ns1:checkDatasetDownloadAccessResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__checkDatasetDownloadAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkDatasetDownloadAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccessResponse * SOAP_FMAC4 soap_get_ns1__checkDatasetDownloadAccessResponse(struct soap *soap, ns1__checkDatasetDownloadAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkDatasetDownloadAccessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__checkDatasetDownloadAccessResponse * SOAP_FMAC2 soap_instantiate_ns1__checkDatasetDownloadAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkDatasetDownloadAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccessResponse);
		if (size)
			*size = sizeof(ns1__checkDatasetDownloadAccessResponse);
		((ns1__checkDatasetDownloadAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccessResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkDatasetDownloadAccessResponse);
		for (int i = 0; i < n; i++)
			((ns1__checkDatasetDownloadAccessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkDatasetDownloadAccessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkDatasetDownloadAccessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkDatasetDownloadAccessResponse %p -> %p\n", q, p));
	*(ns1__checkDatasetDownloadAccessResponse*)p = *(ns1__checkDatasetDownloadAccessResponse*)q;
}

void ns1__checkDatasetDownloadAccess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkDatasetDownloadAccess::sessionId = NULL;
	this->ns1__checkDatasetDownloadAccess::datasetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__checkDatasetDownloadAccess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__checkDatasetDownloadAccess::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__checkDatasetDownloadAccess::datasetId);
	/* transient soap skipped */
}

int ns1__checkDatasetDownloadAccess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkDatasetDownloadAccess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkDatasetDownloadAccess(struct soap *soap, const char *tag, int id, const ns1__checkDatasetDownloadAccess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkDatasetDownloadAccess), "ns1:checkDatasetDownloadAccess"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__checkDatasetDownloadAccess::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__checkDatasetDownloadAccess::datasetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__checkDatasetDownloadAccess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkDatasetDownloadAccess(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccess * SOAP_FMAC4 soap_in_ns1__checkDatasetDownloadAccess(struct soap *soap, const char *tag, ns1__checkDatasetDownloadAccess *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkDatasetDownloadAccess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkDatasetDownloadAccess, sizeof(ns1__checkDatasetDownloadAccess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkDatasetDownloadAccess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkDatasetDownloadAccess *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__checkDatasetDownloadAccess::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__checkDatasetDownloadAccess::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkDatasetDownloadAccess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkDatasetDownloadAccess, 0, sizeof(ns1__checkDatasetDownloadAccess), 0, soap_copy_ns1__checkDatasetDownloadAccess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__checkDatasetDownloadAccess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkDatasetDownloadAccess);
	if (this->soap_out(soap, tag?tag:"ns1:checkDatasetDownloadAccess", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__checkDatasetDownloadAccess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkDatasetDownloadAccess(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccess * SOAP_FMAC4 soap_get_ns1__checkDatasetDownloadAccess(struct soap *soap, ns1__checkDatasetDownloadAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkDatasetDownloadAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__checkDatasetDownloadAccess * SOAP_FMAC2 soap_instantiate_ns1__checkDatasetDownloadAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkDatasetDownloadAccess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkDatasetDownloadAccess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccess);
		if (size)
			*size = sizeof(ns1__checkDatasetDownloadAccess);
		((ns1__checkDatasetDownloadAccess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccess[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkDatasetDownloadAccess);
		for (int i = 0; i < n; i++)
			((ns1__checkDatasetDownloadAccess*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkDatasetDownloadAccess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkDatasetDownloadAccess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkDatasetDownloadAccess %p -> %p\n", q, p));
	*(ns1__checkDatasetDownloadAccess*)p = *(ns1__checkDatasetDownloadAccess*)q;
}

void ns1__searchByUserSurnamePaginationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserSurnamePaginationResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserSurnamePaginationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserSurnamePaginationResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByUserSurnamePaginationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserSurnamePaginationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserSurnamePaginationResponse(struct soap *soap, const char *tag, int id, const ns1__searchByUserSurnamePaginationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse), "ns1:searchByUserSurnamePaginationResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByUserSurnamePaginationResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserSurnamePaginationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserSurnamePaginationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserSurnamePaginationResponse * SOAP_FMAC4 soap_in_ns1__searchByUserSurnamePaginationResponse(struct soap *soap, const char *tag, ns1__searchByUserSurnamePaginationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserSurnamePaginationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse, sizeof(ns1__searchByUserSurnamePaginationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserSurnamePaginationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByUserSurnamePaginationResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserSurnamePaginationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse, 0, sizeof(ns1__searchByUserSurnamePaginationResponse), 0, soap_copy_ns1__searchByUserSurnamePaginationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByUserSurnamePaginationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserSurnamePaginationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserSurnamePaginationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserSurnamePaginationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserSurnamePaginationResponse * SOAP_FMAC4 soap_get_ns1__searchByUserSurnamePaginationResponse(struct soap *soap, ns1__searchByUserSurnamePaginationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserSurnamePaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserSurnamePaginationResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByUserSurnamePaginationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserSurnamePaginationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePaginationResponse);
		if (size)
			*size = sizeof(ns1__searchByUserSurnamePaginationResponse);
		((ns1__searchByUserSurnamePaginationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePaginationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserSurnamePaginationResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserSurnamePaginationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserSurnamePaginationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserSurnamePaginationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserSurnamePaginationResponse %p -> %p\n", q, p));
	*(ns1__searchByUserSurnamePaginationResponse*)p = *(ns1__searchByUserSurnamePaginationResponse*)q;
}

void ns1__searchByUserSurnamePagination::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByUserSurnamePagination::sessionId = NULL;
	this->ns1__searchByUserSurnamePagination::surname = NULL;
	soap_default_int(soap, &this->ns1__searchByUserSurnamePagination::startIndex);
	soap_default_int(soap, &this->ns1__searchByUserSurnamePagination::numberOfResults);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserSurnamePagination::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserSurnamePagination::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserSurnamePagination::surname);
	soap_embedded(soap, &this->ns1__searchByUserSurnamePagination::startIndex, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__searchByUserSurnamePagination::numberOfResults, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__searchByUserSurnamePagination::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserSurnamePagination(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserSurnamePagination(struct soap *soap, const char *tag, int id, const ns1__searchByUserSurnamePagination *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserSurnamePagination), "ns1:searchByUserSurnamePagination"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByUserSurnamePagination::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "surname", -1, &(a->ns1__searchByUserSurnamePagination::surname), ""))
		return soap->error;
	if (soap_out_int(soap, "startIndex", -1, &(a->ns1__searchByUserSurnamePagination::startIndex), ""))
		return soap->error;
	if (soap_out_int(soap, "numberOfResults", -1, &(a->ns1__searchByUserSurnamePagination::numberOfResults), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserSurnamePagination::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserSurnamePagination(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserSurnamePagination * SOAP_FMAC4 soap_in_ns1__searchByUserSurnamePagination(struct soap *soap, const char *tag, ns1__searchByUserSurnamePagination *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserSurnamePagination *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserSurnamePagination, sizeof(ns1__searchByUserSurnamePagination), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserSurnamePagination)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserSurnamePagination *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_surname1 = 1;
	size_t soap_flag_startIndex1 = 1;
	size_t soap_flag_numberOfResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByUserSurnamePagination::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_surname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "surname", &(a->ns1__searchByUserSurnamePagination::surname), "xsd:string"))
				{	soap_flag_surname1--;
					continue;
				}
			if (soap_flag_startIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startIndex", &(a->ns1__searchByUserSurnamePagination::startIndex), "xsd:int"))
				{	soap_flag_startIndex1--;
					continue;
				}
			if (soap_flag_numberOfResults1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numberOfResults", &(a->ns1__searchByUserSurnamePagination::numberOfResults), "xsd:int"))
				{	soap_flag_numberOfResults1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserSurnamePagination *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserSurnamePagination, 0, sizeof(ns1__searchByUserSurnamePagination), 0, soap_copy_ns1__searchByUserSurnamePagination);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startIndex1 > 0 || soap_flag_numberOfResults1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__searchByUserSurnamePagination::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserSurnamePagination);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserSurnamePagination", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserSurnamePagination::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserSurnamePagination(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserSurnamePagination * SOAP_FMAC4 soap_get_ns1__searchByUserSurnamePagination(struct soap *soap, ns1__searchByUserSurnamePagination *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserSurnamePagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserSurnamePagination * SOAP_FMAC2 soap_instantiate_ns1__searchByUserSurnamePagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserSurnamePagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserSurnamePagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePagination);
		if (size)
			*size = sizeof(ns1__searchByUserSurnamePagination);
		((ns1__searchByUserSurnamePagination*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserSurnamePagination);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserSurnamePagination*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserSurnamePagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserSurnamePagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserSurnamePagination %p -> %p\n", q, p));
	*(ns1__searchByUserSurnamePagination*)p = *(ns1__searchByUserSurnamePagination*)q;
}

void ns1__shiftPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__shiftPK::endDate = NULL;
	this->ns1__shiftPK::investigationId = NULL;
	this->ns1__shiftPK::startDate = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__shiftPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__shiftPK::endDate);
	soap_serialize_PointerToLONG64(soap, &this->ns1__shiftPK::investigationId);
	soap_serialize_PointerTotime(soap, &this->ns1__shiftPK::startDate);
	/* transient soap skipped */
}

int ns1__shiftPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__shiftPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__shiftPK(struct soap *soap, const char *tag, int id, const ns1__shiftPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__shiftPK), "ns1:shiftPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "endDate", -1, &(a->ns1__shiftPK::endDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__shiftPK::investigationId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__shiftPK::startDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__shiftPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__shiftPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__shiftPK * SOAP_FMAC4 soap_in_ns1__shiftPK(struct soap *soap, const char *tag, ns1__shiftPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__shiftPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__shiftPK, sizeof(ns1__shiftPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__shiftPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__shiftPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_endDate1 = 1;
	size_t soap_flag_investigationId1 = 1;
	size_t soap_flag_startDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endDate", &(a->ns1__shiftPK::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__shiftPK::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__shiftPK::startDate), "xsd:dateTime"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__shiftPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__shiftPK, 0, sizeof(ns1__shiftPK), 0, soap_copy_ns1__shiftPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__shiftPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__shiftPK);
	if (this->soap_out(soap, tag?tag:"ns1:shiftPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__shiftPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__shiftPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__shiftPK * SOAP_FMAC4 soap_get_ns1__shiftPK(struct soap *soap, ns1__shiftPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__shiftPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__shiftPK * SOAP_FMAC2 soap_instantiate_ns1__shiftPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__shiftPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__shiftPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__shiftPK);
		if (size)
			*size = sizeof(ns1__shiftPK);
		((ns1__shiftPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__shiftPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__shiftPK);
		for (int i = 0; i < n; i++)
			((ns1__shiftPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__shiftPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__shiftPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__shiftPK %p -> %p\n", q, p));
	*(ns1__shiftPK*)p = *(ns1__shiftPK*)q;
}

void ns1__shift::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__shift::shiftComment = NULL;
	this->ns1__shift::shiftPK = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__shift::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__shift::shiftComment);
	soap_serialize_PointerTons1__shiftPK(soap, &this->ns1__shift::shiftPK);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__shift::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__shift(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__shift(struct soap *soap, const char *tag, int id, const ns1__shift *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__shift), "ns1:shift"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "shiftComment", -1, &(a->ns1__shift::shiftComment), ""))
		return soap->error;
	if (soap_out_PointerTons1__shiftPK(soap, "shiftPK", -1, &(a->ns1__shift::shiftPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__shift::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__shift(soap, tag, this, type);
}

SOAP_FMAC3 ns1__shift * SOAP_FMAC4 soap_in_ns1__shift(struct soap *soap, const char *tag, ns1__shift *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__shift *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__shift, sizeof(ns1__shift), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__shift)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__shift *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_shiftComment1 = 1;
	size_t soap_flag_shiftPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_shiftComment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "shiftComment", &(a->ns1__shift::shiftComment), "xsd:string"))
				{	soap_flag_shiftComment1--;
					continue;
				}
			if (soap_flag_shiftPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__shiftPK(soap, "shiftPK", &(a->ns1__shift::shiftPK), "ns1:shiftPK"))
				{	soap_flag_shiftPK1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__shift *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__shift, 0, sizeof(ns1__shift), 0, soap_copy_ns1__shift);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__shift::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__shift);
	if (this->soap_out(soap, tag?tag:"ns1:shift", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__shift::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__shift(soap, this, tag, type);
}

SOAP_FMAC3 ns1__shift * SOAP_FMAC4 soap_get_ns1__shift(struct soap *soap, ns1__shift *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__shift(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__shift * SOAP_FMAC2 soap_instantiate_ns1__shift(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__shift(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__shift, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__shift);
		if (size)
			*size = sizeof(ns1__shift);
		((ns1__shift*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__shift[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__shift);
		for (int i = 0; i < n; i++)
			((ns1__shift*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__shift*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__shift(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__shift %p -> %p\n", q, p));
	*(ns1__shift*)p = *(ns1__shift*)q;
}

void ns1__publication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__publication::fullReference = NULL;
	this->ns1__publication::id = NULL;
	this->ns1__publication::repository = NULL;
	this->ns1__publication::repositoryId = NULL;
	this->ns1__publication::url = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__publication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__publication::fullReference);
	soap_serialize_PointerToLONG64(soap, &this->ns1__publication::id);
	soap_serialize_PointerTostd__string(soap, &this->ns1__publication::repository);
	soap_serialize_PointerTostd__string(soap, &this->ns1__publication::repositoryId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__publication::url);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__publication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__publication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__publication(struct soap *soap, const char *tag, int id, const ns1__publication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__publication), "ns1:publication"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "fullReference", -1, &(a->ns1__publication::fullReference), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__publication::id), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "repository", -1, &(a->ns1__publication::repository), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "repositoryId", -1, &(a->ns1__publication::repositoryId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "url", -1, &(a->ns1__publication::url), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__publication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__publication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__publication * SOAP_FMAC4 soap_in_ns1__publication(struct soap *soap, const char *tag, ns1__publication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__publication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__publication, sizeof(ns1__publication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__publication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__publication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_fullReference1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_repository1 = 1;
	size_t soap_flag_repositoryId1 = 1;
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_fullReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "fullReference", &(a->ns1__publication::fullReference), "xsd:string"))
				{	soap_flag_fullReference1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__publication::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_repository1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "repository", &(a->ns1__publication::repository), "xsd:string"))
				{	soap_flag_repository1--;
					continue;
				}
			if (soap_flag_repositoryId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "repositoryId", &(a->ns1__publication::repositoryId), "xsd:string"))
				{	soap_flag_repositoryId1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "url", &(a->ns1__publication::url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__publication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__publication, 0, sizeof(ns1__publication), 0, soap_copy_ns1__publication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__publication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__publication);
	if (this->soap_out(soap, tag?tag:"ns1:publication", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__publication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__publication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__publication * SOAP_FMAC4 soap_get_ns1__publication(struct soap *soap, ns1__publication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__publication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__publication * SOAP_FMAC2 soap_instantiate_ns1__publication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__publication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__publication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__publication);
		if (size)
			*size = sizeof(ns1__publication);
		((ns1__publication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__publication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__publication);
		for (int i = 0; i < n; i++)
			((ns1__publication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__publication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__publication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__publication %p -> %p\n", q, p));
	*(ns1__publication*)p = *(ns1__publication*)q;
}

void ns1__keyword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__keyword::keywordPK = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__keyword::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__keywordPK(soap, &this->ns1__keyword::keywordPK);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__keyword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__keyword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__keyword(struct soap *soap, const char *tag, int id, const ns1__keyword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__keyword), "ns1:keyword"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTons1__keywordPK(soap, "keywordPK", -1, &(a->ns1__keyword::keywordPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__keyword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__keyword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__keyword * SOAP_FMAC4 soap_in_ns1__keyword(struct soap *soap, const char *tag, ns1__keyword *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__keyword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__keyword, sizeof(ns1__keyword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__keyword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__keyword *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_keywordPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_keywordPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keywordPK(soap, "keywordPK", &(a->ns1__keyword::keywordPK), "ns1:keywordPK"))
				{	soap_flag_keywordPK1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__keyword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__keyword, 0, sizeof(ns1__keyword), 0, soap_copy_ns1__keyword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__keyword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__keyword);
	if (this->soap_out(soap, tag?tag:"ns1:keyword", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__keyword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__keyword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__keyword * SOAP_FMAC4 soap_get_ns1__keyword(struct soap *soap, ns1__keyword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__keyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__keyword * SOAP_FMAC2 soap_instantiate_ns1__keyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__keyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__keyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__keyword);
		if (size)
			*size = sizeof(ns1__keyword);
		((ns1__keyword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__keyword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__keyword);
		for (int i = 0; i < n; i++)
			((ns1__keyword*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__keyword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__keyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__keyword %p -> %p\n", q, p));
	*(ns1__keyword*)p = *(ns1__keyword*)q;
}

void ns1__investigator::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__investigator::facilityUser = NULL;
	this->ns1__investigator::investigatorPK = NULL;
	this->ns1__investigator::role = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__investigator::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__facilityUser(soap, &this->ns1__investigator::facilityUser);
	soap_serialize_PointerTons1__investigatorPK(soap, &this->ns1__investigator::investigatorPK);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigator::role);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__investigator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__investigator(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigator(struct soap *soap, const char *tag, int id, const ns1__investigator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__investigator), "ns1:investigator"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTons1__facilityUser(soap, "facilityUser", -1, &(a->ns1__investigator::facilityUser), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigatorPK(soap, "investigatorPK", -1, &(a->ns1__investigator::investigatorPK), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "role", -1, &(a->ns1__investigator::role), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__investigator::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__investigator(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigator * SOAP_FMAC4 soap_in_ns1__investigator(struct soap *soap, const char *tag, ns1__investigator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__investigator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__investigator, sizeof(ns1__investigator), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__investigator)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__investigator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_facilityUser1 = 1;
	size_t soap_flag_investigatorPK1 = 1;
	size_t soap_flag_role1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_facilityUser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__facilityUser(soap, "facilityUser", &(a->ns1__investigator::facilityUser), "ns1:facilityUser"))
				{	soap_flag_facilityUser1--;
					continue;
				}
			if (soap_flag_investigatorPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigatorPK(soap, "investigatorPK", &(a->ns1__investigator::investigatorPK), "ns1:investigatorPK"))
				{	soap_flag_investigatorPK1--;
					continue;
				}
			if (soap_flag_role1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "role", &(a->ns1__investigator::role), "xsd:string"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__investigator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__investigator, 0, sizeof(ns1__investigator), 0, soap_copy_ns1__investigator);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__investigator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__investigator);
	if (this->soap_out(soap, tag?tag:"ns1:investigator", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__investigator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__investigator(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigator * SOAP_FMAC4 soap_get_ns1__investigator(struct soap *soap, ns1__investigator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__investigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__investigator * SOAP_FMAC2 soap_instantiate_ns1__investigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__investigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigator);
		if (size)
			*size = sizeof(ns1__investigator);
		((ns1__investigator*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__investigator);
		for (int i = 0; i < n; i++)
			((ns1__investigator*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__investigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigator %p -> %p\n", q, p));
	*(ns1__investigator*)p = *(ns1__investigator*)q;
}

void ns1__investigation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__investigation::bcatInvStr = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__investigation::datasetCollection);
	this->ns1__investigation::facility = NULL;
	this->ns1__investigation::facilityCycle = NULL;
	this->ns1__investigation::grantId = NULL;
	this->ns1__investigation::id = NULL;
	this->ns1__investigation::instrument = NULL;
	this->ns1__investigation::invAbstract = NULL;
	this->ns1__investigation::invEndDate = NULL;
	this->ns1__investigation::invNumber = NULL;
	this->ns1__investigation::invParamName = NULL;
	this->ns1__investigation::invParamValue = NULL;
	this->ns1__investigation::invStartDate = NULL;
	this->ns1__investigation::invType = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__investigator(soap, &this->ns1__investigation::investigatorCollection);
	soap_default_std__vectorTemplateOfPointerTons1__keyword(soap, &this->ns1__investigation::keywordCollection);
	this->ns1__investigation::prevInvNumber = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__publication(soap, &this->ns1__investigation::publicationCollection);
	this->ns1__investigation::releaseDate = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__investigation::sampleCollection);
	soap_default_std__vectorTemplateOfPointerTons1__shift(soap, &this->ns1__investigation::shiftCollection);
	this->ns1__investigation::title = NULL;
	this->ns1__investigation::visitId = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__investigation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::bcatInvStr);
	soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__investigation::datasetCollection);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::facility);
	soap_serialize_PointerTons1__facilityCycle(soap, &this->ns1__investigation::facilityCycle);
	soap_serialize_PointerToLONG64(soap, &this->ns1__investigation::grantId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__investigation::id);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::instrument);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::invAbstract);
	soap_serialize_PointerTotime(soap, &this->ns1__investigation::invEndDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::invNumber);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::invParamName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::invParamValue);
	soap_serialize_PointerTotime(soap, &this->ns1__investigation::invStartDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::invType);
	soap_serialize_std__vectorTemplateOfPointerTons1__investigator(soap, &this->ns1__investigation::investigatorCollection);
	soap_serialize_std__vectorTemplateOfPointerTons1__keyword(soap, &this->ns1__investigation::keywordCollection);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::prevInvNumber);
	soap_serialize_std__vectorTemplateOfPointerTons1__publication(soap, &this->ns1__investigation::publicationCollection);
	soap_serialize_PointerTotime(soap, &this->ns1__investigation::releaseDate);
	soap_serialize_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__investigation::sampleCollection);
	soap_serialize_std__vectorTemplateOfPointerTons1__shift(soap, &this->ns1__investigation::shiftCollection);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::title);
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::visitId);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__investigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__investigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigation(struct soap *soap, const char *tag, int id, const ns1__investigation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__investigation), "ns1:investigation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "bcatInvStr", -1, &(a->ns1__investigation::bcatInvStr), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "datasetCollection", -1, &(a->ns1__investigation::datasetCollection), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "facility", -1, &(a->ns1__investigation::facility), ""))
		return soap->error;
	if (soap_out_PointerTons1__facilityCycle(soap, "facilityCycle", -1, &(a->ns1__investigation::facilityCycle), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "grantId", -1, &(a->ns1__investigation::grantId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__investigation::id), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "instrument", -1, &(a->ns1__investigation::instrument), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "invAbstract", -1, &(a->ns1__investigation::invAbstract), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "invEndDate", -1, &(a->ns1__investigation::invEndDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "invNumber", -1, &(a->ns1__investigation::invNumber), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "invParamName", -1, &(a->ns1__investigation::invParamName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "invParamValue", -1, &(a->ns1__investigation::invParamValue), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "invStartDate", -1, &(a->ns1__investigation::invStartDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "invType", -1, &(a->ns1__investigation::invType), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__investigator(soap, "investigatorCollection", -1, &(a->ns1__investigation::investigatorCollection), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__keyword(soap, "keywordCollection", -1, &(a->ns1__investigation::keywordCollection), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "prevInvNumber", -1, &(a->ns1__investigation::prevInvNumber), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__publication(soap, "publicationCollection", -1, &(a->ns1__investigation::publicationCollection), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "releaseDate", -1, &(a->ns1__investigation::releaseDate), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__sample(soap, "sampleCollection", -1, &(a->ns1__investigation::sampleCollection), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__shift(soap, "shiftCollection", -1, &(a->ns1__investigation::shiftCollection), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "title", -1, &(a->ns1__investigation::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "visitId", -1, &(a->ns1__investigation::visitId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__investigation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__investigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigation * SOAP_FMAC4 soap_in_ns1__investigation(struct soap *soap, const char *tag, ns1__investigation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__investigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__investigation, sizeof(ns1__investigation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__investigation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__investigation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_bcatInvStr1 = 1;
	size_t soap_flag_facility1 = 1;
	size_t soap_flag_facilityCycle1 = 1;
	size_t soap_flag_grantId1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_instrument1 = 1;
	size_t soap_flag_invAbstract1 = 1;
	size_t soap_flag_invEndDate1 = 1;
	size_t soap_flag_invNumber1 = 1;
	size_t soap_flag_invParamName1 = 1;
	size_t soap_flag_invParamValue1 = 1;
	size_t soap_flag_invStartDate1 = 1;
	size_t soap_flag_invType1 = 1;
	size_t soap_flag_prevInvNumber1 = 1;
	size_t soap_flag_releaseDate1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_visitId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_bcatInvStr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "bcatInvStr", &(a->ns1__investigation::bcatInvStr), "xsd:string"))
				{	soap_flag_bcatInvStr1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "datasetCollection", &(a->ns1__investigation::datasetCollection), "ns1:dataset"))
					continue;
			if (soap_flag_facility1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "facility", &(a->ns1__investigation::facility), "xsd:string"))
				{	soap_flag_facility1--;
					continue;
				}
			if (soap_flag_facilityCycle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__facilityCycle(soap, "facilityCycle", &(a->ns1__investigation::facilityCycle), "ns1:facilityCycle"))
				{	soap_flag_facilityCycle1--;
					continue;
				}
			if (soap_flag_grantId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "grantId", &(a->ns1__investigation::grantId), "xsd:long"))
				{	soap_flag_grantId1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__investigation::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_instrument1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "instrument", &(a->ns1__investigation::instrument), "xsd:string"))
				{	soap_flag_instrument1--;
					continue;
				}
			if (soap_flag_invAbstract1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "invAbstract", &(a->ns1__investigation::invAbstract), "xsd:string"))
				{	soap_flag_invAbstract1--;
					continue;
				}
			if (soap_flag_invEndDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "invEndDate", &(a->ns1__investigation::invEndDate), "xsd:dateTime"))
				{	soap_flag_invEndDate1--;
					continue;
				}
			if (soap_flag_invNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "invNumber", &(a->ns1__investigation::invNumber), "xsd:string"))
				{	soap_flag_invNumber1--;
					continue;
				}
			if (soap_flag_invParamName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "invParamName", &(a->ns1__investigation::invParamName), "xsd:string"))
				{	soap_flag_invParamName1--;
					continue;
				}
			if (soap_flag_invParamValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "invParamValue", &(a->ns1__investigation::invParamValue), "xsd:string"))
				{	soap_flag_invParamValue1--;
					continue;
				}
			if (soap_flag_invStartDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "invStartDate", &(a->ns1__investigation::invStartDate), "xsd:dateTime"))
				{	soap_flag_invStartDate1--;
					continue;
				}
			if (soap_flag_invType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "invType", &(a->ns1__investigation::invType), "xsd:string"))
				{	soap_flag_invType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigator(soap, "investigatorCollection", &(a->ns1__investigation::investigatorCollection), "ns1:investigator"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__keyword(soap, "keywordCollection", &(a->ns1__investigation::keywordCollection), "ns1:keyword"))
					continue;
			if (soap_flag_prevInvNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "prevInvNumber", &(a->ns1__investigation::prevInvNumber), "xsd:string"))
				{	soap_flag_prevInvNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__publication(soap, "publicationCollection", &(a->ns1__investigation::publicationCollection), "ns1:publication"))
					continue;
			if (soap_flag_releaseDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "releaseDate", &(a->ns1__investigation::releaseDate), "xsd:dateTime"))
				{	soap_flag_releaseDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__sample(soap, "sampleCollection", &(a->ns1__investigation::sampleCollection), "ns1:sample"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__shift(soap, "shiftCollection", &(a->ns1__investigation::shiftCollection), "ns1:shift"))
					continue;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "title", &(a->ns1__investigation::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_visitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "visitId", &(a->ns1__investigation::visitId), "xsd:string"))
				{	soap_flag_visitId1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__investigation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__investigation, 0, sizeof(ns1__investigation), 0, soap_copy_ns1__investigation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__investigation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__investigation);
	if (this->soap_out(soap, tag?tag:"ns1:investigation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__investigation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__investigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigation * SOAP_FMAC4 soap_get_ns1__investigation(struct soap *soap, ns1__investigation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__investigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__investigation * SOAP_FMAC2 soap_instantiate_ns1__investigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__investigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigation);
		if (size)
			*size = sizeof(ns1__investigation);
		((ns1__investigation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__investigation);
		for (int i = 0; i < n; i++)
			((ns1__investigation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__investigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigation %p -> %p\n", q, p));
	*(ns1__investigation*)p = *(ns1__investigation*)q;
}

void ns1__searchByUserSurnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserSurnameResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserSurnameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__searchByUserSurnameResponse::return_);
	/* transient soap skipped */
}

int ns1__searchByUserSurnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserSurnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserSurnameResponse(struct soap *soap, const char *tag, int id, const ns1__searchByUserSurnameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserSurnameResponse), "ns1:searchByUserSurnameResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "return", -1, &(a->ns1__searchByUserSurnameResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserSurnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserSurnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserSurnameResponse * SOAP_FMAC4 soap_in_ns1__searchByUserSurnameResponse(struct soap *soap, const char *tag, ns1__searchByUserSurnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserSurnameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserSurnameResponse, sizeof(ns1__searchByUserSurnameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserSurnameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserSurnameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__investigation(soap, "return", &(a->ns1__searchByUserSurnameResponse::return_), "ns1:investigation"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserSurnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserSurnameResponse, 0, sizeof(ns1__searchByUserSurnameResponse), 0, soap_copy_ns1__searchByUserSurnameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByUserSurnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserSurnameResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserSurnameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserSurnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserSurnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserSurnameResponse * SOAP_FMAC4 soap_get_ns1__searchByUserSurnameResponse(struct soap *soap, ns1__searchByUserSurnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserSurnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserSurnameResponse * SOAP_FMAC2 soap_instantiate_ns1__searchByUserSurnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserSurnameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserSurnameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnameResponse);
		if (size)
			*size = sizeof(ns1__searchByUserSurnameResponse);
		((ns1__searchByUserSurnameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserSurnameResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserSurnameResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserSurnameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserSurnameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserSurnameResponse %p -> %p\n", q, p));
	*(ns1__searchByUserSurnameResponse*)p = *(ns1__searchByUserSurnameResponse*)q;
}

void ns1__searchByUserSurname::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchByUserSurname::sessionId = NULL;
	this->ns1__searchByUserSurname::surname = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchByUserSurname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserSurname::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchByUserSurname::surname);
	/* transient soap skipped */
}

int ns1__searchByUserSurname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchByUserSurname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchByUserSurname(struct soap *soap, const char *tag, int id, const ns1__searchByUserSurname *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchByUserSurname), "ns1:searchByUserSurname"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchByUserSurname::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "surname", -1, &(a->ns1__searchByUserSurname::surname), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchByUserSurname::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchByUserSurname(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchByUserSurname * SOAP_FMAC4 soap_in_ns1__searchByUserSurname(struct soap *soap, const char *tag, ns1__searchByUserSurname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchByUserSurname *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchByUserSurname, sizeof(ns1__searchByUserSurname), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchByUserSurname)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchByUserSurname *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_surname1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchByUserSurname::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_surname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "surname", &(a->ns1__searchByUserSurname::surname), "xsd:string"))
				{	soap_flag_surname1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchByUserSurname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchByUserSurname, 0, sizeof(ns1__searchByUserSurname), 0, soap_copy_ns1__searchByUserSurname);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchByUserSurname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchByUserSurname);
	if (this->soap_out(soap, tag?tag:"ns1:searchByUserSurname", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchByUserSurname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchByUserSurname(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchByUserSurname * SOAP_FMAC4 soap_get_ns1__searchByUserSurname(struct soap *soap, ns1__searchByUserSurname *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchByUserSurname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchByUserSurname * SOAP_FMAC2 soap_instantiate_ns1__searchByUserSurname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchByUserSurname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchByUserSurname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurname);
		if (size)
			*size = sizeof(ns1__searchByUserSurname);
		((ns1__searchByUserSurname*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurname[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchByUserSurname);
		for (int i = 0; i < n; i++)
			((ns1__searchByUserSurname*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchByUserSurname*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchByUserSurname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchByUserSurname %p -> %p\n", q, p));
	*(ns1__searchByUserSurname*)p = *(ns1__searchByUserSurname*)q;
}

void ns1__deleteDataFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteDataFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataFileResponse(struct soap *soap, const char *tag, int id, const ns1__deleteDataFileResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteDataFileResponse");
}

void *ns1__deleteDataFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataFileResponse * SOAP_FMAC4 soap_in_ns1__deleteDataFileResponse(struct soap *soap, const char *tag, ns1__deleteDataFileResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteDataFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataFileResponse, sizeof(ns1__deleteDataFileResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataFileResponse)
			return (ns1__deleteDataFileResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteDataFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataFileResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataFileResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataFileResponse * SOAP_FMAC4 soap_get_ns1__deleteDataFileResponse(struct soap *soap, ns1__deleteDataFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataFileResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteDataFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileResponse);
		if (size)
			*size = sizeof(ns1__deleteDataFileResponse);
		((ns1__deleteDataFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataFileResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataFileResponse %p -> %p\n", q, p));
	*(ns1__deleteDataFileResponse*)p = *(ns1__deleteDataFileResponse*)q;
}

void ns1__deleteDataFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteDataFile::sessionId = NULL;
	this->ns1__deleteDataFile::datafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteDataFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteDataFile::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__deleteDataFile::datafileId);
	/* transient soap skipped */
}

int ns1__deleteDataFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDataFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDataFile(struct soap *soap, const char *tag, int id, const ns1__deleteDataFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDataFile), "ns1:deleteDataFile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteDataFile::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__deleteDataFile::datafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteDataFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDataFile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDataFile * SOAP_FMAC4 soap_in_ns1__deleteDataFile(struct soap *soap, const char *tag, ns1__deleteDataFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteDataFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDataFile, sizeof(ns1__deleteDataFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDataFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteDataFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteDataFile::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__deleteDataFile::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteDataFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDataFile, 0, sizeof(ns1__deleteDataFile), 0, soap_copy_ns1__deleteDataFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteDataFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDataFile);
	if (this->soap_out(soap, tag?tag:"ns1:deleteDataFile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteDataFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDataFile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDataFile * SOAP_FMAC4 soap_get_ns1__deleteDataFile(struct soap *soap, ns1__deleteDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteDataFile * SOAP_FMAC2 soap_instantiate_ns1__deleteDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFile);
		if (size)
			*size = sizeof(ns1__deleteDataFile);
		((ns1__deleteDataFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDataFile);
		for (int i = 0; i < n; i++)
			((ns1__deleteDataFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDataFile %p -> %p\n", q, p));
	*(ns1__deleteDataFile*)p = *(ns1__deleteDataFile*)q;
}

void ns1__downloadInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadInfo::credential = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__downloadInfo::datafileLocations);
	soap_default_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns1__downloadInfo::datafileNames);
	this->ns1__downloadInfo::userId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__downloadInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadInfo::credential);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__downloadInfo::datafileLocations);
	soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns1__downloadInfo::datafileNames);
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadInfo::userId);
	/* transient soap skipped */
}

int ns1__downloadInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadInfo(struct soap *soap, const char *tag, int id, const ns1__downloadInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadInfo), "ns1:downloadInfo"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->ns1__downloadInfo::credential), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "datafileLocations", -1, &(a->ns1__downloadInfo::datafileLocations), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToxsd__anyType(soap, "datafileNames", -1, &(a->ns1__downloadInfo::datafileNames), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userId", -1, &(a->ns1__downloadInfo::userId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadInfo * SOAP_FMAC4 soap_in_ns1__downloadInfo(struct soap *soap, const char *tag, ns1__downloadInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadInfo, sizeof(ns1__downloadInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_credential1 = 1;
	size_t soap_flag_userId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->ns1__downloadInfo::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "datafileLocations", &(a->ns1__downloadInfo::datafileLocations), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToxsd__anyType(soap, "datafileNames", &(a->ns1__downloadInfo::datafileNames), "xsd:anyType"))
					continue;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userId", &(a->ns1__downloadInfo::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadInfo, 0, sizeof(ns1__downloadInfo), 0, soap_copy_ns1__downloadInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__downloadInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadInfo);
	if (this->soap_out(soap, tag?tag:"ns1:downloadInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadInfo * SOAP_FMAC4 soap_get_ns1__downloadInfo(struct soap *soap, ns1__downloadInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadInfo * SOAP_FMAC2 soap_instantiate_ns1__downloadInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadInfo);
		if (size)
			*size = sizeof(ns1__downloadInfo);
		((ns1__downloadInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadInfo);
		for (int i = 0; i < n; i++)
			((ns1__downloadInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadInfo %p -> %p\n", q, p));
	*(ns1__downloadInfo*)p = *(ns1__downloadInfo*)q;
}

void ns1__checkDatafileDownloadAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkDatafileDownloadAccessResponse::downloadInfo = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__checkDatafileDownloadAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__downloadInfo(soap, &this->ns1__checkDatafileDownloadAccessResponse::downloadInfo);
	/* transient soap skipped */
}

int ns1__checkDatafileDownloadAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkDatafileDownloadAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkDatafileDownloadAccessResponse(struct soap *soap, const char *tag, int id, const ns1__checkDatafileDownloadAccessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse), "ns1:checkDatafileDownloadAccessResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__downloadInfo(soap, "downloadInfo", -1, &(a->ns1__checkDatafileDownloadAccessResponse::downloadInfo), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__checkDatafileDownloadAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkDatafileDownloadAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccessResponse * SOAP_FMAC4 soap_in_ns1__checkDatafileDownloadAccessResponse(struct soap *soap, const char *tag, ns1__checkDatafileDownloadAccessResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkDatafileDownloadAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse, sizeof(ns1__checkDatafileDownloadAccessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkDatafileDownloadAccessResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_downloadInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_downloadInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__downloadInfo(soap, "downloadInfo", &(a->ns1__checkDatafileDownloadAccessResponse::downloadInfo), "ns1:downloadInfo"))
				{	soap_flag_downloadInfo1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkDatafileDownloadAccessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse, 0, sizeof(ns1__checkDatafileDownloadAccessResponse), 0, soap_copy_ns1__checkDatafileDownloadAccessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__checkDatafileDownloadAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse);
	if (this->soap_out(soap, tag?tag:"ns1:checkDatafileDownloadAccessResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__checkDatafileDownloadAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkDatafileDownloadAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccessResponse * SOAP_FMAC4 soap_get_ns1__checkDatafileDownloadAccessResponse(struct soap *soap, ns1__checkDatafileDownloadAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkDatafileDownloadAccessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__checkDatafileDownloadAccessResponse * SOAP_FMAC2 soap_instantiate_ns1__checkDatafileDownloadAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkDatafileDownloadAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccessResponse);
		if (size)
			*size = sizeof(ns1__checkDatafileDownloadAccessResponse);
		((ns1__checkDatafileDownloadAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccessResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkDatafileDownloadAccessResponse);
		for (int i = 0; i < n; i++)
			((ns1__checkDatafileDownloadAccessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkDatafileDownloadAccessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkDatafileDownloadAccessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkDatafileDownloadAccessResponse %p -> %p\n", q, p));
	*(ns1__checkDatafileDownloadAccessResponse*)p = *(ns1__checkDatafileDownloadAccessResponse*)q;
}

void ns1__checkDatafileDownloadAccess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkDatafileDownloadAccess::sessionId = NULL;
	soap_default_std__vectorTemplateOfLONG64(soap, &this->ns1__checkDatafileDownloadAccess::datafileIds);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__checkDatafileDownloadAccess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__checkDatafileDownloadAccess::sessionId);
	soap_serialize_std__vectorTemplateOfLONG64(soap, &this->ns1__checkDatafileDownloadAccess::datafileIds);
	/* transient soap skipped */
}

int ns1__checkDatafileDownloadAccess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkDatafileDownloadAccess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkDatafileDownloadAccess(struct soap *soap, const char *tag, int id, const ns1__checkDatafileDownloadAccess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkDatafileDownloadAccess), "ns1:checkDatafileDownloadAccess"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__checkDatafileDownloadAccess::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfLONG64(soap, "datafileIds", -1, &(a->ns1__checkDatafileDownloadAccess::datafileIds), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__checkDatafileDownloadAccess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkDatafileDownloadAccess(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccess * SOAP_FMAC4 soap_in_ns1__checkDatafileDownloadAccess(struct soap *soap, const char *tag, ns1__checkDatafileDownloadAccess *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkDatafileDownloadAccess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkDatafileDownloadAccess, sizeof(ns1__checkDatafileDownloadAccess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkDatafileDownloadAccess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkDatafileDownloadAccess *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__checkDatafileDownloadAccess::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "datafileIds", &(a->ns1__checkDatafileDownloadAccess::datafileIds), "xsd:long"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkDatafileDownloadAccess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkDatafileDownloadAccess, 0, sizeof(ns1__checkDatafileDownloadAccess), 0, soap_copy_ns1__checkDatafileDownloadAccess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__checkDatafileDownloadAccess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkDatafileDownloadAccess);
	if (this->soap_out(soap, tag?tag:"ns1:checkDatafileDownloadAccess", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__checkDatafileDownloadAccess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkDatafileDownloadAccess(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccess * SOAP_FMAC4 soap_get_ns1__checkDatafileDownloadAccess(struct soap *soap, ns1__checkDatafileDownloadAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkDatafileDownloadAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__checkDatafileDownloadAccess * SOAP_FMAC2 soap_instantiate_ns1__checkDatafileDownloadAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkDatafileDownloadAccess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkDatafileDownloadAccess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccess);
		if (size)
			*size = sizeof(ns1__checkDatafileDownloadAccess);
		((ns1__checkDatafileDownloadAccess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccess[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkDatafileDownloadAccess);
		for (int i = 0; i < n; i++)
			((ns1__checkDatafileDownloadAccess*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkDatafileDownloadAccess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkDatafileDownloadAccess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkDatafileDownloadAccess %p -> %p\n", q, p));
	*(ns1__checkDatafileDownloadAccess*)p = *(ns1__checkDatafileDownloadAccess*)q;
}

void ns1__getFacilityUserByFacilityUserIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getFacilityUserByFacilityUserIdResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getFacilityUserByFacilityUserIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__facilityUser(soap, &this->ns1__getFacilityUserByFacilityUserIdResponse::return_);
	/* transient soap skipped */
}

int ns1__getFacilityUserByFacilityUserIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getFacilityUserByFacilityUserIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, const char *tag, int id, const ns1__getFacilityUserByFacilityUserIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse), "ns1:getFacilityUserByFacilityUserIdResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__facilityUser(soap, "return", -1, &(a->ns1__getFacilityUserByFacilityUserIdResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getFacilityUserByFacilityUserIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getFacilityUserByFacilityUserIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserIdResponse * SOAP_FMAC4 soap_in_ns1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, const char *tag, ns1__getFacilityUserByFacilityUserIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getFacilityUserByFacilityUserIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse, sizeof(ns1__getFacilityUserByFacilityUserIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getFacilityUserByFacilityUserIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__facilityUser(soap, "return", &(a->ns1__getFacilityUserByFacilityUserIdResponse::return_), "ns1:facilityUser"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getFacilityUserByFacilityUserIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse, 0, sizeof(ns1__getFacilityUserByFacilityUserIdResponse), 0, soap_copy_ns1__getFacilityUserByFacilityUserIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getFacilityUserByFacilityUserIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getFacilityUserByFacilityUserIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getFacilityUserByFacilityUserIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getFacilityUserByFacilityUserIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserIdResponse * SOAP_FMAC4 soap_get_ns1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, ns1__getFacilityUserByFacilityUserIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFacilityUserByFacilityUserIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getFacilityUserByFacilityUserIdResponse * SOAP_FMAC2 soap_instantiate_ns1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFacilityUserByFacilityUserIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserIdResponse);
		if (size)
			*size = sizeof(ns1__getFacilityUserByFacilityUserIdResponse);
		((ns1__getFacilityUserByFacilityUserIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getFacilityUserByFacilityUserIdResponse);
		for (int i = 0; i < n; i++)
			((ns1__getFacilityUserByFacilityUserIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getFacilityUserByFacilityUserIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getFacilityUserByFacilityUserIdResponse %p -> %p\n", q, p));
	*(ns1__getFacilityUserByFacilityUserIdResponse*)p = *(ns1__getFacilityUserByFacilityUserIdResponse*)q;
}

void ns1__getFacilityUserByFacilityUserId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getFacilityUserByFacilityUserId::sessionId = NULL;
	this->ns1__getFacilityUserByFacilityUserId::facilityUserId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getFacilityUserByFacilityUserId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getFacilityUserByFacilityUserId::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getFacilityUserByFacilityUserId::facilityUserId);
	/* transient soap skipped */
}

int ns1__getFacilityUserByFacilityUserId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getFacilityUserByFacilityUserId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFacilityUserByFacilityUserId(struct soap *soap, const char *tag, int id, const ns1__getFacilityUserByFacilityUserId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId), "ns1:getFacilityUserByFacilityUserId"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getFacilityUserByFacilityUserId::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "facilityUserId", -1, &(a->ns1__getFacilityUserByFacilityUserId::facilityUserId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getFacilityUserByFacilityUserId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getFacilityUserByFacilityUserId(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserId * SOAP_FMAC4 soap_in_ns1__getFacilityUserByFacilityUserId(struct soap *soap, const char *tag, ns1__getFacilityUserByFacilityUserId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getFacilityUserByFacilityUserId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId, sizeof(ns1__getFacilityUserByFacilityUserId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getFacilityUserByFacilityUserId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getFacilityUserByFacilityUserId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_facilityUserId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getFacilityUserByFacilityUserId::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_facilityUserId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "facilityUserId", &(a->ns1__getFacilityUserByFacilityUserId::facilityUserId), "xsd:string"))
				{	soap_flag_facilityUserId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getFacilityUserByFacilityUserId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId, 0, sizeof(ns1__getFacilityUserByFacilityUserId), 0, soap_copy_ns1__getFacilityUserByFacilityUserId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getFacilityUserByFacilityUserId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId);
	if (this->soap_out(soap, tag?tag:"ns1:getFacilityUserByFacilityUserId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getFacilityUserByFacilityUserId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getFacilityUserByFacilityUserId(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserId * SOAP_FMAC4 soap_get_ns1__getFacilityUserByFacilityUserId(struct soap *soap, ns1__getFacilityUserByFacilityUserId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFacilityUserByFacilityUserId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getFacilityUserByFacilityUserId * SOAP_FMAC2 soap_instantiate_ns1__getFacilityUserByFacilityUserId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFacilityUserByFacilityUserId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserId);
		if (size)
			*size = sizeof(ns1__getFacilityUserByFacilityUserId);
		((ns1__getFacilityUserByFacilityUserId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getFacilityUserByFacilityUserId);
		for (int i = 0; i < n; i++)
			((ns1__getFacilityUserByFacilityUserId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getFacilityUserByFacilityUserId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFacilityUserByFacilityUserId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getFacilityUserByFacilityUserId %p -> %p\n", q, p));
	*(ns1__getFacilityUserByFacilityUserId*)p = *(ns1__getFacilityUserByFacilityUserId*)q;
}

void ns1__addSampleParameterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addSampleParameterResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addSampleParameterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sampleParameter(soap, &this->ns1__addSampleParameterResponse::return_);
	/* transient soap skipped */
}

int ns1__addSampleParameterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addSampleParameterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addSampleParameterResponse(struct soap *soap, const char *tag, int id, const ns1__addSampleParameterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addSampleParameterResponse), "ns1:addSampleParameterResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__sampleParameter(soap, "return", -1, &(a->ns1__addSampleParameterResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addSampleParameterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addSampleParameterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addSampleParameterResponse * SOAP_FMAC4 soap_in_ns1__addSampleParameterResponse(struct soap *soap, const char *tag, ns1__addSampleParameterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addSampleParameterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addSampleParameterResponse, sizeof(ns1__addSampleParameterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addSampleParameterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addSampleParameterResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sampleParameter(soap, "return", &(a->ns1__addSampleParameterResponse::return_), "ns1:sampleParameter"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addSampleParameterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addSampleParameterResponse, 0, sizeof(ns1__addSampleParameterResponse), 0, soap_copy_ns1__addSampleParameterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addSampleParameterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addSampleParameterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addSampleParameterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addSampleParameterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addSampleParameterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addSampleParameterResponse * SOAP_FMAC4 soap_get_ns1__addSampleParameterResponse(struct soap *soap, ns1__addSampleParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addSampleParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__addSampleParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addSampleParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addSampleParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameterResponse);
		if (size)
			*size = sizeof(ns1__addSampleParameterResponse);
		((ns1__addSampleParameterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addSampleParameterResponse);
		for (int i = 0; i < n; i++)
			((ns1__addSampleParameterResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addSampleParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addSampleParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addSampleParameterResponse %p -> %p\n", q, p));
	*(ns1__addSampleParameterResponse*)p = *(ns1__addSampleParameterResponse*)q;
}

void ns1__addSampleParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addSampleParameter::sessionId = NULL;
	this->ns1__addSampleParameter::sampleParameter = NULL;
	this->ns1__addSampleParameter::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addSampleParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addSampleParameter::sessionId);
	soap_serialize_PointerTons1__sampleParameter(soap, &this->ns1__addSampleParameter::sampleParameter);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addSampleParameter::investigationId);
	/* transient soap skipped */
}

int ns1__addSampleParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addSampleParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addSampleParameter(struct soap *soap, const char *tag, int id, const ns1__addSampleParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addSampleParameter), "ns1:addSampleParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addSampleParameter::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__sampleParameter(soap, "sampleParameter", -1, &(a->ns1__addSampleParameter::sampleParameter), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__addSampleParameter::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addSampleParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addSampleParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addSampleParameter * SOAP_FMAC4 soap_in_ns1__addSampleParameter(struct soap *soap, const char *tag, ns1__addSampleParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addSampleParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addSampleParameter, sizeof(ns1__addSampleParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addSampleParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addSampleParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleParameter1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addSampleParameter::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sampleParameter(soap, "sampleParameter", &(a->ns1__addSampleParameter::sampleParameter), "ns1:sampleParameter"))
				{	soap_flag_sampleParameter1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__addSampleParameter::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addSampleParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addSampleParameter, 0, sizeof(ns1__addSampleParameter), 0, soap_copy_ns1__addSampleParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addSampleParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addSampleParameter);
	if (this->soap_out(soap, tag?tag:"ns1:addSampleParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addSampleParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addSampleParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addSampleParameter * SOAP_FMAC4 soap_get_ns1__addSampleParameter(struct soap *soap, ns1__addSampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addSampleParameter * SOAP_FMAC2 soap_instantiate_ns1__addSampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addSampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addSampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameter);
		if (size)
			*size = sizeof(ns1__addSampleParameter);
		((ns1__addSampleParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addSampleParameter);
		for (int i = 0; i < n; i++)
			((ns1__addSampleParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addSampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addSampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addSampleParameter %p -> %p\n", q, p));
	*(ns1__addSampleParameter*)p = *(ns1__addSampleParameter*)q;
}

void ns1__modifyDataSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifyDataSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataSetResponse(struct soap *soap, const char *tag, int id, const ns1__modifyDataSetResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifyDataSetResponse");
}

void *ns1__modifyDataSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataSetResponse * SOAP_FMAC4 soap_in_ns1__modifyDataSetResponse(struct soap *soap, const char *tag, ns1__modifyDataSetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifyDataSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataSetResponse, sizeof(ns1__modifyDataSetResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataSetResponse)
			return (ns1__modifyDataSetResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifyDataSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataSetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataSetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataSetResponse * SOAP_FMAC4 soap_get_ns1__modifyDataSetResponse(struct soap *soap, ns1__modifyDataSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataSetResponse * SOAP_FMAC2 soap_instantiate_ns1__modifyDataSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetResponse);
		if (size)
			*size = sizeof(ns1__modifyDataSetResponse);
		((ns1__modifyDataSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataSetResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataSetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataSetResponse %p -> %p\n", q, p));
	*(ns1__modifyDataSetResponse*)p = *(ns1__modifyDataSetResponse*)q;
}

void ns1__modifyDataSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifyDataSet::sessionId = NULL;
	this->ns1__modifyDataSet::dataSet = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifyDataSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifyDataSet::sessionId);
	soap_serialize_PointerTons1__dataset(soap, &this->ns1__modifyDataSet::dataSet);
	/* transient soap skipped */
}

int ns1__modifyDataSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifyDataSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyDataSet(struct soap *soap, const char *tag, int id, const ns1__modifyDataSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyDataSet), "ns1:modifyDataSet"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifyDataSet::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__dataset(soap, "dataSet", -1, &(a->ns1__modifyDataSet::dataSet), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifyDataSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifyDataSet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifyDataSet * SOAP_FMAC4 soap_in_ns1__modifyDataSet(struct soap *soap, const char *tag, ns1__modifyDataSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifyDataSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyDataSet, sizeof(ns1__modifyDataSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifyDataSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifyDataSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataSet1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifyDataSet::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dataset(soap, "dataSet", &(a->ns1__modifyDataSet::dataSet), "ns1:dataset"))
				{	soap_flag_dataSet1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifyDataSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyDataSet, 0, sizeof(ns1__modifyDataSet), 0, soap_copy_ns1__modifyDataSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifyDataSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifyDataSet);
	if (this->soap_out(soap, tag?tag:"ns1:modifyDataSet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifyDataSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifyDataSet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifyDataSet * SOAP_FMAC4 soap_get_ns1__modifyDataSet(struct soap *soap, ns1__modifyDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifyDataSet * SOAP_FMAC2 soap_instantiate_ns1__modifyDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifyDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifyDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSet);
		if (size)
			*size = sizeof(ns1__modifyDataSet);
		((ns1__modifyDataSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifyDataSet);
		for (int i = 0; i < n; i++)
			((ns1__modifyDataSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifyDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifyDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifyDataSet %p -> %p\n", q, p));
	*(ns1__modifyDataSet*)p = *(ns1__modifyDataSet*)q;
}

void ns1__downloadDatafilesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadDatafilesResponse::URL = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__downloadDatafilesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadDatafilesResponse::URL);
	/* transient soap skipped */
}

int ns1__downloadDatafilesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadDatafilesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadDatafilesResponse(struct soap *soap, const char *tag, int id, const ns1__downloadDatafilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadDatafilesResponse), "ns1:downloadDatafilesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "URL", -1, &(a->ns1__downloadDatafilesResponse::URL), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadDatafilesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadDatafilesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadDatafilesResponse * SOAP_FMAC4 soap_in_ns1__downloadDatafilesResponse(struct soap *soap, const char *tag, ns1__downloadDatafilesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadDatafilesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadDatafilesResponse, sizeof(ns1__downloadDatafilesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadDatafilesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadDatafilesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_URL1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_URL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "URL", &(a->ns1__downloadDatafilesResponse::URL), "xsd:string"))
				{	soap_flag_URL1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadDatafilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadDatafilesResponse, 0, sizeof(ns1__downloadDatafilesResponse), 0, soap_copy_ns1__downloadDatafilesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__downloadDatafilesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadDatafilesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:downloadDatafilesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadDatafilesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadDatafilesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadDatafilesResponse * SOAP_FMAC4 soap_get_ns1__downloadDatafilesResponse(struct soap *soap, ns1__downloadDatafilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadDatafilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadDatafilesResponse * SOAP_FMAC2 soap_instantiate_ns1__downloadDatafilesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadDatafilesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadDatafilesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafilesResponse);
		if (size)
			*size = sizeof(ns1__downloadDatafilesResponse);
		((ns1__downloadDatafilesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafilesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadDatafilesResponse);
		for (int i = 0; i < n; i++)
			((ns1__downloadDatafilesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadDatafilesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadDatafilesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadDatafilesResponse %p -> %p\n", q, p));
	*(ns1__downloadDatafilesResponse*)p = *(ns1__downloadDatafilesResponse*)q;
}

void ns1__downloadDatafiles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadDatafiles::sessionId = NULL;
	soap_default_std__vectorTemplateOfLONG64(soap, &this->ns1__downloadDatafiles::datafileIds);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__downloadDatafiles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadDatafiles::sessionId);
	soap_serialize_std__vectorTemplateOfLONG64(soap, &this->ns1__downloadDatafiles::datafileIds);
	/* transient soap skipped */
}

int ns1__downloadDatafiles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadDatafiles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadDatafiles(struct soap *soap, const char *tag, int id, const ns1__downloadDatafiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadDatafiles), "ns1:downloadDatafiles"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__downloadDatafiles::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfLONG64(soap, "datafileIds", -1, &(a->ns1__downloadDatafiles::datafileIds), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadDatafiles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadDatafiles(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadDatafiles * SOAP_FMAC4 soap_in_ns1__downloadDatafiles(struct soap *soap, const char *tag, ns1__downloadDatafiles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadDatafiles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadDatafiles, sizeof(ns1__downloadDatafiles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadDatafiles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadDatafiles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__downloadDatafiles::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "datafileIds", &(a->ns1__downloadDatafiles::datafileIds), "xsd:long"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadDatafiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadDatafiles, 0, sizeof(ns1__downloadDatafiles), 0, soap_copy_ns1__downloadDatafiles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__downloadDatafiles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadDatafiles);
	if (this->soap_out(soap, tag?tag:"ns1:downloadDatafiles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadDatafiles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadDatafiles(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadDatafiles * SOAP_FMAC4 soap_get_ns1__downloadDatafiles(struct soap *soap, ns1__downloadDatafiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadDatafiles * SOAP_FMAC2 soap_instantiate_ns1__downloadDatafiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadDatafiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadDatafiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafiles);
		if (size)
			*size = sizeof(ns1__downloadDatafiles);
		((ns1__downloadDatafiles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadDatafiles);
		for (int i = 0; i < n; i++)
			((ns1__downloadDatafiles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadDatafiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadDatafiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadDatafiles %p -> %p\n", q, p));
	*(ns1__downloadDatafiles*)p = *(ns1__downloadDatafiles*)q;
}

void ns1__NoSuchUserException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NoSuchUserException::message = NULL;
	this->ns1__NoSuchUserException::stackTraceAsString = NULL;
	this->ns1__NoSuchUserException::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__NoSuchUserException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__NoSuchUserException::message);
	soap_serialize_PointerTostd__string(soap, &this->ns1__NoSuchUserException::stackTraceAsString);
	soap_serialize_PointerTostd__string(soap, &this->ns1__NoSuchUserException::uniqueId);
	/* transient soap skipped */
}

int ns1__NoSuchUserException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NoSuchUserException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoSuchUserException(struct soap *soap, const char *tag, int id, const ns1__NoSuchUserException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoSuchUserException), "ns1:NoSuchUserException"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns1__NoSuchUserException::message), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stackTraceAsString", -1, &(a->ns1__NoSuchUserException::stackTraceAsString), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__NoSuchUserException::uniqueId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NoSuchUserException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NoSuchUserException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NoSuchUserException * SOAP_FMAC4 soap_in_ns1__NoSuchUserException(struct soap *soap, const char *tag, ns1__NoSuchUserException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NoSuchUserException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoSuchUserException, sizeof(ns1__NoSuchUserException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__NoSuchUserException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__NoSuchUserException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_stackTraceAsString1 = 1;
	size_t soap_flag_uniqueId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->ns1__NoSuchUserException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_stackTraceAsString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stackTraceAsString", &(a->ns1__NoSuchUserException::stackTraceAsString), "xsd:string"))
				{	soap_flag_stackTraceAsString1--;
					continue;
				}
			if (soap_flag_uniqueId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__NoSuchUserException::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NoSuchUserException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoSuchUserException, 0, sizeof(ns1__NoSuchUserException), 0, soap_copy_ns1__NoSuchUserException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__NoSuchUserException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__NoSuchUserException);
	if (this->soap_out(soap, tag?tag:"ns1:NoSuchUserException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NoSuchUserException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NoSuchUserException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NoSuchUserException * SOAP_FMAC4 soap_get_ns1__NoSuchUserException(struct soap *soap, ns1__NoSuchUserException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoSuchUserException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__NoSuchUserException * SOAP_FMAC2 soap_instantiate_ns1__NoSuchUserException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NoSuchUserException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NoSuchUserException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchUserException);
		if (size)
			*size = sizeof(ns1__NoSuchUserException);
		((ns1__NoSuchUserException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchUserException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__NoSuchUserException);
		for (int i = 0; i < n; i++)
			((ns1__NoSuchUserException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__NoSuchUserException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__NoSuchUserException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__NoSuchUserException %p -> %p\n", q, p));
	*(ns1__NoSuchUserException*)p = *(ns1__NoSuchUserException*)q;
}

void ns1__userDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__userDetails::credential = NULL;
	this->ns1__userDetails::department = NULL;
	this->ns1__userDetails::email = NULL;
	this->ns1__userDetails::federalId = NULL;
	this->ns1__userDetails::firstName = NULL;
	this->ns1__userDetails::initial = NULL;
	this->ns1__userDetails::institution = NULL;
	this->ns1__userDetails::lastName = NULL;
	this->ns1__userDetails::title = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__userDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::credential);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::department);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::email);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::federalId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::firstName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::initial);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::institution);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::lastName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__userDetails::title);
	/* transient soap skipped */
}

int ns1__userDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__userDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userDetails(struct soap *soap, const char *tag, int id, const ns1__userDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userDetails), "ns1:userDetails"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->ns1__userDetails::credential), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "department", -1, &(a->ns1__userDetails::department), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "email", -1, &(a->ns1__userDetails::email), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "federalId", -1, &(a->ns1__userDetails::federalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "firstName", -1, &(a->ns1__userDetails::firstName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "initial", -1, &(a->ns1__userDetails::initial), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "institution", -1, &(a->ns1__userDetails::institution), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "lastName", -1, &(a->ns1__userDetails::lastName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "title", -1, &(a->ns1__userDetails::title), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__userDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__userDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__userDetails * SOAP_FMAC4 soap_in_ns1__userDetails(struct soap *soap, const char *tag, ns1__userDetails *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__userDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userDetails, sizeof(ns1__userDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__userDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__userDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_credential1 = 1;
	size_t soap_flag_department1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_federalId1 = 1;
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_initial1 = 1;
	size_t soap_flag_institution1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->ns1__userDetails::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			if (soap_flag_department1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "department", &(a->ns1__userDetails::department), "xsd:string"))
				{	soap_flag_department1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "email", &(a->ns1__userDetails::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_federalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "federalId", &(a->ns1__userDetails::federalId), "xsd:string"))
				{	soap_flag_federalId1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "firstName", &(a->ns1__userDetails::firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_initial1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "initial", &(a->ns1__userDetails::initial), "xsd:string"))
				{	soap_flag_initial1--;
					continue;
				}
			if (soap_flag_institution1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "institution", &(a->ns1__userDetails::institution), "xsd:string"))
				{	soap_flag_institution1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "lastName", &(a->ns1__userDetails::lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "title", &(a->ns1__userDetails::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__userDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userDetails, 0, sizeof(ns1__userDetails), 0, soap_copy_ns1__userDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__userDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__userDetails);
	if (this->soap_out(soap, tag?tag:"ns1:userDetails", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__userDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__userDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__userDetails * SOAP_FMAC4 soap_get_ns1__userDetails(struct soap *soap, ns1__userDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__userDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__userDetails * SOAP_FMAC2 soap_instantiate_ns1__userDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__userDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__userDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__userDetails);
		if (size)
			*size = sizeof(ns1__userDetails);
		((ns1__userDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__userDetails[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__userDetails);
		for (int i = 0; i < n; i++)
			((ns1__userDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__userDetails*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__userDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__userDetails %p -> %p\n", q, p));
	*(ns1__userDetails*)p = *(ns1__userDetails*)q;
}

void ns1__getUserDetailsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getUserDetailsResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getUserDetailsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__userDetails(soap, &this->ns1__getUserDetailsResponse::return_);
	/* transient soap skipped */
}

int ns1__getUserDetailsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getUserDetailsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetailsResponse(struct soap *soap, const char *tag, int id, const ns1__getUserDetailsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetailsResponse), "ns1:getUserDetailsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__userDetails(soap, "return", -1, &(a->ns1__getUserDetailsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getUserDetailsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getUserDetailsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getUserDetailsResponse * SOAP_FMAC4 soap_in_ns1__getUserDetailsResponse(struct soap *soap, const char *tag, ns1__getUserDetailsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getUserDetailsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetailsResponse, sizeof(ns1__getUserDetailsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getUserDetailsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getUserDetailsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__userDetails(soap, "return", &(a->ns1__getUserDetailsResponse::return_), "ns1:userDetails"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getUserDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetailsResponse, 0, sizeof(ns1__getUserDetailsResponse), 0, soap_copy_ns1__getUserDetailsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getUserDetailsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetailsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getUserDetailsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getUserDetailsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getUserDetailsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getUserDetailsResponse * SOAP_FMAC4 soap_get_ns1__getUserDetailsResponse(struct soap *soap, ns1__getUserDetailsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getUserDetailsResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserDetailsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetailsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetailsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetailsResponse);
		if (size)
			*size = sizeof(ns1__getUserDetailsResponse);
		((ns1__getUserDetailsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetailsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getUserDetailsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getUserDetailsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getUserDetailsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetailsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getUserDetailsResponse %p -> %p\n", q, p));
	*(ns1__getUserDetailsResponse*)p = *(ns1__getUserDetailsResponse*)q;
}

void ns1__getUserDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getUserDetails::sessionId = NULL;
	this->ns1__getUserDetails::usersName = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getUserDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getUserDetails::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getUserDetails::usersName);
	/* transient soap skipped */
}

int ns1__getUserDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getUserDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetails(struct soap *soap, const char *tag, int id, const ns1__getUserDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetails), "ns1:getUserDetails"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getUserDetails::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "usersName", -1, &(a->ns1__getUserDetails::usersName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getUserDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getUserDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getUserDetails * SOAP_FMAC4 soap_in_ns1__getUserDetails(struct soap *soap, const char *tag, ns1__getUserDetails *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getUserDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetails, sizeof(ns1__getUserDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getUserDetails)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getUserDetails *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_usersName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getUserDetails::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_usersName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "usersName", &(a->ns1__getUserDetails::usersName), "xsd:string"))
				{	soap_flag_usersName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getUserDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetails, 0, sizeof(ns1__getUserDetails), 0, soap_copy_ns1__getUserDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getUserDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetails);
	if (this->soap_out(soap, tag?tag:"ns1:getUserDetails", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getUserDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getUserDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getUserDetails * SOAP_FMAC4 soap_get_ns1__getUserDetails(struct soap *soap, ns1__getUserDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getUserDetails * SOAP_FMAC2 soap_instantiate_ns1__getUserDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetails);
		if (size)
			*size = sizeof(ns1__getUserDetails);
		((ns1__getUserDetails*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetails[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getUserDetails);
		for (int i = 0; i < n; i++)
			((ns1__getUserDetails*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getUserDetails*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getUserDetails %p -> %p\n", q, p));
	*(ns1__getUserDetails*)p = *(ns1__getUserDetails*)q;
}

void ns1__getAllKeywordsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getAllKeywordsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getAllKeywordsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getAllKeywordsResponse::return_);
	/* transient soap skipped */
}

int ns1__getAllKeywordsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAllKeywordsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllKeywordsResponse(struct soap *soap, const char *tag, int id, const ns1__getAllKeywordsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllKeywordsResponse), "ns1:getAllKeywordsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getAllKeywordsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getAllKeywordsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAllKeywordsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAllKeywordsResponse * SOAP_FMAC4 soap_in_ns1__getAllKeywordsResponse(struct soap *soap, const char *tag, ns1__getAllKeywordsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAllKeywordsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllKeywordsResponse, sizeof(ns1__getAllKeywordsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAllKeywordsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAllKeywordsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getAllKeywordsResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAllKeywordsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllKeywordsResponse, 0, sizeof(ns1__getAllKeywordsResponse), 0, soap_copy_ns1__getAllKeywordsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAllKeywordsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAllKeywordsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAllKeywordsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAllKeywordsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAllKeywordsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAllKeywordsResponse * SOAP_FMAC4 soap_get_ns1__getAllKeywordsResponse(struct soap *soap, ns1__getAllKeywordsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllKeywordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAllKeywordsResponse * SOAP_FMAC2 soap_instantiate_ns1__getAllKeywordsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllKeywordsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllKeywordsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywordsResponse);
		if (size)
			*size = sizeof(ns1__getAllKeywordsResponse);
		((ns1__getAllKeywordsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywordsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAllKeywordsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getAllKeywordsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAllKeywordsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllKeywordsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAllKeywordsResponse %p -> %p\n", q, p));
	*(ns1__getAllKeywordsResponse*)p = *(ns1__getAllKeywordsResponse*)q;
}

void ns1__getAllKeywords::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getAllKeywords::sessionId = NULL;
	this->ns1__getAllKeywords::type = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getAllKeywords::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAllKeywords::sessionId);
	soap_serialize_PointerTons1__keywordType(soap, &this->ns1__getAllKeywords::type);
	/* transient soap skipped */
}

int ns1__getAllKeywords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAllKeywords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllKeywords(struct soap *soap, const char *tag, int id, const ns1__getAllKeywords *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllKeywords), "ns1:getAllKeywords"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getAllKeywords::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__keywordType(soap, "type", -1, &(a->ns1__getAllKeywords::type), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getAllKeywords::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAllKeywords(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAllKeywords * SOAP_FMAC4 soap_in_ns1__getAllKeywords(struct soap *soap, const char *tag, ns1__getAllKeywords *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAllKeywords *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllKeywords, sizeof(ns1__getAllKeywords), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAllKeywords)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAllKeywords *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getAllKeywords::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keywordType(soap, "type", &(a->ns1__getAllKeywords::type), "ns1:keywordType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAllKeywords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllKeywords, 0, sizeof(ns1__getAllKeywords), 0, soap_copy_ns1__getAllKeywords);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAllKeywords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAllKeywords);
	if (this->soap_out(soap, tag?tag:"ns1:getAllKeywords", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAllKeywords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAllKeywords(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAllKeywords * SOAP_FMAC4 soap_get_ns1__getAllKeywords(struct soap *soap, ns1__getAllKeywords *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllKeywords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAllKeywords * SOAP_FMAC2 soap_instantiate_ns1__getAllKeywords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllKeywords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllKeywords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywords);
		if (size)
			*size = sizeof(ns1__getAllKeywords);
		((ns1__getAllKeywords*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywords[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAllKeywords);
		for (int i = 0; i < n; i++)
			((ns1__getAllKeywords*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAllKeywords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllKeywords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAllKeywords %p -> %p\n", q, p));
	*(ns1__getAllKeywords*)p = *(ns1__getAllKeywords*)q;
}

void ns1__removePublicationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removePublicationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removePublicationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removePublicationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removePublicationResponse(struct soap *soap, const char *tag, int id, const ns1__removePublicationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removePublicationResponse");
}

void *ns1__removePublicationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removePublicationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removePublicationResponse * SOAP_FMAC4 soap_in_ns1__removePublicationResponse(struct soap *soap, const char *tag, ns1__removePublicationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removePublicationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removePublicationResponse, sizeof(ns1__removePublicationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removePublicationResponse)
			return (ns1__removePublicationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removePublicationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removePublicationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removePublicationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removePublicationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removePublicationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removePublicationResponse * SOAP_FMAC4 soap_get_ns1__removePublicationResponse(struct soap *soap, ns1__removePublicationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removePublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removePublicationResponse * SOAP_FMAC2 soap_instantiate_ns1__removePublicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removePublicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removePublicationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removePublicationResponse);
		if (size)
			*size = sizeof(ns1__removePublicationResponse);
		((ns1__removePublicationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removePublicationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removePublicationResponse);
		for (int i = 0; i < n; i++)
			((ns1__removePublicationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removePublicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removePublicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removePublicationResponse %p -> %p\n", q, p));
	*(ns1__removePublicationResponse*)p = *(ns1__removePublicationResponse*)q;
}

void ns1__removePublication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removePublication::sessionId = NULL;
	this->ns1__removePublication::publicationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removePublication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removePublication::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__removePublication::publicationId);
	/* transient soap skipped */
}

int ns1__removePublication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removePublication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removePublication(struct soap *soap, const char *tag, int id, const ns1__removePublication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removePublication), "ns1:removePublication"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removePublication::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "publicationId", -1, &(a->ns1__removePublication::publicationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removePublication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removePublication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removePublication * SOAP_FMAC4 soap_in_ns1__removePublication(struct soap *soap, const char *tag, ns1__removePublication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removePublication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removePublication, sizeof(ns1__removePublication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removePublication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removePublication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_publicationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removePublication::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_publicationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "publicationId", &(a->ns1__removePublication::publicationId), "xsd:long"))
				{	soap_flag_publicationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removePublication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removePublication, 0, sizeof(ns1__removePublication), 0, soap_copy_ns1__removePublication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removePublication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removePublication);
	if (this->soap_out(soap, tag?tag:"ns1:removePublication", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removePublication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removePublication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removePublication * SOAP_FMAC4 soap_get_ns1__removePublication(struct soap *soap, ns1__removePublication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removePublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removePublication * SOAP_FMAC2 soap_instantiate_ns1__removePublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removePublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removePublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removePublication);
		if (size)
			*size = sizeof(ns1__removePublication);
		((ns1__removePublication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removePublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removePublication);
		for (int i = 0; i < n; i++)
			((ns1__removePublication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removePublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removePublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removePublication %p -> %p\n", q, p));
	*(ns1__removePublication*)p = *(ns1__removePublication*)q;
}

void ns1__createDataSetsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__createDataSetsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataSetsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__createDataSetsResponse::return_);
	/* transient soap skipped */
}

int ns1__createDataSetsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataSetsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataSetsResponse(struct soap *soap, const char *tag, int id, const ns1__createDataSetsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataSetsResponse), "ns1:createDataSetsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "return", -1, &(a->ns1__createDataSetsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataSetsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataSetsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataSetsResponse * SOAP_FMAC4 soap_in_ns1__createDataSetsResponse(struct soap *soap, const char *tag, ns1__createDataSetsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataSetsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataSetsResponse, sizeof(ns1__createDataSetsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataSetsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataSetsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "return", &(a->ns1__createDataSetsResponse::return_), "ns1:dataset"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataSetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataSetsResponse, 0, sizeof(ns1__createDataSetsResponse), 0, soap_copy_ns1__createDataSetsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataSetsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataSetsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:createDataSetsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataSetsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataSetsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataSetsResponse * SOAP_FMAC4 soap_get_ns1__createDataSetsResponse(struct soap *soap, ns1__createDataSetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataSetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataSetsResponse * SOAP_FMAC2 soap_instantiate_ns1__createDataSetsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataSetsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataSetsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetsResponse);
		if (size)
			*size = sizeof(ns1__createDataSetsResponse);
		((ns1__createDataSetsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataSetsResponse);
		for (int i = 0; i < n; i++)
			((ns1__createDataSetsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataSetsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataSetsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataSetsResponse %p -> %p\n", q, p));
	*(ns1__createDataSetsResponse*)p = *(ns1__createDataSetsResponse*)q;
}

void ns1__parameterPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__parameterPK::name = NULL;
	this->ns1__parameterPK::units = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__parameterPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__parameterPK::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__parameterPK::units);
	/* transient soap skipped */
}

int ns1__parameterPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__parameterPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__parameterPK(struct soap *soap, const char *tag, int id, const ns1__parameterPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__parameterPK), "ns1:parameterPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__parameterPK::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "units", -1, &(a->ns1__parameterPK::units), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__parameterPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__parameterPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__parameterPK * SOAP_FMAC4 soap_in_ns1__parameterPK(struct soap *soap, const char *tag, ns1__parameterPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__parameterPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__parameterPK, sizeof(ns1__parameterPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__parameterPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__parameterPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_units1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__parameterPK::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_units1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "units", &(a->ns1__parameterPK::units), "xsd:string"))
				{	soap_flag_units1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__parameterPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__parameterPK, 0, sizeof(ns1__parameterPK), 0, soap_copy_ns1__parameterPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__parameterPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__parameterPK);
	if (this->soap_out(soap, tag?tag:"ns1:parameterPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__parameterPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__parameterPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__parameterPK * SOAP_FMAC4 soap_get_ns1__parameterPK(struct soap *soap, ns1__parameterPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__parameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__parameterPK * SOAP_FMAC2 soap_instantiate_ns1__parameterPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__parameterPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__parameterPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__parameterPK);
		if (size)
			*size = sizeof(ns1__parameterPK);
		((ns1__parameterPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__parameterPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__parameterPK);
		for (int i = 0; i < n; i++)
			((ns1__parameterPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__parameterPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__parameterPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__parameterPK %p -> %p\n", q, p));
	*(ns1__parameterPK*)p = *(ns1__parameterPK*)q;
}

void ns1__parameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__parameter::datafileParameter);
	this->ns1__parameter::description = NULL;
	this->ns1__parameter::nonNumericValueFormat = NULL;
	soap_default_bool(soap, &this->ns1__parameter::numeric);
	this->ns1__parameter::numericValue = NULL;
	this->ns1__parameter::parameterPK = NULL;
	soap_default_bool(soap, &this->ns1__parameter::sampleParameter);
	this->ns1__parameter::searchable = NULL;
	this->ns1__parameter::unitsLongVersion = NULL;
	soap_default_bool(soap, &this->ns1__parameter::verified);
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__parameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__parameter::description);
	soap_serialize_PointerTostd__string(soap, &this->ns1__parameter::nonNumericValueFormat);
	soap_serialize_PointerTostd__string(soap, &this->ns1__parameter::numericValue);
	soap_serialize_PointerTons1__parameterPK(soap, &this->ns1__parameter::parameterPK);
	soap_serialize_PointerTostd__string(soap, &this->ns1__parameter::searchable);
	soap_serialize_PointerTostd__string(soap, &this->ns1__parameter::unitsLongVersion);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__parameter(struct soap *soap, const char *tag, int id, const ns1__parameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__parameter), "ns1:parameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_bool(soap, "datafileParameter", -1, &(a->ns1__parameter::datafileParameter), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__parameter::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nonNumericValueFormat", -1, &(a->ns1__parameter::nonNumericValueFormat), ""))
		return soap->error;
	if (soap_out_bool(soap, "numeric", -1, &(a->ns1__parameter::numeric), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "numericValue", -1, &(a->ns1__parameter::numericValue), ""))
		return soap->error;
	if (soap_out_PointerTons1__parameterPK(soap, "parameterPK", -1, &(a->ns1__parameter::parameterPK), ""))
		return soap->error;
	if (soap_out_bool(soap, "sampleParameter", -1, &(a->ns1__parameter::sampleParameter), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "searchable", -1, &(a->ns1__parameter::searchable), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "unitsLongVersion", -1, &(a->ns1__parameter::unitsLongVersion), ""))
		return soap->error;
	if (soap_out_bool(soap, "verified", -1, &(a->ns1__parameter::verified), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__parameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__parameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__parameter * SOAP_FMAC4 soap_in_ns1__parameter(struct soap *soap, const char *tag, ns1__parameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__parameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__parameter, sizeof(ns1__parameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__parameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__parameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_datafileParameter1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_nonNumericValueFormat1 = 1;
	size_t soap_flag_numeric1 = 1;
	size_t soap_flag_numericValue1 = 1;
	size_t soap_flag_parameterPK1 = 1;
	size_t soap_flag_sampleParameter1 = 1;
	size_t soap_flag_searchable1 = 1;
	size_t soap_flag_unitsLongVersion1 = 1;
	size_t soap_flag_verified1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_datafileParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "datafileParameter", &(a->ns1__parameter::datafileParameter), "xsd:boolean"))
				{	soap_flag_datafileParameter1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__parameter::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_nonNumericValueFormat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nonNumericValueFormat", &(a->ns1__parameter::nonNumericValueFormat), "xsd:string"))
				{	soap_flag_nonNumericValueFormat1--;
					continue;
				}
			if (soap_flag_numeric1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "numeric", &(a->ns1__parameter::numeric), "xsd:boolean"))
				{	soap_flag_numeric1--;
					continue;
				}
			if (soap_flag_numericValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "numericValue", &(a->ns1__parameter::numericValue), "xsd:string"))
				{	soap_flag_numericValue1--;
					continue;
				}
			if (soap_flag_parameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__parameterPK(soap, "parameterPK", &(a->ns1__parameter::parameterPK), "ns1:parameterPK"))
				{	soap_flag_parameterPK1--;
					continue;
				}
			if (soap_flag_sampleParameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "sampleParameter", &(a->ns1__parameter::sampleParameter), "xsd:boolean"))
				{	soap_flag_sampleParameter1--;
					continue;
				}
			if (soap_flag_searchable1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "searchable", &(a->ns1__parameter::searchable), "xsd:string"))
				{	soap_flag_searchable1--;
					continue;
				}
			if (soap_flag_unitsLongVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "unitsLongVersion", &(a->ns1__parameter::unitsLongVersion), "xsd:string"))
				{	soap_flag_unitsLongVersion1--;
					continue;
				}
			if (soap_flag_verified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "verified", &(a->ns1__parameter::verified), "xsd:boolean"))
				{	soap_flag_verified1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__parameter, 0, sizeof(ns1__parameter), 0, soap_copy_ns1__parameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0 || soap_flag_datafileParameter1 > 0 || soap_flag_numeric1 > 0 || soap_flag_sampleParameter1 > 0 || soap_flag_verified1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__parameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__parameter);
	if (this->soap_out(soap, tag?tag:"ns1:parameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__parameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__parameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__parameter * SOAP_FMAC4 soap_get_ns1__parameter(struct soap *soap, ns1__parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__parameter * SOAP_FMAC2 soap_instantiate_ns1__parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__parameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__parameter);
		if (size)
			*size = sizeof(ns1__parameter);
		((ns1__parameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__parameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__parameter);
		for (int i = 0; i < n; i++)
			((ns1__parameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__parameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__parameter %p -> %p\n", q, p));
	*(ns1__parameter*)p = *(ns1__parameter*)q;
}

void ns1__datasetParameterPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__datasetParameterPK::datasetId = NULL;
	this->ns1__datasetParameterPK::name = NULL;
	this->ns1__datasetParameterPK::units = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datasetParameterPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__datasetParameterPK::datasetId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datasetParameterPK::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datasetParameterPK::units);
	/* transient soap skipped */
}

int ns1__datasetParameterPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datasetParameterPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datasetParameterPK(struct soap *soap, const char *tag, int id, const ns1__datasetParameterPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datasetParameterPK), "ns1:datasetParameterPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__datasetParameterPK::datasetId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__datasetParameterPK::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "units", -1, &(a->ns1__datasetParameterPK::units), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__datasetParameterPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datasetParameterPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datasetParameterPK * SOAP_FMAC4 soap_in_ns1__datasetParameterPK(struct soap *soap, const char *tag, ns1__datasetParameterPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__datasetParameterPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datasetParameterPK, sizeof(ns1__datasetParameterPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datasetParameterPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__datasetParameterPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_datasetId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_units1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__datasetParameterPK::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__datasetParameterPK::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_units1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "units", &(a->ns1__datasetParameterPK::units), "xsd:string"))
				{	soap_flag_units1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__datasetParameterPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datasetParameterPK, 0, sizeof(ns1__datasetParameterPK), 0, soap_copy_ns1__datasetParameterPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__datasetParameterPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datasetParameterPK);
	if (this->soap_out(soap, tag?tag:"ns1:datasetParameterPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datasetParameterPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datasetParameterPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datasetParameterPK * SOAP_FMAC4 soap_get_ns1__datasetParameterPK(struct soap *soap, ns1__datasetParameterPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datasetParameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datasetParameterPK * SOAP_FMAC2 soap_instantiate_ns1__datasetParameterPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datasetParameterPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datasetParameterPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameterPK);
		if (size)
			*size = sizeof(ns1__datasetParameterPK);
		((ns1__datasetParameterPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameterPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datasetParameterPK);
		for (int i = 0; i < n; i++)
			((ns1__datasetParameterPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datasetParameterPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datasetParameterPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datasetParameterPK %p -> %p\n", q, p));
	*(ns1__datasetParameterPK*)p = *(ns1__datasetParameterPK*)q;
}

void ns1__datasetParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__datasetParameter::datasetParameterPK = NULL;
	this->ns1__datasetParameter::description = NULL;
	this->ns1__datasetParameter::error = NULL;
	soap_default_bool(soap, &this->ns1__datasetParameter::numeric);
	this->ns1__datasetParameter::numericValue = NULL;
	this->ns1__datasetParameter::parameter = NULL;
	this->ns1__datasetParameter::rangeBottom = NULL;
	this->ns1__datasetParameter::rangeTop = NULL;
	this->ns1__datasetParameter::stringValue = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datasetParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__datasetParameterPK(soap, &this->ns1__datasetParameter::datasetParameterPK);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datasetParameter::description);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datasetParameter::error);
	soap_serialize_PointerTodouble(soap, &this->ns1__datasetParameter::numericValue);
	soap_serialize_PointerTons1__parameter(soap, &this->ns1__datasetParameter::parameter);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datasetParameter::rangeBottom);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datasetParameter::rangeTop);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datasetParameter::stringValue);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__datasetParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datasetParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datasetParameter(struct soap *soap, const char *tag, int id, const ns1__datasetParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datasetParameter), "ns1:datasetParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datasetParameterPK(soap, "datasetParameterPK", -1, &(a->ns1__datasetParameter::datasetParameterPK), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__datasetParameter::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "error", -1, &(a->ns1__datasetParameter::error), ""))
		return soap->error;
	if (soap_out_bool(soap, "numeric", -1, &(a->ns1__datasetParameter::numeric), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__datasetParameter::numericValue), ""))
		return soap->error;
	if (soap_out_PointerTons1__parameter(soap, "parameter", -1, &(a->ns1__datasetParameter::parameter), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "rangeBottom", -1, &(a->ns1__datasetParameter::rangeBottom), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "rangeTop", -1, &(a->ns1__datasetParameter::rangeTop), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__datasetParameter::stringValue), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__datasetParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datasetParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datasetParameter * SOAP_FMAC4 soap_in_ns1__datasetParameter(struct soap *soap, const char *tag, ns1__datasetParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__datasetParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datasetParameter, sizeof(ns1__datasetParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datasetParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__datasetParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_datasetParameterPK1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_error1 = 1;
	size_t soap_flag_numeric1 = 1;
	size_t soap_flag_numericValue1 = 1;
	size_t soap_flag_parameter1 = 1;
	size_t soap_flag_rangeBottom1 = 1;
	size_t soap_flag_rangeTop1 = 1;
	size_t soap_flag_stringValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_datasetParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datasetParameterPK(soap, "datasetParameterPK", &(a->ns1__datasetParameter::datasetParameterPK), "ns1:datasetParameterPK"))
				{	soap_flag_datasetParameterPK1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__datasetParameter::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "error", &(a->ns1__datasetParameter::error), "xsd:string"))
				{	soap_flag_error1--;
					continue;
				}
			if (soap_flag_numeric1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "numeric", &(a->ns1__datasetParameter::numeric), "xsd:boolean"))
				{	soap_flag_numeric1--;
					continue;
				}
			if (soap_flag_numericValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__datasetParameter::numericValue), "xsd:double"))
				{	soap_flag_numericValue1--;
					continue;
				}
			if (soap_flag_parameter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__parameter(soap, "parameter", &(a->ns1__datasetParameter::parameter), "ns1:parameter"))
				{	soap_flag_parameter1--;
					continue;
				}
			if (soap_flag_rangeBottom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "rangeBottom", &(a->ns1__datasetParameter::rangeBottom), "xsd:string"))
				{	soap_flag_rangeBottom1--;
					continue;
				}
			if (soap_flag_rangeTop1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "rangeTop", &(a->ns1__datasetParameter::rangeTop), "xsd:string"))
				{	soap_flag_rangeTop1--;
					continue;
				}
			if (soap_flag_stringValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__datasetParameter::stringValue), "xsd:string"))
				{	soap_flag_stringValue1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__datasetParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datasetParameter, 0, sizeof(ns1__datasetParameter), 0, soap_copy_ns1__datasetParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0 || soap_flag_numeric1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__datasetParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datasetParameter);
	if (this->soap_out(soap, tag?tag:"ns1:datasetParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datasetParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datasetParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datasetParameter * SOAP_FMAC4 soap_get_ns1__datasetParameter(struct soap *soap, ns1__datasetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datasetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datasetParameter * SOAP_FMAC2 soap_instantiate_ns1__datasetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datasetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datasetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameter);
		if (size)
			*size = sizeof(ns1__datasetParameter);
		((ns1__datasetParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datasetParameter);
		for (int i = 0; i < n; i++)
			((ns1__datasetParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datasetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datasetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datasetParameter %p -> %p\n", q, p));
	*(ns1__datasetParameter*)p = *(ns1__datasetParameter*)q;
}

void ns1__dataset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__dataset::datafileCollection);
	soap_default_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__dataset::datasetParameterCollection);
	this->ns1__dataset::datasetStatus = NULL;
	this->ns1__dataset::datasetType = NULL;
	this->ns1__dataset::description = NULL;
	this->ns1__dataset::id = NULL;
	this->ns1__dataset::investigationId = NULL;
	this->ns1__dataset::location = NULL;
	this->ns1__dataset::name = NULL;
	this->ns1__dataset::sampleId = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__dataset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__dataset::datafileCollection);
	soap_serialize_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__dataset::datasetParameterCollection);
	soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::datasetStatus);
	soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::datasetType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::description);
	soap_serialize_PointerToLONG64(soap, &this->ns1__dataset::id);
	soap_serialize_PointerToLONG64(soap, &this->ns1__dataset::investigationId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::location);
	soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::name);
	soap_serialize_PointerToLONG64(soap, &this->ns1__dataset::sampleId);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__dataset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__dataset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dataset(struct soap *soap, const char *tag, int id, const ns1__dataset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__dataset), "ns1:dataset"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "datafileCollection", -1, &(a->ns1__dataset::datafileCollection), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "datasetParameterCollection", -1, &(a->ns1__dataset::datasetParameterCollection), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "datasetStatus", -1, &(a->ns1__dataset::datasetStatus), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "datasetType", -1, &(a->ns1__dataset::datasetType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__dataset::description), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__dataset::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__dataset::investigationId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "location", -1, &(a->ns1__dataset::location), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__dataset::name), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "sampleId", -1, &(a->ns1__dataset::sampleId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__dataset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__dataset(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dataset * SOAP_FMAC4 soap_in_ns1__dataset(struct soap *soap, const char *tag, ns1__dataset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__dataset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__dataset, sizeof(ns1__dataset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__dataset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__dataset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_datasetStatus1 = 1;
	size_t soap_flag_datasetType1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_investigationId1 = 1;
	size_t soap_flag_location1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_sampleId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "datafileCollection", &(a->ns1__dataset::datafileCollection), "ns1:datafile"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "datasetParameterCollection", &(a->ns1__dataset::datasetParameterCollection), "ns1:datasetParameter"))
					continue;
			if (soap_flag_datasetStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "datasetStatus", &(a->ns1__dataset::datasetStatus), "xsd:string"))
				{	soap_flag_datasetStatus1--;
					continue;
				}
			if (soap_flag_datasetType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "datasetType", &(a->ns1__dataset::datasetType), "xsd:string"))
				{	soap_flag_datasetType1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__dataset::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__dataset::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__dataset::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "location", &(a->ns1__dataset::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__dataset::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_sampleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "sampleId", &(a->ns1__dataset::sampleId), "xsd:long"))
				{	soap_flag_sampleId1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__dataset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__dataset, 0, sizeof(ns1__dataset), 0, soap_copy_ns1__dataset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__dataset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__dataset);
	if (this->soap_out(soap, tag?tag:"ns1:dataset", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__dataset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__dataset(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dataset * SOAP_FMAC4 soap_get_ns1__dataset(struct soap *soap, ns1__dataset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__dataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__dataset * SOAP_FMAC2 soap_instantiate_ns1__dataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__dataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__dataset);
		if (size)
			*size = sizeof(ns1__dataset);
		((ns1__dataset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__dataset[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__dataset);
		for (int i = 0; i < n; i++)
			((ns1__dataset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__dataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dataset %p -> %p\n", q, p));
	*(ns1__dataset*)p = *(ns1__dataset*)q;
}

void ns1__createDataSets::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDataSets::sessionId = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__createDataSets::dataSets);
	this->ns1__createDataSets::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataSets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__createDataSets::sessionId);
	soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__createDataSets::dataSets);
	soap_serialize_PointerToLONG64(soap, &this->ns1__createDataSets::investigationId);
	/* transient soap skipped */
}

int ns1__createDataSets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataSets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataSets(struct soap *soap, const char *tag, int id, const ns1__createDataSets *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataSets), "ns1:createDataSets"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__createDataSets::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "dataSets", -1, &(a->ns1__createDataSets::dataSets), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__createDataSets::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataSets::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataSets(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataSets * SOAP_FMAC4 soap_in_ns1__createDataSets(struct soap *soap, const char *tag, ns1__createDataSets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataSets *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataSets, sizeof(ns1__createDataSets), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataSets)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataSets *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__createDataSets::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "dataSets", &(a->ns1__createDataSets::dataSets), "ns1:dataset"))
					continue;
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__createDataSets::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataSets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataSets, 0, sizeof(ns1__createDataSets), 0, soap_copy_ns1__createDataSets);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataSets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataSets);
	if (this->soap_out(soap, tag?tag:"ns1:createDataSets", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataSets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataSets(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataSets * SOAP_FMAC4 soap_get_ns1__createDataSets(struct soap *soap, ns1__createDataSets *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataSets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataSets * SOAP_FMAC2 soap_instantiate_ns1__createDataSets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataSets(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataSets, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSets);
		if (size)
			*size = sizeof(ns1__createDataSets);
		((ns1__createDataSets*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSets[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataSets);
		for (int i = 0; i < n; i++)
			((ns1__createDataSets*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataSets*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataSets(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataSets %p -> %p\n", q, p));
	*(ns1__createDataSets*)p = *(ns1__createDataSets*)q;
}

void ns1__deleteInvestigationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteInvestigationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteInvestigationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteInvestigationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteInvestigationResponse(struct soap *soap, const char *tag, int id, const ns1__deleteInvestigationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteInvestigationResponse");
}

void *ns1__deleteInvestigationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteInvestigationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteInvestigationResponse * SOAP_FMAC4 soap_in_ns1__deleteInvestigationResponse(struct soap *soap, const char *tag, ns1__deleteInvestigationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__deleteInvestigationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteInvestigationResponse, sizeof(ns1__deleteInvestigationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteInvestigationResponse)
			return (ns1__deleteInvestigationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__deleteInvestigationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteInvestigationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteInvestigationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteInvestigationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteInvestigationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteInvestigationResponse * SOAP_FMAC4 soap_get_ns1__deleteInvestigationResponse(struct soap *soap, ns1__deleteInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteInvestigationResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigationResponse);
		if (size)
			*size = sizeof(ns1__deleteInvestigationResponse);
		((ns1__deleteInvestigationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteInvestigationResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteInvestigationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteInvestigationResponse %p -> %p\n", q, p));
	*(ns1__deleteInvestigationResponse*)p = *(ns1__deleteInvestigationResponse*)q;
}

void ns1__deleteInvestigation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteInvestigation::sessionId = NULL;
	this->ns1__deleteInvestigation::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__deleteInvestigation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteInvestigation::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__deleteInvestigation::investigationId);
	/* transient soap skipped */
}

int ns1__deleteInvestigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteInvestigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteInvestigation(struct soap *soap, const char *tag, int id, const ns1__deleteInvestigation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteInvestigation), "ns1:deleteInvestigation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteInvestigation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__deleteInvestigation::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteInvestigation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteInvestigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteInvestigation * SOAP_FMAC4 soap_in_ns1__deleteInvestigation(struct soap *soap, const char *tag, ns1__deleteInvestigation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteInvestigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteInvestigation, sizeof(ns1__deleteInvestigation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteInvestigation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteInvestigation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteInvestigation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__deleteInvestigation::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteInvestigation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteInvestigation, 0, sizeof(ns1__deleteInvestigation), 0, soap_copy_ns1__deleteInvestigation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__deleteInvestigation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteInvestigation);
	if (this->soap_out(soap, tag?tag:"ns1:deleteInvestigation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteInvestigation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteInvestigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteInvestigation * SOAP_FMAC4 soap_get_ns1__deleteInvestigation(struct soap *soap, ns1__deleteInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteInvestigation * SOAP_FMAC2 soap_instantiate_ns1__deleteInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigation);
		if (size)
			*size = sizeof(ns1__deleteInvestigation);
		((ns1__deleteInvestigation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteInvestigation);
		for (int i = 0; i < n; i++)
			((ns1__deleteInvestigation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteInvestigation %p -> %p\n", q, p));
	*(ns1__deleteInvestigation*)p = *(ns1__deleteInvestigation*)q;
}

void ns1__removeKeywordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeKeywordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeKeywordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeKeywordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeKeywordResponse(struct soap *soap, const char *tag, int id, const ns1__removeKeywordResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeKeywordResponse");
}

void *ns1__removeKeywordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeKeywordResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeKeywordResponse * SOAP_FMAC4 soap_in_ns1__removeKeywordResponse(struct soap *soap, const char *tag, ns1__removeKeywordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeKeywordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeKeywordResponse, sizeof(ns1__removeKeywordResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeKeywordResponse)
			return (ns1__removeKeywordResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeKeywordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeKeywordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeKeywordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeKeywordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeKeywordResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeKeywordResponse * SOAP_FMAC4 soap_get_ns1__removeKeywordResponse(struct soap *soap, ns1__removeKeywordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeKeywordResponse * SOAP_FMAC2 soap_instantiate_ns1__removeKeywordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeKeywordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeKeywordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeywordResponse);
		if (size)
			*size = sizeof(ns1__removeKeywordResponse);
		((ns1__removeKeywordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeywordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeKeywordResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeKeywordResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeKeywordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeKeywordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeKeywordResponse %p -> %p\n", q, p));
	*(ns1__removeKeywordResponse*)p = *(ns1__removeKeywordResponse*)q;
}

void ns1__keywordPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__keywordPK::investigationId = NULL;
	this->ns1__keywordPK::name = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__keywordPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__keywordPK::investigationId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__keywordPK::name);
	/* transient soap skipped */
}

int ns1__keywordPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__keywordPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__keywordPK(struct soap *soap, const char *tag, int id, const ns1__keywordPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__keywordPK), "ns1:keywordPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__keywordPK::investigationId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__keywordPK::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__keywordPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__keywordPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__keywordPK * SOAP_FMAC4 soap_in_ns1__keywordPK(struct soap *soap, const char *tag, ns1__keywordPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__keywordPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__keywordPK, sizeof(ns1__keywordPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__keywordPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__keywordPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_investigationId1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__keywordPK::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__keywordPK::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__keywordPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__keywordPK, 0, sizeof(ns1__keywordPK), 0, soap_copy_ns1__keywordPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__keywordPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__keywordPK);
	if (this->soap_out(soap, tag?tag:"ns1:keywordPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__keywordPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__keywordPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__keywordPK * SOAP_FMAC4 soap_get_ns1__keywordPK(struct soap *soap, ns1__keywordPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__keywordPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__keywordPK * SOAP_FMAC2 soap_instantiate_ns1__keywordPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__keywordPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__keywordPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__keywordPK);
		if (size)
			*size = sizeof(ns1__keywordPK);
		((ns1__keywordPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__keywordPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__keywordPK);
		for (int i = 0; i < n; i++)
			((ns1__keywordPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__keywordPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__keywordPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__keywordPK %p -> %p\n", q, p));
	*(ns1__keywordPK*)p = *(ns1__keywordPK*)q;
}

void ns1__removeKeyword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeKeyword::sessionId = NULL;
	this->ns1__removeKeyword::keywordPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeKeyword::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeKeyword::sessionId);
	soap_serialize_PointerTons1__keywordPK(soap, &this->ns1__removeKeyword::keywordPK);
	/* transient soap skipped */
}

int ns1__removeKeyword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeKeyword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeKeyword(struct soap *soap, const char *tag, int id, const ns1__removeKeyword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeKeyword), "ns1:removeKeyword"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeKeyword::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__keywordPK(soap, "keywordPK", -1, &(a->ns1__removeKeyword::keywordPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeKeyword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeKeyword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeKeyword * SOAP_FMAC4 soap_in_ns1__removeKeyword(struct soap *soap, const char *tag, ns1__removeKeyword *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeKeyword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeKeyword, sizeof(ns1__removeKeyword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeKeyword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeKeyword *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_keywordPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeKeyword::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_keywordPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__keywordPK(soap, "keywordPK", &(a->ns1__removeKeyword::keywordPK), "ns1:keywordPK"))
				{	soap_flag_keywordPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeKeyword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeKeyword, 0, sizeof(ns1__removeKeyword), 0, soap_copy_ns1__removeKeyword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeKeyword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeKeyword);
	if (this->soap_out(soap, tag?tag:"ns1:removeKeyword", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeKeyword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeKeyword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeKeyword * SOAP_FMAC4 soap_get_ns1__removeKeyword(struct soap *soap, ns1__removeKeyword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeKeyword * SOAP_FMAC2 soap_instantiate_ns1__removeKeyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeKeyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeKeyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeyword);
		if (size)
			*size = sizeof(ns1__removeKeyword);
		((ns1__removeKeyword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeyword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeKeyword);
		for (int i = 0; i < n; i++)
			((ns1__removeKeyword*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeKeyword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeKeyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeKeyword %p -> %p\n", q, p));
	*(ns1__removeKeyword*)p = *(ns1__removeKeyword*)q;
}

void ns1__removeInvestigationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeInvestigationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeInvestigationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeInvestigationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeInvestigationResponse(struct soap *soap, const char *tag, int id, const ns1__removeInvestigationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeInvestigationResponse");
}

void *ns1__removeInvestigationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeInvestigationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeInvestigationResponse * SOAP_FMAC4 soap_in_ns1__removeInvestigationResponse(struct soap *soap, const char *tag, ns1__removeInvestigationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeInvestigationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeInvestigationResponse, sizeof(ns1__removeInvestigationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeInvestigationResponse)
			return (ns1__removeInvestigationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeInvestigationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeInvestigationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeInvestigationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeInvestigationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeInvestigationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeInvestigationResponse * SOAP_FMAC4 soap_get_ns1__removeInvestigationResponse(struct soap *soap, ns1__removeInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeInvestigationResponse * SOAP_FMAC2 soap_instantiate_ns1__removeInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigationResponse);
		if (size)
			*size = sizeof(ns1__removeInvestigationResponse);
		((ns1__removeInvestigationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeInvestigationResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeInvestigationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeInvestigationResponse %p -> %p\n", q, p));
	*(ns1__removeInvestigationResponse*)p = *(ns1__removeInvestigationResponse*)q;
}

void ns1__removeInvestigation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeInvestigation::sessionId = NULL;
	this->ns1__removeInvestigation::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeInvestigation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeInvestigation::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__removeInvestigation::investigationId);
	/* transient soap skipped */
}

int ns1__removeInvestigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeInvestigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeInvestigation(struct soap *soap, const char *tag, int id, const ns1__removeInvestigation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeInvestigation), "ns1:removeInvestigation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeInvestigation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__removeInvestigation::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeInvestigation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeInvestigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeInvestigation * SOAP_FMAC4 soap_in_ns1__removeInvestigation(struct soap *soap, const char *tag, ns1__removeInvestigation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeInvestigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeInvestigation, sizeof(ns1__removeInvestigation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeInvestigation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeInvestigation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeInvestigation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__removeInvestigation::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeInvestigation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeInvestigation, 0, sizeof(ns1__removeInvestigation), 0, soap_copy_ns1__removeInvestigation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeInvestigation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeInvestigation);
	if (this->soap_out(soap, tag?tag:"ns1:removeInvestigation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeInvestigation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeInvestigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeInvestigation * SOAP_FMAC4 soap_get_ns1__removeInvestigation(struct soap *soap, ns1__removeInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeInvestigation * SOAP_FMAC2 soap_instantiate_ns1__removeInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigation);
		if (size)
			*size = sizeof(ns1__removeInvestigation);
		((ns1__removeInvestigation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeInvestigation);
		for (int i = 0; i < n; i++)
			((ns1__removeInvestigation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeInvestigation %p -> %p\n", q, p));
	*(ns1__removeInvestigation*)p = *(ns1__removeInvestigation*)q;
}

void ns1__removeInvestigatorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeInvestigatorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeInvestigatorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeInvestigatorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeInvestigatorResponse(struct soap *soap, const char *tag, int id, const ns1__removeInvestigatorResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeInvestigatorResponse");
}

void *ns1__removeInvestigatorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeInvestigatorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeInvestigatorResponse * SOAP_FMAC4 soap_in_ns1__removeInvestigatorResponse(struct soap *soap, const char *tag, ns1__removeInvestigatorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeInvestigatorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeInvestigatorResponse, sizeof(ns1__removeInvestigatorResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeInvestigatorResponse)
			return (ns1__removeInvestigatorResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeInvestigatorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeInvestigatorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeInvestigatorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeInvestigatorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeInvestigatorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeInvestigatorResponse * SOAP_FMAC4 soap_get_ns1__removeInvestigatorResponse(struct soap *soap, ns1__removeInvestigatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeInvestigatorResponse * SOAP_FMAC2 soap_instantiate_ns1__removeInvestigatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeInvestigatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeInvestigatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigatorResponse);
		if (size)
			*size = sizeof(ns1__removeInvestigatorResponse);
		((ns1__removeInvestigatorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigatorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeInvestigatorResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeInvestigatorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeInvestigatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeInvestigatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeInvestigatorResponse %p -> %p\n", q, p));
	*(ns1__removeInvestigatorResponse*)p = *(ns1__removeInvestigatorResponse*)q;
}

void ns1__investigatorPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__investigatorPK::facilityUserId = NULL;
	this->ns1__investigatorPK::investigationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__investigatorPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__investigatorPK::facilityUserId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__investigatorPK::investigationId);
	/* transient soap skipped */
}

int ns1__investigatorPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__investigatorPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigatorPK(struct soap *soap, const char *tag, int id, const ns1__investigatorPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__investigatorPK), "ns1:investigatorPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "facilityUserId", -1, &(a->ns1__investigatorPK::facilityUserId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "investigationId", -1, &(a->ns1__investigatorPK::investigationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__investigatorPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__investigatorPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigatorPK * SOAP_FMAC4 soap_in_ns1__investigatorPK(struct soap *soap, const char *tag, ns1__investigatorPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__investigatorPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__investigatorPK, sizeof(ns1__investigatorPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__investigatorPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__investigatorPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityUserId1 = 1;
	size_t soap_flag_investigationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityUserId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "facilityUserId", &(a->ns1__investigatorPK::facilityUserId), "xsd:string"))
				{	soap_flag_facilityUserId1--;
					continue;
				}
			if (soap_flag_investigationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "investigationId", &(a->ns1__investigatorPK::investigationId), "xsd:long"))
				{	soap_flag_investigationId1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__investigatorPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__investigatorPK, 0, sizeof(ns1__investigatorPK), 0, soap_copy_ns1__investigatorPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__investigatorPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__investigatorPK);
	if (this->soap_out(soap, tag?tag:"ns1:investigatorPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__investigatorPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__investigatorPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigatorPK * SOAP_FMAC4 soap_get_ns1__investigatorPK(struct soap *soap, ns1__investigatorPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__investigatorPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__investigatorPK * SOAP_FMAC2 soap_instantiate_ns1__investigatorPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigatorPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__investigatorPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigatorPK);
		if (size)
			*size = sizeof(ns1__investigatorPK);
		((ns1__investigatorPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__investigatorPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__investigatorPK);
		for (int i = 0; i < n; i++)
			((ns1__investigatorPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__investigatorPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigatorPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigatorPK %p -> %p\n", q, p));
	*(ns1__investigatorPK*)p = *(ns1__investigatorPK*)q;
}

void ns1__removeInvestigator::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeInvestigator::sessionId = NULL;
	this->ns1__removeInvestigator::investigatorPK = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeInvestigator::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeInvestigator::sessionId);
	soap_serialize_PointerTons1__investigatorPK(soap, &this->ns1__removeInvestigator::investigatorPK);
	/* transient soap skipped */
}

int ns1__removeInvestigator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeInvestigator(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeInvestigator(struct soap *soap, const char *tag, int id, const ns1__removeInvestigator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeInvestigator), "ns1:removeInvestigator"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeInvestigator::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__investigatorPK(soap, "investigatorPK", -1, &(a->ns1__removeInvestigator::investigatorPK), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeInvestigator::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeInvestigator(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeInvestigator * SOAP_FMAC4 soap_in_ns1__removeInvestigator(struct soap *soap, const char *tag, ns1__removeInvestigator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeInvestigator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeInvestigator, sizeof(ns1__removeInvestigator), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeInvestigator)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeInvestigator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_investigatorPK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeInvestigator::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_investigatorPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__investigatorPK(soap, "investigatorPK", &(a->ns1__removeInvestigator::investigatorPK), "ns1:investigatorPK"))
				{	soap_flag_investigatorPK1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeInvestigator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeInvestigator, 0, sizeof(ns1__removeInvestigator), 0, soap_copy_ns1__removeInvestigator);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeInvestigator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeInvestigator);
	if (this->soap_out(soap, tag?tag:"ns1:removeInvestigator", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeInvestigator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeInvestigator(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeInvestigator * SOAP_FMAC4 soap_get_ns1__removeInvestigator(struct soap *soap, ns1__removeInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeInvestigator * SOAP_FMAC2 soap_instantiate_ns1__removeInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigator);
		if (size)
			*size = sizeof(ns1__removeInvestigator);
		((ns1__removeInvestigator*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeInvestigator);
		for (int i = 0; i < n; i++)
			((ns1__removeInvestigator*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeInvestigator %p -> %p\n", q, p));
	*(ns1__removeInvestigator*)p = *(ns1__removeInvestigator*)q;
}

void ns1__facilityUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__facilityUser::facilityUserId = NULL;
	this->ns1__facilityUser::federalId = NULL;
	this->ns1__facilityUser::firstName = NULL;
	this->ns1__facilityUser::initials = NULL;
	this->ns1__facilityUser::lastName = NULL;
	this->ns1__facilityUser::middleName = NULL;
	this->ns1__facilityUser::title = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__facilityUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityUser::facilityUserId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityUser::federalId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityUser::firstName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityUser::initials);
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityUser::lastName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityUser::middleName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityUser::title);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__facilityUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__facilityUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__facilityUser(struct soap *soap, const char *tag, int id, const ns1__facilityUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__facilityUser), "ns1:facilityUser"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "facilityUserId", -1, &(a->ns1__facilityUser::facilityUserId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "federalId", -1, &(a->ns1__facilityUser::federalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "firstName", -1, &(a->ns1__facilityUser::firstName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "initials", -1, &(a->ns1__facilityUser::initials), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "lastName", -1, &(a->ns1__facilityUser::lastName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "middleName", -1, &(a->ns1__facilityUser::middleName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "title", -1, &(a->ns1__facilityUser::title), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__facilityUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__facilityUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__facilityUser * SOAP_FMAC4 soap_in_ns1__facilityUser(struct soap *soap, const char *tag, ns1__facilityUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__facilityUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__facilityUser, sizeof(ns1__facilityUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__facilityUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__facilityUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_facilityUserId1 = 1;
	size_t soap_flag_federalId1 = 1;
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_initials1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_middleName1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_facilityUserId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "facilityUserId", &(a->ns1__facilityUser::facilityUserId), "xsd:string"))
				{	soap_flag_facilityUserId1--;
					continue;
				}
			if (soap_flag_federalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "federalId", &(a->ns1__facilityUser::federalId), "xsd:string"))
				{	soap_flag_federalId1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "firstName", &(a->ns1__facilityUser::firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_initials1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "initials", &(a->ns1__facilityUser::initials), "xsd:string"))
				{	soap_flag_initials1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "lastName", &(a->ns1__facilityUser::lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_middleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "middleName", &(a->ns1__facilityUser::middleName), "xsd:string"))
				{	soap_flag_middleName1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "title", &(a->ns1__facilityUser::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__facilityUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__facilityUser, 0, sizeof(ns1__facilityUser), 0, soap_copy_ns1__facilityUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__facilityUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__facilityUser);
	if (this->soap_out(soap, tag?tag:"ns1:facilityUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__facilityUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__facilityUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__facilityUser * SOAP_FMAC4 soap_get_ns1__facilityUser(struct soap *soap, ns1__facilityUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__facilityUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__facilityUser * SOAP_FMAC2 soap_instantiate_ns1__facilityUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__facilityUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__facilityUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__facilityUser);
		if (size)
			*size = sizeof(ns1__facilityUser);
		((ns1__facilityUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__facilityUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__facilityUser);
		for (int i = 0; i < n; i++)
			((ns1__facilityUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__facilityUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__facilityUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__facilityUser %p -> %p\n", q, p));
	*(ns1__facilityUser*)p = *(ns1__facilityUser*)q;
}

void ns1__getFacilityUserByFederalIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getFacilityUserByFederalIdResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getFacilityUserByFederalIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__facilityUser(soap, &this->ns1__getFacilityUserByFederalIdResponse::return_);
	/* transient soap skipped */
}

int ns1__getFacilityUserByFederalIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getFacilityUserByFederalIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFacilityUserByFederalIdResponse(struct soap *soap, const char *tag, int id, const ns1__getFacilityUserByFederalIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse), "ns1:getFacilityUserByFederalIdResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__facilityUser(soap, "return", -1, &(a->ns1__getFacilityUserByFederalIdResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getFacilityUserByFederalIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getFacilityUserByFederalIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalIdResponse * SOAP_FMAC4 soap_in_ns1__getFacilityUserByFederalIdResponse(struct soap *soap, const char *tag, ns1__getFacilityUserByFederalIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getFacilityUserByFederalIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse, sizeof(ns1__getFacilityUserByFederalIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getFacilityUserByFederalIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__facilityUser(soap, "return", &(a->ns1__getFacilityUserByFederalIdResponse::return_), "ns1:facilityUser"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getFacilityUserByFederalIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse, 0, sizeof(ns1__getFacilityUserByFederalIdResponse), 0, soap_copy_ns1__getFacilityUserByFederalIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getFacilityUserByFederalIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getFacilityUserByFederalIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getFacilityUserByFederalIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getFacilityUserByFederalIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalIdResponse * SOAP_FMAC4 soap_get_ns1__getFacilityUserByFederalIdResponse(struct soap *soap, ns1__getFacilityUserByFederalIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFacilityUserByFederalIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getFacilityUserByFederalIdResponse * SOAP_FMAC2 soap_instantiate_ns1__getFacilityUserByFederalIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFacilityUserByFederalIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalIdResponse);
		if (size)
			*size = sizeof(ns1__getFacilityUserByFederalIdResponse);
		((ns1__getFacilityUserByFederalIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getFacilityUserByFederalIdResponse);
		for (int i = 0; i < n; i++)
			((ns1__getFacilityUserByFederalIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getFacilityUserByFederalIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFacilityUserByFederalIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getFacilityUserByFederalIdResponse %p -> %p\n", q, p));
	*(ns1__getFacilityUserByFederalIdResponse*)p = *(ns1__getFacilityUserByFederalIdResponse*)q;
}

void ns1__getFacilityUserByFederalId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getFacilityUserByFederalId::sessionId = NULL;
	this->ns1__getFacilityUserByFederalId::federalId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__getFacilityUserByFederalId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getFacilityUserByFederalId::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getFacilityUserByFederalId::federalId);
	/* transient soap skipped */
}

int ns1__getFacilityUserByFederalId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getFacilityUserByFederalId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFacilityUserByFederalId(struct soap *soap, const char *tag, int id, const ns1__getFacilityUserByFederalId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFacilityUserByFederalId), "ns1:getFacilityUserByFederalId"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getFacilityUserByFederalId::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "federalId", -1, &(a->ns1__getFacilityUserByFederalId::federalId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getFacilityUserByFederalId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getFacilityUserByFederalId(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalId * SOAP_FMAC4 soap_in_ns1__getFacilityUserByFederalId(struct soap *soap, const char *tag, ns1__getFacilityUserByFederalId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getFacilityUserByFederalId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFacilityUserByFederalId, sizeof(ns1__getFacilityUserByFederalId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getFacilityUserByFederalId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getFacilityUserByFederalId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_federalId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getFacilityUserByFederalId::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_federalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "federalId", &(a->ns1__getFacilityUserByFederalId::federalId), "xsd:string"))
				{	soap_flag_federalId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getFacilityUserByFederalId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFacilityUserByFederalId, 0, sizeof(ns1__getFacilityUserByFederalId), 0, soap_copy_ns1__getFacilityUserByFederalId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getFacilityUserByFederalId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getFacilityUserByFederalId);
	if (this->soap_out(soap, tag?tag:"ns1:getFacilityUserByFederalId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getFacilityUserByFederalId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getFacilityUserByFederalId(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalId * SOAP_FMAC4 soap_get_ns1__getFacilityUserByFederalId(struct soap *soap, ns1__getFacilityUserByFederalId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFacilityUserByFederalId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getFacilityUserByFederalId * SOAP_FMAC2 soap_instantiate_ns1__getFacilityUserByFederalId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFacilityUserByFederalId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFacilityUserByFederalId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalId);
		if (size)
			*size = sizeof(ns1__getFacilityUserByFederalId);
		((ns1__getFacilityUserByFederalId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getFacilityUserByFederalId);
		for (int i = 0; i < n; i++)
			((ns1__getFacilityUserByFederalId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getFacilityUserByFederalId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFacilityUserByFederalId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getFacilityUserByFederalId %p -> %p\n", q, p));
	*(ns1__getFacilityUserByFederalId*)p = *(ns1__getFacilityUserByFederalId*)q;
}

void ns1__downloadDatasetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadDatasetResponse::URL = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__downloadDatasetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadDatasetResponse::URL);
	/* transient soap skipped */
}

int ns1__downloadDatasetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadDatasetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadDatasetResponse(struct soap *soap, const char *tag, int id, const ns1__downloadDatasetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadDatasetResponse), "ns1:downloadDatasetResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "URL", -1, &(a->ns1__downloadDatasetResponse::URL), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadDatasetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadDatasetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadDatasetResponse * SOAP_FMAC4 soap_in_ns1__downloadDatasetResponse(struct soap *soap, const char *tag, ns1__downloadDatasetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadDatasetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadDatasetResponse, sizeof(ns1__downloadDatasetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadDatasetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadDatasetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_URL1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_URL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "URL", &(a->ns1__downloadDatasetResponse::URL), "xsd:string"))
				{	soap_flag_URL1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadDatasetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadDatasetResponse, 0, sizeof(ns1__downloadDatasetResponse), 0, soap_copy_ns1__downloadDatasetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__downloadDatasetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadDatasetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:downloadDatasetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadDatasetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadDatasetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadDatasetResponse * SOAP_FMAC4 soap_get_ns1__downloadDatasetResponse(struct soap *soap, ns1__downloadDatasetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadDatasetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadDatasetResponse * SOAP_FMAC2 soap_instantiate_ns1__downloadDatasetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadDatasetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadDatasetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatasetResponse);
		if (size)
			*size = sizeof(ns1__downloadDatasetResponse);
		((ns1__downloadDatasetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatasetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadDatasetResponse);
		for (int i = 0; i < n; i++)
			((ns1__downloadDatasetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadDatasetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadDatasetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadDatasetResponse %p -> %p\n", q, p));
	*(ns1__downloadDatasetResponse*)p = *(ns1__downloadDatasetResponse*)q;
}

void ns1__downloadDataset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadDataset::sessionId = NULL;
	this->ns1__downloadDataset::datasetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__downloadDataset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__downloadDataset::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__downloadDataset::datasetId);
	/* transient soap skipped */
}

int ns1__downloadDataset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadDataset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadDataset(struct soap *soap, const char *tag, int id, const ns1__downloadDataset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadDataset), "ns1:downloadDataset"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__downloadDataset::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__downloadDataset::datasetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadDataset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadDataset(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadDataset * SOAP_FMAC4 soap_in_ns1__downloadDataset(struct soap *soap, const char *tag, ns1__downloadDataset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadDataset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadDataset, sizeof(ns1__downloadDataset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadDataset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadDataset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datasetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__downloadDataset::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__downloadDataset::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadDataset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadDataset, 0, sizeof(ns1__downloadDataset), 0, soap_copy_ns1__downloadDataset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__downloadDataset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadDataset);
	if (this->soap_out(soap, tag?tag:"ns1:downloadDataset", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadDataset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadDataset(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadDataset * SOAP_FMAC4 soap_get_ns1__downloadDataset(struct soap *soap, ns1__downloadDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadDataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadDataset * SOAP_FMAC2 soap_instantiate_ns1__downloadDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDataset);
		if (size)
			*size = sizeof(ns1__downloadDataset);
		((ns1__downloadDataset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDataset[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadDataset);
		for (int i = 0; i < n; i++)
			((ns1__downloadDataset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadDataset %p -> %p\n", q, p));
	*(ns1__downloadDataset*)p = *(ns1__downloadDataset*)q;
}

void ns1__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__logoutResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logoutResponse(struct soap *soap, const char *tag, int id, const ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logoutResponse), "ns1:logoutResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "return", -1, &(a->ns1__logoutResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_in_ns1__logoutResponse(struct soap *soap, const char *tag, ns1__logoutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__logoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__logoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__logoutResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logoutResponse, 0, sizeof(ns1__logoutResponse), 0, soap_copy_ns1__logoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__logoutResponse);
	if (this->soap_out(soap, tag?tag:"ns1:logoutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_get_ns1__logoutResponse(struct soap *soap, ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__logoutResponse * SOAP_FMAC2 soap_instantiate_ns1__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse);
		if (size)
			*size = sizeof(ns1__logoutResponse);
		((ns1__logoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__logoutResponse);
		for (int i = 0; i < n; i++)
			((ns1__logoutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__logoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logoutResponse %p -> %p\n", q, p));
	*(ns1__logoutResponse*)p = *(ns1__logoutResponse*)q;
}

void ns1__logout::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__logout::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__logout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__logout::sessionId);
	/* transient soap skipped */
}

int ns1__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logout(struct soap *soap, const char *tag, int id, const ns1__logout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logout), "ns1:logout"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__logout::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__logout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__logout(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_in_ns1__logout(struct soap *soap, const char *tag, ns1__logout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__logout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__logout *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__logout::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logout, 0, sizeof(ns1__logout), 0, soap_copy_ns1__logout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__logout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__logout);
	if (this->soap_out(soap, tag?tag:"ns1:logout", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logout(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_get_ns1__logout(struct soap *soap, ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__logout * SOAP_FMAC2 soap_instantiate_ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__logout);
		if (size)
			*size = sizeof(ns1__logout);
		((ns1__logout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__logout);
		for (int i = 0; i < n; i++)
			((ns1__logout*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logout %p -> %p\n", q, p));
	*(ns1__logout*)p = *(ns1__logout*)q;
}

void ns1__facilityCycle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__facilityCycle::description = NULL;
	this->ns1__facilityCycle::finishDate = NULL;
	this->ns1__facilityCycle::name = NULL;
	this->ns1__facilityCycle::startDate = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__facilityCycle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityCycle::description);
	soap_serialize_PointerTotime(soap, &this->ns1__facilityCycle::finishDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__facilityCycle::name);
	soap_serialize_PointerTotime(soap, &this->ns1__facilityCycle::startDate);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__facilityCycle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__facilityCycle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__facilityCycle(struct soap *soap, const char *tag, int id, const ns1__facilityCycle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__facilityCycle), "ns1:facilityCycle"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__facilityCycle::description), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "finishDate", -1, &(a->ns1__facilityCycle::finishDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__facilityCycle::name), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__facilityCycle::startDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__facilityCycle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__facilityCycle(soap, tag, this, type);
}

SOAP_FMAC3 ns1__facilityCycle * SOAP_FMAC4 soap_in_ns1__facilityCycle(struct soap *soap, const char *tag, ns1__facilityCycle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__facilityCycle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__facilityCycle, sizeof(ns1__facilityCycle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__facilityCycle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__facilityCycle *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_finishDate1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_startDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__facilityCycle::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_finishDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "finishDate", &(a->ns1__facilityCycle::finishDate), "xsd:dateTime"))
				{	soap_flag_finishDate1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__facilityCycle::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__facilityCycle::startDate), "xsd:dateTime"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__facilityCycle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__facilityCycle, 0, sizeof(ns1__facilityCycle), 0, soap_copy_ns1__facilityCycle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__facilityCycle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__facilityCycle);
	if (this->soap_out(soap, tag?tag:"ns1:facilityCycle", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__facilityCycle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__facilityCycle(soap, this, tag, type);
}

SOAP_FMAC3 ns1__facilityCycle * SOAP_FMAC4 soap_get_ns1__facilityCycle(struct soap *soap, ns1__facilityCycle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__facilityCycle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__facilityCycle * SOAP_FMAC2 soap_instantiate_ns1__facilityCycle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__facilityCycle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__facilityCycle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__facilityCycle);
		if (size)
			*size = sizeof(ns1__facilityCycle);
		((ns1__facilityCycle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__facilityCycle[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__facilityCycle);
		for (int i = 0; i < n; i++)
			((ns1__facilityCycle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__facilityCycle*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__facilityCycle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__facilityCycle %p -> %p\n", q, p));
	*(ns1__facilityCycle*)p = *(ns1__facilityCycle*)q;
}

void ns1__listFacilityCyclesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__facilityCycle(soap, &this->ns1__listFacilityCyclesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listFacilityCyclesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__facilityCycle(soap, &this->ns1__listFacilityCyclesResponse::return_);
	/* transient soap skipped */
}

int ns1__listFacilityCyclesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listFacilityCyclesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listFacilityCyclesResponse(struct soap *soap, const char *tag, int id, const ns1__listFacilityCyclesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listFacilityCyclesResponse), "ns1:listFacilityCyclesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__facilityCycle(soap, "return", -1, &(a->ns1__listFacilityCyclesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listFacilityCyclesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listFacilityCyclesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listFacilityCyclesResponse * SOAP_FMAC4 soap_in_ns1__listFacilityCyclesResponse(struct soap *soap, const char *tag, ns1__listFacilityCyclesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listFacilityCyclesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listFacilityCyclesResponse, sizeof(ns1__listFacilityCyclesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listFacilityCyclesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listFacilityCyclesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__facilityCycle(soap, "return", &(a->ns1__listFacilityCyclesResponse::return_), "ns1:facilityCycle"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listFacilityCyclesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listFacilityCyclesResponse, 0, sizeof(ns1__listFacilityCyclesResponse), 0, soap_copy_ns1__listFacilityCyclesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listFacilityCyclesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listFacilityCyclesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listFacilityCyclesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listFacilityCyclesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listFacilityCyclesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listFacilityCyclesResponse * SOAP_FMAC4 soap_get_ns1__listFacilityCyclesResponse(struct soap *soap, ns1__listFacilityCyclesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listFacilityCyclesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listFacilityCyclesResponse * SOAP_FMAC2 soap_instantiate_ns1__listFacilityCyclesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listFacilityCyclesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listFacilityCyclesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCyclesResponse);
		if (size)
			*size = sizeof(ns1__listFacilityCyclesResponse);
		((ns1__listFacilityCyclesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCyclesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listFacilityCyclesResponse);
		for (int i = 0; i < n; i++)
			((ns1__listFacilityCyclesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listFacilityCyclesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listFacilityCyclesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listFacilityCyclesResponse %p -> %p\n", q, p));
	*(ns1__listFacilityCyclesResponse*)p = *(ns1__listFacilityCyclesResponse*)q;
}

void ns1__listFacilityCycles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listFacilityCycles::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listFacilityCycles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listFacilityCycles::sessionId);
	/* transient soap skipped */
}

int ns1__listFacilityCycles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listFacilityCycles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listFacilityCycles(struct soap *soap, const char *tag, int id, const ns1__listFacilityCycles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listFacilityCycles), "ns1:listFacilityCycles"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listFacilityCycles::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listFacilityCycles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listFacilityCycles(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listFacilityCycles * SOAP_FMAC4 soap_in_ns1__listFacilityCycles(struct soap *soap, const char *tag, ns1__listFacilityCycles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listFacilityCycles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listFacilityCycles, sizeof(ns1__listFacilityCycles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listFacilityCycles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listFacilityCycles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listFacilityCycles::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listFacilityCycles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listFacilityCycles, 0, sizeof(ns1__listFacilityCycles), 0, soap_copy_ns1__listFacilityCycles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listFacilityCycles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listFacilityCycles);
	if (this->soap_out(soap, tag?tag:"ns1:listFacilityCycles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listFacilityCycles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listFacilityCycles(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listFacilityCycles * SOAP_FMAC4 soap_get_ns1__listFacilityCycles(struct soap *soap, ns1__listFacilityCycles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listFacilityCycles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listFacilityCycles * SOAP_FMAC2 soap_instantiate_ns1__listFacilityCycles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listFacilityCycles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listFacilityCycles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCycles);
		if (size)
			*size = sizeof(ns1__listFacilityCycles);
		((ns1__listFacilityCycles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCycles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listFacilityCycles);
		for (int i = 0; i < n; i++)
			((ns1__listFacilityCycles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listFacilityCycles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listFacilityCycles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listFacilityCycles %p -> %p\n", q, p));
	*(ns1__listFacilityCycles*)p = *(ns1__listFacilityCycles*)q;
}

void ns1__addDataFileParametersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__addDataFileParametersResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataFileParametersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__addDataFileParametersResponse::return_);
	/* transient soap skipped */
}

int ns1__addDataFileParametersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataFileParametersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataFileParametersResponse(struct soap *soap, const char *tag, int id, const ns1__addDataFileParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataFileParametersResponse), "ns1:addDataFileParametersResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "return", -1, &(a->ns1__addDataFileParametersResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataFileParametersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataFileParametersResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataFileParametersResponse * SOAP_FMAC4 soap_in_ns1__addDataFileParametersResponse(struct soap *soap, const char *tag, ns1__addDataFileParametersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataFileParametersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataFileParametersResponse, sizeof(ns1__addDataFileParametersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataFileParametersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataFileParametersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "return", &(a->ns1__addDataFileParametersResponse::return_), "ns1:datafileParameter"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataFileParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataFileParametersResponse, 0, sizeof(ns1__addDataFileParametersResponse), 0, soap_copy_ns1__addDataFileParametersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataFileParametersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataFileParametersResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addDataFileParametersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataFileParametersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataFileParametersResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataFileParametersResponse * SOAP_FMAC4 soap_get_ns1__addDataFileParametersResponse(struct soap *soap, ns1__addDataFileParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataFileParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataFileParametersResponse * SOAP_FMAC2 soap_instantiate_ns1__addDataFileParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataFileParametersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataFileParametersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParametersResponse);
		if (size)
			*size = sizeof(ns1__addDataFileParametersResponse);
		((ns1__addDataFileParametersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParametersResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataFileParametersResponse);
		for (int i = 0; i < n; i++)
			((ns1__addDataFileParametersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataFileParametersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataFileParametersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataFileParametersResponse %p -> %p\n", q, p));
	*(ns1__addDataFileParametersResponse*)p = *(ns1__addDataFileParametersResponse*)q;
}

void ns1__addDataFileParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addDataFileParameters::sessionId = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__addDataFileParameters::dataFileParameters);
	this->ns1__addDataFileParameters::datafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__addDataFileParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__addDataFileParameters::sessionId);
	soap_serialize_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__addDataFileParameters::dataFileParameters);
	soap_serialize_PointerToLONG64(soap, &this->ns1__addDataFileParameters::datafileId);
	/* transient soap skipped */
}

int ns1__addDataFileParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addDataFileParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDataFileParameters(struct soap *soap, const char *tag, int id, const ns1__addDataFileParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDataFileParameters), "ns1:addDataFileParameters"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__addDataFileParameters::sessionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "dataFileParameters", -1, &(a->ns1__addDataFileParameters::dataFileParameters), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__addDataFileParameters::datafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__addDataFileParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addDataFileParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addDataFileParameters * SOAP_FMAC4 soap_in_ns1__addDataFileParameters(struct soap *soap, const char *tag, ns1__addDataFileParameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addDataFileParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDataFileParameters, sizeof(ns1__addDataFileParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addDataFileParameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addDataFileParameters *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__addDataFileParameters::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "dataFileParameters", &(a->ns1__addDataFileParameters::dataFileParameters), "ns1:datafileParameter"))
					continue;
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__addDataFileParameters::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addDataFileParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDataFileParameters, 0, sizeof(ns1__addDataFileParameters), 0, soap_copy_ns1__addDataFileParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__addDataFileParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addDataFileParameters);
	if (this->soap_out(soap, tag?tag:"ns1:addDataFileParameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__addDataFileParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addDataFileParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addDataFileParameters * SOAP_FMAC4 soap_get_ns1__addDataFileParameters(struct soap *soap, ns1__addDataFileParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDataFileParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__addDataFileParameters * SOAP_FMAC2 soap_instantiate_ns1__addDataFileParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDataFileParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDataFileParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameters);
		if (size)
			*size = sizeof(ns1__addDataFileParameters);
		((ns1__addDataFileParameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameters[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addDataFileParameters);
		for (int i = 0; i < n; i++)
			((ns1__addDataFileParameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addDataFileParameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDataFileParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addDataFileParameters %p -> %p\n", q, p));
	*(ns1__addDataFileParameters*)p = *(ns1__addDataFileParameters*)q;
}

void ns1__removeAuthorisationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeAuthorisationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeAuthorisationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeAuthorisationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeAuthorisationResponse(struct soap *soap, const char *tag, int id, const ns1__removeAuthorisationResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeAuthorisationResponse");
}

void *ns1__removeAuthorisationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeAuthorisationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeAuthorisationResponse * SOAP_FMAC4 soap_in_ns1__removeAuthorisationResponse(struct soap *soap, const char *tag, ns1__removeAuthorisationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeAuthorisationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeAuthorisationResponse, sizeof(ns1__removeAuthorisationResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeAuthorisationResponse)
			return (ns1__removeAuthorisationResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeAuthorisationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeAuthorisationResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeAuthorisationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeAuthorisationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeAuthorisationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeAuthorisationResponse * SOAP_FMAC4 soap_get_ns1__removeAuthorisationResponse(struct soap *soap, ns1__removeAuthorisationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeAuthorisationResponse * SOAP_FMAC2 soap_instantiate_ns1__removeAuthorisationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeAuthorisationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeAuthorisationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisationResponse);
		if (size)
			*size = sizeof(ns1__removeAuthorisationResponse);
		((ns1__removeAuthorisationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeAuthorisationResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeAuthorisationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeAuthorisationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeAuthorisationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeAuthorisationResponse %p -> %p\n", q, p));
	*(ns1__removeAuthorisationResponse*)p = *(ns1__removeAuthorisationResponse*)q;
}

void ns1__removeAuthorisation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeAuthorisation::sessionId = NULL;
	this->ns1__removeAuthorisation::authorisationId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeAuthorisation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeAuthorisation::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__removeAuthorisation::authorisationId);
	/* transient soap skipped */
}

int ns1__removeAuthorisation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeAuthorisation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeAuthorisation(struct soap *soap, const char *tag, int id, const ns1__removeAuthorisation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeAuthorisation), "ns1:removeAuthorisation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeAuthorisation::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "authorisationId", -1, &(a->ns1__removeAuthorisation::authorisationId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeAuthorisation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeAuthorisation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeAuthorisation * SOAP_FMAC4 soap_in_ns1__removeAuthorisation(struct soap *soap, const char *tag, ns1__removeAuthorisation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeAuthorisation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeAuthorisation, sizeof(ns1__removeAuthorisation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeAuthorisation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeAuthorisation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_authorisationId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeAuthorisation::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_authorisationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "authorisationId", &(a->ns1__removeAuthorisation::authorisationId), "xsd:long"))
				{	soap_flag_authorisationId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeAuthorisation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeAuthorisation, 0, sizeof(ns1__removeAuthorisation), 0, soap_copy_ns1__removeAuthorisation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeAuthorisation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeAuthorisation);
	if (this->soap_out(soap, tag?tag:"ns1:removeAuthorisation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeAuthorisation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeAuthorisation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeAuthorisation * SOAP_FMAC4 soap_get_ns1__removeAuthorisation(struct soap *soap, ns1__removeAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeAuthorisation * SOAP_FMAC2 soap_instantiate_ns1__removeAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisation);
		if (size)
			*size = sizeof(ns1__removeAuthorisation);
		((ns1__removeAuthorisation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeAuthorisation);
		for (int i = 0; i < n; i++)
			((ns1__removeAuthorisation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeAuthorisation %p -> %p\n", q, p));
	*(ns1__removeAuthorisation*)p = *(ns1__removeAuthorisation*)q;
}

void ns1__removeDataFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeDataFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataFileResponse(struct soap *soap, const char *tag, int id, const ns1__removeDataFileResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeDataFileResponse");
}

void *ns1__removeDataFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataFileResponse * SOAP_FMAC4 soap_in_ns1__removeDataFileResponse(struct soap *soap, const char *tag, ns1__removeDataFileResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeDataFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataFileResponse, sizeof(ns1__removeDataFileResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataFileResponse)
			return (ns1__removeDataFileResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeDataFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataFileResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataFileResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataFileResponse * SOAP_FMAC4 soap_get_ns1__removeDataFileResponse(struct soap *soap, ns1__removeDataFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataFileResponse * SOAP_FMAC2 soap_instantiate_ns1__removeDataFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileResponse);
		if (size)
			*size = sizeof(ns1__removeDataFileResponse);
		((ns1__removeDataFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataFileResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeDataFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataFileResponse %p -> %p\n", q, p));
	*(ns1__removeDataFileResponse*)p = *(ns1__removeDataFileResponse*)q;
}

void ns1__removeDataFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeDataFile::sessionId = NULL;
	this->ns1__removeDataFile::datafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeDataFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeDataFile::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__removeDataFile::datafileId);
	/* transient soap skipped */
}

int ns1__removeDataFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeDataFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeDataFile(struct soap *soap, const char *tag, int id, const ns1__removeDataFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeDataFile), "ns1:removeDataFile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeDataFile::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__removeDataFile::datafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeDataFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeDataFile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeDataFile * SOAP_FMAC4 soap_in_ns1__removeDataFile(struct soap *soap, const char *tag, ns1__removeDataFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeDataFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeDataFile, sizeof(ns1__removeDataFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeDataFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeDataFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_datafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeDataFile::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__removeDataFile::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeDataFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeDataFile, 0, sizeof(ns1__removeDataFile), 0, soap_copy_ns1__removeDataFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeDataFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeDataFile);
	if (this->soap_out(soap, tag?tag:"ns1:removeDataFile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeDataFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeDataFile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeDataFile * SOAP_FMAC4 soap_get_ns1__removeDataFile(struct soap *soap, ns1__removeDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeDataFile * SOAP_FMAC2 soap_instantiate_ns1__removeDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFile);
		if (size)
			*size = sizeof(ns1__removeDataFile);
		((ns1__removeDataFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeDataFile);
		for (int i = 0; i < n; i++)
			((ns1__removeDataFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeDataFile %p -> %p\n", q, p));
	*(ns1__removeDataFile*)p = *(ns1__removeDataFile*)q;
}

void ns1__modifySampleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifySampleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__modifySampleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifySampleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifySampleResponse(struct soap *soap, const char *tag, int id, const ns1__modifySampleResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:modifySampleResponse");
}

void *ns1__modifySampleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifySampleResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifySampleResponse * SOAP_FMAC4 soap_in_ns1__modifySampleResponse(struct soap *soap, const char *tag, ns1__modifySampleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__modifySampleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifySampleResponse, sizeof(ns1__modifySampleResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifySampleResponse)
			return (ns1__modifySampleResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__modifySampleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifySampleResponse);
	if (this->soap_out(soap, tag?tag:"ns1:modifySampleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifySampleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifySampleResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifySampleResponse * SOAP_FMAC4 soap_get_ns1__modifySampleResponse(struct soap *soap, ns1__modifySampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifySampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifySampleResponse * SOAP_FMAC2 soap_instantiate_ns1__modifySampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifySampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifySampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleResponse);
		if (size)
			*size = sizeof(ns1__modifySampleResponse);
		((ns1__modifySampleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifySampleResponse);
		for (int i = 0; i < n; i++)
			((ns1__modifySampleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifySampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifySampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifySampleResponse %p -> %p\n", q, p));
	*(ns1__modifySampleResponse*)p = *(ns1__modifySampleResponse*)q;
}

void ns1__modifySample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__modifySample::sessionId = NULL;
	this->ns1__modifySample::sample = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__modifySample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__modifySample::sessionId);
	soap_serialize_PointerTons1__sample(soap, &this->ns1__modifySample::sample);
	/* transient soap skipped */
}

int ns1__modifySample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__modifySample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifySample(struct soap *soap, const char *tag, int id, const ns1__modifySample *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifySample), "ns1:modifySample"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__modifySample::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__sample(soap, "sample", -1, &(a->ns1__modifySample::sample), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__modifySample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__modifySample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__modifySample * SOAP_FMAC4 soap_in_ns1__modifySample(struct soap *soap, const char *tag, ns1__modifySample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__modifySample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifySample, sizeof(ns1__modifySample), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__modifySample)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__modifySample *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sample1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__modifySample::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sample1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sample(soap, "sample", &(a->ns1__modifySample::sample), "ns1:sample"))
				{	soap_flag_sample1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__modifySample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifySample, 0, sizeof(ns1__modifySample), 0, soap_copy_ns1__modifySample);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__modifySample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__modifySample);
	if (this->soap_out(soap, tag?tag:"ns1:modifySample", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__modifySample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__modifySample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__modifySample * SOAP_FMAC4 soap_get_ns1__modifySample(struct soap *soap, ns1__modifySample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifySample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__modifySample * SOAP_FMAC2 soap_instantiate_ns1__modifySample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__modifySample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__modifySample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySample);
		if (size)
			*size = sizeof(ns1__modifySample);
		((ns1__modifySample*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__modifySample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__modifySample);
		for (int i = 0; i < n; i++)
			((ns1__modifySample*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__modifySample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__modifySample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__modifySample %p -> %p\n", q, p));
	*(ns1__modifySample*)p = *(ns1__modifySample*)q;
}

void ns1__ValidationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ValidationException::message = NULL;
	this->ns1__ValidationException::stackTraceAsString = NULL;
	this->ns1__ValidationException::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ValidationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ValidationException::message);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ValidationException::stackTraceAsString);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ValidationException::uniqueId);
	/* transient soap skipped */
}

int ns1__ValidationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValidationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValidationException(struct soap *soap, const char *tag, int id, const ns1__ValidationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValidationException), "ns1:ValidationException"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns1__ValidationException::message), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stackTraceAsString", -1, &(a->ns1__ValidationException::stackTraceAsString), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__ValidationException::uniqueId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValidationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ValidationException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValidationException * SOAP_FMAC4 soap_in_ns1__ValidationException(struct soap *soap, const char *tag, ns1__ValidationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValidationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValidationException, sizeof(ns1__ValidationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ValidationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ValidationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_stackTraceAsString1 = 1;
	size_t soap_flag_uniqueId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->ns1__ValidationException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_stackTraceAsString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stackTraceAsString", &(a->ns1__ValidationException::stackTraceAsString), "xsd:string"))
				{	soap_flag_stackTraceAsString1--;
					continue;
				}
			if (soap_flag_uniqueId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__ValidationException::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ValidationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValidationException, 0, sizeof(ns1__ValidationException), 0, soap_copy_ns1__ValidationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ValidationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ValidationException);
	if (this->soap_out(soap, tag?tag:"ns1:ValidationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValidationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValidationException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValidationException * SOAP_FMAC4 soap_get_ns1__ValidationException(struct soap *soap, ns1__ValidationException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValidationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ValidationException * SOAP_FMAC2 soap_instantiate_ns1__ValidationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValidationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ValidationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ValidationException);
		if (size)
			*size = sizeof(ns1__ValidationException);
		((ns1__ValidationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ValidationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ValidationException);
		for (int i = 0; i < n; i++)
			((ns1__ValidationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ValidationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ValidationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ValidationException %p -> %p\n", q, p));
	*(ns1__ValidationException*)p = *(ns1__ValidationException*)q;
}

void ns1__createDataFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDataFileResponse::return_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__datafile(soap, &this->ns1__createDataFileResponse::return_);
	/* transient soap skipped */
}

int ns1__createDataFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataFileResponse(struct soap *soap, const char *tag, int id, const ns1__createDataFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataFileResponse), "ns1:createDataFileResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__datafile(soap, "return", -1, &(a->ns1__createDataFileResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataFileResponse * SOAP_FMAC4 soap_in_ns1__createDataFileResponse(struct soap *soap, const char *tag, ns1__createDataFileResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataFileResponse, sizeof(ns1__createDataFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafile(soap, "return", &(a->ns1__createDataFileResponse::return_), "ns1:datafile"))
				{	soap_flag_return_1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataFileResponse, 0, sizeof(ns1__createDataFileResponse), 0, soap_copy_ns1__createDataFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataFileResponse);
	if (this->soap_out(soap, tag?tag:"ns1:createDataFileResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataFileResponse * SOAP_FMAC4 soap_get_ns1__createDataFileResponse(struct soap *soap, ns1__createDataFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataFileResponse * SOAP_FMAC2 soap_instantiate_ns1__createDataFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFileResponse);
		if (size)
			*size = sizeof(ns1__createDataFileResponse);
		((ns1__createDataFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataFileResponse);
		for (int i = 0; i < n; i++)
			((ns1__createDataFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataFileResponse %p -> %p\n", q, p));
	*(ns1__createDataFileResponse*)p = *(ns1__createDataFileResponse*)q;
}

void ns1__relatedDatafilesPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__relatedDatafilesPK::destDatafileId = NULL;
	this->ns1__relatedDatafilesPK::sourceDatafileId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__relatedDatafilesPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__relatedDatafilesPK::destDatafileId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__relatedDatafilesPK::sourceDatafileId);
	/* transient soap skipped */
}

int ns1__relatedDatafilesPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__relatedDatafilesPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relatedDatafilesPK(struct soap *soap, const char *tag, int id, const ns1__relatedDatafilesPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__relatedDatafilesPK), "ns1:relatedDatafilesPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "destDatafileId", -1, &(a->ns1__relatedDatafilesPK::destDatafileId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "sourceDatafileId", -1, &(a->ns1__relatedDatafilesPK::sourceDatafileId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__relatedDatafilesPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__relatedDatafilesPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__relatedDatafilesPK * SOAP_FMAC4 soap_in_ns1__relatedDatafilesPK(struct soap *soap, const char *tag, ns1__relatedDatafilesPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__relatedDatafilesPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__relatedDatafilesPK, sizeof(ns1__relatedDatafilesPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__relatedDatafilesPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__relatedDatafilesPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_destDatafileId1 = 1;
	size_t soap_flag_sourceDatafileId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_destDatafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "destDatafileId", &(a->ns1__relatedDatafilesPK::destDatafileId), "xsd:long"))
				{	soap_flag_destDatafileId1--;
					continue;
				}
			if (soap_flag_sourceDatafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "sourceDatafileId", &(a->ns1__relatedDatafilesPK::sourceDatafileId), "xsd:long"))
				{	soap_flag_sourceDatafileId1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__relatedDatafilesPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__relatedDatafilesPK, 0, sizeof(ns1__relatedDatafilesPK), 0, soap_copy_ns1__relatedDatafilesPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__relatedDatafilesPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__relatedDatafilesPK);
	if (this->soap_out(soap, tag?tag:"ns1:relatedDatafilesPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__relatedDatafilesPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__relatedDatafilesPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__relatedDatafilesPK * SOAP_FMAC4 soap_get_ns1__relatedDatafilesPK(struct soap *soap, ns1__relatedDatafilesPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__relatedDatafilesPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__relatedDatafilesPK * SOAP_FMAC2 soap_instantiate_ns1__relatedDatafilesPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__relatedDatafilesPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__relatedDatafilesPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafilesPK);
		if (size)
			*size = sizeof(ns1__relatedDatafilesPK);
		((ns1__relatedDatafilesPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafilesPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__relatedDatafilesPK);
		for (int i = 0; i < n; i++)
			((ns1__relatedDatafilesPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__relatedDatafilesPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__relatedDatafilesPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__relatedDatafilesPK %p -> %p\n", q, p));
	*(ns1__relatedDatafilesPK*)p = *(ns1__relatedDatafilesPK*)q;
}

void ns1__relatedDatafiles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__relatedDatafiles::relatedDatafilesPK = NULL;
	this->ns1__relatedDatafiles::relation = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__relatedDatafiles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__relatedDatafilesPK(soap, &this->ns1__relatedDatafiles::relatedDatafilesPK);
	soap_serialize_PointerTostd__string(soap, &this->ns1__relatedDatafiles::relation);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__relatedDatafiles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__relatedDatafiles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relatedDatafiles(struct soap *soap, const char *tag, int id, const ns1__relatedDatafiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__relatedDatafiles), "ns1:relatedDatafiles"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTons1__relatedDatafilesPK(soap, "relatedDatafilesPK", -1, &(a->ns1__relatedDatafiles::relatedDatafilesPK), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "relation", -1, &(a->ns1__relatedDatafiles::relation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__relatedDatafiles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__relatedDatafiles(soap, tag, this, type);
}

SOAP_FMAC3 ns1__relatedDatafiles * SOAP_FMAC4 soap_in_ns1__relatedDatafiles(struct soap *soap, const char *tag, ns1__relatedDatafiles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__relatedDatafiles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__relatedDatafiles, sizeof(ns1__relatedDatafiles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__relatedDatafiles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__relatedDatafiles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_relatedDatafilesPK1 = 1;
	size_t soap_flag_relation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_relatedDatafilesPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__relatedDatafilesPK(soap, "relatedDatafilesPK", &(a->ns1__relatedDatafiles::relatedDatafilesPK), "ns1:relatedDatafilesPK"))
				{	soap_flag_relatedDatafilesPK1--;
					continue;
				}
			if (soap_flag_relation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "relation", &(a->ns1__relatedDatafiles::relation), "xsd:string"))
				{	soap_flag_relation1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__relatedDatafiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__relatedDatafiles, 0, sizeof(ns1__relatedDatafiles), 0, soap_copy_ns1__relatedDatafiles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__relatedDatafiles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__relatedDatafiles);
	if (this->soap_out(soap, tag?tag:"ns1:relatedDatafiles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__relatedDatafiles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__relatedDatafiles(soap, this, tag, type);
}

SOAP_FMAC3 ns1__relatedDatafiles * SOAP_FMAC4 soap_get_ns1__relatedDatafiles(struct soap *soap, ns1__relatedDatafiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__relatedDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__relatedDatafiles * SOAP_FMAC2 soap_instantiate_ns1__relatedDatafiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__relatedDatafiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__relatedDatafiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafiles);
		if (size)
			*size = sizeof(ns1__relatedDatafiles);
		((ns1__relatedDatafiles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__relatedDatafiles);
		for (int i = 0; i < n; i++)
			((ns1__relatedDatafiles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__relatedDatafiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__relatedDatafiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__relatedDatafiles %p -> %p\n", q, p));
	*(ns1__relatedDatafiles*)p = *(ns1__relatedDatafiles*)q;
}

void ns1__datafileParameterPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__datafileParameterPK::datafileId = NULL;
	this->ns1__datafileParameterPK::name = NULL;
	this->ns1__datafileParameterPK::units = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datafileParameterPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__datafileParameterPK::datafileId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileParameterPK::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileParameterPK::units);
	/* transient soap skipped */
}

int ns1__datafileParameterPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datafileParameterPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileParameterPK(struct soap *soap, const char *tag, int id, const ns1__datafileParameterPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datafileParameterPK), "ns1:datafileParameterPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "datafileId", -1, &(a->ns1__datafileParameterPK::datafileId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__datafileParameterPK::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "units", -1, &(a->ns1__datafileParameterPK::units), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__datafileParameterPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datafileParameterPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafileParameterPK * SOAP_FMAC4 soap_in_ns1__datafileParameterPK(struct soap *soap, const char *tag, ns1__datafileParameterPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__datafileParameterPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datafileParameterPK, sizeof(ns1__datafileParameterPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datafileParameterPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__datafileParameterPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_datafileId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_units1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_datafileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datafileId", &(a->ns1__datafileParameterPK::datafileId), "xsd:long"))
				{	soap_flag_datafileId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__datafileParameterPK::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_units1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "units", &(a->ns1__datafileParameterPK::units), "xsd:string"))
				{	soap_flag_units1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__datafileParameterPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datafileParameterPK, 0, sizeof(ns1__datafileParameterPK), 0, soap_copy_ns1__datafileParameterPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__datafileParameterPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datafileParameterPK);
	if (this->soap_out(soap, tag?tag:"ns1:datafileParameterPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datafileParameterPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datafileParameterPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafileParameterPK * SOAP_FMAC4 soap_get_ns1__datafileParameterPK(struct soap *soap, ns1__datafileParameterPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datafileParameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datafileParameterPK * SOAP_FMAC2 soap_instantiate_ns1__datafileParameterPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafileParameterPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datafileParameterPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameterPK);
		if (size)
			*size = sizeof(ns1__datafileParameterPK);
		((ns1__datafileParameterPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameterPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datafileParameterPK);
		for (int i = 0; i < n; i++)
			((ns1__datafileParameterPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datafileParameterPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafileParameterPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafileParameterPK %p -> %p\n", q, p));
	*(ns1__datafileParameterPK*)p = *(ns1__datafileParameterPK*)q;
}

void ns1__datafileParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__datafileParameter::datafileParameterPK = NULL;
	this->ns1__datafileParameter::description = NULL;
	this->ns1__datafileParameter::error = NULL;
	soap_default_bool(soap, &this->ns1__datafileParameter::numeric);
	this->ns1__datafileParameter::numericValue = NULL;
	this->ns1__datafileParameter::rangeBottom = NULL;
	this->ns1__datafileParameter::rangeTop = NULL;
	this->ns1__datafileParameter::stringValue = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datafileParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__datafileParameterPK(soap, &this->ns1__datafileParameter::datafileParameterPK);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileParameter::description);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileParameter::error);
	soap_serialize_PointerTodouble(soap, &this->ns1__datafileParameter::numericValue);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileParameter::rangeBottom);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileParameter::rangeTop);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileParameter::stringValue);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__datafileParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datafileParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileParameter(struct soap *soap, const char *tag, int id, const ns1__datafileParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datafileParameter), "ns1:datafileParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileParameterPK(soap, "datafileParameterPK", -1, &(a->ns1__datafileParameter::datafileParameterPK), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__datafileParameter::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "error", -1, &(a->ns1__datafileParameter::error), ""))
		return soap->error;
	if (soap_out_bool(soap, "numeric", -1, &(a->ns1__datafileParameter::numeric), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__datafileParameter::numericValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "rangeBottom", -1, &(a->ns1__datafileParameter::rangeBottom), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "rangeTop", -1, &(a->ns1__datafileParameter::rangeTop), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__datafileParameter::stringValue), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__datafileParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datafileParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafileParameter * SOAP_FMAC4 soap_in_ns1__datafileParameter(struct soap *soap, const char *tag, ns1__datafileParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__datafileParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datafileParameter, sizeof(ns1__datafileParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datafileParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__datafileParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_datafileParameterPK1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_error1 = 1;
	size_t soap_flag_numeric1 = 1;
	size_t soap_flag_numericValue1 = 1;
	size_t soap_flag_rangeBottom1 = 1;
	size_t soap_flag_rangeTop1 = 1;
	size_t soap_flag_stringValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_datafileParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileParameterPK(soap, "datafileParameterPK", &(a->ns1__datafileParameter::datafileParameterPK), "ns1:datafileParameterPK"))
				{	soap_flag_datafileParameterPK1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__datafileParameter::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "error", &(a->ns1__datafileParameter::error), "xsd:string"))
				{	soap_flag_error1--;
					continue;
				}
			if (soap_flag_numeric1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "numeric", &(a->ns1__datafileParameter::numeric), "xsd:boolean"))
				{	soap_flag_numeric1--;
					continue;
				}
			if (soap_flag_numericValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__datafileParameter::numericValue), "xsd:double"))
				{	soap_flag_numericValue1--;
					continue;
				}
			if (soap_flag_rangeBottom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "rangeBottom", &(a->ns1__datafileParameter::rangeBottom), "xsd:string"))
				{	soap_flag_rangeBottom1--;
					continue;
				}
			if (soap_flag_rangeTop1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "rangeTop", &(a->ns1__datafileParameter::rangeTop), "xsd:string"))
				{	soap_flag_rangeTop1--;
					continue;
				}
			if (soap_flag_stringValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__datafileParameter::stringValue), "xsd:string"))
				{	soap_flag_stringValue1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__datafileParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datafileParameter, 0, sizeof(ns1__datafileParameter), 0, soap_copy_ns1__datafileParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0 || soap_flag_numeric1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__datafileParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datafileParameter);
	if (this->soap_out(soap, tag?tag:"ns1:datafileParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datafileParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datafileParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafileParameter * SOAP_FMAC4 soap_get_ns1__datafileParameter(struct soap *soap, ns1__datafileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datafileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datafileParameter * SOAP_FMAC2 soap_instantiate_ns1__datafileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datafileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameter);
		if (size)
			*size = sizeof(ns1__datafileParameter);
		((ns1__datafileParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datafileParameter);
		for (int i = 0; i < n; i++)
			((ns1__datafileParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datafileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafileParameter %p -> %p\n", q, p));
	*(ns1__datafileParameter*)p = *(ns1__datafileParameter*)q;
}

void ns1__datafileFormatPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__datafileFormatPK::name = NULL;
	this->ns1__datafileFormatPK::version = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datafileFormatPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormatPK::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormatPK::version);
	/* transient soap skipped */
}

int ns1__datafileFormatPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datafileFormatPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileFormatPK(struct soap *soap, const char *tag, int id, const ns1__datafileFormatPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datafileFormatPK), "ns1:datafileFormatPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__datafileFormatPK::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "version", -1, &(a->ns1__datafileFormatPK::version), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__datafileFormatPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datafileFormatPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafileFormatPK * SOAP_FMAC4 soap_in_ns1__datafileFormatPK(struct soap *soap, const char *tag, ns1__datafileFormatPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__datafileFormatPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datafileFormatPK, sizeof(ns1__datafileFormatPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datafileFormatPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__datafileFormatPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__datafileFormatPK::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "version", &(a->ns1__datafileFormatPK::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__datafileFormatPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datafileFormatPK, 0, sizeof(ns1__datafileFormatPK), 0, soap_copy_ns1__datafileFormatPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__datafileFormatPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datafileFormatPK);
	if (this->soap_out(soap, tag?tag:"ns1:datafileFormatPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datafileFormatPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datafileFormatPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafileFormatPK * SOAP_FMAC4 soap_get_ns1__datafileFormatPK(struct soap *soap, ns1__datafileFormatPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datafileFormatPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datafileFormatPK * SOAP_FMAC2 soap_instantiate_ns1__datafileFormatPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafileFormatPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datafileFormatPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormatPK);
		if (size)
			*size = sizeof(ns1__datafileFormatPK);
		((ns1__datafileFormatPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormatPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datafileFormatPK);
		for (int i = 0; i < n; i++)
			((ns1__datafileFormatPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datafileFormatPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafileFormatPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafileFormatPK %p -> %p\n", q, p));
	*(ns1__datafileFormatPK*)p = *(ns1__datafileFormatPK*)q;
}

void ns1__datafileFormat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__datafileFormat::datafileFormatPK = NULL;
	this->ns1__datafileFormat::description = NULL;
	this->ns1__datafileFormat::formatType = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datafileFormat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__datafileFormatPK(soap, &this->ns1__datafileFormat::datafileFormatPK);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormat::description);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormat::formatType);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__datafileFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datafileFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileFormat(struct soap *soap, const char *tag, int id, const ns1__datafileFormat *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datafileFormat), "ns1:datafileFormat"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileFormatPK(soap, "datafileFormatPK", -1, &(a->ns1__datafileFormat::datafileFormatPK), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__datafileFormat::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "formatType", -1, &(a->ns1__datafileFormat::formatType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__datafileFormat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datafileFormat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafileFormat * SOAP_FMAC4 soap_in_ns1__datafileFormat(struct soap *soap, const char *tag, ns1__datafileFormat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__datafileFormat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datafileFormat, sizeof(ns1__datafileFormat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datafileFormat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__datafileFormat *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_datafileFormatPK1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_formatType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_datafileFormatPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileFormatPK(soap, "datafileFormatPK", &(a->ns1__datafileFormat::datafileFormatPK), "ns1:datafileFormatPK"))
				{	soap_flag_datafileFormatPK1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__datafileFormat::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_formatType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "formatType", &(a->ns1__datafileFormat::formatType), "xsd:string"))
				{	soap_flag_formatType1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__datafileFormat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datafileFormat, 0, sizeof(ns1__datafileFormat), 0, soap_copy_ns1__datafileFormat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__datafileFormat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datafileFormat);
	if (this->soap_out(soap, tag?tag:"ns1:datafileFormat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datafileFormat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datafileFormat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafileFormat * SOAP_FMAC4 soap_get_ns1__datafileFormat(struct soap *soap, ns1__datafileFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datafileFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datafileFormat * SOAP_FMAC2 soap_instantiate_ns1__datafileFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafileFormat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datafileFormat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormat);
		if (size)
			*size = sizeof(ns1__datafileFormat);
		((ns1__datafileFormat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datafileFormat);
		for (int i = 0; i < n; i++)
			((ns1__datafileFormat*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datafileFormat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafileFormat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafileFormat %p -> %p\n", q, p));
	*(ns1__datafileFormat*)p = *(ns1__datafileFormat*)q;
}

void ns1__datafile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__datafile::checksum = NULL;
	this->ns1__datafile::command = NULL;
	this->ns1__datafile::datafileCreateTime = NULL;
	this->ns1__datafile::datafileFormat = NULL;
	this->ns1__datafile::datafileInclude = NULL;
	this->ns1__datafile::datafileModifyTime = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__datafile::datafileParameterCollection);
	this->ns1__datafile::datafileVersion = NULL;
	this->ns1__datafile::datafileVersionComment = NULL;
	this->ns1__datafile::datasetId = NULL;
	this->ns1__datafile::description = NULL;
	this->ns1__datafile::fileSize = NULL;
	this->ns1__datafile::id = NULL;
	this->ns1__datafile::location = NULL;
	this->ns1__datafile::name = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, &this->ns1__datafile::relatedDatafilesCollection1);
	soap_default_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, &this->ns1__datafile::relatedDatafilesCollection);
	this->ns1__datafile::signature = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__datafile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::checksum);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::command);
	soap_serialize_PointerTotime(soap, &this->ns1__datafile::datafileCreateTime);
	soap_serialize_PointerTons1__datafileFormat(soap, &this->ns1__datafile::datafileFormat);
	soap_serialize_PointerTons1__datafileInclude(soap, &this->ns1__datafile::datafileInclude);
	soap_serialize_PointerTotime(soap, &this->ns1__datafile::datafileModifyTime);
	soap_serialize_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__datafile::datafileParameterCollection);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::datafileVersion);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::datafileVersionComment);
	soap_serialize_PointerToLONG64(soap, &this->ns1__datafile::datasetId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::description);
	soap_serialize_PointerToint(soap, &this->ns1__datafile::fileSize);
	soap_serialize_PointerToLONG64(soap, &this->ns1__datafile::id);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::location);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::name);
	soap_serialize_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, &this->ns1__datafile::relatedDatafilesCollection1);
	soap_serialize_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, &this->ns1__datafile::relatedDatafilesCollection);
	soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::signature);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__datafile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__datafile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafile(struct soap *soap, const char *tag, int id, const ns1__datafile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__datafile), "ns1:datafile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "checksum", -1, &(a->ns1__datafile::checksum), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "command", -1, &(a->ns1__datafile::command), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datafileCreateTime", -1, &(a->ns1__datafile::datafileCreateTime), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileFormat(soap, "datafileFormat", -1, &(a->ns1__datafile::datafileFormat), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafileInclude(soap, "datafileInclude", -1, &(a->ns1__datafile::datafileInclude), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datafileModifyTime", -1, &(a->ns1__datafile::datafileModifyTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "datafileParameterCollection", -1, &(a->ns1__datafile::datafileParameterCollection), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "datafileVersion", -1, &(a->ns1__datafile::datafileVersion), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "datafileVersionComment", -1, &(a->ns1__datafile::datafileVersionComment), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__datafile::datasetId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__datafile::description), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "fileSize", -1, &(a->ns1__datafile::fileSize), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__datafile::id), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "location", -1, &(a->ns1__datafile::location), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__datafile::name), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, "relatedDatafilesCollection1", -1, &(a->ns1__datafile::relatedDatafilesCollection1), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, "relatedDatafilesCollection", -1, &(a->ns1__datafile::relatedDatafilesCollection), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "signature", -1, &(a->ns1__datafile::signature), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__datafile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__datafile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafile * SOAP_FMAC4 soap_in_ns1__datafile(struct soap *soap, const char *tag, ns1__datafile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__datafile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__datafile, sizeof(ns1__datafile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__datafile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__datafile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_checksum1 = 1;
	size_t soap_flag_command1 = 1;
	size_t soap_flag_datafileCreateTime1 = 1;
	size_t soap_flag_datafileFormat1 = 1;
	size_t soap_flag_datafileInclude1 = 1;
	size_t soap_flag_datafileModifyTime1 = 1;
	size_t soap_flag_datafileVersion1 = 1;
	size_t soap_flag_datafileVersionComment1 = 1;
	size_t soap_flag_datasetId1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_fileSize1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_location1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_signature1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_checksum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "checksum", &(a->ns1__datafile::checksum), "xsd:string"))
				{	soap_flag_checksum1--;
					continue;
				}
			if (soap_flag_command1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "command", &(a->ns1__datafile::command), "xsd:string"))
				{	soap_flag_command1--;
					continue;
				}
			if (soap_flag_datafileCreateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datafileCreateTime", &(a->ns1__datafile::datafileCreateTime), "xsd:dateTime"))
				{	soap_flag_datafileCreateTime1--;
					continue;
				}
			if (soap_flag_datafileFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileFormat(soap, "datafileFormat", &(a->ns1__datafile::datafileFormat), "ns1:datafileFormat"))
				{	soap_flag_datafileFormat1--;
					continue;
				}
			if (soap_flag_datafileInclude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafileInclude(soap, "datafileInclude", &(a->ns1__datafile::datafileInclude), "ns1:datafileInclude"))
				{	soap_flag_datafileInclude1--;
					continue;
				}
			if (soap_flag_datafileModifyTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datafileModifyTime", &(a->ns1__datafile::datafileModifyTime), "xsd:dateTime"))
				{	soap_flag_datafileModifyTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "datafileParameterCollection", &(a->ns1__datafile::datafileParameterCollection), "ns1:datafileParameter"))
					continue;
			if (soap_flag_datafileVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "datafileVersion", &(a->ns1__datafile::datafileVersion), "xsd:string"))
				{	soap_flag_datafileVersion1--;
					continue;
				}
			if (soap_flag_datafileVersionComment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "datafileVersionComment", &(a->ns1__datafile::datafileVersionComment), "xsd:string"))
				{	soap_flag_datafileVersionComment1--;
					continue;
				}
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__datafile::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__datafile::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_fileSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "fileSize", &(a->ns1__datafile::fileSize), "xsd:int"))
				{	soap_flag_fileSize1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__datafile::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "location", &(a->ns1__datafile::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__datafile::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, "relatedDatafilesCollection1", &(a->ns1__datafile::relatedDatafilesCollection1), "ns1:relatedDatafiles"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, "relatedDatafilesCollection", &(a->ns1__datafile::relatedDatafilesCollection), "ns1:relatedDatafiles"))
					continue;
			if (soap_flag_signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "signature", &(a->ns1__datafile::signature), "xsd:string"))
				{	soap_flag_signature1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__datafile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__datafile, 0, sizeof(ns1__datafile), 0, soap_copy_ns1__datafile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__datafile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__datafile);
	if (this->soap_out(soap, tag?tag:"ns1:datafile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__datafile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__datafile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafile * SOAP_FMAC4 soap_get_ns1__datafile(struct soap *soap, ns1__datafile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__datafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__datafile * SOAP_FMAC2 soap_instantiate_ns1__datafile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__datafile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafile);
		if (size)
			*size = sizeof(ns1__datafile);
		((ns1__datafile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__datafile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__datafile);
		for (int i = 0; i < n; i++)
			((ns1__datafile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__datafile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafile %p -> %p\n", q, p));
	*(ns1__datafile*)p = *(ns1__datafile*)q;
}

void ns1__createDataFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDataFile::sessionId = NULL;
	this->ns1__createDataFile::dataFile = NULL;
	this->ns1__createDataFile::datasetId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__createDataFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__createDataFile::sessionId);
	soap_serialize_PointerTons1__datafile(soap, &this->ns1__createDataFile::dataFile);
	soap_serialize_PointerToLONG64(soap, &this->ns1__createDataFile::datasetId);
	/* transient soap skipped */
}

int ns1__createDataFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDataFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDataFile(struct soap *soap, const char *tag, int id, const ns1__createDataFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDataFile), "ns1:createDataFile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__createDataFile::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTons1__datafile(soap, "dataFile", -1, &(a->ns1__createDataFile::dataFile), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "datasetId", -1, &(a->ns1__createDataFile::datasetId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__createDataFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDataFile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDataFile * SOAP_FMAC4 soap_in_ns1__createDataFile(struct soap *soap, const char *tag, ns1__createDataFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDataFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDataFile, sizeof(ns1__createDataFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDataFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDataFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_dataFile1 = 1;
	size_t soap_flag_datasetId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__createDataFile::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_dataFile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__datafile(soap, "dataFile", &(a->ns1__createDataFile::dataFile), "ns1:datafile"))
				{	soap_flag_dataFile1--;
					continue;
				}
			if (soap_flag_datasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "datasetId", &(a->ns1__createDataFile::datasetId), "xsd:long"))
				{	soap_flag_datasetId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDataFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDataFile, 0, sizeof(ns1__createDataFile), 0, soap_copy_ns1__createDataFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__createDataFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDataFile);
	if (this->soap_out(soap, tag?tag:"ns1:createDataFile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__createDataFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDataFile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDataFile * SOAP_FMAC4 soap_get_ns1__createDataFile(struct soap *soap, ns1__createDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__createDataFile * SOAP_FMAC2 soap_instantiate_ns1__createDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFile);
		if (size)
			*size = sizeof(ns1__createDataFile);
		((ns1__createDataFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDataFile);
		for (int i = 0; i < n; i++)
			((ns1__createDataFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDataFile %p -> %p\n", q, p));
	*(ns1__createDataFile*)p = *(ns1__createDataFile*)q;
}

void ns1__listInstrumentsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__listInstrumentsResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listInstrumentsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__listInstrumentsResponse::return_);
	/* transient soap skipped */
}

int ns1__listInstrumentsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listInstrumentsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listInstrumentsResponse(struct soap *soap, const char *tag, int id, const ns1__listInstrumentsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listInstrumentsResponse), "ns1:listInstrumentsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__listInstrumentsResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listInstrumentsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listInstrumentsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listInstrumentsResponse * SOAP_FMAC4 soap_in_ns1__listInstrumentsResponse(struct soap *soap, const char *tag, ns1__listInstrumentsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listInstrumentsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listInstrumentsResponse, sizeof(ns1__listInstrumentsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listInstrumentsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listInstrumentsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__listInstrumentsResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listInstrumentsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listInstrumentsResponse, 0, sizeof(ns1__listInstrumentsResponse), 0, soap_copy_ns1__listInstrumentsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listInstrumentsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listInstrumentsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listInstrumentsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listInstrumentsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listInstrumentsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listInstrumentsResponse * SOAP_FMAC4 soap_get_ns1__listInstrumentsResponse(struct soap *soap, ns1__listInstrumentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listInstrumentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listInstrumentsResponse * SOAP_FMAC2 soap_instantiate_ns1__listInstrumentsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listInstrumentsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listInstrumentsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInstrumentsResponse);
		if (size)
			*size = sizeof(ns1__listInstrumentsResponse);
		((ns1__listInstrumentsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInstrumentsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listInstrumentsResponse);
		for (int i = 0; i < n; i++)
			((ns1__listInstrumentsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listInstrumentsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listInstrumentsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listInstrumentsResponse %p -> %p\n", q, p));
	*(ns1__listInstrumentsResponse*)p = *(ns1__listInstrumentsResponse*)q;
}

void ns1__listInstruments::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listInstruments::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listInstruments::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listInstruments::sessionId);
	/* transient soap skipped */
}

int ns1__listInstruments::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listInstruments(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listInstruments(struct soap *soap, const char *tag, int id, const ns1__listInstruments *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listInstruments), "ns1:listInstruments"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listInstruments::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listInstruments::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listInstruments(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listInstruments * SOAP_FMAC4 soap_in_ns1__listInstruments(struct soap *soap, const char *tag, ns1__listInstruments *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listInstruments *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listInstruments, sizeof(ns1__listInstruments), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listInstruments)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listInstruments *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listInstruments::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listInstruments *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listInstruments, 0, sizeof(ns1__listInstruments), 0, soap_copy_ns1__listInstruments);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listInstruments::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listInstruments);
	if (this->soap_out(soap, tag?tag:"ns1:listInstruments", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listInstruments::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listInstruments(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listInstruments * SOAP_FMAC4 soap_get_ns1__listInstruments(struct soap *soap, ns1__listInstruments *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listInstruments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listInstruments * SOAP_FMAC2 soap_instantiate_ns1__listInstruments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listInstruments(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listInstruments, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInstruments);
		if (size)
			*size = sizeof(ns1__listInstruments);
		((ns1__listInstruments*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listInstruments[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listInstruments);
		for (int i = 0; i < n; i++)
			((ns1__listInstruments*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listInstruments*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listInstruments(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listInstruments %p -> %p\n", q, p));
	*(ns1__listInstruments*)p = *(ns1__listInstruments*)q;
}

void ns1__NoSuchObjectFoundException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NoSuchObjectFoundException::message = NULL;
	this->ns1__NoSuchObjectFoundException::stackTraceAsString = NULL;
	this->ns1__NoSuchObjectFoundException::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__NoSuchObjectFoundException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__NoSuchObjectFoundException::message);
	soap_serialize_PointerTostd__string(soap, &this->ns1__NoSuchObjectFoundException::stackTraceAsString);
	soap_serialize_PointerTostd__string(soap, &this->ns1__NoSuchObjectFoundException::uniqueId);
	/* transient soap skipped */
}

int ns1__NoSuchObjectFoundException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NoSuchObjectFoundException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoSuchObjectFoundException(struct soap *soap, const char *tag, int id, const ns1__NoSuchObjectFoundException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoSuchObjectFoundException), "ns1:NoSuchObjectFoundException"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns1__NoSuchObjectFoundException::message), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stackTraceAsString", -1, &(a->ns1__NoSuchObjectFoundException::stackTraceAsString), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__NoSuchObjectFoundException::uniqueId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NoSuchObjectFoundException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NoSuchObjectFoundException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NoSuchObjectFoundException * SOAP_FMAC4 soap_in_ns1__NoSuchObjectFoundException(struct soap *soap, const char *tag, ns1__NoSuchObjectFoundException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NoSuchObjectFoundException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoSuchObjectFoundException, sizeof(ns1__NoSuchObjectFoundException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__NoSuchObjectFoundException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__NoSuchObjectFoundException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_stackTraceAsString1 = 1;
	size_t soap_flag_uniqueId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->ns1__NoSuchObjectFoundException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_stackTraceAsString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stackTraceAsString", &(a->ns1__NoSuchObjectFoundException::stackTraceAsString), "xsd:string"))
				{	soap_flag_stackTraceAsString1--;
					continue;
				}
			if (soap_flag_uniqueId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__NoSuchObjectFoundException::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NoSuchObjectFoundException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoSuchObjectFoundException, 0, sizeof(ns1__NoSuchObjectFoundException), 0, soap_copy_ns1__NoSuchObjectFoundException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__NoSuchObjectFoundException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__NoSuchObjectFoundException);
	if (this->soap_out(soap, tag?tag:"ns1:NoSuchObjectFoundException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NoSuchObjectFoundException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NoSuchObjectFoundException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NoSuchObjectFoundException * SOAP_FMAC4 soap_get_ns1__NoSuchObjectFoundException(struct soap *soap, ns1__NoSuchObjectFoundException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoSuchObjectFoundException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__NoSuchObjectFoundException * SOAP_FMAC2 soap_instantiate_ns1__NoSuchObjectFoundException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NoSuchObjectFoundException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NoSuchObjectFoundException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchObjectFoundException);
		if (size)
			*size = sizeof(ns1__NoSuchObjectFoundException);
		((ns1__NoSuchObjectFoundException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchObjectFoundException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__NoSuchObjectFoundException);
		for (int i = 0; i < n; i++)
			((ns1__NoSuchObjectFoundException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__NoSuchObjectFoundException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__NoSuchObjectFoundException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__NoSuchObjectFoundException %p -> %p\n", q, p));
	*(ns1__NoSuchObjectFoundException*)p = *(ns1__NoSuchObjectFoundException*)q;
}

void ns1__InsufficientPrivilegesException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__InsufficientPrivilegesException::message = NULL;
	this->ns1__InsufficientPrivilegesException::stackTraceAsString = NULL;
	this->ns1__InsufficientPrivilegesException::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__InsufficientPrivilegesException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__InsufficientPrivilegesException::message);
	soap_serialize_PointerTostd__string(soap, &this->ns1__InsufficientPrivilegesException::stackTraceAsString);
	soap_serialize_PointerTostd__string(soap, &this->ns1__InsufficientPrivilegesException::uniqueId);
	/* transient soap skipped */
}

int ns1__InsufficientPrivilegesException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InsufficientPrivilegesException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsufficientPrivilegesException(struct soap *soap, const char *tag, int id, const ns1__InsufficientPrivilegesException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsufficientPrivilegesException), "ns1:InsufficientPrivilegesException"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns1__InsufficientPrivilegesException::message), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stackTraceAsString", -1, &(a->ns1__InsufficientPrivilegesException::stackTraceAsString), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__InsufficientPrivilegesException::uniqueId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__InsufficientPrivilegesException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__InsufficientPrivilegesException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InsufficientPrivilegesException * SOAP_FMAC4 soap_in_ns1__InsufficientPrivilegesException(struct soap *soap, const char *tag, ns1__InsufficientPrivilegesException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InsufficientPrivilegesException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsufficientPrivilegesException, sizeof(ns1__InsufficientPrivilegesException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__InsufficientPrivilegesException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__InsufficientPrivilegesException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_stackTraceAsString1 = 1;
	size_t soap_flag_uniqueId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->ns1__InsufficientPrivilegesException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_stackTraceAsString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stackTraceAsString", &(a->ns1__InsufficientPrivilegesException::stackTraceAsString), "xsd:string"))
				{	soap_flag_stackTraceAsString1--;
					continue;
				}
			if (soap_flag_uniqueId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__InsufficientPrivilegesException::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__InsufficientPrivilegesException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsufficientPrivilegesException, 0, sizeof(ns1__InsufficientPrivilegesException), 0, soap_copy_ns1__InsufficientPrivilegesException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__InsufficientPrivilegesException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__InsufficientPrivilegesException);
	if (this->soap_out(soap, tag?tag:"ns1:InsufficientPrivilegesException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InsufficientPrivilegesException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InsufficientPrivilegesException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InsufficientPrivilegesException * SOAP_FMAC4 soap_get_ns1__InsufficientPrivilegesException(struct soap *soap, ns1__InsufficientPrivilegesException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsufficientPrivilegesException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__InsufficientPrivilegesException * SOAP_FMAC2 soap_instantiate_ns1__InsufficientPrivilegesException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsufficientPrivilegesException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__InsufficientPrivilegesException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__InsufficientPrivilegesException);
		if (size)
			*size = sizeof(ns1__InsufficientPrivilegesException);
		((ns1__InsufficientPrivilegesException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__InsufficientPrivilegesException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__InsufficientPrivilegesException);
		for (int i = 0; i < n; i++)
			((ns1__InsufficientPrivilegesException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__InsufficientPrivilegesException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__InsufficientPrivilegesException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__InsufficientPrivilegesException %p -> %p\n", q, p));
	*(ns1__InsufficientPrivilegesException*)p = *(ns1__InsufficientPrivilegesException*)q;
}

void ns1__removeSampleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeSampleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeSampleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeSampleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeSampleResponse(struct soap *soap, const char *tag, int id, const ns1__removeSampleResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeSampleResponse");
}

void *ns1__removeSampleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeSampleResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeSampleResponse * SOAP_FMAC4 soap_in_ns1__removeSampleResponse(struct soap *soap, const char *tag, ns1__removeSampleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeSampleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeSampleResponse, sizeof(ns1__removeSampleResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeSampleResponse)
			return (ns1__removeSampleResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeSampleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeSampleResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeSampleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeSampleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeSampleResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeSampleResponse * SOAP_FMAC4 soap_get_ns1__removeSampleResponse(struct soap *soap, ns1__removeSampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeSampleResponse * SOAP_FMAC2 soap_instantiate_ns1__removeSampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeSampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeSampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleResponse);
		if (size)
			*size = sizeof(ns1__removeSampleResponse);
		((ns1__removeSampleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeSampleResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeSampleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeSampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeSampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeSampleResponse %p -> %p\n", q, p));
	*(ns1__removeSampleResponse*)p = *(ns1__removeSampleResponse*)q;
}

void ns1__removeSample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__removeSample::sessionId = NULL;
	this->ns1__removeSample::sampleId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__removeSample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__removeSample::sessionId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__removeSample::sampleId);
	/* transient soap skipped */
}

int ns1__removeSample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeSample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeSample(struct soap *soap, const char *tag, int id, const ns1__removeSample *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeSample), "ns1:removeSample"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__removeSample::sessionId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "sampleId", -1, &(a->ns1__removeSample::sampleId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeSample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeSample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeSample * SOAP_FMAC4 soap_in_ns1__removeSample(struct soap *soap, const char *tag, ns1__removeSample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeSample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeSample, sizeof(ns1__removeSample), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeSample)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeSample *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__removeSample::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "sampleId", &(a->ns1__removeSample::sampleId), "xsd:long"))
				{	soap_flag_sampleId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeSample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeSample, 0, sizeof(ns1__removeSample), 0, soap_copy_ns1__removeSample);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeSample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeSample);
	if (this->soap_out(soap, tag?tag:"ns1:removeSample", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeSample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeSample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeSample * SOAP_FMAC4 soap_get_ns1__removeSample(struct soap *soap, ns1__removeSample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeSample * SOAP_FMAC2 soap_instantiate_ns1__removeSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSample);
		if (size)
			*size = sizeof(ns1__removeSample);
		((ns1__removeSample*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeSample);
		for (int i = 0; i < n; i++)
			((ns1__removeSample*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeSample %p -> %p\n", q, p));
	*(ns1__removeSample*)p = *(ns1__removeSample*)q;
}

void ns1__icatRole::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__icatRole::actionDelete);
	soap_default_bool(soap, &this->ns1__icatRole::actionDownload);
	soap_default_bool(soap, &this->ns1__icatRole::actionFacilityAcquired);
	soap_default_bool(soap, &this->ns1__icatRole::actionInsert);
	soap_default_bool(soap, &this->ns1__icatRole::actionManageUsers);
	soap_default_bool(soap, &this->ns1__icatRole::actionRemove);
	soap_default_bool(soap, &this->ns1__icatRole::actionRootInsert);
	soap_default_bool(soap, &this->ns1__icatRole::actionRootRemove);
	soap_default_bool(soap, &this->ns1__icatRole::actionSelect);
	soap_default_bool(soap, &this->ns1__icatRole::actionUpdate);
	this->ns1__icatRole::role = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__icatRole::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__icatRole::role);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__icatRole::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__icatRole(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__icatRole(struct soap *soap, const char *tag, int id, const ns1__icatRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__icatRole), "ns1:icatRole"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionDelete", -1, &(a->ns1__icatRole::actionDelete), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionDownload", -1, &(a->ns1__icatRole::actionDownload), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionFacilityAcquired", -1, &(a->ns1__icatRole::actionFacilityAcquired), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionInsert", -1, &(a->ns1__icatRole::actionInsert), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionManageUsers", -1, &(a->ns1__icatRole::actionManageUsers), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionRemove", -1, &(a->ns1__icatRole::actionRemove), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionRootInsert", -1, &(a->ns1__icatRole::actionRootInsert), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionRootRemove", -1, &(a->ns1__icatRole::actionRootRemove), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionSelect", -1, &(a->ns1__icatRole::actionSelect), ""))
		return soap->error;
	if (soap_out_bool(soap, "actionUpdate", -1, &(a->ns1__icatRole::actionUpdate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "role", -1, &(a->ns1__icatRole::role), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__icatRole::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__icatRole(soap, tag, this, type);
}

SOAP_FMAC3 ns1__icatRole * SOAP_FMAC4 soap_in_ns1__icatRole(struct soap *soap, const char *tag, ns1__icatRole *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__icatRole *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__icatRole, sizeof(ns1__icatRole), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__icatRole)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__icatRole *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_actionDelete1 = 1;
	size_t soap_flag_actionDownload1 = 1;
	size_t soap_flag_actionFacilityAcquired1 = 1;
	size_t soap_flag_actionInsert1 = 1;
	size_t soap_flag_actionManageUsers1 = 1;
	size_t soap_flag_actionRemove1 = 1;
	size_t soap_flag_actionRootInsert1 = 1;
	size_t soap_flag_actionRootRemove1 = 1;
	size_t soap_flag_actionSelect1 = 1;
	size_t soap_flag_actionUpdate1 = 1;
	size_t soap_flag_role1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_actionDelete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionDelete", &(a->ns1__icatRole::actionDelete), "xsd:boolean"))
				{	soap_flag_actionDelete1--;
					continue;
				}
			if (soap_flag_actionDownload1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionDownload", &(a->ns1__icatRole::actionDownload), "xsd:boolean"))
				{	soap_flag_actionDownload1--;
					continue;
				}
			if (soap_flag_actionFacilityAcquired1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionFacilityAcquired", &(a->ns1__icatRole::actionFacilityAcquired), "xsd:boolean"))
				{	soap_flag_actionFacilityAcquired1--;
					continue;
				}
			if (soap_flag_actionInsert1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionInsert", &(a->ns1__icatRole::actionInsert), "xsd:boolean"))
				{	soap_flag_actionInsert1--;
					continue;
				}
			if (soap_flag_actionManageUsers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionManageUsers", &(a->ns1__icatRole::actionManageUsers), "xsd:boolean"))
				{	soap_flag_actionManageUsers1--;
					continue;
				}
			if (soap_flag_actionRemove1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionRemove", &(a->ns1__icatRole::actionRemove), "xsd:boolean"))
				{	soap_flag_actionRemove1--;
					continue;
				}
			if (soap_flag_actionRootInsert1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionRootInsert", &(a->ns1__icatRole::actionRootInsert), "xsd:boolean"))
				{	soap_flag_actionRootInsert1--;
					continue;
				}
			if (soap_flag_actionRootRemove1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionRootRemove", &(a->ns1__icatRole::actionRootRemove), "xsd:boolean"))
				{	soap_flag_actionRootRemove1--;
					continue;
				}
			if (soap_flag_actionSelect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionSelect", &(a->ns1__icatRole::actionSelect), "xsd:boolean"))
				{	soap_flag_actionSelect1--;
					continue;
				}
			if (soap_flag_actionUpdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actionUpdate", &(a->ns1__icatRole::actionUpdate), "xsd:boolean"))
				{	soap_flag_actionUpdate1--;
					continue;
				}
			if (soap_flag_role1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "role", &(a->ns1__icatRole::role), "xsd:string"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__icatRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__icatRole, 0, sizeof(ns1__icatRole), 0, soap_copy_ns1__icatRole);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0 || soap_flag_actionDelete1 > 0 || soap_flag_actionDownload1 > 0 || soap_flag_actionFacilityAcquired1 > 0 || soap_flag_actionInsert1 > 0 || soap_flag_actionManageUsers1 > 0 || soap_flag_actionRemove1 > 0 || soap_flag_actionRootInsert1 > 0 || soap_flag_actionRootRemove1 > 0 || soap_flag_actionSelect1 > 0 || soap_flag_actionUpdate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__icatRole::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__icatRole);
	if (this->soap_out(soap, tag?tag:"ns1:icatRole", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__icatRole::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__icatRole(soap, this, tag, type);
}

SOAP_FMAC3 ns1__icatRole * SOAP_FMAC4 soap_get_ns1__icatRole(struct soap *soap, ns1__icatRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__icatRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__icatRole * SOAP_FMAC2 soap_instantiate_ns1__icatRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__icatRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__icatRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__icatRole);
		if (size)
			*size = sizeof(ns1__icatRole);
		((ns1__icatRole*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__icatRole[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__icatRole);
		for (int i = 0; i < n; i++)
			((ns1__icatRole*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__icatRole*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__icatRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__icatRole %p -> %p\n", q, p));
	*(ns1__icatRole*)p = *(ns1__icatRole*)q;
}

void ns1__entityPrimaryKeyBaseBean::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__entityPrimaryKeyBaseBean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__entityPrimaryKeyBaseBean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__entityPrimaryKeyBaseBean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entityPrimaryKeyBaseBean(struct soap *soap, const char *tag, int id, const ns1__entityPrimaryKeyBaseBean *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:entityPrimaryKeyBaseBean");
}

void *ns1__entityPrimaryKeyBaseBean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__entityPrimaryKeyBaseBean(soap, tag, this, type);
}

SOAP_FMAC3 ns1__entityPrimaryKeyBaseBean * SOAP_FMAC4 soap_in_ns1__entityPrimaryKeyBaseBean(struct soap *soap, const char *tag, ns1__entityPrimaryKeyBaseBean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__entityPrimaryKeyBaseBean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__entityPrimaryKeyBaseBean, sizeof(ns1__entityPrimaryKeyBaseBean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__entityPrimaryKeyBaseBean)
			return (ns1__entityPrimaryKeyBaseBean *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__entityPrimaryKeyBaseBean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__entityPrimaryKeyBaseBean);
	if (this->soap_out(soap, tag?tag:"ns1:entityPrimaryKeyBaseBean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__entityPrimaryKeyBaseBean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__entityPrimaryKeyBaseBean(soap, this, tag, type);
}

SOAP_FMAC3 ns1__entityPrimaryKeyBaseBean * SOAP_FMAC4 soap_get_ns1__entityPrimaryKeyBaseBean(struct soap *soap, ns1__entityPrimaryKeyBaseBean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__entityPrimaryKeyBaseBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__entityPrimaryKeyBaseBean * SOAP_FMAC2 soap_instantiate_ns1__entityPrimaryKeyBaseBean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__entityPrimaryKeyBaseBean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__entityPrimaryKeyBaseBean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:sampleParameterPK"))
	{	cp->type = SOAP_TYPE_ns1__sampleParameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__sampleParameterPK);
			((ns1__sampleParameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__sampleParameterPK);
			for (int i = 0; i < n; i++)
				((ns1__sampleParameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__sampleParameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileFormatPK"))
	{	cp->type = SOAP_TYPE_ns1__datafileFormatPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormatPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileFormatPK);
			((ns1__datafileFormatPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormatPK[n]);
			if (size)
				*size = n * sizeof(ns1__datafileFormatPK);
			for (int i = 0; i < n; i++)
				((ns1__datafileFormatPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileFormatPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileParameterPK"))
	{	cp->type = SOAP_TYPE_ns1__datafileParameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileParameterPK);
			((ns1__datafileParameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__datafileParameterPK);
			for (int i = 0; i < n; i++)
				((ns1__datafileParameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileParameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:relatedDatafilesPK"))
	{	cp->type = SOAP_TYPE_ns1__relatedDatafilesPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafilesPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__relatedDatafilesPK);
			((ns1__relatedDatafilesPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafilesPK[n]);
			if (size)
				*size = n * sizeof(ns1__relatedDatafilesPK);
			for (int i = 0; i < n; i++)
				((ns1__relatedDatafilesPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__relatedDatafilesPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:investigatorPK"))
	{	cp->type = SOAP_TYPE_ns1__investigatorPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigatorPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__investigatorPK);
			((ns1__investigatorPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigatorPK[n]);
			if (size)
				*size = n * sizeof(ns1__investigatorPK);
			for (int i = 0; i < n; i++)
				((ns1__investigatorPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__investigatorPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:keywordPK"))
	{	cp->type = SOAP_TYPE_ns1__keywordPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__keywordPK);
			((ns1__keywordPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordPK[n]);
			if (size)
				*size = n * sizeof(ns1__keywordPK);
			for (int i = 0; i < n; i++)
				((ns1__keywordPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__keywordPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datasetParameterPK"))
	{	cp->type = SOAP_TYPE_ns1__datasetParameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datasetParameterPK);
			((ns1__datasetParameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__datasetParameterPK);
			for (int i = 0; i < n; i++)
				((ns1__datasetParameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datasetParameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:parameterPK"))
	{	cp->type = SOAP_TYPE_ns1__parameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__parameterPK);
			((ns1__parameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__parameterPK);
			for (int i = 0; i < n; i++)
				((ns1__parameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__parameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:shiftPK"))
	{	cp->type = SOAP_TYPE_ns1__shiftPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__shiftPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__shiftPK);
			((ns1__shiftPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__shiftPK[n]);
			if (size)
				*size = n * sizeof(ns1__shiftPK);
			for (int i = 0; i < n; i++)
				((ns1__shiftPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__shiftPK*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__entityPrimaryKeyBaseBean);
		if (size)
			*size = sizeof(ns1__entityPrimaryKeyBaseBean);
		((ns1__entityPrimaryKeyBaseBean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__entityPrimaryKeyBaseBean[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__entityPrimaryKeyBaseBean);
		for (int i = 0; i < n; i++)
			((ns1__entityPrimaryKeyBaseBean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__entityPrimaryKeyBaseBean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__entityPrimaryKeyBaseBean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__entityPrimaryKeyBaseBean %p -> %p\n", q, p));
	*(ns1__entityPrimaryKeyBaseBean*)p = *(ns1__entityPrimaryKeyBaseBean*)q;
}

void ns1__sampleParameterPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sampleParameterPK::name = NULL;
	this->ns1__sampleParameterPK::sampleId = NULL;
	this->ns1__sampleParameterPK::units = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__sampleParameterPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__sampleParameterPK::name);
	soap_serialize_PointerToLONG64(soap, &this->ns1__sampleParameterPK::sampleId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sampleParameterPK::units);
	/* transient soap skipped */
}

int ns1__sampleParameterPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sampleParameterPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sampleParameterPK(struct soap *soap, const char *tag, int id, const ns1__sampleParameterPK *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sampleParameterPK), "ns1:sampleParameterPK"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__sampleParameterPK::name), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "sampleId", -1, &(a->ns1__sampleParameterPK::sampleId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "units", -1, &(a->ns1__sampleParameterPK::units), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__sampleParameterPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sampleParameterPK(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sampleParameterPK * SOAP_FMAC4 soap_in_ns1__sampleParameterPK(struct soap *soap, const char *tag, ns1__sampleParameterPK *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sampleParameterPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sampleParameterPK, sizeof(ns1__sampleParameterPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sampleParameterPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sampleParameterPK *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_sampleId1 = 1;
	size_t soap_flag_units1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__sampleParameterPK::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_sampleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "sampleId", &(a->ns1__sampleParameterPK::sampleId), "xsd:long"))
				{	soap_flag_sampleId1--;
					continue;
				}
			if (soap_flag_units1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "units", &(a->ns1__sampleParameterPK::units), "xsd:string"))
				{	soap_flag_units1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sampleParameterPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sampleParameterPK, 0, sizeof(ns1__sampleParameterPK), 0, soap_copy_ns1__sampleParameterPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__sampleParameterPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__sampleParameterPK);
	if (this->soap_out(soap, tag?tag:"ns1:sampleParameterPK", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sampleParameterPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sampleParameterPK(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sampleParameterPK * SOAP_FMAC4 soap_get_ns1__sampleParameterPK(struct soap *soap, ns1__sampleParameterPK *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sampleParameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sampleParameterPK * SOAP_FMAC2 soap_instantiate_ns1__sampleParameterPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sampleParameterPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sampleParameterPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameterPK);
		if (size)
			*size = sizeof(ns1__sampleParameterPK);
		((ns1__sampleParameterPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameterPK[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__sampleParameterPK);
		for (int i = 0; i < n; i++)
			((ns1__sampleParameterPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__sampleParameterPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sampleParameterPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sampleParameterPK %p -> %p\n", q, p));
	*(ns1__sampleParameterPK*)p = *(ns1__sampleParameterPK*)q;
}

void ns1__sampleParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sampleParameter::description = NULL;
	this->ns1__sampleParameter::error = NULL;
	soap_default_bool(soap, &this->ns1__sampleParameter::numeric);
	this->ns1__sampleParameter::numericValue = NULL;
	this->ns1__sampleParameter::rangeBottom = NULL;
	this->ns1__sampleParameter::rangeTop = NULL;
	this->ns1__sampleParameter::sampleParameterPK = NULL;
	this->ns1__sampleParameter::stringValue = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__sampleParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__sampleParameter::description);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sampleParameter::error);
	soap_serialize_PointerTodouble(soap, &this->ns1__sampleParameter::numericValue);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sampleParameter::rangeBottom);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sampleParameter::rangeTop);
	soap_serialize_PointerTons1__sampleParameterPK(soap, &this->ns1__sampleParameter::sampleParameterPK);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sampleParameter::stringValue);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__sampleParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sampleParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sampleParameter(struct soap *soap, const char *tag, int id, const ns1__sampleParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sampleParameter), "ns1:sampleParameter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__sampleParameter::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "error", -1, &(a->ns1__sampleParameter::error), ""))
		return soap->error;
	if (soap_out_bool(soap, "numeric", -1, &(a->ns1__sampleParameter::numeric), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__sampleParameter::numericValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "rangeBottom", -1, &(a->ns1__sampleParameter::rangeBottom), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "rangeTop", -1, &(a->ns1__sampleParameter::rangeTop), ""))
		return soap->error;
	if (soap_out_PointerTons1__sampleParameterPK(soap, "sampleParameterPK", -1, &(a->ns1__sampleParameter::sampleParameterPK), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__sampleParameter::stringValue), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__sampleParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sampleParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sampleParameter * SOAP_FMAC4 soap_in_ns1__sampleParameter(struct soap *soap, const char *tag, ns1__sampleParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sampleParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sampleParameter, sizeof(ns1__sampleParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sampleParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sampleParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_error1 = 1;
	size_t soap_flag_numeric1 = 1;
	size_t soap_flag_numericValue1 = 1;
	size_t soap_flag_rangeBottom1 = 1;
	size_t soap_flag_rangeTop1 = 1;
	size_t soap_flag_sampleParameterPK1 = 1;
	size_t soap_flag_stringValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__sampleParameter::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "error", &(a->ns1__sampleParameter::error), "xsd:string"))
				{	soap_flag_error1--;
					continue;
				}
			if (soap_flag_numeric1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "numeric", &(a->ns1__sampleParameter::numeric), "xsd:boolean"))
				{	soap_flag_numeric1--;
					continue;
				}
			if (soap_flag_numericValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__sampleParameter::numericValue), "xsd:double"))
				{	soap_flag_numericValue1--;
					continue;
				}
			if (soap_flag_rangeBottom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "rangeBottom", &(a->ns1__sampleParameter::rangeBottom), "xsd:string"))
				{	soap_flag_rangeBottom1--;
					continue;
				}
			if (soap_flag_rangeTop1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "rangeTop", &(a->ns1__sampleParameter::rangeTop), "xsd:string"))
				{	soap_flag_rangeTop1--;
					continue;
				}
			if (soap_flag_sampleParameterPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sampleParameterPK(soap, "sampleParameterPK", &(a->ns1__sampleParameter::sampleParameterPK), "ns1:sampleParameterPK"))
				{	soap_flag_sampleParameterPK1--;
					continue;
				}
			if (soap_flag_stringValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__sampleParameter::stringValue), "xsd:string"))
				{	soap_flag_stringValue1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sampleParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sampleParameter, 0, sizeof(ns1__sampleParameter), 0, soap_copy_ns1__sampleParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0 || soap_flag_numeric1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sampleParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__sampleParameter);
	if (this->soap_out(soap, tag?tag:"ns1:sampleParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sampleParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sampleParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sampleParameter * SOAP_FMAC4 soap_get_ns1__sampleParameter(struct soap *soap, ns1__sampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sampleParameter * SOAP_FMAC2 soap_instantiate_ns1__sampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameter);
		if (size)
			*size = sizeof(ns1__sampleParameter);
		((ns1__sampleParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__sampleParameter);
		for (int i = 0; i < n; i++)
			((ns1__sampleParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__sampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sampleParameter %p -> %p\n", q, p));
	*(ns1__sampleParameter*)p = *(ns1__sampleParameter*)q;
}

void ns1__entityBaseBean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__entityBaseBean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__entityBaseBean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__entityBaseBean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entityBaseBean(struct soap *soap, const char *tag, int id, const ns1__entityBaseBean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__entityBaseBean), "ns1:entityBaseBean"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__entityBaseBean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__entityBaseBean(soap, tag, this, type);
}

SOAP_FMAC3 ns1__entityBaseBean * SOAP_FMAC4 soap_in_ns1__entityBaseBean(struct soap *soap, const char *tag, ns1__entityBaseBean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__entityBaseBean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__entityBaseBean, sizeof(ns1__entityBaseBean), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__entityBaseBean)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__entityBaseBean *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_facilityAcquiredData1 = 1;
	size_t soap_flag_icatRole1 = 1;
	size_t soap_flag_selected1 = 1;
	size_t soap_flag_uniqueId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData1--;
					continue;
				}
			if (soap_flag_icatRole1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole1--;
					continue;
				}
			if (soap_flag_selected1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected1--;
					continue;
				}
			if (soap_flag_uniqueId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__entityBaseBean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__entityBaseBean, 0, sizeof(ns1__entityBaseBean), 0, soap_copy_ns1__entityBaseBean);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData1 > 0 || soap_flag_selected1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__entityBaseBean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__entityBaseBean);
	if (this->soap_out(soap, tag?tag:"ns1:entityBaseBean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__entityBaseBean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__entityBaseBean(soap, this, tag, type);
}

SOAP_FMAC3 ns1__entityBaseBean * SOAP_FMAC4 soap_get_ns1__entityBaseBean(struct soap *soap, ns1__entityBaseBean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__entityBaseBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__entityBaseBean * SOAP_FMAC2 soap_instantiate_ns1__entityBaseBean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__entityBaseBean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__entityBaseBean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:sample"))
	{	cp->type = SOAP_TYPE_ns1__sample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__sample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__sample);
			((ns1__sample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__sample[n]);
			if (size)
				*size = n * sizeof(ns1__sample);
			for (int i = 0; i < n; i++)
				((ns1__sample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__sample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:sampleParameter"))
	{	cp->type = SOAP_TYPE_ns1__sampleParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__sampleParameter);
			((ns1__sampleParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameter[n]);
			if (size)
				*size = n * sizeof(ns1__sampleParameter);
			for (int i = 0; i < n; i++)
				((ns1__sampleParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__sampleParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:icatRole"))
	{	cp->type = SOAP_TYPE_ns1__icatRole;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatRole);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__icatRole);
			((ns1__icatRole*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatRole[n]);
			if (size)
				*size = n * sizeof(ns1__icatRole);
			for (int i = 0; i < n; i++)
				((ns1__icatRole*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__icatRole*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafile"))
	{	cp->type = SOAP_TYPE_ns1__datafile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafile);
			((ns1__datafile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafile[n]);
			if (size)
				*size = n * sizeof(ns1__datafile);
			for (int i = 0; i < n; i++)
				((ns1__datafile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileFormat"))
	{	cp->type = SOAP_TYPE_ns1__datafileFormat;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormat);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileFormat);
			((ns1__datafileFormat*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormat[n]);
			if (size)
				*size = n * sizeof(ns1__datafileFormat);
			for (int i = 0; i < n; i++)
				((ns1__datafileFormat*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileFormat*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileParameter"))
	{	cp->type = SOAP_TYPE_ns1__datafileParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileParameter);
			((ns1__datafileParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameter[n]);
			if (size)
				*size = n * sizeof(ns1__datafileParameter);
			for (int i = 0; i < n; i++)
				((ns1__datafileParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:relatedDatafiles"))
	{	cp->type = SOAP_TYPE_ns1__relatedDatafiles;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafiles);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__relatedDatafiles);
			((ns1__relatedDatafiles*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafiles[n]);
			if (size)
				*size = n * sizeof(ns1__relatedDatafiles);
			for (int i = 0; i < n; i++)
				((ns1__relatedDatafiles*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__relatedDatafiles*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:facilityCycle"))
	{	cp->type = SOAP_TYPE_ns1__facilityCycle;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityCycle);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__facilityCycle);
			((ns1__facilityCycle*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityCycle[n]);
			if (size)
				*size = n * sizeof(ns1__facilityCycle);
			for (int i = 0; i < n; i++)
				((ns1__facilityCycle*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__facilityCycle*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:facilityUser"))
	{	cp->type = SOAP_TYPE_ns1__facilityUser;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityUser);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__facilityUser);
			((ns1__facilityUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityUser[n]);
			if (size)
				*size = n * sizeof(ns1__facilityUser);
			for (int i = 0; i < n; i++)
				((ns1__facilityUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__facilityUser*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:dataset"))
	{	cp->type = SOAP_TYPE_ns1__dataset;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__dataset);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__dataset);
			((ns1__dataset*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__dataset[n]);
			if (size)
				*size = n * sizeof(ns1__dataset);
			for (int i = 0; i < n; i++)
				((ns1__dataset*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__dataset*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datasetParameter"))
	{	cp->type = SOAP_TYPE_ns1__datasetParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datasetParameter);
			((ns1__datasetParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameter[n]);
			if (size)
				*size = n * sizeof(ns1__datasetParameter);
			for (int i = 0; i < n; i++)
				((ns1__datasetParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datasetParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:parameter"))
	{	cp->type = SOAP_TYPE_ns1__parameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__parameter);
			((ns1__parameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameter[n]);
			if (size)
				*size = n * sizeof(ns1__parameter);
			for (int i = 0; i < n; i++)
				((ns1__parameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__parameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:investigation"))
	{	cp->type = SOAP_TYPE_ns1__investigation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__investigation);
			((ns1__investigation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigation[n]);
			if (size)
				*size = n * sizeof(ns1__investigation);
			for (int i = 0; i < n; i++)
				((ns1__investigation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__investigation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:investigator"))
	{	cp->type = SOAP_TYPE_ns1__investigator;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigator);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__investigator);
			((ns1__investigator*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigator[n]);
			if (size)
				*size = n * sizeof(ns1__investigator);
			for (int i = 0; i < n; i++)
				((ns1__investigator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__investigator*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:keyword"))
	{	cp->type = SOAP_TYPE_ns1__keyword;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__keyword);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__keyword);
			((ns1__keyword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__keyword[n]);
			if (size)
				*size = n * sizeof(ns1__keyword);
			for (int i = 0; i < n; i++)
				((ns1__keyword*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__keyword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:publication"))
	{	cp->type = SOAP_TYPE_ns1__publication;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__publication);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__publication);
			((ns1__publication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__publication[n]);
			if (size)
				*size = n * sizeof(ns1__publication);
			for (int i = 0; i < n; i++)
				((ns1__publication*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__publication*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:shift"))
	{	cp->type = SOAP_TYPE_ns1__shift;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__shift);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__shift);
			((ns1__shift*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__shift[n]);
			if (size)
				*size = n * sizeof(ns1__shift);
			for (int i = 0; i < n; i++)
				((ns1__shift*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__shift*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:icatAuthorisation"))
	{	cp->type = SOAP_TYPE_ns1__icatAuthorisation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatAuthorisation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__icatAuthorisation);
			((ns1__icatAuthorisation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatAuthorisation[n]);
			if (size)
				*size = n * sizeof(ns1__icatAuthorisation);
			for (int i = 0; i < n; i++)
				((ns1__icatAuthorisation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__icatAuthorisation*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__entityBaseBean);
		if (size)
			*size = sizeof(ns1__entityBaseBean);
		((ns1__entityBaseBean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__entityBaseBean[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__entityBaseBean);
		for (int i = 0; i < n; i++)
			((ns1__entityBaseBean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__entityBaseBean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__entityBaseBean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__entityBaseBean %p -> %p\n", q, p));
	*(ns1__entityBaseBean*)p = *(ns1__entityBaseBean*)q;
}

void ns1__sample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sample::chemicalFormula = NULL;
	this->ns1__sample::id = NULL;
	this->ns1__sample::instance = NULL;
	this->ns1__sample::name = NULL;
	this->ns1__sample::proposalSampleId = NULL;
	this->ns1__sample::safetyInformation = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__sampleParameter(soap, &this->ns1__sample::sampleParameterCollection);
	soap_default_bool(soap, &this->ns1__entityBaseBean::facilityAcquiredData);
	this->ns1__entityBaseBean::icatRole = NULL;
	soap_default_bool(soap, &this->ns1__entityBaseBean::selected);
	this->ns1__entityBaseBean::uniqueId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__sample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__sample::chemicalFormula);
	soap_serialize_PointerToLONG64(soap, &this->ns1__sample::id);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sample::instance);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sample::name);
	soap_serialize_PointerToint(soap, &this->ns1__sample::proposalSampleId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__sample::safetyInformation);
	soap_serialize_std__vectorTemplateOfPointerTons1__sampleParameter(soap, &this->ns1__sample::sampleParameterCollection);
	soap_serialize_PointerTons1__icatRole(soap, &this->ns1__entityBaseBean::icatRole);
	soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::uniqueId);
	/* transient soap skipped */
}

int ns1__sample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sample(struct soap *soap, const char *tag, int id, const ns1__sample *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sample), "ns1:sample"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "facilityAcquiredData", -1, &(a->ns1__entityBaseBean::facilityAcquiredData), ""))
		return soap->error;
	if (soap_out_PointerTons1__icatRole(soap, "icatRole", -1, &(a->ns1__entityBaseBean::icatRole), ""))
		return soap->error;
	if (soap_out_bool(soap, "selected", -1, &(a->ns1__entityBaseBean::selected), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uniqueId", -1, &(a->ns1__entityBaseBean::uniqueId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "chemicalFormula", -1, &(a->ns1__sample::chemicalFormula), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__sample::id), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "instance", -1, &(a->ns1__sample::instance), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__sample::name), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "proposalSampleId", -1, &(a->ns1__sample::proposalSampleId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "safetyInformation", -1, &(a->ns1__sample::safetyInformation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__sampleParameter(soap, "sampleParameterCollection", -1, &(a->ns1__sample::sampleParameterCollection), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__sample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sample * SOAP_FMAC4 soap_in_ns1__sample(struct soap *soap, const char *tag, ns1__sample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sample, sizeof(ns1__sample), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sample)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sample *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_facilityAcquiredData2 = 1;
	size_t soap_flag_icatRole2 = 1;
	size_t soap_flag_selected2 = 1;
	size_t soap_flag_uniqueId2 = 1;
	size_t soap_flag_chemicalFormula1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_instance1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_proposalSampleId1 = 1;
	size_t soap_flag_safetyInformation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_facilityAcquiredData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "facilityAcquiredData", &(a->ns1__entityBaseBean::facilityAcquiredData), "xsd:boolean"))
				{	soap_flag_facilityAcquiredData2--;
					continue;
				}
			if (soap_flag_icatRole2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__icatRole(soap, "icatRole", &(a->ns1__entityBaseBean::icatRole), "ns1:icatRole"))
				{	soap_flag_icatRole2--;
					continue;
				}
			if (soap_flag_selected2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "selected", &(a->ns1__entityBaseBean::selected), "xsd:boolean"))
				{	soap_flag_selected2--;
					continue;
				}
			if (soap_flag_uniqueId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uniqueId", &(a->ns1__entityBaseBean::uniqueId), "xsd:string"))
				{	soap_flag_uniqueId2--;
					continue;
				}
			if (soap_flag_chemicalFormula1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "chemicalFormula", &(a->ns1__sample::chemicalFormula), "xsd:string"))
				{	soap_flag_chemicalFormula1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__sample::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_instance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "instance", &(a->ns1__sample::instance), "xsd:string"))
				{	soap_flag_instance1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__sample::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_proposalSampleId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "proposalSampleId", &(a->ns1__sample::proposalSampleId), "xsd:int"))
				{	soap_flag_proposalSampleId1--;
					continue;
				}
			if (soap_flag_safetyInformation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "safetyInformation", &(a->ns1__sample::safetyInformation), "xsd:string"))
				{	soap_flag_safetyInformation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__sampleParameter(soap, "sampleParameterCollection", &(a->ns1__sample::sampleParameterCollection), "ns1:sampleParameter"))
					continue;
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sample, 0, sizeof(ns1__sample), 0, soap_copy_ns1__sample);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_facilityAcquiredData2 > 0 || soap_flag_selected2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__sample);
	if (this->soap_out(soap, tag?tag:"ns1:sample", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sample * SOAP_FMAC4 soap_get_ns1__sample(struct soap *soap, ns1__sample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sample * SOAP_FMAC2 soap_instantiate_ns1__sample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sample);
		if (size)
			*size = sizeof(ns1__sample);
		((ns1__sample*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__sample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__sample);
		for (int i = 0; i < n; i++)
			((ns1__sample*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__sample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sample %p -> %p\n", q, p));
	*(ns1__sample*)p = *(ns1__sample*)q;
}

void ns1__searchSamplesBySampleNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__searchSamplesBySampleNameResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchSamplesBySampleNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__searchSamplesBySampleNameResponse::return_);
	/* transient soap skipped */
}

int ns1__searchSamplesBySampleNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchSamplesBySampleNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchSamplesBySampleNameResponse(struct soap *soap, const char *tag, int id, const ns1__searchSamplesBySampleNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse), "ns1:searchSamplesBySampleNameResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__sample(soap, "return", -1, &(a->ns1__searchSamplesBySampleNameResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchSamplesBySampleNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchSamplesBySampleNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchSamplesBySampleNameResponse * SOAP_FMAC4 soap_in_ns1__searchSamplesBySampleNameResponse(struct soap *soap, const char *tag, ns1__searchSamplesBySampleNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchSamplesBySampleNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse, sizeof(ns1__searchSamplesBySampleNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchSamplesBySampleNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchSamplesBySampleNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__sample(soap, "return", &(a->ns1__searchSamplesBySampleNameResponse::return_), "ns1:sample"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchSamplesBySampleNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse, 0, sizeof(ns1__searchSamplesBySampleNameResponse), 0, soap_copy_ns1__searchSamplesBySampleNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchSamplesBySampleNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse);
	if (this->soap_out(soap, tag?tag:"ns1:searchSamplesBySampleNameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchSamplesBySampleNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchSamplesBySampleNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchSamplesBySampleNameResponse * SOAP_FMAC4 soap_get_ns1__searchSamplesBySampleNameResponse(struct soap *soap, ns1__searchSamplesBySampleNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchSamplesBySampleNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchSamplesBySampleNameResponse * SOAP_FMAC2 soap_instantiate_ns1__searchSamplesBySampleNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchSamplesBySampleNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleNameResponse);
		if (size)
			*size = sizeof(ns1__searchSamplesBySampleNameResponse);
		((ns1__searchSamplesBySampleNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchSamplesBySampleNameResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchSamplesBySampleNameResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchSamplesBySampleNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchSamplesBySampleNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchSamplesBySampleNameResponse %p -> %p\n", q, p));
	*(ns1__searchSamplesBySampleNameResponse*)p = *(ns1__searchSamplesBySampleNameResponse*)q;
}

void ns1__searchSamplesBySampleName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchSamplesBySampleName::sessionId = NULL;
	this->ns1__searchSamplesBySampleName::sampleName = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__searchSamplesBySampleName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchSamplesBySampleName::sessionId);
	soap_serialize_PointerTostd__string(soap, &this->ns1__searchSamplesBySampleName::sampleName);
	/* transient soap skipped */
}

int ns1__searchSamplesBySampleName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchSamplesBySampleName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchSamplesBySampleName(struct soap *soap, const char *tag, int id, const ns1__searchSamplesBySampleName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchSamplesBySampleName), "ns1:searchSamplesBySampleName"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchSamplesBySampleName::sessionId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sampleName", -1, &(a->ns1__searchSamplesBySampleName::sampleName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchSamplesBySampleName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchSamplesBySampleName(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchSamplesBySampleName * SOAP_FMAC4 soap_in_ns1__searchSamplesBySampleName(struct soap *soap, const char *tag, ns1__searchSamplesBySampleName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchSamplesBySampleName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchSamplesBySampleName, sizeof(ns1__searchSamplesBySampleName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchSamplesBySampleName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchSamplesBySampleName *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_sampleName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchSamplesBySampleName::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_sampleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sampleName", &(a->ns1__searchSamplesBySampleName::sampleName), "xsd:string"))
				{	soap_flag_sampleName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchSamplesBySampleName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchSamplesBySampleName, 0, sizeof(ns1__searchSamplesBySampleName), 0, soap_copy_ns1__searchSamplesBySampleName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__searchSamplesBySampleName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchSamplesBySampleName);
	if (this->soap_out(soap, tag?tag:"ns1:searchSamplesBySampleName", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchSamplesBySampleName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchSamplesBySampleName(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchSamplesBySampleName * SOAP_FMAC4 soap_get_ns1__searchSamplesBySampleName(struct soap *soap, ns1__searchSamplesBySampleName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchSamplesBySampleName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__searchSamplesBySampleName * SOAP_FMAC2 soap_instantiate_ns1__searchSamplesBySampleName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchSamplesBySampleName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchSamplesBySampleName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleName);
		if (size)
			*size = sizeof(ns1__searchSamplesBySampleName);
		((ns1__searchSamplesBySampleName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchSamplesBySampleName);
		for (int i = 0; i < n; i++)
			((ns1__searchSamplesBySampleName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchSamplesBySampleName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchSamplesBySampleName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchSamplesBySampleName %p -> %p\n", q, p));
	*(ns1__searchSamplesBySampleName*)p = *(ns1__searchSamplesBySampleName*)q;
}

void ns1__listDatasetTypesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__listDatasetTypesResponse::return_);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listDatasetTypesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__listDatasetTypesResponse::return_);
	/* transient soap skipped */
}

int ns1__listDatasetTypesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listDatasetTypesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listDatasetTypesResponse(struct soap *soap, const char *tag, int id, const ns1__listDatasetTypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listDatasetTypesResponse), "ns1:listDatasetTypesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__listDatasetTypesResponse::return_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listDatasetTypesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listDatasetTypesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listDatasetTypesResponse * SOAP_FMAC4 soap_in_ns1__listDatasetTypesResponse(struct soap *soap, const char *tag, ns1__listDatasetTypesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listDatasetTypesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listDatasetTypesResponse, sizeof(ns1__listDatasetTypesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listDatasetTypesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listDatasetTypesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__listDatasetTypesResponse::return_), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listDatasetTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listDatasetTypesResponse, 0, sizeof(ns1__listDatasetTypesResponse), 0, soap_copy_ns1__listDatasetTypesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listDatasetTypesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listDatasetTypesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listDatasetTypesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listDatasetTypesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listDatasetTypesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listDatasetTypesResponse * SOAP_FMAC4 soap_get_ns1__listDatasetTypesResponse(struct soap *soap, ns1__listDatasetTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listDatasetTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listDatasetTypesResponse * SOAP_FMAC2 soap_instantiate_ns1__listDatasetTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listDatasetTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listDatasetTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypesResponse);
		if (size)
			*size = sizeof(ns1__listDatasetTypesResponse);
		((ns1__listDatasetTypesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listDatasetTypesResponse);
		for (int i = 0; i < n; i++)
			((ns1__listDatasetTypesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listDatasetTypesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listDatasetTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listDatasetTypesResponse %p -> %p\n", q, p));
	*(ns1__listDatasetTypesResponse*)p = *(ns1__listDatasetTypesResponse*)q;
}

void ns1__listDatasetTypes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listDatasetTypes::sessionId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__listDatasetTypes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__listDatasetTypes::sessionId);
	/* transient soap skipped */
}

int ns1__listDatasetTypes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listDatasetTypes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listDatasetTypes(struct soap *soap, const char *tag, int id, const ns1__listDatasetTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listDatasetTypes), "ns1:listDatasetTypes"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__listDatasetTypes::sessionId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__listDatasetTypes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listDatasetTypes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listDatasetTypes * SOAP_FMAC4 soap_in_ns1__listDatasetTypes(struct soap *soap, const char *tag, ns1__listDatasetTypes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listDatasetTypes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listDatasetTypes, sizeof(ns1__listDatasetTypes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listDatasetTypes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listDatasetTypes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__listDatasetTypes::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listDatasetTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listDatasetTypes, 0, sizeof(ns1__listDatasetTypes), 0, soap_copy_ns1__listDatasetTypes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__listDatasetTypes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listDatasetTypes);
	if (this->soap_out(soap, tag?tag:"ns1:listDatasetTypes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listDatasetTypes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listDatasetTypes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listDatasetTypes * SOAP_FMAC4 soap_get_ns1__listDatasetTypes(struct soap *soap, ns1__listDatasetTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listDatasetTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listDatasetTypes * SOAP_FMAC2 soap_instantiate_ns1__listDatasetTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listDatasetTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listDatasetTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypes);
		if (size)
			*size = sizeof(ns1__listDatasetTypes);
		((ns1__listDatasetTypes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listDatasetTypes);
		for (int i = 0; i < n; i++)
			((ns1__listDatasetTypes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listDatasetTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listDatasetTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listDatasetTypes %p -> %p\n", q, p));
	*(ns1__listDatasetTypes*)p = *(ns1__listDatasetTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->xsd__string::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string::__item);
	/* transient soap skipped */
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag?tag:"xsd:string", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__string);
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->xsd__long::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__long::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__long::__item, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))
		return NULL;
	return a;
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag?tag:"xsd:long", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__long);
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__long[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__long);
		for (int i = 0; i < n; i++)
			((xsd__long*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__long*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->xsd__int::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__int::__item, SOAP_TYPE_int);
	/* transient soap skipped */
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag?tag:"xsd:int", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__int);
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__int[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__int);
		for (int i = 0; i < n; i++)
			((xsd__int*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__float::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->xsd__float::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__float::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__float::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float(struct soap *soap, const char *tag, int id, const xsd__float *a, const char *type)
{
	return soap_out_float(soap, tag, id, &(a->xsd__float::__item), "xsd:float");
}

void *xsd__float::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__float(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_in_xsd__float(struct soap *soap, const char *tag, xsd__float *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__float *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float, sizeof(xsd__float), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__float)
			return (xsd__float *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_float(soap, tag, &(a->xsd__float::__item), "xsd:float"))
		return NULL;
	return a;
}

int xsd__float::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float);
	if (this->soap_out(soap, tag?tag:"xsd:float", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__float::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_get_xsd__float(struct soap *soap, xsd__float *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__float, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__float);
		if (size)
			*size = sizeof(xsd__float);
		((xsd__float*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__float[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__float);
		for (int i = 0; i < n; i++)
			((xsd__float*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__float*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__float(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float %p -> %p\n", q, p));
	*(xsd__float*)p = *(xsd__float*)q;
}

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->xsd__double::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__double::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__double::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(a->xsd__double::__item), "xsd:double");
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(a->xsd__double::__item), "xsd:double"))
		return NULL;
	return a;
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (this->soap_out(soap, tag?tag:"xsd:double", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__double);
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__double[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__double);
		for (int i = 0; i < n; i++)
			((xsd__double*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->xsd__dateTime::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_time);
	/* transient soap skipped */
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag?tag:"xsd:dateTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__dateTime);
		for (int i = 0; i < n; i++)
			((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->xsd__boolean::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag?tag:"xsd:boolean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__boolean[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag?tag:"xsd:anyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__boolean[n]);
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime[n]);
			if (size)
				*size = n * sizeof(xsd__dateTime);
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__double);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__double[n]);
			if (size)
				*size = n * sizeof(xsd__double);
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__float);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__float);
			((xsd__float*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__float[n]);
			if (size)
				*size = n * sizeof(xsd__float);
			for (int i = 0; i < n; i++)
				((xsd__float*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__float*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__int);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__int[n]);
			if (size)
				*size = n * sizeof(xsd__int);
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__long);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__long[n]);
			if (size)
				*size = n * sizeof(xsd__long);
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__string);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__string[n]);
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileInclude"))
	{	cp->type = SOAP_TYPE_ns1__datafileInclude_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileInclude_);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileInclude_);
			((ns1__datafileInclude_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileInclude_[n]);
			if (size)
				*size = n * sizeof(ns1__datafileInclude_);
			for (int i = 0; i < n; i++)
				((ns1__datafileInclude_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileInclude_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:keywordType"))
	{	cp->type = SOAP_TYPE_ns1__keywordType_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordType_);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__keywordType_);
			((ns1__keywordType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordType_[n]);
			if (size)
				*size = n * sizeof(ns1__keywordType_);
			for (int i = 0; i < n; i++)
				((ns1__keywordType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__keywordType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:investigationInclude"))
	{	cp->type = SOAP_TYPE_ns1__investigationInclude_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigationInclude_);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__investigationInclude_);
			((ns1__investigationInclude_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigationInclude_[n]);
			if (size)
				*size = n * sizeof(ns1__investigationInclude_);
			for (int i = 0; i < n; i++)
				((ns1__investigationInclude_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__investigationInclude_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:elementType"))
	{	cp->type = SOAP_TYPE_ns1__elementType_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__elementType_);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__elementType_);
			((ns1__elementType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__elementType_[n]);
			if (size)
				*size = n * sizeof(ns1__elementType_);
			for (int i = 0; i < n; i++)
				((ns1__elementType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__elementType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datasetInclude"))
	{	cp->type = SOAP_TYPE_ns1__datasetInclude_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetInclude_);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datasetInclude_);
			((ns1__datasetInclude_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetInclude_[n]);
			if (size)
				*size = n * sizeof(ns1__datasetInclude_);
			for (int i = 0; i < n; i++)
				((ns1__datasetInclude_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datasetInclude_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listDatasetTypes"))
	{	cp->type = SOAP_TYPE_ns1__listDatasetTypes;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypes);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listDatasetTypes);
			((ns1__listDatasetTypes*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypes[n]);
			if (size)
				*size = n * sizeof(ns1__listDatasetTypes);
			for (int i = 0; i < n; i++)
				((ns1__listDatasetTypes*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listDatasetTypes*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listDatasetTypesResponse"))
	{	cp->type = SOAP_TYPE_ns1__listDatasetTypesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listDatasetTypesResponse);
			((ns1__listDatasetTypesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetTypesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listDatasetTypesResponse);
			for (int i = 0; i < n; i++)
				((ns1__listDatasetTypesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listDatasetTypesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchSamplesBySampleName"))
	{	cp->type = SOAP_TYPE_ns1__searchSamplesBySampleName;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleName);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchSamplesBySampleName);
			((ns1__searchSamplesBySampleName*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleName[n]);
			if (size)
				*size = n * sizeof(ns1__searchSamplesBySampleName);
			for (int i = 0; i < n; i++)
				((ns1__searchSamplesBySampleName*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchSamplesBySampleName*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchSamplesBySampleNameResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchSamplesBySampleNameResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleNameResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchSamplesBySampleNameResponse);
			((ns1__searchSamplesBySampleNameResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchSamplesBySampleNameResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchSamplesBySampleNameResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchSamplesBySampleNameResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchSamplesBySampleNameResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:entityBaseBean"))
	{	cp->type = SOAP_TYPE_ns1__entityBaseBean;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__entityBaseBean);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__entityBaseBean);
			((ns1__entityBaseBean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__entityBaseBean[n]);
			if (size)
				*size = n * sizeof(ns1__entityBaseBean);
			for (int i = 0; i < n; i++)
				((ns1__entityBaseBean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__entityBaseBean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:entityPrimaryKeyBaseBean"))
	{	cp->type = SOAP_TYPE_ns1__entityPrimaryKeyBaseBean;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__entityPrimaryKeyBaseBean);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__entityPrimaryKeyBaseBean);
			((ns1__entityPrimaryKeyBaseBean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__entityPrimaryKeyBaseBean[n]);
			if (size)
				*size = n * sizeof(ns1__entityPrimaryKeyBaseBean);
			for (int i = 0; i < n; i++)
				((ns1__entityPrimaryKeyBaseBean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__entityPrimaryKeyBaseBean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeSample"))
	{	cp->type = SOAP_TYPE_ns1__removeSample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeSample);
			((ns1__removeSample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSample[n]);
			if (size)
				*size = n * sizeof(ns1__removeSample);
			for (int i = 0; i < n; i++)
				((ns1__removeSample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeSample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeSampleResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeSampleResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeSampleResponse);
			((ns1__removeSampleResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeSampleResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeSampleResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeSampleResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:InsufficientPrivilegesException"))
	{	cp->type = SOAP_TYPE_ns1__InsufficientPrivilegesException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__InsufficientPrivilegesException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__InsufficientPrivilegesException);
			((ns1__InsufficientPrivilegesException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__InsufficientPrivilegesException[n]);
			if (size)
				*size = n * sizeof(ns1__InsufficientPrivilegesException);
			for (int i = 0; i < n; i++)
				((ns1__InsufficientPrivilegesException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__InsufficientPrivilegesException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:NoSuchObjectFoundException"))
	{	cp->type = SOAP_TYPE_ns1__NoSuchObjectFoundException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchObjectFoundException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__NoSuchObjectFoundException);
			((ns1__NoSuchObjectFoundException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchObjectFoundException[n]);
			if (size)
				*size = n * sizeof(ns1__NoSuchObjectFoundException);
			for (int i = 0; i < n; i++)
				((ns1__NoSuchObjectFoundException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__NoSuchObjectFoundException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listInstruments"))
	{	cp->type = SOAP_TYPE_ns1__listInstruments;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInstruments);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listInstruments);
			((ns1__listInstruments*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInstruments[n]);
			if (size)
				*size = n * sizeof(ns1__listInstruments);
			for (int i = 0; i < n; i++)
				((ns1__listInstruments*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listInstruments*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listInstrumentsResponse"))
	{	cp->type = SOAP_TYPE_ns1__listInstrumentsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInstrumentsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listInstrumentsResponse);
			((ns1__listInstrumentsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInstrumentsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listInstrumentsResponse);
			for (int i = 0; i < n; i++)
				((ns1__listInstrumentsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listInstrumentsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataFile"))
	{	cp->type = SOAP_TYPE_ns1__createDataFile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataFile);
			((ns1__createDataFile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFile[n]);
			if (size)
				*size = n * sizeof(ns1__createDataFile);
			for (int i = 0; i < n; i++)
				((ns1__createDataFile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataFile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataFileResponse"))
	{	cp->type = SOAP_TYPE_ns1__createDataFileResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFileResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataFileResponse);
			((ns1__createDataFileResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFileResponse[n]);
			if (size)
				*size = n * sizeof(ns1__createDataFileResponse);
			for (int i = 0; i < n; i++)
				((ns1__createDataFileResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataFileResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ValidationException"))
	{	cp->type = SOAP_TYPE_ns1__ValidationException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__ValidationException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ValidationException);
			((ns1__ValidationException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__ValidationException[n]);
			if (size)
				*size = n * sizeof(ns1__ValidationException);
			for (int i = 0; i < n; i++)
				((ns1__ValidationException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ValidationException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifySample"))
	{	cp->type = SOAP_TYPE_ns1__modifySample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifySample);
			((ns1__modifySample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySample[n]);
			if (size)
				*size = n * sizeof(ns1__modifySample);
			for (int i = 0; i < n; i++)
				((ns1__modifySample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifySample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifySampleResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifySampleResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifySampleResponse);
			((ns1__modifySampleResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifySampleResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifySampleResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifySampleResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataFile"))
	{	cp->type = SOAP_TYPE_ns1__removeDataFile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataFile);
			((ns1__removeDataFile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFile[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataFile);
			for (int i = 0; i < n; i++)
				((ns1__removeDataFile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataFile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataFileResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeDataFileResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataFileResponse);
			((ns1__removeDataFileResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataFileResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeDataFileResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataFileResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeAuthorisation"))
	{	cp->type = SOAP_TYPE_ns1__removeAuthorisation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeAuthorisation);
			((ns1__removeAuthorisation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisation[n]);
			if (size)
				*size = n * sizeof(ns1__removeAuthorisation);
			for (int i = 0; i < n; i++)
				((ns1__removeAuthorisation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeAuthorisation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeAuthorisationResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeAuthorisationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeAuthorisationResponse);
			((ns1__removeAuthorisationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeAuthorisationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeAuthorisationResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeAuthorisationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeAuthorisationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataFileParameters"))
	{	cp->type = SOAP_TYPE_ns1__addDataFileParameters;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameters);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataFileParameters);
			((ns1__addDataFileParameters*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameters[n]);
			if (size)
				*size = n * sizeof(ns1__addDataFileParameters);
			for (int i = 0; i < n; i++)
				((ns1__addDataFileParameters*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataFileParameters*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataFileParametersResponse"))
	{	cp->type = SOAP_TYPE_ns1__addDataFileParametersResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParametersResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataFileParametersResponse);
			((ns1__addDataFileParametersResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParametersResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addDataFileParametersResponse);
			for (int i = 0; i < n; i++)
				((ns1__addDataFileParametersResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataFileParametersResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listFacilityCycles"))
	{	cp->type = SOAP_TYPE_ns1__listFacilityCycles;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCycles);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listFacilityCycles);
			((ns1__listFacilityCycles*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCycles[n]);
			if (size)
				*size = n * sizeof(ns1__listFacilityCycles);
			for (int i = 0; i < n; i++)
				((ns1__listFacilityCycles*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listFacilityCycles*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listFacilityCyclesResponse"))
	{	cp->type = SOAP_TYPE_ns1__listFacilityCyclesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCyclesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listFacilityCyclesResponse);
			((ns1__listFacilityCyclesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listFacilityCyclesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listFacilityCyclesResponse);
			for (int i = 0; i < n; i++)
				((ns1__listFacilityCyclesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listFacilityCyclesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:logout"))
	{	cp->type = SOAP_TYPE_ns1__logout;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__logout);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__logout);
			((ns1__logout*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__logout[n]);
			if (size)
				*size = n * sizeof(ns1__logout);
			for (int i = 0; i < n; i++)
				((ns1__logout*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__logout*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:logoutResponse"))
	{	cp->type = SOAP_TYPE_ns1__logoutResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__logoutResponse);
			((ns1__logoutResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse[n]);
			if (size)
				*size = n * sizeof(ns1__logoutResponse);
			for (int i = 0; i < n; i++)
				((ns1__logoutResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__logoutResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:downloadDataset"))
	{	cp->type = SOAP_TYPE_ns1__downloadDataset;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDataset);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__downloadDataset);
			((ns1__downloadDataset*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDataset[n]);
			if (size)
				*size = n * sizeof(ns1__downloadDataset);
			for (int i = 0; i < n; i++)
				((ns1__downloadDataset*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__downloadDataset*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:downloadDatasetResponse"))
	{	cp->type = SOAP_TYPE_ns1__downloadDatasetResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatasetResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__downloadDatasetResponse);
			((ns1__downloadDatasetResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatasetResponse[n]);
			if (size)
				*size = n * sizeof(ns1__downloadDatasetResponse);
			for (int i = 0; i < n; i++)
				((ns1__downloadDatasetResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__downloadDatasetResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getFacilityUserByFederalId"))
	{	cp->type = SOAP_TYPE_ns1__getFacilityUserByFederalId;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalId);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getFacilityUserByFederalId);
			((ns1__getFacilityUserByFederalId*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalId[n]);
			if (size)
				*size = n * sizeof(ns1__getFacilityUserByFederalId);
			for (int i = 0; i < n; i++)
				((ns1__getFacilityUserByFederalId*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getFacilityUserByFederalId*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getFacilityUserByFederalIdResponse"))
	{	cp->type = SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalIdResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getFacilityUserByFederalIdResponse);
			((ns1__getFacilityUserByFederalIdResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFederalIdResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getFacilityUserByFederalIdResponse);
			for (int i = 0; i < n; i++)
				((ns1__getFacilityUserByFederalIdResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getFacilityUserByFederalIdResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeInvestigator"))
	{	cp->type = SOAP_TYPE_ns1__removeInvestigator;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigator);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeInvestigator);
			((ns1__removeInvestigator*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigator[n]);
			if (size)
				*size = n * sizeof(ns1__removeInvestigator);
			for (int i = 0; i < n; i++)
				((ns1__removeInvestigator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeInvestigator*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeInvestigatorResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeInvestigatorResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigatorResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeInvestigatorResponse);
			((ns1__removeInvestigatorResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigatorResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeInvestigatorResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeInvestigatorResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeInvestigatorResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeInvestigation"))
	{	cp->type = SOAP_TYPE_ns1__removeInvestigation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeInvestigation);
			((ns1__removeInvestigation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigation[n]);
			if (size)
				*size = n * sizeof(ns1__removeInvestigation);
			for (int i = 0; i < n; i++)
				((ns1__removeInvestigation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeInvestigation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeInvestigationResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeInvestigationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeInvestigationResponse);
			((ns1__removeInvestigationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeInvestigationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeInvestigationResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeInvestigationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeInvestigationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeKeyword"))
	{	cp->type = SOAP_TYPE_ns1__removeKeyword;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeyword);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeKeyword);
			((ns1__removeKeyword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeyword[n]);
			if (size)
				*size = n * sizeof(ns1__removeKeyword);
			for (int i = 0; i < n; i++)
				((ns1__removeKeyword*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeKeyword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeKeywordResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeKeywordResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeywordResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeKeywordResponse);
			((ns1__removeKeywordResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeKeywordResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeKeywordResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeKeywordResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeKeywordResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteInvestigation"))
	{	cp->type = SOAP_TYPE_ns1__deleteInvestigation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteInvestigation);
			((ns1__deleteInvestigation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigation[n]);
			if (size)
				*size = n * sizeof(ns1__deleteInvestigation);
			for (int i = 0; i < n; i++)
				((ns1__deleteInvestigation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteInvestigation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteInvestigationResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteInvestigationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteInvestigationResponse);
			((ns1__deleteInvestigationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteInvestigationResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteInvestigationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteInvestigationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataSets"))
	{	cp->type = SOAP_TYPE_ns1__createDataSets;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSets);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataSets);
			((ns1__createDataSets*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSets[n]);
			if (size)
				*size = n * sizeof(ns1__createDataSets);
			for (int i = 0; i < n; i++)
				((ns1__createDataSets*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataSets*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataSetsResponse"))
	{	cp->type = SOAP_TYPE_ns1__createDataSetsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataSetsResponse);
			((ns1__createDataSetsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__createDataSetsResponse);
			for (int i = 0; i < n; i++)
				((ns1__createDataSetsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataSetsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removePublication"))
	{	cp->type = SOAP_TYPE_ns1__removePublication;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removePublication);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removePublication);
			((ns1__removePublication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removePublication[n]);
			if (size)
				*size = n * sizeof(ns1__removePublication);
			for (int i = 0; i < n; i++)
				((ns1__removePublication*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removePublication*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removePublicationResponse"))
	{	cp->type = SOAP_TYPE_ns1__removePublicationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removePublicationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removePublicationResponse);
			((ns1__removePublicationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removePublicationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removePublicationResponse);
			for (int i = 0; i < n; i++)
				((ns1__removePublicationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removePublicationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getAllKeywords"))
	{	cp->type = SOAP_TYPE_ns1__getAllKeywords;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywords);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getAllKeywords);
			((ns1__getAllKeywords*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywords[n]);
			if (size)
				*size = n * sizeof(ns1__getAllKeywords);
			for (int i = 0; i < n; i++)
				((ns1__getAllKeywords*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getAllKeywords*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getAllKeywordsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getAllKeywordsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywordsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getAllKeywordsResponse);
			((ns1__getAllKeywordsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAllKeywordsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getAllKeywordsResponse);
			for (int i = 0; i < n; i++)
				((ns1__getAllKeywordsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getAllKeywordsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getUserDetails"))
	{	cp->type = SOAP_TYPE_ns1__getUserDetails;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetails);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getUserDetails);
			((ns1__getUserDetails*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetails[n]);
			if (size)
				*size = n * sizeof(ns1__getUserDetails);
			for (int i = 0; i < n; i++)
				((ns1__getUserDetails*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getUserDetails*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getUserDetailsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getUserDetailsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetailsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getUserDetailsResponse);
			((ns1__getUserDetailsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getUserDetailsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getUserDetailsResponse);
			for (int i = 0; i < n; i++)
				((ns1__getUserDetailsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getUserDetailsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:userDetails"))
	{	cp->type = SOAP_TYPE_ns1__userDetails;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__userDetails);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__userDetails);
			((ns1__userDetails*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__userDetails[n]);
			if (size)
				*size = n * sizeof(ns1__userDetails);
			for (int i = 0; i < n; i++)
				((ns1__userDetails*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__userDetails*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:NoSuchUserException"))
	{	cp->type = SOAP_TYPE_ns1__NoSuchUserException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchUserException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__NoSuchUserException);
			((ns1__NoSuchUserException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuchUserException[n]);
			if (size)
				*size = n * sizeof(ns1__NoSuchUserException);
			for (int i = 0; i < n; i++)
				((ns1__NoSuchUserException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__NoSuchUserException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:downloadDatafiles"))
	{	cp->type = SOAP_TYPE_ns1__downloadDatafiles;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafiles);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__downloadDatafiles);
			((ns1__downloadDatafiles*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafiles[n]);
			if (size)
				*size = n * sizeof(ns1__downloadDatafiles);
			for (int i = 0; i < n; i++)
				((ns1__downloadDatafiles*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__downloadDatafiles*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:downloadDatafilesResponse"))
	{	cp->type = SOAP_TYPE_ns1__downloadDatafilesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafilesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__downloadDatafilesResponse);
			((ns1__downloadDatafilesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafilesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__downloadDatafilesResponse);
			for (int i = 0; i < n; i++)
				((ns1__downloadDatafilesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__downloadDatafilesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataSet"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataSet;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSet);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataSet);
			((ns1__modifyDataSet*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSet[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataSet);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataSet*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataSet*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataSetResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataSetResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataSetResponse);
			((ns1__modifyDataSetResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataSetResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataSetResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataSetResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addSampleParameter"))
	{	cp->type = SOAP_TYPE_ns1__addSampleParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addSampleParameter);
			((ns1__addSampleParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameter[n]);
			if (size)
				*size = n * sizeof(ns1__addSampleParameter);
			for (int i = 0; i < n; i++)
				((ns1__addSampleParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addSampleParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addSampleParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__addSampleParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addSampleParameterResponse);
			((ns1__addSampleParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addSampleParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__addSampleParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addSampleParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getFacilityUserByFacilityUserId"))
	{	cp->type = SOAP_TYPE_ns1__getFacilityUserByFacilityUserId;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserId);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getFacilityUserByFacilityUserId);
			((ns1__getFacilityUserByFacilityUserId*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserId[n]);
			if (size)
				*size = n * sizeof(ns1__getFacilityUserByFacilityUserId);
			for (int i = 0; i < n; i++)
				((ns1__getFacilityUserByFacilityUserId*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getFacilityUserByFacilityUserId*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getFacilityUserByFacilityUserIdResponse"))
	{	cp->type = SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserIdResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getFacilityUserByFacilityUserIdResponse);
			((ns1__getFacilityUserByFacilityUserIdResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getFacilityUserByFacilityUserIdResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getFacilityUserByFacilityUserIdResponse);
			for (int i = 0; i < n; i++)
				((ns1__getFacilityUserByFacilityUserIdResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getFacilityUserByFacilityUserIdResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:checkDatafileDownloadAccess"))
	{	cp->type = SOAP_TYPE_ns1__checkDatafileDownloadAccess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccess);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__checkDatafileDownloadAccess);
			((ns1__checkDatafileDownloadAccess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccess[n]);
			if (size)
				*size = n * sizeof(ns1__checkDatafileDownloadAccess);
			for (int i = 0; i < n; i++)
				((ns1__checkDatafileDownloadAccess*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__checkDatafileDownloadAccess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:checkDatafileDownloadAccessResponse"))
	{	cp->type = SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccessResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__checkDatafileDownloadAccessResponse);
			((ns1__checkDatafileDownloadAccessResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatafileDownloadAccessResponse[n]);
			if (size)
				*size = n * sizeof(ns1__checkDatafileDownloadAccessResponse);
			for (int i = 0; i < n; i++)
				((ns1__checkDatafileDownloadAccessResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__checkDatafileDownloadAccessResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:downloadInfo"))
	{	cp->type = SOAP_TYPE_ns1__downloadInfo;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadInfo);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__downloadInfo);
			((ns1__downloadInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadInfo[n]);
			if (size)
				*size = n * sizeof(ns1__downloadInfo);
			for (int i = 0; i < n; i++)
				((ns1__downloadInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__downloadInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataFile"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataFile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataFile);
			((ns1__deleteDataFile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFile[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataFile);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataFile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataFile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataFileResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataFileResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataFileResponse);
			((ns1__deleteDataFileResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataFileResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataFileResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataFileResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserSurname"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserSurname;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurname);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserSurname);
			((ns1__searchByUserSurname*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurname[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserSurname);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserSurname*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserSurname*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserSurnameResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserSurnameResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnameResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserSurnameResponse);
			((ns1__searchByUserSurnameResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnameResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserSurnameResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserSurnameResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserSurnameResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserSurnamePagination"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserSurnamePagination;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePagination);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserSurnamePagination);
			((ns1__searchByUserSurnamePagination*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePagination[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserSurnamePagination);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserSurnamePagination*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserSurnamePagination*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserSurnamePaginationResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePaginationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserSurnamePaginationResponse);
			((ns1__searchByUserSurnamePaginationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserSurnamePaginationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserSurnamePaginationResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserSurnamePaginationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserSurnamePaginationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:checkDatasetDownloadAccess"))
	{	cp->type = SOAP_TYPE_ns1__checkDatasetDownloadAccess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccess);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__checkDatasetDownloadAccess);
			((ns1__checkDatasetDownloadAccess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccess[n]);
			if (size)
				*size = n * sizeof(ns1__checkDatasetDownloadAccess);
			for (int i = 0; i < n; i++)
				((ns1__checkDatasetDownloadAccess*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__checkDatasetDownloadAccess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:checkDatasetDownloadAccessResponse"))
	{	cp->type = SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccessResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__checkDatasetDownloadAccessResponse);
			((ns1__checkDatasetDownloadAccessResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__checkDatasetDownloadAccessResponse[n]);
			if (size)
				*size = n * sizeof(ns1__checkDatasetDownloadAccessResponse);
			for (int i = 0; i < n; i++)
				((ns1__checkDatasetDownloadAccessResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__checkDatasetDownloadAccessResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByKeywords"))
	{	cp->type = SOAP_TYPE_ns1__searchByKeywords;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywords);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByKeywords);
			((ns1__searchByKeywords*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywords[n]);
			if (size)
				*size = n * sizeof(ns1__searchByKeywords);
			for (int i = 0; i < n; i++)
				((ns1__searchByKeywords*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByKeywords*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByKeywordsResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByKeywordsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByKeywordsResponse);
			((ns1__searchByKeywordsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByKeywordsResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByKeywordsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByKeywordsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByKeywordsAll"))
	{	cp->type = SOAP_TYPE_ns1__searchByKeywordsAll;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAll);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByKeywordsAll);
			((ns1__searchByKeywordsAll*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAll[n]);
			if (size)
				*size = n * sizeof(ns1__searchByKeywordsAll);
			for (int i = 0; i < n; i++)
				((ns1__searchByKeywordsAll*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByKeywordsAll*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:keywordDetails"))
	{	cp->type = SOAP_TYPE_ns1__keywordDetails;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordDetails);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__keywordDetails);
			((ns1__keywordDetails*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordDetails[n]);
			if (size)
				*size = n * sizeof(ns1__keywordDetails);
			for (int i = 0; i < n; i++)
				((ns1__keywordDetails*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__keywordDetails*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByKeywordsAllResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByKeywordsAllResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAllResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByKeywordsAllResponse);
			((ns1__searchByKeywordsAllResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByKeywordsAllResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByKeywordsAllResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByKeywordsAllResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByKeywordsAllResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyInvestigations"))
	{	cp->type = SOAP_TYPE_ns1__getMyInvestigations;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigations);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getMyInvestigations);
			((ns1__getMyInvestigations*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigations[n]);
			if (size)
				*size = n * sizeof(ns1__getMyInvestigations);
			for (int i = 0; i < n; i++)
				((ns1__getMyInvestigations*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getMyInvestigations*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyInvestigationsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getMyInvestigationsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getMyInvestigationsResponse);
			((ns1__getMyInvestigationsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getMyInvestigationsResponse);
			for (int i = 0; i < n; i++)
				((ns1__getMyInvestigationsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getMyInvestigationsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyInvestigationsIncludes"))
	{	cp->type = SOAP_TYPE_ns1__getMyInvestigationsIncludes;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludes);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getMyInvestigationsIncludes);
			((ns1__getMyInvestigationsIncludes*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludes[n]);
			if (size)
				*size = n * sizeof(ns1__getMyInvestigationsIncludes);
			for (int i = 0; i < n; i++)
				((ns1__getMyInvestigationsIncludes*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getMyInvestigationsIncludes*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyInvestigationsIncludesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getMyInvestigationsIncludesResponse);
			((ns1__getMyInvestigationsIncludesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getMyInvestigationsIncludesResponse);
			for (int i = 0; i < n; i++)
				((ns1__getMyInvestigationsIncludesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getMyInvestigationsIncludesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyInvestigationsIncludesPagination"))
	{	cp->type = SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPagination);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getMyInvestigationsIncludesPagination);
			((ns1__getMyInvestigationsIncludesPagination*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPagination[n]);
			if (size)
				*size = n * sizeof(ns1__getMyInvestigationsIncludesPagination);
			for (int i = 0; i < n; i++)
				((ns1__getMyInvestigationsIncludesPagination*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getMyInvestigationsIncludesPagination*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyInvestigationsIncludesPaginationResponse"))
	{	cp->type = SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPaginationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getMyInvestigationsIncludesPaginationResponse);
			((ns1__getMyInvestigationsIncludesPaginationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyInvestigationsIncludesPaginationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getMyInvestigationsIncludesPaginationResponse);
			for (int i = 0; i < n; i++)
				((ns1__getMyInvestigationsIncludesPaginationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getMyInvestigationsIncludesPaginationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataSetParameter"))
	{	cp->type = SOAP_TYPE_ns1__removeDataSetParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataSetParameter);
			((ns1__removeDataSetParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameter[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataSetParameter);
			for (int i = 0; i < n; i++)
				((ns1__removeDataSetParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataSetParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataSetParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeDataSetParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataSetParameterResponse);
			((ns1__removeDataSetParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataSetParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeDataSetParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataSetParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyPublication"))
	{	cp->type = SOAP_TYPE_ns1__modifyPublication;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublication);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyPublication);
			((ns1__modifyPublication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublication[n]);
			if (size)
				*size = n * sizeof(ns1__modifyPublication);
			for (int i = 0; i < n; i++)
				((ns1__modifyPublication*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyPublication*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyPublicationResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifyPublicationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublicationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyPublicationResponse);
			((ns1__modifyPublicationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyPublicationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifyPublicationResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifyPublicationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyPublicationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserID"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserID;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserID);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserID);
			((ns1__searchByUserID*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserID[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserID);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserID*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserID*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserIDResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserIDResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserIDResponse);
			((ns1__searchByUserIDResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserIDResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserIDResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserIDResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserIDPagination"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserIDPagination;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPagination);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserIDPagination);
			((ns1__searchByUserIDPagination*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPagination[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserIDPagination);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserIDPagination*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserIDPagination*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByUserIDPaginationResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByUserIDPaginationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPaginationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByUserIDPaginationResponse);
			((ns1__searchByUserIDPaginationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByUserIDPaginationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByUserIDPaginationResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByUserIDPaginationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByUserIDPaginationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataFileParameter"))
	{	cp->type = SOAP_TYPE_ns1__removeDataFileParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataFileParameter);
			((ns1__removeDataFileParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameter[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataFileParameter);
			for (int i = 0; i < n; i++)
				((ns1__removeDataFileParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataFileParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataFileParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeDataFileParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataFileParameterResponse);
			((ns1__removeDataFileParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataFileParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataFileParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeDataFileParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataFileParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getInvestigationsIncludes"))
	{	cp->type = SOAP_TYPE_ns1__getInvestigationsIncludes;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludes);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getInvestigationsIncludes);
			((ns1__getInvestigationsIncludes*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludes[n]);
			if (size)
				*size = n * sizeof(ns1__getInvestigationsIncludes);
			for (int i = 0; i < n; i++)
				((ns1__getInvestigationsIncludes*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getInvestigationsIncludes*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getInvestigationsIncludesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getInvestigationsIncludesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getInvestigationsIncludesResponse);
			((ns1__getInvestigationsIncludesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationsIncludesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getInvestigationsIncludesResponse);
			for (int i = 0; i < n; i++)
				((ns1__getInvestigationsIncludesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getInvestigationsIncludesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataSet"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataSet;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSet);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataSet);
			((ns1__deleteDataSet*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSet[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataSet);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataSet*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataSet*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataSetResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataSetResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataSetResponse);
			((ns1__deleteDataSetResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataSetResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataSetResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataSetResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatafiles"))
	{	cp->type = SOAP_TYPE_ns1__getDatafiles;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafiles);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatafiles);
			((ns1__getDatafiles*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafiles[n]);
			if (size)
				*size = n * sizeof(ns1__getDatafiles);
			for (int i = 0; i < n; i++)
				((ns1__getDatafiles*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatafiles*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatafilesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getDatafilesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafilesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatafilesResponse);
			((ns1__getDatafilesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafilesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getDatafilesResponse);
			for (int i = 0; i < n; i++)
				((ns1__getDatafilesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatafilesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getICATAPIVersion"))
	{	cp->type = SOAP_TYPE_ns1__getICATAPIVersion;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersion);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getICATAPIVersion);
			((ns1__getICATAPIVersion*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersion[n]);
			if (size)
				*size = n * sizeof(ns1__getICATAPIVersion);
			for (int i = 0; i < n; i++)
				((ns1__getICATAPIVersion*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getICATAPIVersion*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getICATAPIVersionResponse"))
	{	cp->type = SOAP_TYPE_ns1__getICATAPIVersionResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersionResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getICATAPIVersionResponse);
			((ns1__getICATAPIVersionResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getICATAPIVersionResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getICATAPIVersionResponse);
			for (int i = 0; i < n; i++)
				((ns1__getICATAPIVersionResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getICATAPIVersionResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteInvestigator"))
	{	cp->type = SOAP_TYPE_ns1__deleteInvestigator;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigator);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteInvestigator);
			((ns1__deleteInvestigator*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigator[n]);
			if (size)
				*size = n * sizeof(ns1__deleteInvestigator);
			for (int i = 0; i < n; i++)
				((ns1__deleteInvestigator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteInvestigator*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteInvestigatorResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteInvestigatorResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigatorResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteInvestigatorResponse);
			((ns1__deleteInvestigatorResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteInvestigatorResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteInvestigatorResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteInvestigatorResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteInvestigatorResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addInvestigator"))
	{	cp->type = SOAP_TYPE_ns1__addInvestigator;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigator);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addInvestigator);
			((ns1__addInvestigator*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigator[n]);
			if (size)
				*size = n * sizeof(ns1__addInvestigator);
			for (int i = 0; i < n; i++)
				((ns1__addInvestigator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addInvestigator*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addInvestigatorResponse"))
	{	cp->type = SOAP_TYPE_ns1__addInvestigatorResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigatorResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addInvestigatorResponse);
			((ns1__addInvestigatorResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addInvestigatorResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addInvestigatorResponse);
			for (int i = 0; i < n; i++)
				((ns1__addInvestigatorResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addInvestigatorResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataSet"))
	{	cp->type = SOAP_TYPE_ns1__createDataSet;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSet);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataSet);
			((ns1__createDataSet*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSet[n]);
			if (size)
				*size = n * sizeof(ns1__createDataSet);
			for (int i = 0; i < n; i++)
				((ns1__createDataSet*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataSet*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataSetResponse"))
	{	cp->type = SOAP_TYPE_ns1__createDataSetResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataSetResponse);
			((ns1__createDataSetResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataSetResponse[n]);
			if (size)
				*size = n * sizeof(ns1__createDataSetResponse);
			for (int i = 0; i < n; i++)
				((ns1__createDataSetResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataSetResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeSampleParameter"))
	{	cp->type = SOAP_TYPE_ns1__removeSampleParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeSampleParameter);
			((ns1__removeSampleParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameter[n]);
			if (size)
				*size = n * sizeof(ns1__removeSampleParameter);
			for (int i = 0; i < n; i++)
				((ns1__removeSampleParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeSampleParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeSampleParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeSampleParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeSampleParameterResponse);
			((ns1__removeSampleParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeSampleParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeSampleParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeSampleParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeSampleParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataSetParameter"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataSetParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataSetParameter);
			((ns1__deleteDataSetParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameter[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataSetParameter);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataSetParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataSetParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataSetParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataSetParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataSetParameterResponse);
			((ns1__deleteDataSetParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataSetParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataSetParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataSetParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataSetParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:setDataSetSample"))
	{	cp->type = SOAP_TYPE_ns1__setDataSetSample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__setDataSetSample);
			((ns1__setDataSetSample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSample[n]);
			if (size)
				*size = n * sizeof(ns1__setDataSetSample);
			for (int i = 0; i < n; i++)
				((ns1__setDataSetSample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__setDataSetSample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:setDataSetSampleResponse"))
	{	cp->type = SOAP_TYPE_ns1__setDataSetSampleResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSampleResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__setDataSetSampleResponse);
			((ns1__setDataSetSampleResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__setDataSetSampleResponse[n]);
			if (size)
				*size = n * sizeof(ns1__setDataSetSampleResponse);
			for (int i = 0; i < n; i++)
				((ns1__setDataSetSampleResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__setDataSetSampleResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:downloadDatafile"))
	{	cp->type = SOAP_TYPE_ns1__downloadDatafile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__downloadDatafile);
			((ns1__downloadDatafile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafile[n]);
			if (size)
				*size = n * sizeof(ns1__downloadDatafile);
			for (int i = 0; i < n; i++)
				((ns1__downloadDatafile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__downloadDatafile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:downloadDatafileResponse"))
	{	cp->type = SOAP_TYPE_ns1__downloadDatafileResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafileResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__downloadDatafileResponse);
			((ns1__downloadDatafileResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__downloadDatafileResponse[n]);
			if (size)
				*size = n * sizeof(ns1__downloadDatafileResponse);
			for (int i = 0; i < n; i++)
				((ns1__downloadDatafileResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__downloadDatafileResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUser"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUser;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUser);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUser);
			((ns1__getKeywordsForUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUser[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUser);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUser*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUserResponse"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUserResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUserResponse);
			((ns1__getKeywordsForUserResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUserResponse);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUserResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUserStartWithMax"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUserStartWithMax;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMax);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUserStartWithMax);
			((ns1__getKeywordsForUserStartWithMax*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMax[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUserStartWithMax);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUserStartWithMax*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUserStartWithMax*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUserStartWithMaxResponse"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMaxResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUserStartWithMaxResponse);
			((ns1__getKeywordsForUserStartWithMaxResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserStartWithMaxResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUserStartWithMaxResponse);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUserStartWithMaxResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUserStartWithMaxResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUserMax"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUserMax;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMax);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUserMax);
			((ns1__getKeywordsForUserMax*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMax[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUserMax);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUserMax*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUserMax*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUserMaxResponse"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUserMaxResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMaxResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUserMaxResponse);
			((ns1__getKeywordsForUserMaxResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserMaxResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUserMaxResponse);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUserMaxResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUserMaxResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUserType"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUserType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUserType);
			((ns1__getKeywordsForUserType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserType[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUserType);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUserType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUserType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getKeywordsForUserTypeResponse"))
	{	cp->type = SOAP_TYPE_ns1__getKeywordsForUserTypeResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserTypeResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getKeywordsForUserTypeResponse);
			((ns1__getKeywordsForUserTypeResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getKeywordsForUserTypeResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getKeywordsForUserTypeResponse);
			for (int i = 0; i < n; i++)
				((ns1__getKeywordsForUserTypeResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getKeywordsForUserTypeResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listInvestigationTypes"))
	{	cp->type = SOAP_TYPE_ns1__listInvestigationTypes;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypes);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listInvestigationTypes);
			((ns1__listInvestigationTypes*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypes[n]);
			if (size)
				*size = n * sizeof(ns1__listInvestigationTypes);
			for (int i = 0; i < n; i++)
				((ns1__listInvestigationTypes*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listInvestigationTypes*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listInvestigationTypesResponse"))
	{	cp->type = SOAP_TYPE_ns1__listInvestigationTypesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listInvestigationTypesResponse);
			((ns1__listInvestigationTypesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listInvestigationTypesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listInvestigationTypesResponse);
			for (int i = 0; i < n; i++)
				((ns1__listInvestigationTypesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listInvestigationTypesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataSetParameter"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataSetParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataSetParameter);
			((ns1__modifyDataSetParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameter[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataSetParameter);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataSetParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataSetParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataSetParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataSetParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataSetParameterResponse);
			((ns1__modifyDataSetParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataSetParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataSetParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataSetParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataSetParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataSet"))
	{	cp->type = SOAP_TYPE_ns1__removeDataSet;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSet);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataSet);
			((ns1__removeDataSet*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSet[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataSet);
			for (int i = 0; i < n; i++)
				((ns1__removeDataSet*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataSet*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeDataSetResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeDataSetResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__removeDataSetResponse);
			((ns1__removeDataSetResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeDataSetResponse[n]);
			if (size)
				*size = n * sizeof(ns1__removeDataSetResponse);
			for (int i = 0; i < n; i++)
				((ns1__removeDataSetResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__removeDataSetResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getAuthorisations"))
	{	cp->type = SOAP_TYPE_ns1__getAuthorisations;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisations);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getAuthorisations);
			((ns1__getAuthorisations*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisations[n]);
			if (size)
				*size = n * sizeof(ns1__getAuthorisations);
			for (int i = 0; i < n; i++)
				((ns1__getAuthorisations*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getAuthorisations*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getAuthorisationsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getAuthorisationsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisationsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getAuthorisationsResponse);
			((ns1__getAuthorisationsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getAuthorisationsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getAuthorisationsResponse);
			for (int i = 0; i < n; i++)
				((ns1__getAuthorisationsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getAuthorisationsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addKeyword"))
	{	cp->type = SOAP_TYPE_ns1__addKeyword;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addKeyword);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addKeyword);
			((ns1__addKeyword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addKeyword[n]);
			if (size)
				*size = n * sizeof(ns1__addKeyword);
			for (int i = 0; i < n; i++)
				((ns1__addKeyword*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addKeyword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addKeywordResponse"))
	{	cp->type = SOAP_TYPE_ns1__addKeywordResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addKeywordResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addKeywordResponse);
			((ns1__addKeywordResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addKeywordResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addKeywordResponse);
			for (int i = 0; i < n; i++)
				((ns1__addKeywordResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addKeywordResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyInvestigation"))
	{	cp->type = SOAP_TYPE_ns1__modifyInvestigation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyInvestigation);
			((ns1__modifyInvestigation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigation[n]);
			if (size)
				*size = n * sizeof(ns1__modifyInvestigation);
			for (int i = 0; i < n; i++)
				((ns1__modifyInvestigation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyInvestigation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyInvestigationResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifyInvestigationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyInvestigationResponse);
			((ns1__modifyInvestigationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifyInvestigationResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifyInvestigationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyInvestigationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listDatasetStatus"))
	{	cp->type = SOAP_TYPE_ns1__listDatasetStatus;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatus);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listDatasetStatus);
			((ns1__listDatasetStatus*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatus[n]);
			if (size)
				*size = n * sizeof(ns1__listDatasetStatus);
			for (int i = 0; i < n; i++)
				((ns1__listDatasetStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listDatasetStatus*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listDatasetStatusResponse"))
	{	cp->type = SOAP_TYPE_ns1__listDatasetStatusResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatusResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listDatasetStatusResponse);
			((ns1__listDatasetStatusResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatasetStatusResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listDatasetStatusResponse);
			for (int i = 0; i < n; i++)
				((ns1__listDatasetStatusResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listDatasetStatusResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteSample"))
	{	cp->type = SOAP_TYPE_ns1__deleteSample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteSample);
			((ns1__deleteSample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSample[n]);
			if (size)
				*size = n * sizeof(ns1__deleteSample);
			for (int i = 0; i < n; i++)
				((ns1__deleteSample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteSample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteSampleResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteSampleResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteSampleResponse);
			((ns1__deleteSampleResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteSampleResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteSampleResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteSampleResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteKeyword"))
	{	cp->type = SOAP_TYPE_ns1__deleteKeyword;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeyword);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteKeyword);
			((ns1__deleteKeyword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeyword[n]);
			if (size)
				*size = n * sizeof(ns1__deleteKeyword);
			for (int i = 0; i < n; i++)
				((ns1__deleteKeyword*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteKeyword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteKeywordResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteKeywordResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeywordResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteKeywordResponse);
			((ns1__deleteKeywordResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteKeywordResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteKeywordResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteKeywordResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteKeywordResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataSetParameters"))
	{	cp->type = SOAP_TYPE_ns1__addDataSetParameters;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameters);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataSetParameters);
			((ns1__addDataSetParameters*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameters[n]);
			if (size)
				*size = n * sizeof(ns1__addDataSetParameters);
			for (int i = 0; i < n; i++)
				((ns1__addDataSetParameters*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataSetParameters*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataSetParametersResponse"))
	{	cp->type = SOAP_TYPE_ns1__addDataSetParametersResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParametersResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataSetParametersResponse);
			((ns1__addDataSetParametersResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParametersResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addDataSetParametersResponse);
			for (int i = 0; i < n; i++)
				((ns1__addDataSetParametersResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataSetParametersResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByRunNumber"))
	{	cp->type = SOAP_TYPE_ns1__searchByRunNumber;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumber);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByRunNumber);
			((ns1__searchByRunNumber*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumber[n]);
			if (size)
				*size = n * sizeof(ns1__searchByRunNumber);
			for (int i = 0; i < n; i++)
				((ns1__searchByRunNumber*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByRunNumber*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByRunNumberResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByRunNumberResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByRunNumberResponse);
			((ns1__searchByRunNumberResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByRunNumberResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByRunNumberResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByRunNumberResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByRunNumberPagination"))
	{	cp->type = SOAP_TYPE_ns1__searchByRunNumberPagination;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPagination);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByRunNumberPagination);
			((ns1__searchByRunNumberPagination*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPagination[n]);
			if (size)
				*size = n * sizeof(ns1__searchByRunNumberPagination);
			for (int i = 0; i < n; i++)
				((ns1__searchByRunNumberPagination*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByRunNumberPagination*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByRunNumberPaginationResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByRunNumberPaginationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPaginationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByRunNumberPaginationResponse);
			((ns1__searchByRunNumberPaginationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByRunNumberPaginationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByRunNumberPaginationResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByRunNumberPaginationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByRunNumberPaginationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByAdvanced"))
	{	cp->type = SOAP_TYPE_ns1__searchByAdvanced;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvanced);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByAdvanced);
			((ns1__searchByAdvanced*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvanced[n]);
			if (size)
				*size = n * sizeof(ns1__searchByAdvanced);
			for (int i = 0; i < n; i++)
				((ns1__searchByAdvanced*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByAdvanced*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:advancedSearchDetails"))
	{	cp->type = SOAP_TYPE_ns1__advancedSearchDetails;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__advancedSearchDetails);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__advancedSearchDetails);
			((ns1__advancedSearchDetails*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__advancedSearchDetails[n]);
			if (size)
				*size = n * sizeof(ns1__advancedSearchDetails);
			for (int i = 0; i < n; i++)
				((ns1__advancedSearchDetails*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__advancedSearchDetails*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByAdvancedResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByAdvancedResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByAdvancedResponse);
			((ns1__searchByAdvancedResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByAdvancedResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByAdvancedResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByAdvancedResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByAdvancedPagination"))
	{	cp->type = SOAP_TYPE_ns1__searchByAdvancedPagination;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPagination);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByAdvancedPagination);
			((ns1__searchByAdvancedPagination*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPagination[n]);
			if (size)
				*size = n * sizeof(ns1__searchByAdvancedPagination);
			for (int i = 0; i < n; i++)
				((ns1__searchByAdvancedPagination*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByAdvancedPagination*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchByAdvancedPaginationResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchByAdvancedPaginationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPaginationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchByAdvancedPaginationResponse);
			((ns1__searchByAdvancedPaginationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchByAdvancedPaginationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchByAdvancedPaginationResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchByAdvancedPaginationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchByAdvancedPaginationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listDatafileFormats"))
	{	cp->type = SOAP_TYPE_ns1__listDatafileFormats;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormats);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listDatafileFormats);
			((ns1__listDatafileFormats*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormats[n]);
			if (size)
				*size = n * sizeof(ns1__listDatafileFormats);
			for (int i = 0; i < n; i++)
				((ns1__listDatafileFormats*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listDatafileFormats*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listDatafileFormatsResponse"))
	{	cp->type = SOAP_TYPE_ns1__listDatafileFormatsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormatsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listDatafileFormatsResponse);
			((ns1__listDatafileFormatsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listDatafileFormatsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listDatafileFormatsResponse);
			for (int i = 0; i < n; i++)
				((ns1__listDatafileFormatsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listDatafileFormatsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifySampleParameter"))
	{	cp->type = SOAP_TYPE_ns1__modifySampleParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifySampleParameter);
			((ns1__modifySampleParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameter[n]);
			if (size)
				*size = n * sizeof(ns1__modifySampleParameter);
			for (int i = 0; i < n; i++)
				((ns1__modifySampleParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifySampleParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifySampleParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifySampleParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifySampleParameterResponse);
			((ns1__modifySampleParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifySampleParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifySampleParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifySampleParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifySampleParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyInvestigator"))
	{	cp->type = SOAP_TYPE_ns1__modifyInvestigator;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigator);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyInvestigator);
			((ns1__modifyInvestigator*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigator[n]);
			if (size)
				*size = n * sizeof(ns1__modifyInvestigator);
			for (int i = 0; i < n; i++)
				((ns1__modifyInvestigator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyInvestigator*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyInvestigatorResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifyInvestigatorResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigatorResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyInvestigatorResponse);
			((ns1__modifyInvestigatorResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyInvestigatorResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifyInvestigatorResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifyInvestigatorResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyInvestigatorResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataFiles"))
	{	cp->type = SOAP_TYPE_ns1__createDataFiles;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFiles);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataFiles);
			((ns1__createDataFiles*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFiles[n]);
			if (size)
				*size = n * sizeof(ns1__createDataFiles);
			for (int i = 0; i < n; i++)
				((ns1__createDataFiles*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataFiles*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createDataFilesResponse"))
	{	cp->type = SOAP_TYPE_ns1__createDataFilesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFilesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createDataFilesResponse);
			((ns1__createDataFilesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createDataFilesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__createDataFilesResponse);
			for (int i = 0; i < n; i++)
				((ns1__createDataFilesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createDataFilesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataSetParameter"))
	{	cp->type = SOAP_TYPE_ns1__addDataSetParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataSetParameter);
			((ns1__addDataSetParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameter[n]);
			if (size)
				*size = n * sizeof(ns1__addDataSetParameter);
			for (int i = 0; i < n; i++)
				((ns1__addDataSetParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataSetParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataSetParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__addDataSetParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataSetParameterResponse);
			((ns1__addDataSetParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataSetParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addDataSetParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__addDataSetParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataSetParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addAuthorisation"))
	{	cp->type = SOAP_TYPE_ns1__addAuthorisation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addAuthorisation);
			((ns1__addAuthorisation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisation[n]);
			if (size)
				*size = n * sizeof(ns1__addAuthorisation);
			for (int i = 0; i < n; i++)
				((ns1__addAuthorisation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addAuthorisation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addAuthorisationResponse"))
	{	cp->type = SOAP_TYPE_ns1__addAuthorisationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addAuthorisationResponse);
			((ns1__addAuthorisationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addAuthorisationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addAuthorisationResponse);
			for (int i = 0; i < n; i++)
				((ns1__addAuthorisationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addAuthorisationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addSample"))
	{	cp->type = SOAP_TYPE_ns1__addSample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addSample);
			((ns1__addSample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSample[n]);
			if (size)
				*size = n * sizeof(ns1__addSample);
			for (int i = 0; i < n; i++)
				((ns1__addSample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addSample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addSampleResponse"))
	{	cp->type = SOAP_TYPE_ns1__addSampleResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addSampleResponse);
			((ns1__addSampleResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addSampleResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addSampleResponse);
			for (int i = 0; i < n; i++)
				((ns1__addSampleResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addSampleResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deletePublication"))
	{	cp->type = SOAP_TYPE_ns1__deletePublication;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublication);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deletePublication);
			((ns1__deletePublication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublication[n]);
			if (size)
				*size = n * sizeof(ns1__deletePublication);
			for (int i = 0; i < n; i++)
				((ns1__deletePublication*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deletePublication*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deletePublicationResponse"))
	{	cp->type = SOAP_TYPE_ns1__deletePublicationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublicationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deletePublicationResponse);
			((ns1__deletePublicationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deletePublicationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deletePublicationResponse);
			for (int i = 0; i < n; i++)
				((ns1__deletePublicationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deletePublicationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:loginLifetime"))
	{	cp->type = SOAP_TYPE_ns1__loginLifetime;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetime);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__loginLifetime);
			((ns1__loginLifetime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetime[n]);
			if (size)
				*size = n * sizeof(ns1__loginLifetime);
			for (int i = 0; i < n; i++)
				((ns1__loginLifetime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__loginLifetime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:loginLifetimeResponse"))
	{	cp->type = SOAP_TYPE_ns1__loginLifetimeResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetimeResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__loginLifetimeResponse);
			((ns1__loginLifetimeResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__loginLifetimeResponse[n]);
			if (size)
				*size = n * sizeof(ns1__loginLifetimeResponse);
			for (int i = 0; i < n; i++)
				((ns1__loginLifetimeResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__loginLifetimeResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:login"))
	{	cp->type = SOAP_TYPE_ns1__login;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__login);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__login);
			((ns1__login*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__login[n]);
			if (size)
				*size = n * sizeof(ns1__login);
			for (int i = 0; i < n; i++)
				((ns1__login*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__login*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:loginResponse"))
	{	cp->type = SOAP_TYPE_ns1__loginResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__loginResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__loginResponse);
			((ns1__loginResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__loginResponse[n]);
			if (size)
				*size = n * sizeof(ns1__loginResponse);
			for (int i = 0; i < n; i++)
				((ns1__loginResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__loginResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteAuthorisation"))
	{	cp->type = SOAP_TYPE_ns1__deleteAuthorisation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteAuthorisation);
			((ns1__deleteAuthorisation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisation[n]);
			if (size)
				*size = n * sizeof(ns1__deleteAuthorisation);
			for (int i = 0; i < n; i++)
				((ns1__deleteAuthorisation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteAuthorisation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteAuthorisationResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteAuthorisationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteAuthorisationResponse);
			((ns1__deleteAuthorisationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteAuthorisationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteAuthorisationResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteAuthorisationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteAuthorisationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:updateAuthorisation"))
	{	cp->type = SOAP_TYPE_ns1__updateAuthorisation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__updateAuthorisation);
			((ns1__updateAuthorisation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisation[n]);
			if (size)
				*size = n * sizeof(ns1__updateAuthorisation);
			for (int i = 0; i < n; i++)
				((ns1__updateAuthorisation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__updateAuthorisation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:updateAuthorisationResponse"))
	{	cp->type = SOAP_TYPE_ns1__updateAuthorisationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__updateAuthorisationResponse);
			((ns1__updateAuthorisationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__updateAuthorisationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__updateAuthorisationResponse);
			for (int i = 0; i < n; i++)
				((ns1__updateAuthorisationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__updateAuthorisationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatasetIncludes"))
	{	cp->type = SOAP_TYPE_ns1__getDatasetIncludes;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludes);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatasetIncludes);
			((ns1__getDatasetIncludes*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludes[n]);
			if (size)
				*size = n * sizeof(ns1__getDatasetIncludes);
			for (int i = 0; i < n; i++)
				((ns1__getDatasetIncludes*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatasetIncludes*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatasetIncludesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getDatasetIncludesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatasetIncludesResponse);
			((ns1__getDatasetIncludesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetIncludesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getDatasetIncludesResponse);
			for (int i = 0; i < n; i++)
				((ns1__getDatasetIncludesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatasetIncludesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDataset"))
	{	cp->type = SOAP_TYPE_ns1__getDataset;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDataset);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDataset);
			((ns1__getDataset*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDataset[n]);
			if (size)
				*size = n * sizeof(ns1__getDataset);
			for (int i = 0; i < n; i++)
				((ns1__getDataset*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDataset*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatasetResponse"))
	{	cp->type = SOAP_TYPE_ns1__getDatasetResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatasetResponse);
			((ns1__getDatasetResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getDatasetResponse);
			for (int i = 0; i < n; i++)
				((ns1__getDatasetResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatasetResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listRoles"))
	{	cp->type = SOAP_TYPE_ns1__listRoles;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listRoles);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listRoles);
			((ns1__listRoles*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listRoles[n]);
			if (size)
				*size = n * sizeof(ns1__listRoles);
			for (int i = 0; i < n; i++)
				((ns1__listRoles*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listRoles*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listRolesResponse"))
	{	cp->type = SOAP_TYPE_ns1__listRolesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listRolesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listRolesResponse);
			((ns1__listRolesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listRolesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listRolesResponse);
			for (int i = 0; i < n; i++)
				((ns1__listRolesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listRolesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ingestMetadata"))
	{	cp->type = SOAP_TYPE_ns1__ingestMetadata;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadata);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ingestMetadata);
			((ns1__ingestMetadata*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadata[n]);
			if (size)
				*size = n * sizeof(ns1__ingestMetadata);
			for (int i = 0; i < n; i++)
				((ns1__ingestMetadata*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ingestMetadata*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ingestMetadataResponse"))
	{	cp->type = SOAP_TYPE_ns1__ingestMetadataResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadataResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ingestMetadataResponse);
			((ns1__ingestMetadataResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__ingestMetadataResponse[n]);
			if (size)
				*size = n * sizeof(ns1__ingestMetadataResponse);
			for (int i = 0; i < n; i++)
				((ns1__ingestMetadataResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ingestMetadataResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ICATAPIException"))
	{	cp->type = SOAP_TYPE_ns1__ICATAPIException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__ICATAPIException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ICATAPIException);
			((ns1__ICATAPIException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__ICATAPIException[n]);
			if (size)
				*size = n * sizeof(ns1__ICATAPIException);
			for (int i = 0; i < n; i++)
				((ns1__ICATAPIException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ICATAPIException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatafile"))
	{	cp->type = SOAP_TYPE_ns1__getDatafile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatafile);
			((ns1__getDatafile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafile[n]);
			if (size)
				*size = n * sizeof(ns1__getDatafile);
			for (int i = 0; i < n; i++)
				((ns1__getDatafile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatafile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatafileResponse"))
	{	cp->type = SOAP_TYPE_ns1__getDatafileResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafileResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatafileResponse);
			((ns1__getDatafileResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatafileResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getDatafileResponse);
			for (int i = 0; i < n; i++)
				((ns1__getDatafileResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatafileResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataFile"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataFile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataFile);
			((ns1__modifyDataFile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFile[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataFile);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataFile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataFile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataFileResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataFileResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataFileResponse);
			((ns1__modifyDataFileResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataFileResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataFileResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataFileResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getInvestigationIncludes"))
	{	cp->type = SOAP_TYPE_ns1__getInvestigationIncludes;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludes);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getInvestigationIncludes);
			((ns1__getInvestigationIncludes*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludes[n]);
			if (size)
				*size = n * sizeof(ns1__getInvestigationIncludes);
			for (int i = 0; i < n; i++)
				((ns1__getInvestigationIncludes*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getInvestigationIncludes*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getInvestigationIncludesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getInvestigationIncludesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludesResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getInvestigationIncludesResponse);
			((ns1__getInvestigationIncludesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationIncludesResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getInvestigationIncludesResponse);
			for (int i = 0; i < n; i++)
				((ns1__getInvestigationIncludesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getInvestigationIncludesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getInvestigation"))
	{	cp->type = SOAP_TYPE_ns1__getInvestigation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getInvestigation);
			((ns1__getInvestigation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigation[n]);
			if (size)
				*size = n * sizeof(ns1__getInvestigation);
			for (int i = 0; i < n; i++)
				((ns1__getInvestigation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getInvestigation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getInvestigationResponse"))
	{	cp->type = SOAP_TYPE_ns1__getInvestigationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getInvestigationResponse);
			((ns1__getInvestigationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getInvestigationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getInvestigationResponse);
			for (int i = 0; i < n; i++)
				((ns1__getInvestigationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getInvestigationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataFileParameter"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataFileParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataFileParameter);
			((ns1__deleteDataFileParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameter[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataFileParameter);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataFileParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataFileParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteDataFileParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteDataFileParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteDataFileParameterResponse);
			((ns1__deleteDataFileParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteDataFileParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteDataFileParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteDataFileParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteDataFileParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createInvestigation"))
	{	cp->type = SOAP_TYPE_ns1__createInvestigation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createInvestigation);
			((ns1__createInvestigation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigation[n]);
			if (size)
				*size = n * sizeof(ns1__createInvestigation);
			for (int i = 0; i < n; i++)
				((ns1__createInvestigation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createInvestigation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:createInvestigationResponse"))
	{	cp->type = SOAP_TYPE_ns1__createInvestigationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__createInvestigationResponse);
			((ns1__createInvestigationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__createInvestigationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__createInvestigationResponse);
			for (int i = 0; i < n; i++)
				((ns1__createInvestigationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__createInvestigationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addPublication"))
	{	cp->type = SOAP_TYPE_ns1__addPublication;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addPublication);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addPublication);
			((ns1__addPublication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addPublication[n]);
			if (size)
				*size = n * sizeof(ns1__addPublication);
			for (int i = 0; i < n; i++)
				((ns1__addPublication*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addPublication*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addPublicationResponse"))
	{	cp->type = SOAP_TYPE_ns1__addPublicationResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addPublicationResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addPublicationResponse);
			((ns1__addPublicationResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addPublicationResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addPublicationResponse);
			for (int i = 0; i < n; i++)
				((ns1__addPublicationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addPublicationResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchDatasetsBySample"))
	{	cp->type = SOAP_TYPE_ns1__searchDatasetsBySample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchDatasetsBySample);
			((ns1__searchDatasetsBySample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySample[n]);
			if (size)
				*size = n * sizeof(ns1__searchDatasetsBySample);
			for (int i = 0; i < n; i++)
				((ns1__searchDatasetsBySample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchDatasetsBySample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:searchDatasetsBySampleResponse"))
	{	cp->type = SOAP_TYPE_ns1__searchDatasetsBySampleResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySampleResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__searchDatasetsBySampleResponse);
			((ns1__searchDatasetsBySampleResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__searchDatasetsBySampleResponse[n]);
			if (size)
				*size = n * sizeof(ns1__searchDatasetsBySampleResponse);
			for (int i = 0; i < n; i++)
				((ns1__searchDatasetsBySampleResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__searchDatasetsBySampleResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataFileParameter"))
	{	cp->type = SOAP_TYPE_ns1__addDataFileParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataFileParameter);
			((ns1__addDataFileParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameter[n]);
			if (size)
				*size = n * sizeof(ns1__addDataFileParameter);
			for (int i = 0; i < n; i++)
				((ns1__addDataFileParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataFileParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:addDataFileParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__addDataFileParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__addDataFileParameterResponse);
			((ns1__addDataFileParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__addDataFileParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__addDataFileParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__addDataFileParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__addDataFileParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteSampleParameter"))
	{	cp->type = SOAP_TYPE_ns1__deleteSampleParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteSampleParameter);
			((ns1__deleteSampleParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameter[n]);
			if (size)
				*size = n * sizeof(ns1__deleteSampleParameter);
			for (int i = 0; i < n; i++)
				((ns1__deleteSampleParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteSampleParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:deleteSampleParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__deleteSampleParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__deleteSampleParameterResponse);
			((ns1__deleteSampleParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__deleteSampleParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__deleteSampleParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__deleteSampleParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__deleteSampleParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataFileParameter"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataFileParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataFileParameter);
			((ns1__modifyDataFileParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameter[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataFileParameter);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataFileParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataFileParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:modifyDataFileParameterResponse"))
	{	cp->type = SOAP_TYPE_ns1__modifyDataFileParameterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameterResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__modifyDataFileParameterResponse);
			((ns1__modifyDataFileParameterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__modifyDataFileParameterResponse[n]);
			if (size)
				*size = n * sizeof(ns1__modifyDataFileParameterResponse);
			for (int i = 0; i < n; i++)
				((ns1__modifyDataFileParameterResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__modifyDataFileParameterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listParameters"))
	{	cp->type = SOAP_TYPE_ns1__listParameters;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listParameters);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listParameters);
			((ns1__listParameters*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listParameters[n]);
			if (size)
				*size = n * sizeof(ns1__listParameters);
			for (int i = 0; i < n; i++)
				((ns1__listParameters*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listParameters*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:listParametersResponse"))
	{	cp->type = SOAP_TYPE_ns1__listParametersResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__listParametersResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__listParametersResponse);
			((ns1__listParametersResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__listParametersResponse[n]);
			if (size)
				*size = n * sizeof(ns1__listParametersResponse);
			for (int i = 0; i < n; i++)
				((ns1__listParametersResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__listParametersResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatasets"))
	{	cp->type = SOAP_TYPE_ns1__getDatasets;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasets);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatasets);
			((ns1__getDatasets*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasets[n]);
			if (size)
				*size = n * sizeof(ns1__getDatasets);
			for (int i = 0; i < n; i++)
				((ns1__getDatasets*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatasets*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getDatasetsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getDatasetsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetsResponse);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__getDatasetsResponse);
			((ns1__getDatasetsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__getDatasetsResponse[n]);
			if (size)
				*size = n * sizeof(ns1__getDatasetsResponse);
			for (int i = 0; i < n; i++)
				((ns1__getDatasetsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__getDatasetsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:SessionException"))
	{	cp->type = SOAP_TYPE_ns3__SessionException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__SessionException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__SessionException);
			((ns3__SessionException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns3__SessionException[n]);
			if (size)
				*size = n * sizeof(ns3__SessionException);
			for (int i = 0; i < n; i++)
				((ns3__SessionException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__SessionException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:sample"))
	{	cp->type = SOAP_TYPE_ns1__sample;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__sample);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__sample);
			((ns1__sample*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__sample[n]);
			if (size)
				*size = n * sizeof(ns1__sample);
			for (int i = 0; i < n; i++)
				((ns1__sample*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__sample*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:sampleParameter"))
	{	cp->type = SOAP_TYPE_ns1__sampleParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__sampleParameter);
			((ns1__sampleParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameter[n]);
			if (size)
				*size = n * sizeof(ns1__sampleParameter);
			for (int i = 0; i < n; i++)
				((ns1__sampleParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__sampleParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:sampleParameterPK"))
	{	cp->type = SOAP_TYPE_ns1__sampleParameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__sampleParameterPK);
			((ns1__sampleParameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__sampleParameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__sampleParameterPK);
			for (int i = 0; i < n; i++)
				((ns1__sampleParameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__sampleParameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:icatRole"))
	{	cp->type = SOAP_TYPE_ns1__icatRole;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatRole);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__icatRole);
			((ns1__icatRole*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatRole[n]);
			if (size)
				*size = n * sizeof(ns1__icatRole);
			for (int i = 0; i < n; i++)
				((ns1__icatRole*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__icatRole*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafile"))
	{	cp->type = SOAP_TYPE_ns1__datafile;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafile);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafile);
			((ns1__datafile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafile[n]);
			if (size)
				*size = n * sizeof(ns1__datafile);
			for (int i = 0; i < n; i++)
				((ns1__datafile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileFormat"))
	{	cp->type = SOAP_TYPE_ns1__datafileFormat;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormat);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileFormat);
			((ns1__datafileFormat*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormat[n]);
			if (size)
				*size = n * sizeof(ns1__datafileFormat);
			for (int i = 0; i < n; i++)
				((ns1__datafileFormat*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileFormat*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileFormatPK"))
	{	cp->type = SOAP_TYPE_ns1__datafileFormatPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormatPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileFormatPK);
			((ns1__datafileFormatPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileFormatPK[n]);
			if (size)
				*size = n * sizeof(ns1__datafileFormatPK);
			for (int i = 0; i < n; i++)
				((ns1__datafileFormatPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileFormatPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileParameter"))
	{	cp->type = SOAP_TYPE_ns1__datafileParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileParameter);
			((ns1__datafileParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameter[n]);
			if (size)
				*size = n * sizeof(ns1__datafileParameter);
			for (int i = 0; i < n; i++)
				((ns1__datafileParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datafileParameterPK"))
	{	cp->type = SOAP_TYPE_ns1__datafileParameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datafileParameterPK);
			((ns1__datafileParameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datafileParameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__datafileParameterPK);
			for (int i = 0; i < n; i++)
				((ns1__datafileParameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datafileParameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:relatedDatafiles"))
	{	cp->type = SOAP_TYPE_ns1__relatedDatafiles;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafiles);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__relatedDatafiles);
			((ns1__relatedDatafiles*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafiles[n]);
			if (size)
				*size = n * sizeof(ns1__relatedDatafiles);
			for (int i = 0; i < n; i++)
				((ns1__relatedDatafiles*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__relatedDatafiles*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:relatedDatafilesPK"))
	{	cp->type = SOAP_TYPE_ns1__relatedDatafilesPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafilesPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__relatedDatafilesPK);
			((ns1__relatedDatafilesPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__relatedDatafilesPK[n]);
			if (size)
				*size = n * sizeof(ns1__relatedDatafilesPK);
			for (int i = 0; i < n; i++)
				((ns1__relatedDatafilesPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__relatedDatafilesPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:facilityCycle"))
	{	cp->type = SOAP_TYPE_ns1__facilityCycle;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityCycle);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__facilityCycle);
			((ns1__facilityCycle*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityCycle[n]);
			if (size)
				*size = n * sizeof(ns1__facilityCycle);
			for (int i = 0; i < n; i++)
				((ns1__facilityCycle*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__facilityCycle*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:facilityUser"))
	{	cp->type = SOAP_TYPE_ns1__facilityUser;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityUser);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__facilityUser);
			((ns1__facilityUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__facilityUser[n]);
			if (size)
				*size = n * sizeof(ns1__facilityUser);
			for (int i = 0; i < n; i++)
				((ns1__facilityUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__facilityUser*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:investigatorPK"))
	{	cp->type = SOAP_TYPE_ns1__investigatorPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigatorPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__investigatorPK);
			((ns1__investigatorPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigatorPK[n]);
			if (size)
				*size = n * sizeof(ns1__investigatorPK);
			for (int i = 0; i < n; i++)
				((ns1__investigatorPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__investigatorPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:keywordPK"))
	{	cp->type = SOAP_TYPE_ns1__keywordPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__keywordPK);
			((ns1__keywordPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__keywordPK[n]);
			if (size)
				*size = n * sizeof(ns1__keywordPK);
			for (int i = 0; i < n; i++)
				((ns1__keywordPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__keywordPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:dataset"))
	{	cp->type = SOAP_TYPE_ns1__dataset;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__dataset);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__dataset);
			((ns1__dataset*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__dataset[n]);
			if (size)
				*size = n * sizeof(ns1__dataset);
			for (int i = 0; i < n; i++)
				((ns1__dataset*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__dataset*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datasetParameter"))
	{	cp->type = SOAP_TYPE_ns1__datasetParameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datasetParameter);
			((ns1__datasetParameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameter[n]);
			if (size)
				*size = n * sizeof(ns1__datasetParameter);
			for (int i = 0; i < n; i++)
				((ns1__datasetParameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datasetParameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:datasetParameterPK"))
	{	cp->type = SOAP_TYPE_ns1__datasetParameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__datasetParameterPK);
			((ns1__datasetParameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__datasetParameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__datasetParameterPK);
			for (int i = 0; i < n; i++)
				((ns1__datasetParameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__datasetParameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:parameter"))
	{	cp->type = SOAP_TYPE_ns1__parameter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__parameter);
			((ns1__parameter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameter[n]);
			if (size)
				*size = n * sizeof(ns1__parameter);
			for (int i = 0; i < n; i++)
				((ns1__parameter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__parameter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:parameterPK"))
	{	cp->type = SOAP_TYPE_ns1__parameterPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameterPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__parameterPK);
			((ns1__parameterPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__parameterPK[n]);
			if (size)
				*size = n * sizeof(ns1__parameterPK);
			for (int i = 0; i < n; i++)
				((ns1__parameterPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__parameterPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:investigation"))
	{	cp->type = SOAP_TYPE_ns1__investigation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__investigation);
			((ns1__investigation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigation[n]);
			if (size)
				*size = n * sizeof(ns1__investigation);
			for (int i = 0; i < n; i++)
				((ns1__investigation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__investigation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:investigator"))
	{	cp->type = SOAP_TYPE_ns1__investigator;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigator);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__investigator);
			((ns1__investigator*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__investigator[n]);
			if (size)
				*size = n * sizeof(ns1__investigator);
			for (int i = 0; i < n; i++)
				((ns1__investigator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__investigator*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:keyword"))
	{	cp->type = SOAP_TYPE_ns1__keyword;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__keyword);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__keyword);
			((ns1__keyword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__keyword[n]);
			if (size)
				*size = n * sizeof(ns1__keyword);
			for (int i = 0; i < n; i++)
				((ns1__keyword*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__keyword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:publication"))
	{	cp->type = SOAP_TYPE_ns1__publication;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__publication);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__publication);
			((ns1__publication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__publication[n]);
			if (size)
				*size = n * sizeof(ns1__publication);
			for (int i = 0; i < n; i++)
				((ns1__publication*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__publication*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:shift"))
	{	cp->type = SOAP_TYPE_ns1__shift;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__shift);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__shift);
			((ns1__shift*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__shift[n]);
			if (size)
				*size = n * sizeof(ns1__shift);
			for (int i = 0; i < n; i++)
				((ns1__shift*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__shift*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:shiftPK"))
	{	cp->type = SOAP_TYPE_ns1__shiftPK;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__shiftPK);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__shiftPK);
			((ns1__shiftPK*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__shiftPK[n]);
			if (size)
				*size = n * sizeof(ns1__shiftPK);
			for (int i = 0; i < n; i++)
				((ns1__shiftPK*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__shiftPK*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:icatAuthorisation"))
	{	cp->type = SOAP_TYPE_ns1__icatAuthorisation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatAuthorisation);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__icatAuthorisation);
			((ns1__icatAuthorisation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__icatAuthorisation[n]);
			if (size)
				*size = n * sizeof(ns1__icatAuthorisation);
			for (int i = 0; i < n; i++)
				((ns1__icatAuthorisation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__icatAuthorisation*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyType);
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getICATAPIVersion(struct soap *soap, struct __ns1__getICATAPIVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getICATAPIVersion_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getICATAPIVersion(struct soap *soap, const struct __ns1__getICATAPIVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getICATAPIVersion(soap, &a->ns1__getICATAPIVersion_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getICATAPIVersion(struct soap *soap, const char *tag, int id, const struct __ns1__getICATAPIVersion *a, const char *type)
{
	if (soap_out_PointerTons1__getICATAPIVersion(soap, "ns1:getICATAPIVersion", -1, &a->ns1__getICATAPIVersion_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getICATAPIVersion * SOAP_FMAC4 soap_in___ns1__getICATAPIVersion(struct soap *soap, const char *tag, struct __ns1__getICATAPIVersion *a, const char *type)
{
	size_t soap_flag_ns1__getICATAPIVersion_ = 1;
	short soap_flag;
	a = (struct __ns1__getICATAPIVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getICATAPIVersion, sizeof(struct __ns1__getICATAPIVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getICATAPIVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getICATAPIVersion_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getICATAPIVersion(soap, "ns1:getICATAPIVersion", &a->ns1__getICATAPIVersion_, "ns1:getICATAPIVersion"))
				{	soap_flag_ns1__getICATAPIVersion_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getICATAPIVersion(struct soap *soap, const struct __ns1__getICATAPIVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getICATAPIVersion(soap, tag?tag:"-ns1:getICATAPIVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getICATAPIVersion * SOAP_FMAC4 soap_get___ns1__getICATAPIVersion(struct soap *soap, struct __ns1__getICATAPIVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getICATAPIVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getICATAPIVersion * SOAP_FMAC2 soap_instantiate___ns1__getICATAPIVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getICATAPIVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getICATAPIVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getICATAPIVersion);
		if (size)
			*size = sizeof(struct __ns1__getICATAPIVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getICATAPIVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getICATAPIVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getICATAPIVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getICATAPIVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getICATAPIVersion %p -> %p\n", q, p));
	*(struct __ns1__getICATAPIVersion*)p = *(struct __ns1__getICATAPIVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listFacilityCycles(struct soap *soap, struct __ns1__listFacilityCycles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listFacilityCycles_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listFacilityCycles(struct soap *soap, const struct __ns1__listFacilityCycles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listFacilityCycles(soap, &a->ns1__listFacilityCycles_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listFacilityCycles(struct soap *soap, const char *tag, int id, const struct __ns1__listFacilityCycles *a, const char *type)
{
	if (soap_out_PointerTons1__listFacilityCycles(soap, "ns1:listFacilityCycles", -1, &a->ns1__listFacilityCycles_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listFacilityCycles * SOAP_FMAC4 soap_in___ns1__listFacilityCycles(struct soap *soap, const char *tag, struct __ns1__listFacilityCycles *a, const char *type)
{
	size_t soap_flag_ns1__listFacilityCycles_ = 1;
	short soap_flag;
	a = (struct __ns1__listFacilityCycles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listFacilityCycles, sizeof(struct __ns1__listFacilityCycles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listFacilityCycles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listFacilityCycles_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listFacilityCycles(soap, "ns1:listFacilityCycles", &a->ns1__listFacilityCycles_, "ns1:listFacilityCycles"))
				{	soap_flag_ns1__listFacilityCycles_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listFacilityCycles(struct soap *soap, const struct __ns1__listFacilityCycles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listFacilityCycles(soap, tag?tag:"-ns1:listFacilityCycles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listFacilityCycles * SOAP_FMAC4 soap_get___ns1__listFacilityCycles(struct soap *soap, struct __ns1__listFacilityCycles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listFacilityCycles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listFacilityCycles * SOAP_FMAC2 soap_instantiate___ns1__listFacilityCycles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listFacilityCycles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listFacilityCycles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listFacilityCycles);
		if (size)
			*size = sizeof(struct __ns1__listFacilityCycles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listFacilityCycles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listFacilityCycles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listFacilityCycles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listFacilityCycles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listFacilityCycles %p -> %p\n", q, p));
	*(struct __ns1__listFacilityCycles*)p = *(struct __ns1__listFacilityCycles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getFacilityUserByFederalId(struct soap *soap, struct __ns1__getFacilityUserByFederalId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getFacilityUserByFederalId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getFacilityUserByFederalId(struct soap *soap, const struct __ns1__getFacilityUserByFederalId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getFacilityUserByFederalId(soap, &a->ns1__getFacilityUserByFederalId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getFacilityUserByFederalId(struct soap *soap, const char *tag, int id, const struct __ns1__getFacilityUserByFederalId *a, const char *type)
{
	if (soap_out_PointerTons1__getFacilityUserByFederalId(soap, "ns1:getFacilityUserByFederalId", -1, &a->ns1__getFacilityUserByFederalId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFacilityUserByFederalId * SOAP_FMAC4 soap_in___ns1__getFacilityUserByFederalId(struct soap *soap, const char *tag, struct __ns1__getFacilityUserByFederalId *a, const char *type)
{
	size_t soap_flag_ns1__getFacilityUserByFederalId_ = 1;
	short soap_flag;
	a = (struct __ns1__getFacilityUserByFederalId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getFacilityUserByFederalId, sizeof(struct __ns1__getFacilityUserByFederalId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getFacilityUserByFederalId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getFacilityUserByFederalId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getFacilityUserByFederalId(soap, "ns1:getFacilityUserByFederalId", &a->ns1__getFacilityUserByFederalId_, "ns1:getFacilityUserByFederalId"))
				{	soap_flag_ns1__getFacilityUserByFederalId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getFacilityUserByFederalId(struct soap *soap, const struct __ns1__getFacilityUserByFederalId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getFacilityUserByFederalId(soap, tag?tag:"-ns1:getFacilityUserByFederalId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFacilityUserByFederalId * SOAP_FMAC4 soap_get___ns1__getFacilityUserByFederalId(struct soap *soap, struct __ns1__getFacilityUserByFederalId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getFacilityUserByFederalId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getFacilityUserByFederalId * SOAP_FMAC2 soap_instantiate___ns1__getFacilityUserByFederalId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getFacilityUserByFederalId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getFacilityUserByFederalId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFacilityUserByFederalId);
		if (size)
			*size = sizeof(struct __ns1__getFacilityUserByFederalId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFacilityUserByFederalId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getFacilityUserByFederalId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getFacilityUserByFederalId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getFacilityUserByFederalId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getFacilityUserByFederalId %p -> %p\n", q, p));
	*(struct __ns1__getFacilityUserByFederalId*)p = *(struct __ns1__getFacilityUserByFederalId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getFacilityUserByFacilityUserId(struct soap *soap, struct __ns1__getFacilityUserByFacilityUserId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getFacilityUserByFacilityUserId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getFacilityUserByFacilityUserId(struct soap *soap, const struct __ns1__getFacilityUserByFacilityUserId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getFacilityUserByFacilityUserId(soap, &a->ns1__getFacilityUserByFacilityUserId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getFacilityUserByFacilityUserId(struct soap *soap, const char *tag, int id, const struct __ns1__getFacilityUserByFacilityUserId *a, const char *type)
{
	if (soap_out_PointerTons1__getFacilityUserByFacilityUserId(soap, "ns1:getFacilityUserByFacilityUserId", -1, &a->ns1__getFacilityUserByFacilityUserId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFacilityUserByFacilityUserId * SOAP_FMAC4 soap_in___ns1__getFacilityUserByFacilityUserId(struct soap *soap, const char *tag, struct __ns1__getFacilityUserByFacilityUserId *a, const char *type)
{
	size_t soap_flag_ns1__getFacilityUserByFacilityUserId_ = 1;
	short soap_flag;
	a = (struct __ns1__getFacilityUserByFacilityUserId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getFacilityUserByFacilityUserId, sizeof(struct __ns1__getFacilityUserByFacilityUserId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getFacilityUserByFacilityUserId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getFacilityUserByFacilityUserId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getFacilityUserByFacilityUserId(soap, "ns1:getFacilityUserByFacilityUserId", &a->ns1__getFacilityUserByFacilityUserId_, "ns1:getFacilityUserByFacilityUserId"))
				{	soap_flag_ns1__getFacilityUserByFacilityUserId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getFacilityUserByFacilityUserId(struct soap *soap, const struct __ns1__getFacilityUserByFacilityUserId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getFacilityUserByFacilityUserId(soap, tag?tag:"-ns1:getFacilityUserByFacilityUserId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFacilityUserByFacilityUserId * SOAP_FMAC4 soap_get___ns1__getFacilityUserByFacilityUserId(struct soap *soap, struct __ns1__getFacilityUserByFacilityUserId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getFacilityUserByFacilityUserId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getFacilityUserByFacilityUserId * SOAP_FMAC2 soap_instantiate___ns1__getFacilityUserByFacilityUserId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getFacilityUserByFacilityUserId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getFacilityUserByFacilityUserId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFacilityUserByFacilityUserId);
		if (size)
			*size = sizeof(struct __ns1__getFacilityUserByFacilityUserId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFacilityUserByFacilityUserId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getFacilityUserByFacilityUserId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getFacilityUserByFacilityUserId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getFacilityUserByFacilityUserId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getFacilityUserByFacilityUserId %p -> %p\n", q, p));
	*(struct __ns1__getFacilityUserByFacilityUserId*)p = *(struct __ns1__getFacilityUserByFacilityUserId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchDatasetsBySample(struct soap *soap, struct __ns1__searchDatasetsBySample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchDatasetsBySample_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchDatasetsBySample(struct soap *soap, const struct __ns1__searchDatasetsBySample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchDatasetsBySample(soap, &a->ns1__searchDatasetsBySample_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchDatasetsBySample(struct soap *soap, const char *tag, int id, const struct __ns1__searchDatasetsBySample *a, const char *type)
{
	if (soap_out_PointerTons1__searchDatasetsBySample(soap, "ns1:searchDatasetsBySample", -1, &a->ns1__searchDatasetsBySample_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchDatasetsBySample * SOAP_FMAC4 soap_in___ns1__searchDatasetsBySample(struct soap *soap, const char *tag, struct __ns1__searchDatasetsBySample *a, const char *type)
{
	size_t soap_flag_ns1__searchDatasetsBySample_ = 1;
	short soap_flag;
	a = (struct __ns1__searchDatasetsBySample *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchDatasetsBySample, sizeof(struct __ns1__searchDatasetsBySample), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchDatasetsBySample(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchDatasetsBySample_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchDatasetsBySample(soap, "ns1:searchDatasetsBySample", &a->ns1__searchDatasetsBySample_, "ns1:searchDatasetsBySample"))
				{	soap_flag_ns1__searchDatasetsBySample_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchDatasetsBySample(struct soap *soap, const struct __ns1__searchDatasetsBySample *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchDatasetsBySample(soap, tag?tag:"-ns1:searchDatasetsBySample", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchDatasetsBySample * SOAP_FMAC4 soap_get___ns1__searchDatasetsBySample(struct soap *soap, struct __ns1__searchDatasetsBySample *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchDatasetsBySample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchDatasetsBySample * SOAP_FMAC2 soap_instantiate___ns1__searchDatasetsBySample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchDatasetsBySample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchDatasetsBySample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchDatasetsBySample);
		if (size)
			*size = sizeof(struct __ns1__searchDatasetsBySample);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchDatasetsBySample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchDatasetsBySample);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchDatasetsBySample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchDatasetsBySample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchDatasetsBySample %p -> %p\n", q, p));
	*(struct __ns1__searchDatasetsBySample*)p = *(struct __ns1__searchDatasetsBySample*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkDatasetDownloadAccess(struct soap *soap, struct __ns1__checkDatasetDownloadAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkDatasetDownloadAccess_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkDatasetDownloadAccess(struct soap *soap, const struct __ns1__checkDatasetDownloadAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__checkDatasetDownloadAccess(soap, &a->ns1__checkDatasetDownloadAccess_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkDatasetDownloadAccess(struct soap *soap, const char *tag, int id, const struct __ns1__checkDatasetDownloadAccess *a, const char *type)
{
	if (soap_out_PointerTons1__checkDatasetDownloadAccess(soap, "ns1:checkDatasetDownloadAccess", -1, &a->ns1__checkDatasetDownloadAccess_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkDatasetDownloadAccess * SOAP_FMAC4 soap_in___ns1__checkDatasetDownloadAccess(struct soap *soap, const char *tag, struct __ns1__checkDatasetDownloadAccess *a, const char *type)
{
	size_t soap_flag_ns1__checkDatasetDownloadAccess_ = 1;
	short soap_flag;
	a = (struct __ns1__checkDatasetDownloadAccess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkDatasetDownloadAccess, sizeof(struct __ns1__checkDatasetDownloadAccess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkDatasetDownloadAccess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkDatasetDownloadAccess_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__checkDatasetDownloadAccess(soap, "ns1:checkDatasetDownloadAccess", &a->ns1__checkDatasetDownloadAccess_, "ns1:checkDatasetDownloadAccess"))
				{	soap_flag_ns1__checkDatasetDownloadAccess_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkDatasetDownloadAccess(struct soap *soap, const struct __ns1__checkDatasetDownloadAccess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__checkDatasetDownloadAccess(soap, tag?tag:"-ns1:checkDatasetDownloadAccess", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkDatasetDownloadAccess * SOAP_FMAC4 soap_get___ns1__checkDatasetDownloadAccess(struct soap *soap, struct __ns1__checkDatasetDownloadAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkDatasetDownloadAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__checkDatasetDownloadAccess * SOAP_FMAC2 soap_instantiate___ns1__checkDatasetDownloadAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkDatasetDownloadAccess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__checkDatasetDownloadAccess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkDatasetDownloadAccess);
		if (size)
			*size = sizeof(struct __ns1__checkDatasetDownloadAccess);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkDatasetDownloadAccess[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__checkDatasetDownloadAccess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__checkDatasetDownloadAccess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__checkDatasetDownloadAccess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__checkDatasetDownloadAccess %p -> %p\n", q, p));
	*(struct __ns1__checkDatasetDownloadAccess*)p = *(struct __ns1__checkDatasetDownloadAccess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkDatafileDownloadAccess(struct soap *soap, struct __ns1__checkDatafileDownloadAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkDatafileDownloadAccess_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkDatafileDownloadAccess(struct soap *soap, const struct __ns1__checkDatafileDownloadAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__checkDatafileDownloadAccess(soap, &a->ns1__checkDatafileDownloadAccess_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkDatafileDownloadAccess(struct soap *soap, const char *tag, int id, const struct __ns1__checkDatafileDownloadAccess *a, const char *type)
{
	if (soap_out_PointerTons1__checkDatafileDownloadAccess(soap, "ns1:checkDatafileDownloadAccess", -1, &a->ns1__checkDatafileDownloadAccess_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkDatafileDownloadAccess * SOAP_FMAC4 soap_in___ns1__checkDatafileDownloadAccess(struct soap *soap, const char *tag, struct __ns1__checkDatafileDownloadAccess *a, const char *type)
{
	size_t soap_flag_ns1__checkDatafileDownloadAccess_ = 1;
	short soap_flag;
	a = (struct __ns1__checkDatafileDownloadAccess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkDatafileDownloadAccess, sizeof(struct __ns1__checkDatafileDownloadAccess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkDatafileDownloadAccess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkDatafileDownloadAccess_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__checkDatafileDownloadAccess(soap, "ns1:checkDatafileDownloadAccess", &a->ns1__checkDatafileDownloadAccess_, "ns1:checkDatafileDownloadAccess"))
				{	soap_flag_ns1__checkDatafileDownloadAccess_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkDatafileDownloadAccess(struct soap *soap, const struct __ns1__checkDatafileDownloadAccess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__checkDatafileDownloadAccess(soap, tag?tag:"-ns1:checkDatafileDownloadAccess", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkDatafileDownloadAccess * SOAP_FMAC4 soap_get___ns1__checkDatafileDownloadAccess(struct soap *soap, struct __ns1__checkDatafileDownloadAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkDatafileDownloadAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__checkDatafileDownloadAccess * SOAP_FMAC2 soap_instantiate___ns1__checkDatafileDownloadAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkDatafileDownloadAccess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__checkDatafileDownloadAccess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkDatafileDownloadAccess);
		if (size)
			*size = sizeof(struct __ns1__checkDatafileDownloadAccess);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkDatafileDownloadAccess[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__checkDatafileDownloadAccess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__checkDatafileDownloadAccess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__checkDatafileDownloadAccess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__checkDatafileDownloadAccess %p -> %p\n", q, p));
	*(struct __ns1__checkDatafileDownloadAccess*)p = *(struct __ns1__checkDatafileDownloadAccess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__downloadDataset(struct soap *soap, struct __ns1__downloadDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__downloadDataset_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__downloadDataset(struct soap *soap, const struct __ns1__downloadDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__downloadDataset(soap, &a->ns1__downloadDataset_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__downloadDataset(struct soap *soap, const char *tag, int id, const struct __ns1__downloadDataset *a, const char *type)
{
	if (soap_out_PointerTons1__downloadDataset(soap, "ns1:downloadDataset", -1, &a->ns1__downloadDataset_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadDataset * SOAP_FMAC4 soap_in___ns1__downloadDataset(struct soap *soap, const char *tag, struct __ns1__downloadDataset *a, const char *type)
{
	size_t soap_flag_ns1__downloadDataset_ = 1;
	short soap_flag;
	a = (struct __ns1__downloadDataset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__downloadDataset, sizeof(struct __ns1__downloadDataset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__downloadDataset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__downloadDataset_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__downloadDataset(soap, "ns1:downloadDataset", &a->ns1__downloadDataset_, "ns1:downloadDataset"))
				{	soap_flag_ns1__downloadDataset_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__downloadDataset(struct soap *soap, const struct __ns1__downloadDataset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__downloadDataset(soap, tag?tag:"-ns1:downloadDataset", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadDataset * SOAP_FMAC4 soap_get___ns1__downloadDataset(struct soap *soap, struct __ns1__downloadDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__downloadDataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__downloadDataset * SOAP_FMAC2 soap_instantiate___ns1__downloadDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__downloadDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__downloadDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadDataset);
		if (size)
			*size = sizeof(struct __ns1__downloadDataset);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadDataset[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__downloadDataset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__downloadDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__downloadDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__downloadDataset %p -> %p\n", q, p));
	*(struct __ns1__downloadDataset*)p = *(struct __ns1__downloadDataset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__downloadDatafiles(struct soap *soap, struct __ns1__downloadDatafiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__downloadDatafiles_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__downloadDatafiles(struct soap *soap, const struct __ns1__downloadDatafiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__downloadDatafiles(soap, &a->ns1__downloadDatafiles_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__downloadDatafiles(struct soap *soap, const char *tag, int id, const struct __ns1__downloadDatafiles *a, const char *type)
{
	if (soap_out_PointerTons1__downloadDatafiles(soap, "ns1:downloadDatafiles", -1, &a->ns1__downloadDatafiles_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadDatafiles * SOAP_FMAC4 soap_in___ns1__downloadDatafiles(struct soap *soap, const char *tag, struct __ns1__downloadDatafiles *a, const char *type)
{
	size_t soap_flag_ns1__downloadDatafiles_ = 1;
	short soap_flag;
	a = (struct __ns1__downloadDatafiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__downloadDatafiles, sizeof(struct __ns1__downloadDatafiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__downloadDatafiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__downloadDatafiles_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__downloadDatafiles(soap, "ns1:downloadDatafiles", &a->ns1__downloadDatafiles_, "ns1:downloadDatafiles"))
				{	soap_flag_ns1__downloadDatafiles_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__downloadDatafiles(struct soap *soap, const struct __ns1__downloadDatafiles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__downloadDatafiles(soap, tag?tag:"-ns1:downloadDatafiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadDatafiles * SOAP_FMAC4 soap_get___ns1__downloadDatafiles(struct soap *soap, struct __ns1__downloadDatafiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__downloadDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__downloadDatafiles * SOAP_FMAC2 soap_instantiate___ns1__downloadDatafiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__downloadDatafiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__downloadDatafiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadDatafiles);
		if (size)
			*size = sizeof(struct __ns1__downloadDatafiles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadDatafiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__downloadDatafiles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__downloadDatafiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__downloadDatafiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__downloadDatafiles %p -> %p\n", q, p));
	*(struct __ns1__downloadDatafiles*)p = *(struct __ns1__downloadDatafiles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__downloadDatafile(struct soap *soap, struct __ns1__downloadDatafile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__downloadDatafile_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__downloadDatafile(struct soap *soap, const struct __ns1__downloadDatafile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__downloadDatafile(soap, &a->ns1__downloadDatafile_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__downloadDatafile(struct soap *soap, const char *tag, int id, const struct __ns1__downloadDatafile *a, const char *type)
{
	if (soap_out_PointerTons1__downloadDatafile(soap, "ns1:downloadDatafile", -1, &a->ns1__downloadDatafile_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadDatafile * SOAP_FMAC4 soap_in___ns1__downloadDatafile(struct soap *soap, const char *tag, struct __ns1__downloadDatafile *a, const char *type)
{
	size_t soap_flag_ns1__downloadDatafile_ = 1;
	short soap_flag;
	a = (struct __ns1__downloadDatafile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__downloadDatafile, sizeof(struct __ns1__downloadDatafile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__downloadDatafile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__downloadDatafile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__downloadDatafile(soap, "ns1:downloadDatafile", &a->ns1__downloadDatafile_, "ns1:downloadDatafile"))
				{	soap_flag_ns1__downloadDatafile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__downloadDatafile(struct soap *soap, const struct __ns1__downloadDatafile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__downloadDatafile(soap, tag?tag:"-ns1:downloadDatafile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadDatafile * SOAP_FMAC4 soap_get___ns1__downloadDatafile(struct soap *soap, struct __ns1__downloadDatafile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__downloadDatafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__downloadDatafile * SOAP_FMAC2 soap_instantiate___ns1__downloadDatafile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__downloadDatafile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__downloadDatafile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadDatafile);
		if (size)
			*size = sizeof(struct __ns1__downloadDatafile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadDatafile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__downloadDatafile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__downloadDatafile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__downloadDatafile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__downloadDatafile %p -> %p\n", q, p));
	*(struct __ns1__downloadDatafile*)p = *(struct __ns1__downloadDatafile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listParameters(struct soap *soap, struct __ns1__listParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listParameters_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listParameters(struct soap *soap, const struct __ns1__listParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listParameters(soap, &a->ns1__listParameters_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listParameters(struct soap *soap, const char *tag, int id, const struct __ns1__listParameters *a, const char *type)
{
	if (soap_out_PointerTons1__listParameters(soap, "ns1:listParameters", -1, &a->ns1__listParameters_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listParameters * SOAP_FMAC4 soap_in___ns1__listParameters(struct soap *soap, const char *tag, struct __ns1__listParameters *a, const char *type)
{
	size_t soap_flag_ns1__listParameters_ = 1;
	short soap_flag;
	a = (struct __ns1__listParameters *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listParameters, sizeof(struct __ns1__listParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listParameters(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listParameters_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listParameters(soap, "ns1:listParameters", &a->ns1__listParameters_, "ns1:listParameters"))
				{	soap_flag_ns1__listParameters_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listParameters(struct soap *soap, const struct __ns1__listParameters *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listParameters(soap, tag?tag:"-ns1:listParameters", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listParameters * SOAP_FMAC4 soap_get___ns1__listParameters(struct soap *soap, struct __ns1__listParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listParameters * SOAP_FMAC2 soap_instantiate___ns1__listParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listParameters);
		if (size)
			*size = sizeof(struct __ns1__listParameters);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listParameters[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listParameters);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listParameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listParameters %p -> %p\n", q, p));
	*(struct __ns1__listParameters*)p = *(struct __ns1__listParameters*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listInvestigationTypes(struct soap *soap, struct __ns1__listInvestigationTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listInvestigationTypes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listInvestigationTypes(struct soap *soap, const struct __ns1__listInvestigationTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listInvestigationTypes(soap, &a->ns1__listInvestigationTypes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listInvestigationTypes(struct soap *soap, const char *tag, int id, const struct __ns1__listInvestigationTypes *a, const char *type)
{
	if (soap_out_PointerTons1__listInvestigationTypes(soap, "ns1:listInvestigationTypes", -1, &a->ns1__listInvestigationTypes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listInvestigationTypes * SOAP_FMAC4 soap_in___ns1__listInvestigationTypes(struct soap *soap, const char *tag, struct __ns1__listInvestigationTypes *a, const char *type)
{
	size_t soap_flag_ns1__listInvestigationTypes_ = 1;
	short soap_flag;
	a = (struct __ns1__listInvestigationTypes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listInvestigationTypes, sizeof(struct __ns1__listInvestigationTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listInvestigationTypes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listInvestigationTypes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listInvestigationTypes(soap, "ns1:listInvestigationTypes", &a->ns1__listInvestigationTypes_, "ns1:listInvestigationTypes"))
				{	soap_flag_ns1__listInvestigationTypes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listInvestigationTypes(struct soap *soap, const struct __ns1__listInvestigationTypes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listInvestigationTypes(soap, tag?tag:"-ns1:listInvestigationTypes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listInvestigationTypes * SOAP_FMAC4 soap_get___ns1__listInvestigationTypes(struct soap *soap, struct __ns1__listInvestigationTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listInvestigationTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listInvestigationTypes * SOAP_FMAC2 soap_instantiate___ns1__listInvestigationTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listInvestigationTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listInvestigationTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listInvestigationTypes);
		if (size)
			*size = sizeof(struct __ns1__listInvestigationTypes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listInvestigationTypes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listInvestigationTypes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listInvestigationTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listInvestigationTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listInvestigationTypes %p -> %p\n", q, p));
	*(struct __ns1__listInvestigationTypes*)p = *(struct __ns1__listInvestigationTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listRoles(struct soap *soap, struct __ns1__listRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listRoles_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listRoles(struct soap *soap, const struct __ns1__listRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listRoles(soap, &a->ns1__listRoles_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listRoles(struct soap *soap, const char *tag, int id, const struct __ns1__listRoles *a, const char *type)
{
	if (soap_out_PointerTons1__listRoles(soap, "ns1:listRoles", -1, &a->ns1__listRoles_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listRoles * SOAP_FMAC4 soap_in___ns1__listRoles(struct soap *soap, const char *tag, struct __ns1__listRoles *a, const char *type)
{
	size_t soap_flag_ns1__listRoles_ = 1;
	short soap_flag;
	a = (struct __ns1__listRoles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listRoles, sizeof(struct __ns1__listRoles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listRoles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listRoles_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listRoles(soap, "ns1:listRoles", &a->ns1__listRoles_, "ns1:listRoles"))
				{	soap_flag_ns1__listRoles_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listRoles(struct soap *soap, const struct __ns1__listRoles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listRoles(soap, tag?tag:"-ns1:listRoles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listRoles * SOAP_FMAC4 soap_get___ns1__listRoles(struct soap *soap, struct __ns1__listRoles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listRoles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listRoles * SOAP_FMAC2 soap_instantiate___ns1__listRoles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listRoles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listRoles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listRoles);
		if (size)
			*size = sizeof(struct __ns1__listRoles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listRoles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listRoles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listRoles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listRoles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listRoles %p -> %p\n", q, p));
	*(struct __ns1__listRoles*)p = *(struct __ns1__listRoles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listInstruments(struct soap *soap, struct __ns1__listInstruments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listInstruments_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listInstruments(struct soap *soap, const struct __ns1__listInstruments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listInstruments(soap, &a->ns1__listInstruments_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listInstruments(struct soap *soap, const char *tag, int id, const struct __ns1__listInstruments *a, const char *type)
{
	if (soap_out_PointerTons1__listInstruments(soap, "ns1:listInstruments", -1, &a->ns1__listInstruments_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listInstruments * SOAP_FMAC4 soap_in___ns1__listInstruments(struct soap *soap, const char *tag, struct __ns1__listInstruments *a, const char *type)
{
	size_t soap_flag_ns1__listInstruments_ = 1;
	short soap_flag;
	a = (struct __ns1__listInstruments *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listInstruments, sizeof(struct __ns1__listInstruments), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listInstruments(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listInstruments_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listInstruments(soap, "ns1:listInstruments", &a->ns1__listInstruments_, "ns1:listInstruments"))
				{	soap_flag_ns1__listInstruments_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listInstruments(struct soap *soap, const struct __ns1__listInstruments *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listInstruments(soap, tag?tag:"-ns1:listInstruments", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listInstruments * SOAP_FMAC4 soap_get___ns1__listInstruments(struct soap *soap, struct __ns1__listInstruments *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listInstruments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listInstruments * SOAP_FMAC2 soap_instantiate___ns1__listInstruments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listInstruments(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listInstruments, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listInstruments);
		if (size)
			*size = sizeof(struct __ns1__listInstruments);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listInstruments[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listInstruments);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listInstruments*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listInstruments(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listInstruments %p -> %p\n", q, p));
	*(struct __ns1__listInstruments*)p = *(struct __ns1__listInstruments*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByUserSurnamePagination(struct soap *soap, struct __ns1__searchByUserSurnamePagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByUserSurnamePagination_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByUserSurnamePagination(struct soap *soap, const struct __ns1__searchByUserSurnamePagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByUserSurnamePagination(soap, &a->ns1__searchByUserSurnamePagination_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByUserSurnamePagination(struct soap *soap, const char *tag, int id, const struct __ns1__searchByUserSurnamePagination *a, const char *type)
{
	if (soap_out_PointerTons1__searchByUserSurnamePagination(soap, "ns1:searchByUserSurnamePagination", -1, &a->ns1__searchByUserSurnamePagination_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserSurnamePagination * SOAP_FMAC4 soap_in___ns1__searchByUserSurnamePagination(struct soap *soap, const char *tag, struct __ns1__searchByUserSurnamePagination *a, const char *type)
{
	size_t soap_flag_ns1__searchByUserSurnamePagination_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByUserSurnamePagination *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByUserSurnamePagination, sizeof(struct __ns1__searchByUserSurnamePagination), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByUserSurnamePagination(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByUserSurnamePagination_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByUserSurnamePagination(soap, "ns1:searchByUserSurnamePagination", &a->ns1__searchByUserSurnamePagination_, "ns1:searchByUserSurnamePagination"))
				{	soap_flag_ns1__searchByUserSurnamePagination_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByUserSurnamePagination(struct soap *soap, const struct __ns1__searchByUserSurnamePagination *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByUserSurnamePagination(soap, tag?tag:"-ns1:searchByUserSurnamePagination", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserSurnamePagination * SOAP_FMAC4 soap_get___ns1__searchByUserSurnamePagination(struct soap *soap, struct __ns1__searchByUserSurnamePagination *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByUserSurnamePagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByUserSurnamePagination * SOAP_FMAC2 soap_instantiate___ns1__searchByUserSurnamePagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByUserSurnamePagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByUserSurnamePagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserSurnamePagination);
		if (size)
			*size = sizeof(struct __ns1__searchByUserSurnamePagination);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserSurnamePagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByUserSurnamePagination);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByUserSurnamePagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByUserSurnamePagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByUserSurnamePagination %p -> %p\n", q, p));
	*(struct __ns1__searchByUserSurnamePagination*)p = *(struct __ns1__searchByUserSurnamePagination*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByUserSurname(struct soap *soap, struct __ns1__searchByUserSurname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByUserSurname_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByUserSurname(struct soap *soap, const struct __ns1__searchByUserSurname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByUserSurname(soap, &a->ns1__searchByUserSurname_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByUserSurname(struct soap *soap, const char *tag, int id, const struct __ns1__searchByUserSurname *a, const char *type)
{
	if (soap_out_PointerTons1__searchByUserSurname(soap, "ns1:searchByUserSurname", -1, &a->ns1__searchByUserSurname_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserSurname * SOAP_FMAC4 soap_in___ns1__searchByUserSurname(struct soap *soap, const char *tag, struct __ns1__searchByUserSurname *a, const char *type)
{
	size_t soap_flag_ns1__searchByUserSurname_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByUserSurname *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByUserSurname, sizeof(struct __ns1__searchByUserSurname), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByUserSurname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByUserSurname_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByUserSurname(soap, "ns1:searchByUserSurname", &a->ns1__searchByUserSurname_, "ns1:searchByUserSurname"))
				{	soap_flag_ns1__searchByUserSurname_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByUserSurname(struct soap *soap, const struct __ns1__searchByUserSurname *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByUserSurname(soap, tag?tag:"-ns1:searchByUserSurname", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserSurname * SOAP_FMAC4 soap_get___ns1__searchByUserSurname(struct soap *soap, struct __ns1__searchByUserSurname *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByUserSurname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByUserSurname * SOAP_FMAC2 soap_instantiate___ns1__searchByUserSurname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByUserSurname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByUserSurname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserSurname);
		if (size)
			*size = sizeof(struct __ns1__searchByUserSurname);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserSurname[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByUserSurname);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByUserSurname*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByUserSurname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByUserSurname %p -> %p\n", q, p));
	*(struct __ns1__searchByUserSurname*)p = *(struct __ns1__searchByUserSurname*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByUserIDPagination(struct soap *soap, struct __ns1__searchByUserIDPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByUserIDPagination_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByUserIDPagination(struct soap *soap, const struct __ns1__searchByUserIDPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByUserIDPagination(soap, &a->ns1__searchByUserIDPagination_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByUserIDPagination(struct soap *soap, const char *tag, int id, const struct __ns1__searchByUserIDPagination *a, const char *type)
{
	if (soap_out_PointerTons1__searchByUserIDPagination(soap, "ns1:searchByUserIDPagination", -1, &a->ns1__searchByUserIDPagination_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserIDPagination * SOAP_FMAC4 soap_in___ns1__searchByUserIDPagination(struct soap *soap, const char *tag, struct __ns1__searchByUserIDPagination *a, const char *type)
{
	size_t soap_flag_ns1__searchByUserIDPagination_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByUserIDPagination *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByUserIDPagination, sizeof(struct __ns1__searchByUserIDPagination), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByUserIDPagination(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByUserIDPagination_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByUserIDPagination(soap, "ns1:searchByUserIDPagination", &a->ns1__searchByUserIDPagination_, "ns1:searchByUserIDPagination"))
				{	soap_flag_ns1__searchByUserIDPagination_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByUserIDPagination(struct soap *soap, const struct __ns1__searchByUserIDPagination *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByUserIDPagination(soap, tag?tag:"-ns1:searchByUserIDPagination", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserIDPagination * SOAP_FMAC4 soap_get___ns1__searchByUserIDPagination(struct soap *soap, struct __ns1__searchByUserIDPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByUserIDPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByUserIDPagination * SOAP_FMAC2 soap_instantiate___ns1__searchByUserIDPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByUserIDPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByUserIDPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserIDPagination);
		if (size)
			*size = sizeof(struct __ns1__searchByUserIDPagination);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserIDPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByUserIDPagination);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByUserIDPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByUserIDPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByUserIDPagination %p -> %p\n", q, p));
	*(struct __ns1__searchByUserIDPagination*)p = *(struct __ns1__searchByUserIDPagination*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByUserID(struct soap *soap, struct __ns1__searchByUserID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByUserID_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByUserID(struct soap *soap, const struct __ns1__searchByUserID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByUserID(soap, &a->ns1__searchByUserID_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByUserID(struct soap *soap, const char *tag, int id, const struct __ns1__searchByUserID *a, const char *type)
{
	if (soap_out_PointerTons1__searchByUserID(soap, "ns1:searchByUserID", -1, &a->ns1__searchByUserID_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserID * SOAP_FMAC4 soap_in___ns1__searchByUserID(struct soap *soap, const char *tag, struct __ns1__searchByUserID *a, const char *type)
{
	size_t soap_flag_ns1__searchByUserID_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByUserID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByUserID, sizeof(struct __ns1__searchByUserID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByUserID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByUserID_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByUserID(soap, "ns1:searchByUserID", &a->ns1__searchByUserID_, "ns1:searchByUserID"))
				{	soap_flag_ns1__searchByUserID_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByUserID(struct soap *soap, const struct __ns1__searchByUserID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByUserID(soap, tag?tag:"-ns1:searchByUserID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByUserID * SOAP_FMAC4 soap_get___ns1__searchByUserID(struct soap *soap, struct __ns1__searchByUserID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByUserID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByUserID * SOAP_FMAC2 soap_instantiate___ns1__searchByUserID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByUserID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByUserID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserID);
		if (size)
			*size = sizeof(struct __ns1__searchByUserID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByUserID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByUserID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByUserID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByUserID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByUserID %p -> %p\n", q, p));
	*(struct __ns1__searchByUserID*)p = *(struct __ns1__searchByUserID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, struct __ns1__getMyInvestigationsIncludesPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMyInvestigationsIncludesPagination_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, const struct __ns1__getMyInvestigationsIncludesPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getMyInvestigationsIncludesPagination(soap, &a->ns1__getMyInvestigationsIncludesPagination_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, const char *tag, int id, const struct __ns1__getMyInvestigationsIncludesPagination *a, const char *type)
{
	if (soap_out_PointerTons1__getMyInvestigationsIncludesPagination(soap, "ns1:getMyInvestigationsIncludesPagination", -1, &a->ns1__getMyInvestigationsIncludesPagination_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyInvestigationsIncludesPagination * SOAP_FMAC4 soap_in___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, const char *tag, struct __ns1__getMyInvestigationsIncludesPagination *a, const char *type)
{
	size_t soap_flag_ns1__getMyInvestigationsIncludesPagination_ = 1;
	short soap_flag;
	a = (struct __ns1__getMyInvestigationsIncludesPagination *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMyInvestigationsIncludesPagination, sizeof(struct __ns1__getMyInvestigationsIncludesPagination), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMyInvestigationsIncludesPagination(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMyInvestigationsIncludesPagination_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getMyInvestigationsIncludesPagination(soap, "ns1:getMyInvestigationsIncludesPagination", &a->ns1__getMyInvestigationsIncludesPagination_, "ns1:getMyInvestigationsIncludesPagination"))
				{	soap_flag_ns1__getMyInvestigationsIncludesPagination_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, const struct __ns1__getMyInvestigationsIncludesPagination *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMyInvestigationsIncludesPagination(soap, tag?tag:"-ns1:getMyInvestigationsIncludesPagination", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyInvestigationsIncludesPagination * SOAP_FMAC4 soap_get___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, struct __ns1__getMyInvestigationsIncludesPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMyInvestigationsIncludesPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMyInvestigationsIncludesPagination * SOAP_FMAC2 soap_instantiate___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMyInvestigationsIncludesPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMyInvestigationsIncludesPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyInvestigationsIncludesPagination);
		if (size)
			*size = sizeof(struct __ns1__getMyInvestigationsIncludesPagination);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyInvestigationsIncludesPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMyInvestigationsIncludesPagination);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMyInvestigationsIncludesPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMyInvestigationsIncludesPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMyInvestigationsIncludesPagination %p -> %p\n", q, p));
	*(struct __ns1__getMyInvestigationsIncludesPagination*)p = *(struct __ns1__getMyInvestigationsIncludesPagination*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMyInvestigationsIncludes(struct soap *soap, struct __ns1__getMyInvestigationsIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMyInvestigationsIncludes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMyInvestigationsIncludes(struct soap *soap, const struct __ns1__getMyInvestigationsIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getMyInvestigationsIncludes(soap, &a->ns1__getMyInvestigationsIncludes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMyInvestigationsIncludes(struct soap *soap, const char *tag, int id, const struct __ns1__getMyInvestigationsIncludes *a, const char *type)
{
	if (soap_out_PointerTons1__getMyInvestigationsIncludes(soap, "ns1:getMyInvestigationsIncludes", -1, &a->ns1__getMyInvestigationsIncludes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyInvestigationsIncludes * SOAP_FMAC4 soap_in___ns1__getMyInvestigationsIncludes(struct soap *soap, const char *tag, struct __ns1__getMyInvestigationsIncludes *a, const char *type)
{
	size_t soap_flag_ns1__getMyInvestigationsIncludes_ = 1;
	short soap_flag;
	a = (struct __ns1__getMyInvestigationsIncludes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMyInvestigationsIncludes, sizeof(struct __ns1__getMyInvestigationsIncludes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMyInvestigationsIncludes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMyInvestigationsIncludes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getMyInvestigationsIncludes(soap, "ns1:getMyInvestigationsIncludes", &a->ns1__getMyInvestigationsIncludes_, "ns1:getMyInvestigationsIncludes"))
				{	soap_flag_ns1__getMyInvestigationsIncludes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMyInvestigationsIncludes(struct soap *soap, const struct __ns1__getMyInvestigationsIncludes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMyInvestigationsIncludes(soap, tag?tag:"-ns1:getMyInvestigationsIncludes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyInvestigationsIncludes * SOAP_FMAC4 soap_get___ns1__getMyInvestigationsIncludes(struct soap *soap, struct __ns1__getMyInvestigationsIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMyInvestigationsIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMyInvestigationsIncludes * SOAP_FMAC2 soap_instantiate___ns1__getMyInvestigationsIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMyInvestigationsIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMyInvestigationsIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyInvestigationsIncludes);
		if (size)
			*size = sizeof(struct __ns1__getMyInvestigationsIncludes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyInvestigationsIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMyInvestigationsIncludes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMyInvestigationsIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMyInvestigationsIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMyInvestigationsIncludes %p -> %p\n", q, p));
	*(struct __ns1__getMyInvestigationsIncludes*)p = *(struct __ns1__getMyInvestigationsIncludes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMyInvestigations(struct soap *soap, struct __ns1__getMyInvestigations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMyInvestigations_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMyInvestigations(struct soap *soap, const struct __ns1__getMyInvestigations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getMyInvestigations(soap, &a->ns1__getMyInvestigations_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMyInvestigations(struct soap *soap, const char *tag, int id, const struct __ns1__getMyInvestigations *a, const char *type)
{
	if (soap_out_PointerTons1__getMyInvestigations(soap, "ns1:getMyInvestigations", -1, &a->ns1__getMyInvestigations_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyInvestigations * SOAP_FMAC4 soap_in___ns1__getMyInvestigations(struct soap *soap, const char *tag, struct __ns1__getMyInvestigations *a, const char *type)
{
	size_t soap_flag_ns1__getMyInvestigations_ = 1;
	short soap_flag;
	a = (struct __ns1__getMyInvestigations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMyInvestigations, sizeof(struct __ns1__getMyInvestigations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMyInvestigations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMyInvestigations_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getMyInvestigations(soap, "ns1:getMyInvestigations", &a->ns1__getMyInvestigations_, "ns1:getMyInvestigations"))
				{	soap_flag_ns1__getMyInvestigations_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMyInvestigations(struct soap *soap, const struct __ns1__getMyInvestigations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMyInvestigations(soap, tag?tag:"-ns1:getMyInvestigations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyInvestigations * SOAP_FMAC4 soap_get___ns1__getMyInvestigations(struct soap *soap, struct __ns1__getMyInvestigations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMyInvestigations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMyInvestigations * SOAP_FMAC2 soap_instantiate___ns1__getMyInvestigations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMyInvestigations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMyInvestigations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyInvestigations);
		if (size)
			*size = sizeof(struct __ns1__getMyInvestigations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyInvestigations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMyInvestigations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMyInvestigations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMyInvestigations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMyInvestigations %p -> %p\n", q, p));
	*(struct __ns1__getMyInvestigations*)p = *(struct __ns1__getMyInvestigations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByKeywordsAll(struct soap *soap, struct __ns1__searchByKeywordsAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByKeywordsAll_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByKeywordsAll(struct soap *soap, const struct __ns1__searchByKeywordsAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByKeywordsAll(soap, &a->ns1__searchByKeywordsAll_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByKeywordsAll(struct soap *soap, const char *tag, int id, const struct __ns1__searchByKeywordsAll *a, const char *type)
{
	if (soap_out_PointerTons1__searchByKeywordsAll(soap, "ns1:searchByKeywordsAll", -1, &a->ns1__searchByKeywordsAll_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByKeywordsAll * SOAP_FMAC4 soap_in___ns1__searchByKeywordsAll(struct soap *soap, const char *tag, struct __ns1__searchByKeywordsAll *a, const char *type)
{
	size_t soap_flag_ns1__searchByKeywordsAll_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByKeywordsAll *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByKeywordsAll, sizeof(struct __ns1__searchByKeywordsAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByKeywordsAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByKeywordsAll_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByKeywordsAll(soap, "ns1:searchByKeywordsAll", &a->ns1__searchByKeywordsAll_, "ns1:searchByKeywordsAll"))
				{	soap_flag_ns1__searchByKeywordsAll_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByKeywordsAll(struct soap *soap, const struct __ns1__searchByKeywordsAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByKeywordsAll(soap, tag?tag:"-ns1:searchByKeywordsAll", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByKeywordsAll * SOAP_FMAC4 soap_get___ns1__searchByKeywordsAll(struct soap *soap, struct __ns1__searchByKeywordsAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByKeywordsAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByKeywordsAll * SOAP_FMAC2 soap_instantiate___ns1__searchByKeywordsAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByKeywordsAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByKeywordsAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByKeywordsAll);
		if (size)
			*size = sizeof(struct __ns1__searchByKeywordsAll);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByKeywordsAll[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByKeywordsAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByKeywordsAll*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByKeywordsAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByKeywordsAll %p -> %p\n", q, p));
	*(struct __ns1__searchByKeywordsAll*)p = *(struct __ns1__searchByKeywordsAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByKeywords(struct soap *soap, struct __ns1__searchByKeywords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByKeywords_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByKeywords(struct soap *soap, const struct __ns1__searchByKeywords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByKeywords(soap, &a->ns1__searchByKeywords_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByKeywords(struct soap *soap, const char *tag, int id, const struct __ns1__searchByKeywords *a, const char *type)
{
	if (soap_out_PointerTons1__searchByKeywords(soap, "ns1:searchByKeywords", -1, &a->ns1__searchByKeywords_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByKeywords * SOAP_FMAC4 soap_in___ns1__searchByKeywords(struct soap *soap, const char *tag, struct __ns1__searchByKeywords *a, const char *type)
{
	size_t soap_flag_ns1__searchByKeywords_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByKeywords *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByKeywords, sizeof(struct __ns1__searchByKeywords), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByKeywords(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByKeywords_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByKeywords(soap, "ns1:searchByKeywords", &a->ns1__searchByKeywords_, "ns1:searchByKeywords"))
				{	soap_flag_ns1__searchByKeywords_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByKeywords(struct soap *soap, const struct __ns1__searchByKeywords *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByKeywords(soap, tag?tag:"-ns1:searchByKeywords", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByKeywords * SOAP_FMAC4 soap_get___ns1__searchByKeywords(struct soap *soap, struct __ns1__searchByKeywords *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByKeywords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByKeywords * SOAP_FMAC2 soap_instantiate___ns1__searchByKeywords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByKeywords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByKeywords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByKeywords);
		if (size)
			*size = sizeof(struct __ns1__searchByKeywords);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByKeywords[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByKeywords);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByKeywords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByKeywords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByKeywords %p -> %p\n", q, p));
	*(struct __ns1__searchByKeywords*)p = *(struct __ns1__searchByKeywords*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByAdvancedPagination(struct soap *soap, struct __ns1__searchByAdvancedPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByAdvancedPagination_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByAdvancedPagination(struct soap *soap, const struct __ns1__searchByAdvancedPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByAdvancedPagination(soap, &a->ns1__searchByAdvancedPagination_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByAdvancedPagination(struct soap *soap, const char *tag, int id, const struct __ns1__searchByAdvancedPagination *a, const char *type)
{
	if (soap_out_PointerTons1__searchByAdvancedPagination(soap, "ns1:searchByAdvancedPagination", -1, &a->ns1__searchByAdvancedPagination_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByAdvancedPagination * SOAP_FMAC4 soap_in___ns1__searchByAdvancedPagination(struct soap *soap, const char *tag, struct __ns1__searchByAdvancedPagination *a, const char *type)
{
	size_t soap_flag_ns1__searchByAdvancedPagination_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByAdvancedPagination *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByAdvancedPagination, sizeof(struct __ns1__searchByAdvancedPagination), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByAdvancedPagination(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByAdvancedPagination_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByAdvancedPagination(soap, "ns1:searchByAdvancedPagination", &a->ns1__searchByAdvancedPagination_, "ns1:searchByAdvancedPagination"))
				{	soap_flag_ns1__searchByAdvancedPagination_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByAdvancedPagination(struct soap *soap, const struct __ns1__searchByAdvancedPagination *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByAdvancedPagination(soap, tag?tag:"-ns1:searchByAdvancedPagination", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByAdvancedPagination * SOAP_FMAC4 soap_get___ns1__searchByAdvancedPagination(struct soap *soap, struct __ns1__searchByAdvancedPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByAdvancedPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByAdvancedPagination * SOAP_FMAC2 soap_instantiate___ns1__searchByAdvancedPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByAdvancedPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByAdvancedPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByAdvancedPagination);
		if (size)
			*size = sizeof(struct __ns1__searchByAdvancedPagination);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByAdvancedPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByAdvancedPagination);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByAdvancedPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByAdvancedPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByAdvancedPagination %p -> %p\n", q, p));
	*(struct __ns1__searchByAdvancedPagination*)p = *(struct __ns1__searchByAdvancedPagination*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByAdvanced(struct soap *soap, struct __ns1__searchByAdvanced *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByAdvanced_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByAdvanced(struct soap *soap, const struct __ns1__searchByAdvanced *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByAdvanced(soap, &a->ns1__searchByAdvanced_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByAdvanced(struct soap *soap, const char *tag, int id, const struct __ns1__searchByAdvanced *a, const char *type)
{
	if (soap_out_PointerTons1__searchByAdvanced(soap, "ns1:searchByAdvanced", -1, &a->ns1__searchByAdvanced_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByAdvanced * SOAP_FMAC4 soap_in___ns1__searchByAdvanced(struct soap *soap, const char *tag, struct __ns1__searchByAdvanced *a, const char *type)
{
	size_t soap_flag_ns1__searchByAdvanced_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByAdvanced *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByAdvanced, sizeof(struct __ns1__searchByAdvanced), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByAdvanced(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByAdvanced_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByAdvanced(soap, "ns1:searchByAdvanced", &a->ns1__searchByAdvanced_, "ns1:searchByAdvanced"))
				{	soap_flag_ns1__searchByAdvanced_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByAdvanced(struct soap *soap, const struct __ns1__searchByAdvanced *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByAdvanced(soap, tag?tag:"-ns1:searchByAdvanced", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByAdvanced * SOAP_FMAC4 soap_get___ns1__searchByAdvanced(struct soap *soap, struct __ns1__searchByAdvanced *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByAdvanced(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByAdvanced * SOAP_FMAC2 soap_instantiate___ns1__searchByAdvanced(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByAdvanced(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByAdvanced, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByAdvanced);
		if (size)
			*size = sizeof(struct __ns1__searchByAdvanced);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByAdvanced[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByAdvanced);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByAdvanced*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByAdvanced(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByAdvanced %p -> %p\n", q, p));
	*(struct __ns1__searchByAdvanced*)p = *(struct __ns1__searchByAdvanced*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setDataSetSample(struct soap *soap, struct __ns1__setDataSetSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setDataSetSample_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setDataSetSample(struct soap *soap, const struct __ns1__setDataSetSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setDataSetSample(soap, &a->ns1__setDataSetSample_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setDataSetSample(struct soap *soap, const char *tag, int id, const struct __ns1__setDataSetSample *a, const char *type)
{
	if (soap_out_PointerTons1__setDataSetSample(soap, "ns1:setDataSetSample", -1, &a->ns1__setDataSetSample_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setDataSetSample * SOAP_FMAC4 soap_in___ns1__setDataSetSample(struct soap *soap, const char *tag, struct __ns1__setDataSetSample *a, const char *type)
{
	size_t soap_flag_ns1__setDataSetSample_ = 1;
	short soap_flag;
	a = (struct __ns1__setDataSetSample *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setDataSetSample, sizeof(struct __ns1__setDataSetSample), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setDataSetSample(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setDataSetSample_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setDataSetSample(soap, "ns1:setDataSetSample", &a->ns1__setDataSetSample_, "ns1:setDataSetSample"))
				{	soap_flag_ns1__setDataSetSample_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setDataSetSample(struct soap *soap, const struct __ns1__setDataSetSample *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setDataSetSample(soap, tag?tag:"-ns1:setDataSetSample", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setDataSetSample * SOAP_FMAC4 soap_get___ns1__setDataSetSample(struct soap *soap, struct __ns1__setDataSetSample *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setDataSetSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setDataSetSample * SOAP_FMAC2 soap_instantiate___ns1__setDataSetSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setDataSetSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setDataSetSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setDataSetSample);
		if (size)
			*size = sizeof(struct __ns1__setDataSetSample);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setDataSetSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setDataSetSample);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setDataSetSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setDataSetSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setDataSetSample %p -> %p\n", q, p));
	*(struct __ns1__setDataSetSample*)p = *(struct __ns1__setDataSetSample*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setDataSetSampleResponse(struct soap *soap, struct __ns1__setDataSetSampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setDataSetSampleResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setDataSetSampleResponse(struct soap *soap, const struct __ns1__setDataSetSampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setDataSetSampleResponse(soap, &a->ns1__setDataSetSampleResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setDataSetSampleResponse(struct soap *soap, const char *tag, int id, const struct __ns1__setDataSetSampleResponse *a, const char *type)
{
	if (a->ns1__setDataSetSampleResponse_)
		soap_element_result(soap, "ns1:setDataSetSampleResponse");
	if (soap_out_PointerTons1__setDataSetSampleResponse(soap, "ns1:setDataSetSampleResponse", -1, &a->ns1__setDataSetSampleResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setDataSetSampleResponse * SOAP_FMAC4 soap_in___ns1__setDataSetSampleResponse(struct soap *soap, const char *tag, struct __ns1__setDataSetSampleResponse *a, const char *type)
{
	size_t soap_flag_ns1__setDataSetSampleResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__setDataSetSampleResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setDataSetSampleResponse, sizeof(struct __ns1__setDataSetSampleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setDataSetSampleResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setDataSetSampleResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setDataSetSampleResponse(soap, "ns1:setDataSetSampleResponse", &a->ns1__setDataSetSampleResponse_, "ns1:setDataSetSampleResponse"))
				{	soap_flag_ns1__setDataSetSampleResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:setDataSetSampleResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setDataSetSampleResponse(struct soap *soap, const struct __ns1__setDataSetSampleResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setDataSetSampleResponse(soap, tag?tag:"-ns1:setDataSetSampleResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setDataSetSampleResponse * SOAP_FMAC4 soap_get___ns1__setDataSetSampleResponse(struct soap *soap, struct __ns1__setDataSetSampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setDataSetSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__setDataSetSampleResponse * SOAP_FMAC2 soap_instantiate___ns1__setDataSetSampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setDataSetSampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setDataSetSampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setDataSetSampleResponse);
		if (size)
			*size = sizeof(struct __ns1__setDataSetSampleResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__setDataSetSampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setDataSetSampleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setDataSetSampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setDataSetSampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setDataSetSampleResponse %p -> %p\n", q, p));
	*(struct __ns1__setDataSetSampleResponse*)p = *(struct __ns1__setDataSetSampleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataSetParameter(struct soap *soap, struct __ns1__deleteDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataSetParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataSetParameter(struct soap *soap, const struct __ns1__deleteDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataSetParameter(soap, &a->ns1__deleteDataSetParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataSetParameter(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataSetParameter *a, const char *type)
{
	if (soap_out_PointerTons1__deleteDataSetParameter(soap, "ns1:deleteDataSetParameter", -1, &a->ns1__deleteDataSetParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSetParameter * SOAP_FMAC4 soap_in___ns1__deleteDataSetParameter(struct soap *soap, const char *tag, struct __ns1__deleteDataSetParameter *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataSetParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataSetParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataSetParameter, sizeof(struct __ns1__deleteDataSetParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataSetParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataSetParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataSetParameter(soap, "ns1:deleteDataSetParameter", &a->ns1__deleteDataSetParameter_, "ns1:deleteDataSetParameter"))
				{	soap_flag_ns1__deleteDataSetParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataSetParameter(struct soap *soap, const struct __ns1__deleteDataSetParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataSetParameter(soap, tag?tag:"-ns1:deleteDataSetParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSetParameter * SOAP_FMAC4 soap_get___ns1__deleteDataSetParameter(struct soap *soap, struct __ns1__deleteDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataSetParameter * SOAP_FMAC2 soap_instantiate___ns1__deleteDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSetParameter);
		if (size)
			*size = sizeof(struct __ns1__deleteDataSetParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataSetParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataSetParameter %p -> %p\n", q, p));
	*(struct __ns1__deleteDataSetParameter*)p = *(struct __ns1__deleteDataSetParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataSetParameterResponse(struct soap *soap, struct __ns1__deleteDataSetParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataSetParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataSetParameterResponse(struct soap *soap, const struct __ns1__deleteDataSetParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataSetParameterResponse(soap, &a->ns1__deleteDataSetParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataSetParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataSetParameterResponse *a, const char *type)
{
	if (a->ns1__deleteDataSetParameterResponse_)
		soap_element_result(soap, "ns1:deleteDataSetParameterResponse");
	if (soap_out_PointerTons1__deleteDataSetParameterResponse(soap, "ns1:deleteDataSetParameterResponse", -1, &a->ns1__deleteDataSetParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSetParameterResponse * SOAP_FMAC4 soap_in___ns1__deleteDataSetParameterResponse(struct soap *soap, const char *tag, struct __ns1__deleteDataSetParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataSetParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataSetParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataSetParameterResponse, sizeof(struct __ns1__deleteDataSetParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataSetParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataSetParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataSetParameterResponse(soap, "ns1:deleteDataSetParameterResponse", &a->ns1__deleteDataSetParameterResponse_, "ns1:deleteDataSetParameterResponse"))
				{	soap_flag_ns1__deleteDataSetParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteDataSetParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataSetParameterResponse(struct soap *soap, const struct __ns1__deleteDataSetParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataSetParameterResponse(soap, tag?tag:"-ns1:deleteDataSetParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSetParameterResponse * SOAP_FMAC4 soap_get___ns1__deleteDataSetParameterResponse(struct soap *soap, struct __ns1__deleteDataSetParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataSetParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteDataSetParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataSetParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataSetParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSetParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteDataSetParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSetParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataSetParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataSetParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataSetParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataSetParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteDataSetParameterResponse*)p = *(struct __ns1__deleteDataSetParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataSetParameter(struct soap *soap, struct __ns1__removeDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataSetParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataSetParameter(struct soap *soap, const struct __ns1__removeDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataSetParameter(soap, &a->ns1__removeDataSetParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataSetParameter(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataSetParameter *a, const char *type)
{
	if (soap_out_PointerTons1__removeDataSetParameter(soap, "ns1:removeDataSetParameter", -1, &a->ns1__removeDataSetParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSetParameter * SOAP_FMAC4 soap_in___ns1__removeDataSetParameter(struct soap *soap, const char *tag, struct __ns1__removeDataSetParameter *a, const char *type)
{
	size_t soap_flag_ns1__removeDataSetParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataSetParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataSetParameter, sizeof(struct __ns1__removeDataSetParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataSetParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataSetParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataSetParameter(soap, "ns1:removeDataSetParameter", &a->ns1__removeDataSetParameter_, "ns1:removeDataSetParameter"))
				{	soap_flag_ns1__removeDataSetParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataSetParameter(struct soap *soap, const struct __ns1__removeDataSetParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataSetParameter(soap, tag?tag:"-ns1:removeDataSetParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSetParameter * SOAP_FMAC4 soap_get___ns1__removeDataSetParameter(struct soap *soap, struct __ns1__removeDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataSetParameter * SOAP_FMAC2 soap_instantiate___ns1__removeDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSetParameter);
		if (size)
			*size = sizeof(struct __ns1__removeDataSetParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataSetParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataSetParameter %p -> %p\n", q, p));
	*(struct __ns1__removeDataSetParameter*)p = *(struct __ns1__removeDataSetParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataSetParameterResponse(struct soap *soap, struct __ns1__removeDataSetParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataSetParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataSetParameterResponse(struct soap *soap, const struct __ns1__removeDataSetParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataSetParameterResponse(soap, &a->ns1__removeDataSetParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataSetParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataSetParameterResponse *a, const char *type)
{
	if (a->ns1__removeDataSetParameterResponse_)
		soap_element_result(soap, "ns1:removeDataSetParameterResponse");
	if (soap_out_PointerTons1__removeDataSetParameterResponse(soap, "ns1:removeDataSetParameterResponse", -1, &a->ns1__removeDataSetParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSetParameterResponse * SOAP_FMAC4 soap_in___ns1__removeDataSetParameterResponse(struct soap *soap, const char *tag, struct __ns1__removeDataSetParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeDataSetParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataSetParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataSetParameterResponse, sizeof(struct __ns1__removeDataSetParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataSetParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataSetParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataSetParameterResponse(soap, "ns1:removeDataSetParameterResponse", &a->ns1__removeDataSetParameterResponse_, "ns1:removeDataSetParameterResponse"))
				{	soap_flag_ns1__removeDataSetParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeDataSetParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataSetParameterResponse(struct soap *soap, const struct __ns1__removeDataSetParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataSetParameterResponse(soap, tag?tag:"-ns1:removeDataSetParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSetParameterResponse * SOAP_FMAC4 soap_get___ns1__removeDataSetParameterResponse(struct soap *soap, struct __ns1__removeDataSetParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataSetParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__removeDataSetParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataSetParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataSetParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSetParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__removeDataSetParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSetParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataSetParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataSetParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataSetParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataSetParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__removeDataSetParameterResponse*)p = *(struct __ns1__removeDataSetParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataSetParameter(struct soap *soap, struct __ns1__modifyDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataSetParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataSetParameter(struct soap *soap, const struct __ns1__modifyDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataSetParameter(soap, &a->ns1__modifyDataSetParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataSetParameter(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataSetParameter *a, const char *type)
{
	if (soap_out_PointerTons1__modifyDataSetParameter(soap, "ns1:modifyDataSetParameter", -1, &a->ns1__modifyDataSetParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSetParameter * SOAP_FMAC4 soap_in___ns1__modifyDataSetParameter(struct soap *soap, const char *tag, struct __ns1__modifyDataSetParameter *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataSetParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataSetParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataSetParameter, sizeof(struct __ns1__modifyDataSetParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataSetParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataSetParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataSetParameter(soap, "ns1:modifyDataSetParameter", &a->ns1__modifyDataSetParameter_, "ns1:modifyDataSetParameter"))
				{	soap_flag_ns1__modifyDataSetParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataSetParameter(struct soap *soap, const struct __ns1__modifyDataSetParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataSetParameter(soap, tag?tag:"-ns1:modifyDataSetParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSetParameter * SOAP_FMAC4 soap_get___ns1__modifyDataSetParameter(struct soap *soap, struct __ns1__modifyDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataSetParameter * SOAP_FMAC2 soap_instantiate___ns1__modifyDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSetParameter);
		if (size)
			*size = sizeof(struct __ns1__modifyDataSetParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataSetParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataSetParameter %p -> %p\n", q, p));
	*(struct __ns1__modifyDataSetParameter*)p = *(struct __ns1__modifyDataSetParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataSetParameterResponse(struct soap *soap, struct __ns1__modifyDataSetParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataSetParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataSetParameterResponse(struct soap *soap, const struct __ns1__modifyDataSetParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataSetParameterResponse(soap, &a->ns1__modifyDataSetParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataSetParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataSetParameterResponse *a, const char *type)
{
	if (a->ns1__modifyDataSetParameterResponse_)
		soap_element_result(soap, "ns1:modifyDataSetParameterResponse");
	if (soap_out_PointerTons1__modifyDataSetParameterResponse(soap, "ns1:modifyDataSetParameterResponse", -1, &a->ns1__modifyDataSetParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSetParameterResponse * SOAP_FMAC4 soap_in___ns1__modifyDataSetParameterResponse(struct soap *soap, const char *tag, struct __ns1__modifyDataSetParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataSetParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataSetParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataSetParameterResponse, sizeof(struct __ns1__modifyDataSetParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataSetParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataSetParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataSetParameterResponse(soap, "ns1:modifyDataSetParameterResponse", &a->ns1__modifyDataSetParameterResponse_, "ns1:modifyDataSetParameterResponse"))
				{	soap_flag_ns1__modifyDataSetParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifyDataSetParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataSetParameterResponse(struct soap *soap, const struct __ns1__modifyDataSetParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataSetParameterResponse(soap, tag?tag:"-ns1:modifyDataSetParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSetParameterResponse * SOAP_FMAC4 soap_get___ns1__modifyDataSetParameterResponse(struct soap *soap, struct __ns1__modifyDataSetParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataSetParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__modifyDataSetParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataSetParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataSetParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSetParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__modifyDataSetParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSetParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataSetParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataSetParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataSetParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataSetParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__modifyDataSetParameterResponse*)p = *(struct __ns1__modifyDataSetParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDataSetParameters(struct soap *soap, struct __ns1__addDataSetParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDataSetParameters_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDataSetParameters(struct soap *soap, const struct __ns1__addDataSetParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addDataSetParameters(soap, &a->ns1__addDataSetParameters_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDataSetParameters(struct soap *soap, const char *tag, int id, const struct __ns1__addDataSetParameters *a, const char *type)
{
	if (soap_out_PointerTons1__addDataSetParameters(soap, "ns1:addDataSetParameters", -1, &a->ns1__addDataSetParameters_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataSetParameters * SOAP_FMAC4 soap_in___ns1__addDataSetParameters(struct soap *soap, const char *tag, struct __ns1__addDataSetParameters *a, const char *type)
{
	size_t soap_flag_ns1__addDataSetParameters_ = 1;
	short soap_flag;
	a = (struct __ns1__addDataSetParameters *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDataSetParameters, sizeof(struct __ns1__addDataSetParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDataSetParameters(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDataSetParameters_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addDataSetParameters(soap, "ns1:addDataSetParameters", &a->ns1__addDataSetParameters_, "ns1:addDataSetParameters"))
				{	soap_flag_ns1__addDataSetParameters_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDataSetParameters(struct soap *soap, const struct __ns1__addDataSetParameters *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDataSetParameters(soap, tag?tag:"-ns1:addDataSetParameters", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataSetParameters * SOAP_FMAC4 soap_get___ns1__addDataSetParameters(struct soap *soap, struct __ns1__addDataSetParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDataSetParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addDataSetParameters * SOAP_FMAC2 soap_instantiate___ns1__addDataSetParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addDataSetParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addDataSetParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataSetParameters);
		if (size)
			*size = sizeof(struct __ns1__addDataSetParameters);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataSetParameters[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addDataSetParameters);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addDataSetParameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addDataSetParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addDataSetParameters %p -> %p\n", q, p));
	*(struct __ns1__addDataSetParameters*)p = *(struct __ns1__addDataSetParameters*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDataSetParameter(struct soap *soap, struct __ns1__addDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDataSetParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDataSetParameter(struct soap *soap, const struct __ns1__addDataSetParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addDataSetParameter(soap, &a->ns1__addDataSetParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDataSetParameter(struct soap *soap, const char *tag, int id, const struct __ns1__addDataSetParameter *a, const char *type)
{
	if (soap_out_PointerTons1__addDataSetParameter(soap, "ns1:addDataSetParameter", -1, &a->ns1__addDataSetParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataSetParameter * SOAP_FMAC4 soap_in___ns1__addDataSetParameter(struct soap *soap, const char *tag, struct __ns1__addDataSetParameter *a, const char *type)
{
	size_t soap_flag_ns1__addDataSetParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__addDataSetParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDataSetParameter, sizeof(struct __ns1__addDataSetParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDataSetParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDataSetParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addDataSetParameter(soap, "ns1:addDataSetParameter", &a->ns1__addDataSetParameter_, "ns1:addDataSetParameter"))
				{	soap_flag_ns1__addDataSetParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDataSetParameter(struct soap *soap, const struct __ns1__addDataSetParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDataSetParameter(soap, tag?tag:"-ns1:addDataSetParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataSetParameter * SOAP_FMAC4 soap_get___ns1__addDataSetParameter(struct soap *soap, struct __ns1__addDataSetParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addDataSetParameter * SOAP_FMAC2 soap_instantiate___ns1__addDataSetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addDataSetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addDataSetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataSetParameter);
		if (size)
			*size = sizeof(struct __ns1__addDataSetParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataSetParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addDataSetParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addDataSetParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addDataSetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addDataSetParameter %p -> %p\n", q, p));
	*(struct __ns1__addDataSetParameter*)p = *(struct __ns1__addDataSetParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataSet(struct soap *soap, struct __ns1__modifyDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataSet_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataSet(struct soap *soap, const struct __ns1__modifyDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataSet(soap, &a->ns1__modifyDataSet_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataSet(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataSet *a, const char *type)
{
	if (soap_out_PointerTons1__modifyDataSet(soap, "ns1:modifyDataSet", -1, &a->ns1__modifyDataSet_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSet * SOAP_FMAC4 soap_in___ns1__modifyDataSet(struct soap *soap, const char *tag, struct __ns1__modifyDataSet *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataSet_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataSet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataSet, sizeof(struct __ns1__modifyDataSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataSet_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataSet(soap, "ns1:modifyDataSet", &a->ns1__modifyDataSet_, "ns1:modifyDataSet"))
				{	soap_flag_ns1__modifyDataSet_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataSet(struct soap *soap, const struct __ns1__modifyDataSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataSet(soap, tag?tag:"-ns1:modifyDataSet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSet * SOAP_FMAC4 soap_get___ns1__modifyDataSet(struct soap *soap, struct __ns1__modifyDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataSet * SOAP_FMAC2 soap_instantiate___ns1__modifyDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSet);
		if (size)
			*size = sizeof(struct __ns1__modifyDataSet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataSet %p -> %p\n", q, p));
	*(struct __ns1__modifyDataSet*)p = *(struct __ns1__modifyDataSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataSetResponse(struct soap *soap, struct __ns1__modifyDataSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataSetResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataSetResponse(struct soap *soap, const struct __ns1__modifyDataSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataSetResponse(soap, &a->ns1__modifyDataSetResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataSetResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataSetResponse *a, const char *type)
{
	if (a->ns1__modifyDataSetResponse_)
		soap_element_result(soap, "ns1:modifyDataSetResponse");
	if (soap_out_PointerTons1__modifyDataSetResponse(soap, "ns1:modifyDataSetResponse", -1, &a->ns1__modifyDataSetResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSetResponse * SOAP_FMAC4 soap_in___ns1__modifyDataSetResponse(struct soap *soap, const char *tag, struct __ns1__modifyDataSetResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataSetResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataSetResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataSetResponse, sizeof(struct __ns1__modifyDataSetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataSetResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataSetResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataSetResponse(soap, "ns1:modifyDataSetResponse", &a->ns1__modifyDataSetResponse_, "ns1:modifyDataSetResponse"))
				{	soap_flag_ns1__modifyDataSetResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifyDataSetResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataSetResponse(struct soap *soap, const struct __ns1__modifyDataSetResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataSetResponse(soap, tag?tag:"-ns1:modifyDataSetResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataSetResponse * SOAP_FMAC4 soap_get___ns1__modifyDataSetResponse(struct soap *soap, struct __ns1__modifyDataSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataSetResponse * SOAP_FMAC2 soap_instantiate___ns1__modifyDataSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSetResponse);
		if (size)
			*size = sizeof(struct __ns1__modifyDataSetResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataSetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataSetResponse %p -> %p\n", q, p));
	*(struct __ns1__modifyDataSetResponse*)p = *(struct __ns1__modifyDataSetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataSet(struct soap *soap, struct __ns1__deleteDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataSet_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataSet(struct soap *soap, const struct __ns1__deleteDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataSet(soap, &a->ns1__deleteDataSet_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataSet(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataSet *a, const char *type)
{
	if (soap_out_PointerTons1__deleteDataSet(soap, "ns1:deleteDataSet", -1, &a->ns1__deleteDataSet_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSet * SOAP_FMAC4 soap_in___ns1__deleteDataSet(struct soap *soap, const char *tag, struct __ns1__deleteDataSet *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataSet_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataSet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataSet, sizeof(struct __ns1__deleteDataSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataSet_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataSet(soap, "ns1:deleteDataSet", &a->ns1__deleteDataSet_, "ns1:deleteDataSet"))
				{	soap_flag_ns1__deleteDataSet_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataSet(struct soap *soap, const struct __ns1__deleteDataSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataSet(soap, tag?tag:"-ns1:deleteDataSet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSet * SOAP_FMAC4 soap_get___ns1__deleteDataSet(struct soap *soap, struct __ns1__deleteDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataSet * SOAP_FMAC2 soap_instantiate___ns1__deleteDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSet);
		if (size)
			*size = sizeof(struct __ns1__deleteDataSet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataSet %p -> %p\n", q, p));
	*(struct __ns1__deleteDataSet*)p = *(struct __ns1__deleteDataSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataSetResponse(struct soap *soap, struct __ns1__deleteDataSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataSetResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataSetResponse(struct soap *soap, const struct __ns1__deleteDataSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataSetResponse(soap, &a->ns1__deleteDataSetResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataSetResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataSetResponse *a, const char *type)
{
	if (a->ns1__deleteDataSetResponse_)
		soap_element_result(soap, "ns1:deleteDataSetResponse");
	if (soap_out_PointerTons1__deleteDataSetResponse(soap, "ns1:deleteDataSetResponse", -1, &a->ns1__deleteDataSetResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSetResponse * SOAP_FMAC4 soap_in___ns1__deleteDataSetResponse(struct soap *soap, const char *tag, struct __ns1__deleteDataSetResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataSetResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataSetResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataSetResponse, sizeof(struct __ns1__deleteDataSetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataSetResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataSetResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataSetResponse(soap, "ns1:deleteDataSetResponse", &a->ns1__deleteDataSetResponse_, "ns1:deleteDataSetResponse"))
				{	soap_flag_ns1__deleteDataSetResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteDataSetResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataSetResponse(struct soap *soap, const struct __ns1__deleteDataSetResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataSetResponse(soap, tag?tag:"-ns1:deleteDataSetResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataSetResponse * SOAP_FMAC4 soap_get___ns1__deleteDataSetResponse(struct soap *soap, struct __ns1__deleteDataSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataSetResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteDataSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSetResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteDataSetResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataSetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataSetResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteDataSetResponse*)p = *(struct __ns1__deleteDataSetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataSet(struct soap *soap, struct __ns1__removeDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataSet_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataSet(struct soap *soap, const struct __ns1__removeDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataSet(soap, &a->ns1__removeDataSet_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataSet(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataSet *a, const char *type)
{
	if (soap_out_PointerTons1__removeDataSet(soap, "ns1:removeDataSet", -1, &a->ns1__removeDataSet_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSet * SOAP_FMAC4 soap_in___ns1__removeDataSet(struct soap *soap, const char *tag, struct __ns1__removeDataSet *a, const char *type)
{
	size_t soap_flag_ns1__removeDataSet_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataSet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataSet, sizeof(struct __ns1__removeDataSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataSet_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataSet(soap, "ns1:removeDataSet", &a->ns1__removeDataSet_, "ns1:removeDataSet"))
				{	soap_flag_ns1__removeDataSet_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataSet(struct soap *soap, const struct __ns1__removeDataSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataSet(soap, tag?tag:"-ns1:removeDataSet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSet * SOAP_FMAC4 soap_get___ns1__removeDataSet(struct soap *soap, struct __ns1__removeDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataSet * SOAP_FMAC2 soap_instantiate___ns1__removeDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSet);
		if (size)
			*size = sizeof(struct __ns1__removeDataSet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataSet %p -> %p\n", q, p));
	*(struct __ns1__removeDataSet*)p = *(struct __ns1__removeDataSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataSetResponse(struct soap *soap, struct __ns1__removeDataSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataSetResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataSetResponse(struct soap *soap, const struct __ns1__removeDataSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataSetResponse(soap, &a->ns1__removeDataSetResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataSetResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataSetResponse *a, const char *type)
{
	if (a->ns1__removeDataSetResponse_)
		soap_element_result(soap, "ns1:removeDataSetResponse");
	if (soap_out_PointerTons1__removeDataSetResponse(soap, "ns1:removeDataSetResponse", -1, &a->ns1__removeDataSetResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSetResponse * SOAP_FMAC4 soap_in___ns1__removeDataSetResponse(struct soap *soap, const char *tag, struct __ns1__removeDataSetResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeDataSetResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataSetResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataSetResponse, sizeof(struct __ns1__removeDataSetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataSetResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataSetResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataSetResponse(soap, "ns1:removeDataSetResponse", &a->ns1__removeDataSetResponse_, "ns1:removeDataSetResponse"))
				{	soap_flag_ns1__removeDataSetResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeDataSetResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataSetResponse(struct soap *soap, const struct __ns1__removeDataSetResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataSetResponse(soap, tag?tag:"-ns1:removeDataSetResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataSetResponse * SOAP_FMAC4 soap_get___ns1__removeDataSetResponse(struct soap *soap, struct __ns1__removeDataSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataSetResponse * SOAP_FMAC2 soap_instantiate___ns1__removeDataSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSetResponse);
		if (size)
			*size = sizeof(struct __ns1__removeDataSetResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataSetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataSetResponse %p -> %p\n", q, p));
	*(struct __ns1__removeDataSetResponse*)p = *(struct __ns1__removeDataSetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createDataSets(struct soap *soap, struct __ns1__createDataSets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createDataSets_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createDataSets(struct soap *soap, const struct __ns1__createDataSets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__createDataSets(soap, &a->ns1__createDataSets_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createDataSets(struct soap *soap, const char *tag, int id, const struct __ns1__createDataSets *a, const char *type)
{
	if (soap_out_PointerTons1__createDataSets(soap, "ns1:createDataSets", -1, &a->ns1__createDataSets_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataSets * SOAP_FMAC4 soap_in___ns1__createDataSets(struct soap *soap, const char *tag, struct __ns1__createDataSets *a, const char *type)
{
	size_t soap_flag_ns1__createDataSets_ = 1;
	short soap_flag;
	a = (struct __ns1__createDataSets *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createDataSets, sizeof(struct __ns1__createDataSets), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createDataSets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createDataSets_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createDataSets(soap, "ns1:createDataSets", &a->ns1__createDataSets_, "ns1:createDataSets"))
				{	soap_flag_ns1__createDataSets_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createDataSets(struct soap *soap, const struct __ns1__createDataSets *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createDataSets(soap, tag?tag:"-ns1:createDataSets", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataSets * SOAP_FMAC4 soap_get___ns1__createDataSets(struct soap *soap, struct __ns1__createDataSets *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createDataSets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__createDataSets * SOAP_FMAC2 soap_instantiate___ns1__createDataSets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createDataSets(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__createDataSets, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataSets);
		if (size)
			*size = sizeof(struct __ns1__createDataSets);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataSets[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__createDataSets);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__createDataSets*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createDataSets(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createDataSets %p -> %p\n", q, p));
	*(struct __ns1__createDataSets*)p = *(struct __ns1__createDataSets*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createDataSet(struct soap *soap, struct __ns1__createDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createDataSet_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createDataSet(struct soap *soap, const struct __ns1__createDataSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__createDataSet(soap, &a->ns1__createDataSet_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createDataSet(struct soap *soap, const char *tag, int id, const struct __ns1__createDataSet *a, const char *type)
{
	if (soap_out_PointerTons1__createDataSet(soap, "ns1:createDataSet", -1, &a->ns1__createDataSet_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataSet * SOAP_FMAC4 soap_in___ns1__createDataSet(struct soap *soap, const char *tag, struct __ns1__createDataSet *a, const char *type)
{
	size_t soap_flag_ns1__createDataSet_ = 1;
	short soap_flag;
	a = (struct __ns1__createDataSet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createDataSet, sizeof(struct __ns1__createDataSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createDataSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createDataSet_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createDataSet(soap, "ns1:createDataSet", &a->ns1__createDataSet_, "ns1:createDataSet"))
				{	soap_flag_ns1__createDataSet_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createDataSet(struct soap *soap, const struct __ns1__createDataSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createDataSet(soap, tag?tag:"-ns1:createDataSet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataSet * SOAP_FMAC4 soap_get___ns1__createDataSet(struct soap *soap, struct __ns1__createDataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__createDataSet * SOAP_FMAC2 soap_instantiate___ns1__createDataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createDataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__createDataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataSet);
		if (size)
			*size = sizeof(struct __ns1__createDataSet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__createDataSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__createDataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createDataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createDataSet %p -> %p\n", q, p));
	*(struct __ns1__createDataSet*)p = *(struct __ns1__createDataSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDatasets(struct soap *soap, struct __ns1__getDatasets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDatasets_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDatasets(struct soap *soap, const struct __ns1__getDatasets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDatasets(soap, &a->ns1__getDatasets_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDatasets(struct soap *soap, const char *tag, int id, const struct __ns1__getDatasets *a, const char *type)
{
	if (soap_out_PointerTons1__getDatasets(soap, "ns1:getDatasets", -1, &a->ns1__getDatasets_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatasets * SOAP_FMAC4 soap_in___ns1__getDatasets(struct soap *soap, const char *tag, struct __ns1__getDatasets *a, const char *type)
{
	size_t soap_flag_ns1__getDatasets_ = 1;
	short soap_flag;
	a = (struct __ns1__getDatasets *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDatasets, sizeof(struct __ns1__getDatasets), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDatasets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDatasets_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDatasets(soap, "ns1:getDatasets", &a->ns1__getDatasets_, "ns1:getDatasets"))
				{	soap_flag_ns1__getDatasets_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDatasets(struct soap *soap, const struct __ns1__getDatasets *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDatasets(soap, tag?tag:"-ns1:getDatasets", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatasets * SOAP_FMAC4 soap_get___ns1__getDatasets(struct soap *soap, struct __ns1__getDatasets *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDatasets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDatasets * SOAP_FMAC2 soap_instantiate___ns1__getDatasets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDatasets(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDatasets, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatasets);
		if (size)
			*size = sizeof(struct __ns1__getDatasets);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatasets[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDatasets);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDatasets*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDatasets(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDatasets %p -> %p\n", q, p));
	*(struct __ns1__getDatasets*)p = *(struct __ns1__getDatasets*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listDatasetStatus(struct soap *soap, struct __ns1__listDatasetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listDatasetStatus_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listDatasetStatus(struct soap *soap, const struct __ns1__listDatasetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listDatasetStatus(soap, &a->ns1__listDatasetStatus_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listDatasetStatus(struct soap *soap, const char *tag, int id, const struct __ns1__listDatasetStatus *a, const char *type)
{
	if (soap_out_PointerTons1__listDatasetStatus(soap, "ns1:listDatasetStatus", -1, &a->ns1__listDatasetStatus_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listDatasetStatus * SOAP_FMAC4 soap_in___ns1__listDatasetStatus(struct soap *soap, const char *tag, struct __ns1__listDatasetStatus *a, const char *type)
{
	size_t soap_flag_ns1__listDatasetStatus_ = 1;
	short soap_flag;
	a = (struct __ns1__listDatasetStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listDatasetStatus, sizeof(struct __ns1__listDatasetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listDatasetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listDatasetStatus_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listDatasetStatus(soap, "ns1:listDatasetStatus", &a->ns1__listDatasetStatus_, "ns1:listDatasetStatus"))
				{	soap_flag_ns1__listDatasetStatus_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listDatasetStatus(struct soap *soap, const struct __ns1__listDatasetStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listDatasetStatus(soap, tag?tag:"-ns1:listDatasetStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listDatasetStatus * SOAP_FMAC4 soap_get___ns1__listDatasetStatus(struct soap *soap, struct __ns1__listDatasetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listDatasetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listDatasetStatus * SOAP_FMAC2 soap_instantiate___ns1__listDatasetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listDatasetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listDatasetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listDatasetStatus);
		if (size)
			*size = sizeof(struct __ns1__listDatasetStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listDatasetStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listDatasetStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listDatasetStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listDatasetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listDatasetStatus %p -> %p\n", q, p));
	*(struct __ns1__listDatasetStatus*)p = *(struct __ns1__listDatasetStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listDatasetTypes(struct soap *soap, struct __ns1__listDatasetTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listDatasetTypes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listDatasetTypes(struct soap *soap, const struct __ns1__listDatasetTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listDatasetTypes(soap, &a->ns1__listDatasetTypes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listDatasetTypes(struct soap *soap, const char *tag, int id, const struct __ns1__listDatasetTypes *a, const char *type)
{
	if (soap_out_PointerTons1__listDatasetTypes(soap, "ns1:listDatasetTypes", -1, &a->ns1__listDatasetTypes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listDatasetTypes * SOAP_FMAC4 soap_in___ns1__listDatasetTypes(struct soap *soap, const char *tag, struct __ns1__listDatasetTypes *a, const char *type)
{
	size_t soap_flag_ns1__listDatasetTypes_ = 1;
	short soap_flag;
	a = (struct __ns1__listDatasetTypes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listDatasetTypes, sizeof(struct __ns1__listDatasetTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listDatasetTypes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listDatasetTypes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listDatasetTypes(soap, "ns1:listDatasetTypes", &a->ns1__listDatasetTypes_, "ns1:listDatasetTypes"))
				{	soap_flag_ns1__listDatasetTypes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listDatasetTypes(struct soap *soap, const struct __ns1__listDatasetTypes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listDatasetTypes(soap, tag?tag:"-ns1:listDatasetTypes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listDatasetTypes * SOAP_FMAC4 soap_get___ns1__listDatasetTypes(struct soap *soap, struct __ns1__listDatasetTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listDatasetTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listDatasetTypes * SOAP_FMAC2 soap_instantiate___ns1__listDatasetTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listDatasetTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listDatasetTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listDatasetTypes);
		if (size)
			*size = sizeof(struct __ns1__listDatasetTypes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listDatasetTypes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listDatasetTypes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listDatasetTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listDatasetTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listDatasetTypes %p -> %p\n", q, p));
	*(struct __ns1__listDatasetTypes*)p = *(struct __ns1__listDatasetTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchSamplesBySampleName(struct soap *soap, struct __ns1__searchSamplesBySampleName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchSamplesBySampleName_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchSamplesBySampleName(struct soap *soap, const struct __ns1__searchSamplesBySampleName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchSamplesBySampleName(soap, &a->ns1__searchSamplesBySampleName_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchSamplesBySampleName(struct soap *soap, const char *tag, int id, const struct __ns1__searchSamplesBySampleName *a, const char *type)
{
	if (soap_out_PointerTons1__searchSamplesBySampleName(soap, "ns1:searchSamplesBySampleName", -1, &a->ns1__searchSamplesBySampleName_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchSamplesBySampleName * SOAP_FMAC4 soap_in___ns1__searchSamplesBySampleName(struct soap *soap, const char *tag, struct __ns1__searchSamplesBySampleName *a, const char *type)
{
	size_t soap_flag_ns1__searchSamplesBySampleName_ = 1;
	short soap_flag;
	a = (struct __ns1__searchSamplesBySampleName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchSamplesBySampleName, sizeof(struct __ns1__searchSamplesBySampleName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchSamplesBySampleName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchSamplesBySampleName_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchSamplesBySampleName(soap, "ns1:searchSamplesBySampleName", &a->ns1__searchSamplesBySampleName_, "ns1:searchSamplesBySampleName"))
				{	soap_flag_ns1__searchSamplesBySampleName_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchSamplesBySampleName(struct soap *soap, const struct __ns1__searchSamplesBySampleName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchSamplesBySampleName(soap, tag?tag:"-ns1:searchSamplesBySampleName", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchSamplesBySampleName * SOAP_FMAC4 soap_get___ns1__searchSamplesBySampleName(struct soap *soap, struct __ns1__searchSamplesBySampleName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchSamplesBySampleName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchSamplesBySampleName * SOAP_FMAC2 soap_instantiate___ns1__searchSamplesBySampleName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchSamplesBySampleName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchSamplesBySampleName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchSamplesBySampleName);
		if (size)
			*size = sizeof(struct __ns1__searchSamplesBySampleName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchSamplesBySampleName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchSamplesBySampleName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchSamplesBySampleName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchSamplesBySampleName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchSamplesBySampleName %p -> %p\n", q, p));
	*(struct __ns1__searchSamplesBySampleName*)p = *(struct __ns1__searchSamplesBySampleName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listDatafileFormats(struct soap *soap, struct __ns1__listDatafileFormats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listDatafileFormats_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listDatafileFormats(struct soap *soap, const struct __ns1__listDatafileFormats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listDatafileFormats(soap, &a->ns1__listDatafileFormats_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listDatafileFormats(struct soap *soap, const char *tag, int id, const struct __ns1__listDatafileFormats *a, const char *type)
{
	if (soap_out_PointerTons1__listDatafileFormats(soap, "ns1:listDatafileFormats", -1, &a->ns1__listDatafileFormats_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listDatafileFormats * SOAP_FMAC4 soap_in___ns1__listDatafileFormats(struct soap *soap, const char *tag, struct __ns1__listDatafileFormats *a, const char *type)
{
	size_t soap_flag_ns1__listDatafileFormats_ = 1;
	short soap_flag;
	a = (struct __ns1__listDatafileFormats *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listDatafileFormats, sizeof(struct __ns1__listDatafileFormats), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listDatafileFormats(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listDatafileFormats_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listDatafileFormats(soap, "ns1:listDatafileFormats", &a->ns1__listDatafileFormats_, "ns1:listDatafileFormats"))
				{	soap_flag_ns1__listDatafileFormats_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listDatafileFormats(struct soap *soap, const struct __ns1__listDatafileFormats *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listDatafileFormats(soap, tag?tag:"-ns1:listDatafileFormats", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listDatafileFormats * SOAP_FMAC4 soap_get___ns1__listDatafileFormats(struct soap *soap, struct __ns1__listDatafileFormats *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listDatafileFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listDatafileFormats * SOAP_FMAC2 soap_instantiate___ns1__listDatafileFormats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listDatafileFormats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listDatafileFormats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listDatafileFormats);
		if (size)
			*size = sizeof(struct __ns1__listDatafileFormats);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listDatafileFormats[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listDatafileFormats);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listDatafileFormats*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listDatafileFormats(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listDatafileFormats %p -> %p\n", q, p));
	*(struct __ns1__listDatafileFormats*)p = *(struct __ns1__listDatafileFormats*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByRunNumberPagination(struct soap *soap, struct __ns1__searchByRunNumberPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByRunNumberPagination_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByRunNumberPagination(struct soap *soap, const struct __ns1__searchByRunNumberPagination *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByRunNumberPagination(soap, &a->ns1__searchByRunNumberPagination_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByRunNumberPagination(struct soap *soap, const char *tag, int id, const struct __ns1__searchByRunNumberPagination *a, const char *type)
{
	if (soap_out_PointerTons1__searchByRunNumberPagination(soap, "ns1:searchByRunNumberPagination", -1, &a->ns1__searchByRunNumberPagination_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByRunNumberPagination * SOAP_FMAC4 soap_in___ns1__searchByRunNumberPagination(struct soap *soap, const char *tag, struct __ns1__searchByRunNumberPagination *a, const char *type)
{
	size_t soap_flag_ns1__searchByRunNumberPagination_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByRunNumberPagination *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByRunNumberPagination, sizeof(struct __ns1__searchByRunNumberPagination), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByRunNumberPagination(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByRunNumberPagination_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByRunNumberPagination(soap, "ns1:searchByRunNumberPagination", &a->ns1__searchByRunNumberPagination_, "ns1:searchByRunNumberPagination"))
				{	soap_flag_ns1__searchByRunNumberPagination_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByRunNumberPagination(struct soap *soap, const struct __ns1__searchByRunNumberPagination *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByRunNumberPagination(soap, tag?tag:"-ns1:searchByRunNumberPagination", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByRunNumberPagination * SOAP_FMAC4 soap_get___ns1__searchByRunNumberPagination(struct soap *soap, struct __ns1__searchByRunNumberPagination *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByRunNumberPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByRunNumberPagination * SOAP_FMAC2 soap_instantiate___ns1__searchByRunNumberPagination(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByRunNumberPagination(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByRunNumberPagination, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByRunNumberPagination);
		if (size)
			*size = sizeof(struct __ns1__searchByRunNumberPagination);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByRunNumberPagination[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByRunNumberPagination);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByRunNumberPagination*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByRunNumberPagination(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByRunNumberPagination %p -> %p\n", q, p));
	*(struct __ns1__searchByRunNumberPagination*)p = *(struct __ns1__searchByRunNumberPagination*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByRunNumber(struct soap *soap, struct __ns1__searchByRunNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchByRunNumber_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByRunNumber(struct soap *soap, const struct __ns1__searchByRunNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchByRunNumber(soap, &a->ns1__searchByRunNumber_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByRunNumber(struct soap *soap, const char *tag, int id, const struct __ns1__searchByRunNumber *a, const char *type)
{
	if (soap_out_PointerTons1__searchByRunNumber(soap, "ns1:searchByRunNumber", -1, &a->ns1__searchByRunNumber_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByRunNumber * SOAP_FMAC4 soap_in___ns1__searchByRunNumber(struct soap *soap, const char *tag, struct __ns1__searchByRunNumber *a, const char *type)
{
	size_t soap_flag_ns1__searchByRunNumber_ = 1;
	short soap_flag;
	a = (struct __ns1__searchByRunNumber *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByRunNumber, sizeof(struct __ns1__searchByRunNumber), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByRunNumber(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchByRunNumber_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchByRunNumber(soap, "ns1:searchByRunNumber", &a->ns1__searchByRunNumber_, "ns1:searchByRunNumber"))
				{	soap_flag_ns1__searchByRunNumber_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByRunNumber(struct soap *soap, const struct __ns1__searchByRunNumber *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchByRunNumber(soap, tag?tag:"-ns1:searchByRunNumber", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByRunNumber * SOAP_FMAC4 soap_get___ns1__searchByRunNumber(struct soap *soap, struct __ns1__searchByRunNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByRunNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__searchByRunNumber * SOAP_FMAC2 soap_instantiate___ns1__searchByRunNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByRunNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchByRunNumber, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByRunNumber);
		if (size)
			*size = sizeof(struct __ns1__searchByRunNumber);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__searchByRunNumber[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchByRunNumber);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchByRunNumber*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchByRunNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchByRunNumber %p -> %p\n", q, p));
	*(struct __ns1__searchByRunNumber*)p = *(struct __ns1__searchByRunNumber*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllKeywords(struct soap *soap, struct __ns1__getAllKeywords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllKeywords_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllKeywords(struct soap *soap, const struct __ns1__getAllKeywords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getAllKeywords(soap, &a->ns1__getAllKeywords_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllKeywords(struct soap *soap, const char *tag, int id, const struct __ns1__getAllKeywords *a, const char *type)
{
	if (soap_out_PointerTons1__getAllKeywords(soap, "ns1:getAllKeywords", -1, &a->ns1__getAllKeywords_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllKeywords * SOAP_FMAC4 soap_in___ns1__getAllKeywords(struct soap *soap, const char *tag, struct __ns1__getAllKeywords *a, const char *type)
{
	size_t soap_flag_ns1__getAllKeywords_ = 1;
	short soap_flag;
	a = (struct __ns1__getAllKeywords *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllKeywords, sizeof(struct __ns1__getAllKeywords), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllKeywords(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllKeywords_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getAllKeywords(soap, "ns1:getAllKeywords", &a->ns1__getAllKeywords_, "ns1:getAllKeywords"))
				{	soap_flag_ns1__getAllKeywords_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllKeywords(struct soap *soap, const struct __ns1__getAllKeywords *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllKeywords(soap, tag?tag:"-ns1:getAllKeywords", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllKeywords * SOAP_FMAC4 soap_get___ns1__getAllKeywords(struct soap *soap, struct __ns1__getAllKeywords *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllKeywords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAllKeywords * SOAP_FMAC2 soap_instantiate___ns1__getAllKeywords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAllKeywords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAllKeywords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllKeywords);
		if (size)
			*size = sizeof(struct __ns1__getAllKeywords);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllKeywords[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAllKeywords);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAllKeywords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAllKeywords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAllKeywords %p -> %p\n", q, p));
	*(struct __ns1__getAllKeywords*)p = *(struct __ns1__getAllKeywords*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getKeywordsForUserType(struct soap *soap, struct __ns1__getKeywordsForUserType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getKeywordsForUserType_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getKeywordsForUserType(struct soap *soap, const struct __ns1__getKeywordsForUserType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getKeywordsForUserType(soap, &a->ns1__getKeywordsForUserType_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getKeywordsForUserType(struct soap *soap, const char *tag, int id, const struct __ns1__getKeywordsForUserType *a, const char *type)
{
	if (soap_out_PointerTons1__getKeywordsForUserType(soap, "ns1:getKeywordsForUserType", -1, &a->ns1__getKeywordsForUserType_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUserType * SOAP_FMAC4 soap_in___ns1__getKeywordsForUserType(struct soap *soap, const char *tag, struct __ns1__getKeywordsForUserType *a, const char *type)
{
	size_t soap_flag_ns1__getKeywordsForUserType_ = 1;
	short soap_flag;
	a = (struct __ns1__getKeywordsForUserType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getKeywordsForUserType, sizeof(struct __ns1__getKeywordsForUserType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getKeywordsForUserType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getKeywordsForUserType_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getKeywordsForUserType(soap, "ns1:getKeywordsForUserType", &a->ns1__getKeywordsForUserType_, "ns1:getKeywordsForUserType"))
				{	soap_flag_ns1__getKeywordsForUserType_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getKeywordsForUserType(struct soap *soap, const struct __ns1__getKeywordsForUserType *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getKeywordsForUserType(soap, tag?tag:"-ns1:getKeywordsForUserType", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUserType * SOAP_FMAC4 soap_get___ns1__getKeywordsForUserType(struct soap *soap, struct __ns1__getKeywordsForUserType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getKeywordsForUserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getKeywordsForUserType * SOAP_FMAC2 soap_instantiate___ns1__getKeywordsForUserType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getKeywordsForUserType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getKeywordsForUserType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUserType);
		if (size)
			*size = sizeof(struct __ns1__getKeywordsForUserType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUserType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getKeywordsForUserType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getKeywordsForUserType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getKeywordsForUserType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getKeywordsForUserType %p -> %p\n", q, p));
	*(struct __ns1__getKeywordsForUserType*)p = *(struct __ns1__getKeywordsForUserType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getKeywordsForUserMax(struct soap *soap, struct __ns1__getKeywordsForUserMax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getKeywordsForUserMax_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getKeywordsForUserMax(struct soap *soap, const struct __ns1__getKeywordsForUserMax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getKeywordsForUserMax(soap, &a->ns1__getKeywordsForUserMax_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getKeywordsForUserMax(struct soap *soap, const char *tag, int id, const struct __ns1__getKeywordsForUserMax *a, const char *type)
{
	if (soap_out_PointerTons1__getKeywordsForUserMax(soap, "ns1:getKeywordsForUserMax", -1, &a->ns1__getKeywordsForUserMax_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUserMax * SOAP_FMAC4 soap_in___ns1__getKeywordsForUserMax(struct soap *soap, const char *tag, struct __ns1__getKeywordsForUserMax *a, const char *type)
{
	size_t soap_flag_ns1__getKeywordsForUserMax_ = 1;
	short soap_flag;
	a = (struct __ns1__getKeywordsForUserMax *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getKeywordsForUserMax, sizeof(struct __ns1__getKeywordsForUserMax), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getKeywordsForUserMax(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getKeywordsForUserMax_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getKeywordsForUserMax(soap, "ns1:getKeywordsForUserMax", &a->ns1__getKeywordsForUserMax_, "ns1:getKeywordsForUserMax"))
				{	soap_flag_ns1__getKeywordsForUserMax_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getKeywordsForUserMax(struct soap *soap, const struct __ns1__getKeywordsForUserMax *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getKeywordsForUserMax(soap, tag?tag:"-ns1:getKeywordsForUserMax", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUserMax * SOAP_FMAC4 soap_get___ns1__getKeywordsForUserMax(struct soap *soap, struct __ns1__getKeywordsForUserMax *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getKeywordsForUserMax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getKeywordsForUserMax * SOAP_FMAC2 soap_instantiate___ns1__getKeywordsForUserMax(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getKeywordsForUserMax(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getKeywordsForUserMax, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUserMax);
		if (size)
			*size = sizeof(struct __ns1__getKeywordsForUserMax);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUserMax[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getKeywordsForUserMax);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getKeywordsForUserMax*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getKeywordsForUserMax(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getKeywordsForUserMax %p -> %p\n", q, p));
	*(struct __ns1__getKeywordsForUserMax*)p = *(struct __ns1__getKeywordsForUserMax*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getKeywordsForUserStartWithMax(struct soap *soap, struct __ns1__getKeywordsForUserStartWithMax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getKeywordsForUserStartWithMax_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getKeywordsForUserStartWithMax(struct soap *soap, const struct __ns1__getKeywordsForUserStartWithMax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getKeywordsForUserStartWithMax(soap, &a->ns1__getKeywordsForUserStartWithMax_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getKeywordsForUserStartWithMax(struct soap *soap, const char *tag, int id, const struct __ns1__getKeywordsForUserStartWithMax *a, const char *type)
{
	if (soap_out_PointerTons1__getKeywordsForUserStartWithMax(soap, "ns1:getKeywordsForUserStartWithMax", -1, &a->ns1__getKeywordsForUserStartWithMax_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUserStartWithMax * SOAP_FMAC4 soap_in___ns1__getKeywordsForUserStartWithMax(struct soap *soap, const char *tag, struct __ns1__getKeywordsForUserStartWithMax *a, const char *type)
{
	size_t soap_flag_ns1__getKeywordsForUserStartWithMax_ = 1;
	short soap_flag;
	a = (struct __ns1__getKeywordsForUserStartWithMax *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getKeywordsForUserStartWithMax, sizeof(struct __ns1__getKeywordsForUserStartWithMax), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getKeywordsForUserStartWithMax(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getKeywordsForUserStartWithMax_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getKeywordsForUserStartWithMax(soap, "ns1:getKeywordsForUserStartWithMax", &a->ns1__getKeywordsForUserStartWithMax_, "ns1:getKeywordsForUserStartWithMax"))
				{	soap_flag_ns1__getKeywordsForUserStartWithMax_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getKeywordsForUserStartWithMax(struct soap *soap, const struct __ns1__getKeywordsForUserStartWithMax *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getKeywordsForUserStartWithMax(soap, tag?tag:"-ns1:getKeywordsForUserStartWithMax", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUserStartWithMax * SOAP_FMAC4 soap_get___ns1__getKeywordsForUserStartWithMax(struct soap *soap, struct __ns1__getKeywordsForUserStartWithMax *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getKeywordsForUserStartWithMax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getKeywordsForUserStartWithMax * SOAP_FMAC2 soap_instantiate___ns1__getKeywordsForUserStartWithMax(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getKeywordsForUserStartWithMax(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getKeywordsForUserStartWithMax, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUserStartWithMax);
		if (size)
			*size = sizeof(struct __ns1__getKeywordsForUserStartWithMax);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUserStartWithMax[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getKeywordsForUserStartWithMax);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getKeywordsForUserStartWithMax*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getKeywordsForUserStartWithMax(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getKeywordsForUserStartWithMax %p -> %p\n", q, p));
	*(struct __ns1__getKeywordsForUserStartWithMax*)p = *(struct __ns1__getKeywordsForUserStartWithMax*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getKeywordsForUser(struct soap *soap, struct __ns1__getKeywordsForUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getKeywordsForUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getKeywordsForUser(struct soap *soap, const struct __ns1__getKeywordsForUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getKeywordsForUser(soap, &a->ns1__getKeywordsForUser_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getKeywordsForUser(struct soap *soap, const char *tag, int id, const struct __ns1__getKeywordsForUser *a, const char *type)
{
	if (soap_out_PointerTons1__getKeywordsForUser(soap, "ns1:getKeywordsForUser", -1, &a->ns1__getKeywordsForUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUser * SOAP_FMAC4 soap_in___ns1__getKeywordsForUser(struct soap *soap, const char *tag, struct __ns1__getKeywordsForUser *a, const char *type)
{
	size_t soap_flag_ns1__getKeywordsForUser_ = 1;
	short soap_flag;
	a = (struct __ns1__getKeywordsForUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getKeywordsForUser, sizeof(struct __ns1__getKeywordsForUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getKeywordsForUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getKeywordsForUser_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getKeywordsForUser(soap, "ns1:getKeywordsForUser", &a->ns1__getKeywordsForUser_, "ns1:getKeywordsForUser"))
				{	soap_flag_ns1__getKeywordsForUser_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getKeywordsForUser(struct soap *soap, const struct __ns1__getKeywordsForUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getKeywordsForUser(soap, tag?tag:"-ns1:getKeywordsForUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getKeywordsForUser * SOAP_FMAC4 soap_get___ns1__getKeywordsForUser(struct soap *soap, struct __ns1__getKeywordsForUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getKeywordsForUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getKeywordsForUser * SOAP_FMAC2 soap_instantiate___ns1__getKeywordsForUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getKeywordsForUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getKeywordsForUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUser);
		if (size)
			*size = sizeof(struct __ns1__getKeywordsForUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getKeywordsForUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getKeywordsForUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getKeywordsForUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getKeywordsForUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getKeywordsForUser %p -> %p\n", q, p));
	*(struct __ns1__getKeywordsForUser*)p = *(struct __ns1__getKeywordsForUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifySampleParameter(struct soap *soap, struct __ns1__modifySampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifySampleParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifySampleParameter(struct soap *soap, const struct __ns1__modifySampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifySampleParameter(soap, &a->ns1__modifySampleParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifySampleParameter(struct soap *soap, const char *tag, int id, const struct __ns1__modifySampleParameter *a, const char *type)
{
	if (soap_out_PointerTons1__modifySampleParameter(soap, "ns1:modifySampleParameter", -1, &a->ns1__modifySampleParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySampleParameter * SOAP_FMAC4 soap_in___ns1__modifySampleParameter(struct soap *soap, const char *tag, struct __ns1__modifySampleParameter *a, const char *type)
{
	size_t soap_flag_ns1__modifySampleParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__modifySampleParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifySampleParameter, sizeof(struct __ns1__modifySampleParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifySampleParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifySampleParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifySampleParameter(soap, "ns1:modifySampleParameter", &a->ns1__modifySampleParameter_, "ns1:modifySampleParameter"))
				{	soap_flag_ns1__modifySampleParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifySampleParameter(struct soap *soap, const struct __ns1__modifySampleParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifySampleParameter(soap, tag?tag:"-ns1:modifySampleParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySampleParameter * SOAP_FMAC4 soap_get___ns1__modifySampleParameter(struct soap *soap, struct __ns1__modifySampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifySampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifySampleParameter * SOAP_FMAC2 soap_instantiate___ns1__modifySampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifySampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifySampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySampleParameter);
		if (size)
			*size = sizeof(struct __ns1__modifySampleParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifySampleParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifySampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifySampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifySampleParameter %p -> %p\n", q, p));
	*(struct __ns1__modifySampleParameter*)p = *(struct __ns1__modifySampleParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifySampleParameterResponse(struct soap *soap, struct __ns1__modifySampleParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifySampleParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifySampleParameterResponse(struct soap *soap, const struct __ns1__modifySampleParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifySampleParameterResponse(soap, &a->ns1__modifySampleParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifySampleParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifySampleParameterResponse *a, const char *type)
{
	if (a->ns1__modifySampleParameterResponse_)
		soap_element_result(soap, "ns1:modifySampleParameterResponse");
	if (soap_out_PointerTons1__modifySampleParameterResponse(soap, "ns1:modifySampleParameterResponse", -1, &a->ns1__modifySampleParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySampleParameterResponse * SOAP_FMAC4 soap_in___ns1__modifySampleParameterResponse(struct soap *soap, const char *tag, struct __ns1__modifySampleParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifySampleParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifySampleParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifySampleParameterResponse, sizeof(struct __ns1__modifySampleParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifySampleParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifySampleParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifySampleParameterResponse(soap, "ns1:modifySampleParameterResponse", &a->ns1__modifySampleParameterResponse_, "ns1:modifySampleParameterResponse"))
				{	soap_flag_ns1__modifySampleParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifySampleParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifySampleParameterResponse(struct soap *soap, const struct __ns1__modifySampleParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifySampleParameterResponse(soap, tag?tag:"-ns1:modifySampleParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySampleParameterResponse * SOAP_FMAC4 soap_get___ns1__modifySampleParameterResponse(struct soap *soap, struct __ns1__modifySampleParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifySampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifySampleParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__modifySampleParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifySampleParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifySampleParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySampleParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__modifySampleParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySampleParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifySampleParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifySampleParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifySampleParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifySampleParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__modifySampleParameterResponse*)p = *(struct __ns1__modifySampleParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteSampleParameter(struct soap *soap, struct __ns1__deleteSampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteSampleParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteSampleParameter(struct soap *soap, const struct __ns1__deleteSampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteSampleParameter(soap, &a->ns1__deleteSampleParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteSampleParameter(struct soap *soap, const char *tag, int id, const struct __ns1__deleteSampleParameter *a, const char *type)
{
	if (soap_out_PointerTons1__deleteSampleParameter(soap, "ns1:deleteSampleParameter", -1, &a->ns1__deleteSampleParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSampleParameter * SOAP_FMAC4 soap_in___ns1__deleteSampleParameter(struct soap *soap, const char *tag, struct __ns1__deleteSampleParameter *a, const char *type)
{
	size_t soap_flag_ns1__deleteSampleParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteSampleParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteSampleParameter, sizeof(struct __ns1__deleteSampleParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteSampleParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteSampleParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteSampleParameter(soap, "ns1:deleteSampleParameter", &a->ns1__deleteSampleParameter_, "ns1:deleteSampleParameter"))
				{	soap_flag_ns1__deleteSampleParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteSampleParameter(struct soap *soap, const struct __ns1__deleteSampleParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteSampleParameter(soap, tag?tag:"-ns1:deleteSampleParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSampleParameter * SOAP_FMAC4 soap_get___ns1__deleteSampleParameter(struct soap *soap, struct __ns1__deleteSampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteSampleParameter * SOAP_FMAC2 soap_instantiate___ns1__deleteSampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteSampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteSampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSampleParameter);
		if (size)
			*size = sizeof(struct __ns1__deleteSampleParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteSampleParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteSampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteSampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteSampleParameter %p -> %p\n", q, p));
	*(struct __ns1__deleteSampleParameter*)p = *(struct __ns1__deleteSampleParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteSampleParameterResponse(struct soap *soap, struct __ns1__deleteSampleParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteSampleParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteSampleParameterResponse(struct soap *soap, const struct __ns1__deleteSampleParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteSampleParameterResponse(soap, &a->ns1__deleteSampleParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteSampleParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteSampleParameterResponse *a, const char *type)
{
	if (a->ns1__deleteSampleParameterResponse_)
		soap_element_result(soap, "ns1:deleteSampleParameterResponse");
	if (soap_out_PointerTons1__deleteSampleParameterResponse(soap, "ns1:deleteSampleParameterResponse", -1, &a->ns1__deleteSampleParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSampleParameterResponse * SOAP_FMAC4 soap_in___ns1__deleteSampleParameterResponse(struct soap *soap, const char *tag, struct __ns1__deleteSampleParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteSampleParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteSampleParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteSampleParameterResponse, sizeof(struct __ns1__deleteSampleParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteSampleParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteSampleParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteSampleParameterResponse(soap, "ns1:deleteSampleParameterResponse", &a->ns1__deleteSampleParameterResponse_, "ns1:deleteSampleParameterResponse"))
				{	soap_flag_ns1__deleteSampleParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteSampleParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteSampleParameterResponse(struct soap *soap, const struct __ns1__deleteSampleParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteSampleParameterResponse(soap, tag?tag:"-ns1:deleteSampleParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSampleParameterResponse * SOAP_FMAC4 soap_get___ns1__deleteSampleParameterResponse(struct soap *soap, struct __ns1__deleteSampleParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteSampleParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteSampleParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteSampleParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteSampleParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSampleParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteSampleParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSampleParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteSampleParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteSampleParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteSampleParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteSampleParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteSampleParameterResponse*)p = *(struct __ns1__deleteSampleParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeSampleParameter(struct soap *soap, struct __ns1__removeSampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeSampleParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeSampleParameter(struct soap *soap, const struct __ns1__removeSampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeSampleParameter(soap, &a->ns1__removeSampleParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeSampleParameter(struct soap *soap, const char *tag, int id, const struct __ns1__removeSampleParameter *a, const char *type)
{
	if (soap_out_PointerTons1__removeSampleParameter(soap, "ns1:removeSampleParameter", -1, &a->ns1__removeSampleParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSampleParameter * SOAP_FMAC4 soap_in___ns1__removeSampleParameter(struct soap *soap, const char *tag, struct __ns1__removeSampleParameter *a, const char *type)
{
	size_t soap_flag_ns1__removeSampleParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__removeSampleParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeSampleParameter, sizeof(struct __ns1__removeSampleParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeSampleParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeSampleParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeSampleParameter(soap, "ns1:removeSampleParameter", &a->ns1__removeSampleParameter_, "ns1:removeSampleParameter"))
				{	soap_flag_ns1__removeSampleParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeSampleParameter(struct soap *soap, const struct __ns1__removeSampleParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeSampleParameter(soap, tag?tag:"-ns1:removeSampleParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSampleParameter * SOAP_FMAC4 soap_get___ns1__removeSampleParameter(struct soap *soap, struct __ns1__removeSampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeSampleParameter * SOAP_FMAC2 soap_instantiate___ns1__removeSampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeSampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeSampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSampleParameter);
		if (size)
			*size = sizeof(struct __ns1__removeSampleParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeSampleParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeSampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeSampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeSampleParameter %p -> %p\n", q, p));
	*(struct __ns1__removeSampleParameter*)p = *(struct __ns1__removeSampleParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeSampleParameterResponse(struct soap *soap, struct __ns1__removeSampleParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeSampleParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeSampleParameterResponse(struct soap *soap, const struct __ns1__removeSampleParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeSampleParameterResponse(soap, &a->ns1__removeSampleParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeSampleParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeSampleParameterResponse *a, const char *type)
{
	if (a->ns1__removeSampleParameterResponse_)
		soap_element_result(soap, "ns1:removeSampleParameterResponse");
	if (soap_out_PointerTons1__removeSampleParameterResponse(soap, "ns1:removeSampleParameterResponse", -1, &a->ns1__removeSampleParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSampleParameterResponse * SOAP_FMAC4 soap_in___ns1__removeSampleParameterResponse(struct soap *soap, const char *tag, struct __ns1__removeSampleParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeSampleParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeSampleParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeSampleParameterResponse, sizeof(struct __ns1__removeSampleParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeSampleParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeSampleParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeSampleParameterResponse(soap, "ns1:removeSampleParameterResponse", &a->ns1__removeSampleParameterResponse_, "ns1:removeSampleParameterResponse"))
				{	soap_flag_ns1__removeSampleParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeSampleParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeSampleParameterResponse(struct soap *soap, const struct __ns1__removeSampleParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeSampleParameterResponse(soap, tag?tag:"-ns1:removeSampleParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSampleParameterResponse * SOAP_FMAC4 soap_get___ns1__removeSampleParameterResponse(struct soap *soap, struct __ns1__removeSampleParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeSampleParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__removeSampleParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeSampleParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeSampleParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSampleParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__removeSampleParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSampleParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeSampleParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeSampleParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeSampleParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeSampleParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__removeSampleParameterResponse*)p = *(struct __ns1__removeSampleParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifySample(struct soap *soap, struct __ns1__modifySample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifySample_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifySample(struct soap *soap, const struct __ns1__modifySample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifySample(soap, &a->ns1__modifySample_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifySample(struct soap *soap, const char *tag, int id, const struct __ns1__modifySample *a, const char *type)
{
	if (soap_out_PointerTons1__modifySample(soap, "ns1:modifySample", -1, &a->ns1__modifySample_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySample * SOAP_FMAC4 soap_in___ns1__modifySample(struct soap *soap, const char *tag, struct __ns1__modifySample *a, const char *type)
{
	size_t soap_flag_ns1__modifySample_ = 1;
	short soap_flag;
	a = (struct __ns1__modifySample *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifySample, sizeof(struct __ns1__modifySample), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifySample(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifySample_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifySample(soap, "ns1:modifySample", &a->ns1__modifySample_, "ns1:modifySample"))
				{	soap_flag_ns1__modifySample_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifySample(struct soap *soap, const struct __ns1__modifySample *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifySample(soap, tag?tag:"-ns1:modifySample", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySample * SOAP_FMAC4 soap_get___ns1__modifySample(struct soap *soap, struct __ns1__modifySample *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifySample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifySample * SOAP_FMAC2 soap_instantiate___ns1__modifySample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifySample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifySample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySample);
		if (size)
			*size = sizeof(struct __ns1__modifySample);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifySample);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifySample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifySample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifySample %p -> %p\n", q, p));
	*(struct __ns1__modifySample*)p = *(struct __ns1__modifySample*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifySampleResponse(struct soap *soap, struct __ns1__modifySampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifySampleResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifySampleResponse(struct soap *soap, const struct __ns1__modifySampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifySampleResponse(soap, &a->ns1__modifySampleResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifySampleResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifySampleResponse *a, const char *type)
{
	if (a->ns1__modifySampleResponse_)
		soap_element_result(soap, "ns1:modifySampleResponse");
	if (soap_out_PointerTons1__modifySampleResponse(soap, "ns1:modifySampleResponse", -1, &a->ns1__modifySampleResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySampleResponse * SOAP_FMAC4 soap_in___ns1__modifySampleResponse(struct soap *soap, const char *tag, struct __ns1__modifySampleResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifySampleResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifySampleResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifySampleResponse, sizeof(struct __ns1__modifySampleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifySampleResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifySampleResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifySampleResponse(soap, "ns1:modifySampleResponse", &a->ns1__modifySampleResponse_, "ns1:modifySampleResponse"))
				{	soap_flag_ns1__modifySampleResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifySampleResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifySampleResponse(struct soap *soap, const struct __ns1__modifySampleResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifySampleResponse(soap, tag?tag:"-ns1:modifySampleResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifySampleResponse * SOAP_FMAC4 soap_get___ns1__modifySampleResponse(struct soap *soap, struct __ns1__modifySampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifySampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifySampleResponse * SOAP_FMAC2 soap_instantiate___ns1__modifySampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifySampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifySampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySampleResponse);
		if (size)
			*size = sizeof(struct __ns1__modifySampleResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifySampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifySampleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifySampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifySampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifySampleResponse %p -> %p\n", q, p));
	*(struct __ns1__modifySampleResponse*)p = *(struct __ns1__modifySampleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteSample(struct soap *soap, struct __ns1__deleteSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteSample_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteSample(struct soap *soap, const struct __ns1__deleteSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteSample(soap, &a->ns1__deleteSample_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteSample(struct soap *soap, const char *tag, int id, const struct __ns1__deleteSample *a, const char *type)
{
	if (soap_out_PointerTons1__deleteSample(soap, "ns1:deleteSample", -1, &a->ns1__deleteSample_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSample * SOAP_FMAC4 soap_in___ns1__deleteSample(struct soap *soap, const char *tag, struct __ns1__deleteSample *a, const char *type)
{
	size_t soap_flag_ns1__deleteSample_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteSample *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteSample, sizeof(struct __ns1__deleteSample), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteSample(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteSample_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteSample(soap, "ns1:deleteSample", &a->ns1__deleteSample_, "ns1:deleteSample"))
				{	soap_flag_ns1__deleteSample_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteSample(struct soap *soap, const struct __ns1__deleteSample *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteSample(soap, tag?tag:"-ns1:deleteSample", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSample * SOAP_FMAC4 soap_get___ns1__deleteSample(struct soap *soap, struct __ns1__deleteSample *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteSample * SOAP_FMAC2 soap_instantiate___ns1__deleteSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSample);
		if (size)
			*size = sizeof(struct __ns1__deleteSample);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteSample);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteSample %p -> %p\n", q, p));
	*(struct __ns1__deleteSample*)p = *(struct __ns1__deleteSample*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteSampleResponse(struct soap *soap, struct __ns1__deleteSampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteSampleResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteSampleResponse(struct soap *soap, const struct __ns1__deleteSampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteSampleResponse(soap, &a->ns1__deleteSampleResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteSampleResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteSampleResponse *a, const char *type)
{
	if (a->ns1__deleteSampleResponse_)
		soap_element_result(soap, "ns1:deleteSampleResponse");
	if (soap_out_PointerTons1__deleteSampleResponse(soap, "ns1:deleteSampleResponse", -1, &a->ns1__deleteSampleResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSampleResponse * SOAP_FMAC4 soap_in___ns1__deleteSampleResponse(struct soap *soap, const char *tag, struct __ns1__deleteSampleResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteSampleResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteSampleResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteSampleResponse, sizeof(struct __ns1__deleteSampleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteSampleResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteSampleResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteSampleResponse(soap, "ns1:deleteSampleResponse", &a->ns1__deleteSampleResponse_, "ns1:deleteSampleResponse"))
				{	soap_flag_ns1__deleteSampleResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteSampleResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteSampleResponse(struct soap *soap, const struct __ns1__deleteSampleResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteSampleResponse(soap, tag?tag:"-ns1:deleteSampleResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSampleResponse * SOAP_FMAC4 soap_get___ns1__deleteSampleResponse(struct soap *soap, struct __ns1__deleteSampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteSampleResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteSampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteSampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteSampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSampleResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteSampleResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteSampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteSampleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteSampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteSampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteSampleResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteSampleResponse*)p = *(struct __ns1__deleteSampleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeSample(struct soap *soap, struct __ns1__removeSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeSample_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeSample(struct soap *soap, const struct __ns1__removeSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeSample(soap, &a->ns1__removeSample_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeSample(struct soap *soap, const char *tag, int id, const struct __ns1__removeSample *a, const char *type)
{
	if (soap_out_PointerTons1__removeSample(soap, "ns1:removeSample", -1, &a->ns1__removeSample_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSample * SOAP_FMAC4 soap_in___ns1__removeSample(struct soap *soap, const char *tag, struct __ns1__removeSample *a, const char *type)
{
	size_t soap_flag_ns1__removeSample_ = 1;
	short soap_flag;
	a = (struct __ns1__removeSample *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeSample, sizeof(struct __ns1__removeSample), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeSample(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeSample_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeSample(soap, "ns1:removeSample", &a->ns1__removeSample_, "ns1:removeSample"))
				{	soap_flag_ns1__removeSample_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeSample(struct soap *soap, const struct __ns1__removeSample *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeSample(soap, tag?tag:"-ns1:removeSample", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSample * SOAP_FMAC4 soap_get___ns1__removeSample(struct soap *soap, struct __ns1__removeSample *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeSample * SOAP_FMAC2 soap_instantiate___ns1__removeSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSample);
		if (size)
			*size = sizeof(struct __ns1__removeSample);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeSample);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeSample %p -> %p\n", q, p));
	*(struct __ns1__removeSample*)p = *(struct __ns1__removeSample*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeSampleResponse(struct soap *soap, struct __ns1__removeSampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeSampleResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeSampleResponse(struct soap *soap, const struct __ns1__removeSampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeSampleResponse(soap, &a->ns1__removeSampleResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeSampleResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeSampleResponse *a, const char *type)
{
	if (a->ns1__removeSampleResponse_)
		soap_element_result(soap, "ns1:removeSampleResponse");
	if (soap_out_PointerTons1__removeSampleResponse(soap, "ns1:removeSampleResponse", -1, &a->ns1__removeSampleResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSampleResponse * SOAP_FMAC4 soap_in___ns1__removeSampleResponse(struct soap *soap, const char *tag, struct __ns1__removeSampleResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeSampleResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeSampleResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeSampleResponse, sizeof(struct __ns1__removeSampleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeSampleResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeSampleResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeSampleResponse(soap, "ns1:removeSampleResponse", &a->ns1__removeSampleResponse_, "ns1:removeSampleResponse"))
				{	soap_flag_ns1__removeSampleResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeSampleResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeSampleResponse(struct soap *soap, const struct __ns1__removeSampleResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeSampleResponse(soap, tag?tag:"-ns1:removeSampleResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSampleResponse * SOAP_FMAC4 soap_get___ns1__removeSampleResponse(struct soap *soap, struct __ns1__removeSampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeSampleResponse * SOAP_FMAC2 soap_instantiate___ns1__removeSampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeSampleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeSampleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSampleResponse);
		if (size)
			*size = sizeof(struct __ns1__removeSampleResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSampleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeSampleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeSampleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeSampleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeSampleResponse %p -> %p\n", q, p));
	*(struct __ns1__removeSampleResponse*)p = *(struct __ns1__removeSampleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteInvestigator(struct soap *soap, struct __ns1__deleteInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteInvestigator_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteInvestigator(struct soap *soap, const struct __ns1__deleteInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteInvestigator(soap, &a->ns1__deleteInvestigator_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteInvestigator(struct soap *soap, const char *tag, int id, const struct __ns1__deleteInvestigator *a, const char *type)
{
	if (soap_out_PointerTons1__deleteInvestigator(soap, "ns1:deleteInvestigator", -1, &a->ns1__deleteInvestigator_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigator * SOAP_FMAC4 soap_in___ns1__deleteInvestigator(struct soap *soap, const char *tag, struct __ns1__deleteInvestigator *a, const char *type)
{
	size_t soap_flag_ns1__deleteInvestigator_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteInvestigator *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteInvestigator, sizeof(struct __ns1__deleteInvestigator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteInvestigator(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteInvestigator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteInvestigator(soap, "ns1:deleteInvestigator", &a->ns1__deleteInvestigator_, "ns1:deleteInvestigator"))
				{	soap_flag_ns1__deleteInvestigator_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteInvestigator(struct soap *soap, const struct __ns1__deleteInvestigator *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteInvestigator(soap, tag?tag:"-ns1:deleteInvestigator", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigator * SOAP_FMAC4 soap_get___ns1__deleteInvestigator(struct soap *soap, struct __ns1__deleteInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteInvestigator * SOAP_FMAC2 soap_instantiate___ns1__deleteInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigator);
		if (size)
			*size = sizeof(struct __ns1__deleteInvestigator);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteInvestigator);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteInvestigator %p -> %p\n", q, p));
	*(struct __ns1__deleteInvestigator*)p = *(struct __ns1__deleteInvestigator*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteInvestigatorResponse(struct soap *soap, struct __ns1__deleteInvestigatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteInvestigatorResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteInvestigatorResponse(struct soap *soap, const struct __ns1__deleteInvestigatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteInvestigatorResponse(soap, &a->ns1__deleteInvestigatorResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteInvestigatorResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteInvestigatorResponse *a, const char *type)
{
	if (a->ns1__deleteInvestigatorResponse_)
		soap_element_result(soap, "ns1:deleteInvestigatorResponse");
	if (soap_out_PointerTons1__deleteInvestigatorResponse(soap, "ns1:deleteInvestigatorResponse", -1, &a->ns1__deleteInvestigatorResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigatorResponse * SOAP_FMAC4 soap_in___ns1__deleteInvestigatorResponse(struct soap *soap, const char *tag, struct __ns1__deleteInvestigatorResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteInvestigatorResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteInvestigatorResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteInvestigatorResponse, sizeof(struct __ns1__deleteInvestigatorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteInvestigatorResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteInvestigatorResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteInvestigatorResponse(soap, "ns1:deleteInvestigatorResponse", &a->ns1__deleteInvestigatorResponse_, "ns1:deleteInvestigatorResponse"))
				{	soap_flag_ns1__deleteInvestigatorResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteInvestigatorResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteInvestigatorResponse(struct soap *soap, const struct __ns1__deleteInvestigatorResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteInvestigatorResponse(soap, tag?tag:"-ns1:deleteInvestigatorResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigatorResponse * SOAP_FMAC4 soap_get___ns1__deleteInvestigatorResponse(struct soap *soap, struct __ns1__deleteInvestigatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteInvestigatorResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteInvestigatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteInvestigatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteInvestigatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigatorResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteInvestigatorResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigatorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteInvestigatorResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteInvestigatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteInvestigatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteInvestigatorResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteInvestigatorResponse*)p = *(struct __ns1__deleteInvestigatorResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyInvestigator(struct soap *soap, struct __ns1__modifyInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyInvestigator_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyInvestigator(struct soap *soap, const struct __ns1__modifyInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyInvestigator(soap, &a->ns1__modifyInvestigator_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyInvestigator(struct soap *soap, const char *tag, int id, const struct __ns1__modifyInvestigator *a, const char *type)
{
	if (soap_out_PointerTons1__modifyInvestigator(soap, "ns1:modifyInvestigator", -1, &a->ns1__modifyInvestigator_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigator * SOAP_FMAC4 soap_in___ns1__modifyInvestigator(struct soap *soap, const char *tag, struct __ns1__modifyInvestigator *a, const char *type)
{
	size_t soap_flag_ns1__modifyInvestigator_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyInvestigator *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyInvestigator, sizeof(struct __ns1__modifyInvestigator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyInvestigator(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyInvestigator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyInvestigator(soap, "ns1:modifyInvestigator", &a->ns1__modifyInvestigator_, "ns1:modifyInvestigator"))
				{	soap_flag_ns1__modifyInvestigator_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyInvestigator(struct soap *soap, const struct __ns1__modifyInvestigator *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyInvestigator(soap, tag?tag:"-ns1:modifyInvestigator", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigator * SOAP_FMAC4 soap_get___ns1__modifyInvestigator(struct soap *soap, struct __ns1__modifyInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyInvestigator * SOAP_FMAC2 soap_instantiate___ns1__modifyInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigator);
		if (size)
			*size = sizeof(struct __ns1__modifyInvestigator);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyInvestigator);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyInvestigator %p -> %p\n", q, p));
	*(struct __ns1__modifyInvestigator*)p = *(struct __ns1__modifyInvestigator*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyInvestigatorResponse(struct soap *soap, struct __ns1__modifyInvestigatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyInvestigatorResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyInvestigatorResponse(struct soap *soap, const struct __ns1__modifyInvestigatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyInvestigatorResponse(soap, &a->ns1__modifyInvestigatorResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyInvestigatorResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifyInvestigatorResponse *a, const char *type)
{
	if (a->ns1__modifyInvestigatorResponse_)
		soap_element_result(soap, "ns1:modifyInvestigatorResponse");
	if (soap_out_PointerTons1__modifyInvestigatorResponse(soap, "ns1:modifyInvestigatorResponse", -1, &a->ns1__modifyInvestigatorResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigatorResponse * SOAP_FMAC4 soap_in___ns1__modifyInvestigatorResponse(struct soap *soap, const char *tag, struct __ns1__modifyInvestigatorResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifyInvestigatorResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyInvestigatorResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyInvestigatorResponse, sizeof(struct __ns1__modifyInvestigatorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyInvestigatorResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyInvestigatorResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyInvestigatorResponse(soap, "ns1:modifyInvestigatorResponse", &a->ns1__modifyInvestigatorResponse_, "ns1:modifyInvestigatorResponse"))
				{	soap_flag_ns1__modifyInvestigatorResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifyInvestigatorResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyInvestigatorResponse(struct soap *soap, const struct __ns1__modifyInvestigatorResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyInvestigatorResponse(soap, tag?tag:"-ns1:modifyInvestigatorResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigatorResponse * SOAP_FMAC4 soap_get___ns1__modifyInvestigatorResponse(struct soap *soap, struct __ns1__modifyInvestigatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyInvestigatorResponse * SOAP_FMAC2 soap_instantiate___ns1__modifyInvestigatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyInvestigatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyInvestigatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigatorResponse);
		if (size)
			*size = sizeof(struct __ns1__modifyInvestigatorResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigatorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyInvestigatorResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyInvestigatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyInvestigatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyInvestigatorResponse %p -> %p\n", q, p));
	*(struct __ns1__modifyInvestigatorResponse*)p = *(struct __ns1__modifyInvestigatorResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeInvestigator(struct soap *soap, struct __ns1__removeInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeInvestigator_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeInvestigator(struct soap *soap, const struct __ns1__removeInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeInvestigator(soap, &a->ns1__removeInvestigator_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeInvestigator(struct soap *soap, const char *tag, int id, const struct __ns1__removeInvestigator *a, const char *type)
{
	if (soap_out_PointerTons1__removeInvestigator(soap, "ns1:removeInvestigator", -1, &a->ns1__removeInvestigator_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigator * SOAP_FMAC4 soap_in___ns1__removeInvestigator(struct soap *soap, const char *tag, struct __ns1__removeInvestigator *a, const char *type)
{
	size_t soap_flag_ns1__removeInvestigator_ = 1;
	short soap_flag;
	a = (struct __ns1__removeInvestigator *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeInvestigator, sizeof(struct __ns1__removeInvestigator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeInvestigator(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeInvestigator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeInvestigator(soap, "ns1:removeInvestigator", &a->ns1__removeInvestigator_, "ns1:removeInvestigator"))
				{	soap_flag_ns1__removeInvestigator_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeInvestigator(struct soap *soap, const struct __ns1__removeInvestigator *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeInvestigator(soap, tag?tag:"-ns1:removeInvestigator", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigator * SOAP_FMAC4 soap_get___ns1__removeInvestigator(struct soap *soap, struct __ns1__removeInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeInvestigator * SOAP_FMAC2 soap_instantiate___ns1__removeInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigator);
		if (size)
			*size = sizeof(struct __ns1__removeInvestigator);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeInvestigator);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeInvestigator %p -> %p\n", q, p));
	*(struct __ns1__removeInvestigator*)p = *(struct __ns1__removeInvestigator*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeInvestigatorResponse(struct soap *soap, struct __ns1__removeInvestigatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeInvestigatorResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeInvestigatorResponse(struct soap *soap, const struct __ns1__removeInvestigatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeInvestigatorResponse(soap, &a->ns1__removeInvestigatorResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeInvestigatorResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeInvestigatorResponse *a, const char *type)
{
	if (a->ns1__removeInvestigatorResponse_)
		soap_element_result(soap, "ns1:removeInvestigatorResponse");
	if (soap_out_PointerTons1__removeInvestigatorResponse(soap, "ns1:removeInvestigatorResponse", -1, &a->ns1__removeInvestigatorResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigatorResponse * SOAP_FMAC4 soap_in___ns1__removeInvestigatorResponse(struct soap *soap, const char *tag, struct __ns1__removeInvestigatorResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeInvestigatorResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeInvestigatorResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeInvestigatorResponse, sizeof(struct __ns1__removeInvestigatorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeInvestigatorResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeInvestigatorResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeInvestigatorResponse(soap, "ns1:removeInvestigatorResponse", &a->ns1__removeInvestigatorResponse_, "ns1:removeInvestigatorResponse"))
				{	soap_flag_ns1__removeInvestigatorResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeInvestigatorResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeInvestigatorResponse(struct soap *soap, const struct __ns1__removeInvestigatorResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeInvestigatorResponse(soap, tag?tag:"-ns1:removeInvestigatorResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigatorResponse * SOAP_FMAC4 soap_get___ns1__removeInvestigatorResponse(struct soap *soap, struct __ns1__removeInvestigatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeInvestigatorResponse * SOAP_FMAC2 soap_instantiate___ns1__removeInvestigatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeInvestigatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeInvestigatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigatorResponse);
		if (size)
			*size = sizeof(struct __ns1__removeInvestigatorResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigatorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeInvestigatorResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeInvestigatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeInvestigatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeInvestigatorResponse %p -> %p\n", q, p));
	*(struct __ns1__removeInvestigatorResponse*)p = *(struct __ns1__removeInvestigatorResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyPublication(struct soap *soap, struct __ns1__modifyPublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyPublication_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyPublication(struct soap *soap, const struct __ns1__modifyPublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyPublication(soap, &a->ns1__modifyPublication_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyPublication(struct soap *soap, const char *tag, int id, const struct __ns1__modifyPublication *a, const char *type)
{
	if (soap_out_PointerTons1__modifyPublication(soap, "ns1:modifyPublication", -1, &a->ns1__modifyPublication_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyPublication * SOAP_FMAC4 soap_in___ns1__modifyPublication(struct soap *soap, const char *tag, struct __ns1__modifyPublication *a, const char *type)
{
	size_t soap_flag_ns1__modifyPublication_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyPublication *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyPublication, sizeof(struct __ns1__modifyPublication), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyPublication(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyPublication_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyPublication(soap, "ns1:modifyPublication", &a->ns1__modifyPublication_, "ns1:modifyPublication"))
				{	soap_flag_ns1__modifyPublication_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyPublication(struct soap *soap, const struct __ns1__modifyPublication *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyPublication(soap, tag?tag:"-ns1:modifyPublication", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyPublication * SOAP_FMAC4 soap_get___ns1__modifyPublication(struct soap *soap, struct __ns1__modifyPublication *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyPublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyPublication * SOAP_FMAC2 soap_instantiate___ns1__modifyPublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyPublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyPublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyPublication);
		if (size)
			*size = sizeof(struct __ns1__modifyPublication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyPublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyPublication);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyPublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyPublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyPublication %p -> %p\n", q, p));
	*(struct __ns1__modifyPublication*)p = *(struct __ns1__modifyPublication*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyPublicationResponse(struct soap *soap, struct __ns1__modifyPublicationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyPublicationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyPublicationResponse(struct soap *soap, const struct __ns1__modifyPublicationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyPublicationResponse(soap, &a->ns1__modifyPublicationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyPublicationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifyPublicationResponse *a, const char *type)
{
	if (a->ns1__modifyPublicationResponse_)
		soap_element_result(soap, "ns1:modifyPublicationResponse");
	if (soap_out_PointerTons1__modifyPublicationResponse(soap, "ns1:modifyPublicationResponse", -1, &a->ns1__modifyPublicationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyPublicationResponse * SOAP_FMAC4 soap_in___ns1__modifyPublicationResponse(struct soap *soap, const char *tag, struct __ns1__modifyPublicationResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifyPublicationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyPublicationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyPublicationResponse, sizeof(struct __ns1__modifyPublicationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyPublicationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyPublicationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyPublicationResponse(soap, "ns1:modifyPublicationResponse", &a->ns1__modifyPublicationResponse_, "ns1:modifyPublicationResponse"))
				{	soap_flag_ns1__modifyPublicationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifyPublicationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyPublicationResponse(struct soap *soap, const struct __ns1__modifyPublicationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyPublicationResponse(soap, tag?tag:"-ns1:modifyPublicationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyPublicationResponse * SOAP_FMAC4 soap_get___ns1__modifyPublicationResponse(struct soap *soap, struct __ns1__modifyPublicationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyPublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyPublicationResponse * SOAP_FMAC2 soap_instantiate___ns1__modifyPublicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyPublicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyPublicationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyPublicationResponse);
		if (size)
			*size = sizeof(struct __ns1__modifyPublicationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyPublicationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyPublicationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyPublicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyPublicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyPublicationResponse %p -> %p\n", q, p));
	*(struct __ns1__modifyPublicationResponse*)p = *(struct __ns1__modifyPublicationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deletePublication(struct soap *soap, struct __ns1__deletePublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deletePublication_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deletePublication(struct soap *soap, const struct __ns1__deletePublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deletePublication(soap, &a->ns1__deletePublication_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deletePublication(struct soap *soap, const char *tag, int id, const struct __ns1__deletePublication *a, const char *type)
{
	if (soap_out_PointerTons1__deletePublication(soap, "ns1:deletePublication", -1, &a->ns1__deletePublication_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deletePublication * SOAP_FMAC4 soap_in___ns1__deletePublication(struct soap *soap, const char *tag, struct __ns1__deletePublication *a, const char *type)
{
	size_t soap_flag_ns1__deletePublication_ = 1;
	short soap_flag;
	a = (struct __ns1__deletePublication *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deletePublication, sizeof(struct __ns1__deletePublication), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deletePublication(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deletePublication_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deletePublication(soap, "ns1:deletePublication", &a->ns1__deletePublication_, "ns1:deletePublication"))
				{	soap_flag_ns1__deletePublication_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deletePublication(struct soap *soap, const struct __ns1__deletePublication *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deletePublication(soap, tag?tag:"-ns1:deletePublication", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deletePublication * SOAP_FMAC4 soap_get___ns1__deletePublication(struct soap *soap, struct __ns1__deletePublication *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deletePublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deletePublication * SOAP_FMAC2 soap_instantiate___ns1__deletePublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deletePublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deletePublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deletePublication);
		if (size)
			*size = sizeof(struct __ns1__deletePublication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deletePublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deletePublication);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deletePublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deletePublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deletePublication %p -> %p\n", q, p));
	*(struct __ns1__deletePublication*)p = *(struct __ns1__deletePublication*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deletePublicationResponse(struct soap *soap, struct __ns1__deletePublicationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deletePublicationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deletePublicationResponse(struct soap *soap, const struct __ns1__deletePublicationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deletePublicationResponse(soap, &a->ns1__deletePublicationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deletePublicationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deletePublicationResponse *a, const char *type)
{
	if (a->ns1__deletePublicationResponse_)
		soap_element_result(soap, "ns1:deletePublicationResponse");
	if (soap_out_PointerTons1__deletePublicationResponse(soap, "ns1:deletePublicationResponse", -1, &a->ns1__deletePublicationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deletePublicationResponse * SOAP_FMAC4 soap_in___ns1__deletePublicationResponse(struct soap *soap, const char *tag, struct __ns1__deletePublicationResponse *a, const char *type)
{
	size_t soap_flag_ns1__deletePublicationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deletePublicationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deletePublicationResponse, sizeof(struct __ns1__deletePublicationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deletePublicationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deletePublicationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deletePublicationResponse(soap, "ns1:deletePublicationResponse", &a->ns1__deletePublicationResponse_, "ns1:deletePublicationResponse"))
				{	soap_flag_ns1__deletePublicationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deletePublicationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deletePublicationResponse(struct soap *soap, const struct __ns1__deletePublicationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deletePublicationResponse(soap, tag?tag:"-ns1:deletePublicationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deletePublicationResponse * SOAP_FMAC4 soap_get___ns1__deletePublicationResponse(struct soap *soap, struct __ns1__deletePublicationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deletePublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deletePublicationResponse * SOAP_FMAC2 soap_instantiate___ns1__deletePublicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deletePublicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deletePublicationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deletePublicationResponse);
		if (size)
			*size = sizeof(struct __ns1__deletePublicationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deletePublicationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deletePublicationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deletePublicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deletePublicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deletePublicationResponse %p -> %p\n", q, p));
	*(struct __ns1__deletePublicationResponse*)p = *(struct __ns1__deletePublicationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removePublication(struct soap *soap, struct __ns1__removePublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removePublication_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removePublication(struct soap *soap, const struct __ns1__removePublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removePublication(soap, &a->ns1__removePublication_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removePublication(struct soap *soap, const char *tag, int id, const struct __ns1__removePublication *a, const char *type)
{
	if (soap_out_PointerTons1__removePublication(soap, "ns1:removePublication", -1, &a->ns1__removePublication_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removePublication * SOAP_FMAC4 soap_in___ns1__removePublication(struct soap *soap, const char *tag, struct __ns1__removePublication *a, const char *type)
{
	size_t soap_flag_ns1__removePublication_ = 1;
	short soap_flag;
	a = (struct __ns1__removePublication *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removePublication, sizeof(struct __ns1__removePublication), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removePublication(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removePublication_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removePublication(soap, "ns1:removePublication", &a->ns1__removePublication_, "ns1:removePublication"))
				{	soap_flag_ns1__removePublication_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removePublication(struct soap *soap, const struct __ns1__removePublication *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removePublication(soap, tag?tag:"-ns1:removePublication", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removePublication * SOAP_FMAC4 soap_get___ns1__removePublication(struct soap *soap, struct __ns1__removePublication *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removePublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removePublication * SOAP_FMAC2 soap_instantiate___ns1__removePublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removePublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removePublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removePublication);
		if (size)
			*size = sizeof(struct __ns1__removePublication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removePublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removePublication);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removePublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removePublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removePublication %p -> %p\n", q, p));
	*(struct __ns1__removePublication*)p = *(struct __ns1__removePublication*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removePublicationResponse(struct soap *soap, struct __ns1__removePublicationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removePublicationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removePublicationResponse(struct soap *soap, const struct __ns1__removePublicationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removePublicationResponse(soap, &a->ns1__removePublicationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removePublicationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removePublicationResponse *a, const char *type)
{
	if (a->ns1__removePublicationResponse_)
		soap_element_result(soap, "ns1:removePublicationResponse");
	if (soap_out_PointerTons1__removePublicationResponse(soap, "ns1:removePublicationResponse", -1, &a->ns1__removePublicationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removePublicationResponse * SOAP_FMAC4 soap_in___ns1__removePublicationResponse(struct soap *soap, const char *tag, struct __ns1__removePublicationResponse *a, const char *type)
{
	size_t soap_flag_ns1__removePublicationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removePublicationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removePublicationResponse, sizeof(struct __ns1__removePublicationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removePublicationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removePublicationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removePublicationResponse(soap, "ns1:removePublicationResponse", &a->ns1__removePublicationResponse_, "ns1:removePublicationResponse"))
				{	soap_flag_ns1__removePublicationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removePublicationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removePublicationResponse(struct soap *soap, const struct __ns1__removePublicationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removePublicationResponse(soap, tag?tag:"-ns1:removePublicationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removePublicationResponse * SOAP_FMAC4 soap_get___ns1__removePublicationResponse(struct soap *soap, struct __ns1__removePublicationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removePublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removePublicationResponse * SOAP_FMAC2 soap_instantiate___ns1__removePublicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removePublicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removePublicationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removePublicationResponse);
		if (size)
			*size = sizeof(struct __ns1__removePublicationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removePublicationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removePublicationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removePublicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removePublicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removePublicationResponse %p -> %p\n", q, p));
	*(struct __ns1__removePublicationResponse*)p = *(struct __ns1__removePublicationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteKeyword(struct soap *soap, struct __ns1__deleteKeyword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteKeyword_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteKeyword(struct soap *soap, const struct __ns1__deleteKeyword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteKeyword(soap, &a->ns1__deleteKeyword_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteKeyword(struct soap *soap, const char *tag, int id, const struct __ns1__deleteKeyword *a, const char *type)
{
	if (soap_out_PointerTons1__deleteKeyword(soap, "ns1:deleteKeyword", -1, &a->ns1__deleteKeyword_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteKeyword * SOAP_FMAC4 soap_in___ns1__deleteKeyword(struct soap *soap, const char *tag, struct __ns1__deleteKeyword *a, const char *type)
{
	size_t soap_flag_ns1__deleteKeyword_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteKeyword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteKeyword, sizeof(struct __ns1__deleteKeyword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteKeyword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteKeyword_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteKeyword(soap, "ns1:deleteKeyword", &a->ns1__deleteKeyword_, "ns1:deleteKeyword"))
				{	soap_flag_ns1__deleteKeyword_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteKeyword(struct soap *soap, const struct __ns1__deleteKeyword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteKeyword(soap, tag?tag:"-ns1:deleteKeyword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteKeyword * SOAP_FMAC4 soap_get___ns1__deleteKeyword(struct soap *soap, struct __ns1__deleteKeyword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteKeyword * SOAP_FMAC2 soap_instantiate___ns1__deleteKeyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteKeyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteKeyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteKeyword);
		if (size)
			*size = sizeof(struct __ns1__deleteKeyword);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteKeyword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteKeyword);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteKeyword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteKeyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteKeyword %p -> %p\n", q, p));
	*(struct __ns1__deleteKeyword*)p = *(struct __ns1__deleteKeyword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteKeywordResponse(struct soap *soap, struct __ns1__deleteKeywordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteKeywordResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteKeywordResponse(struct soap *soap, const struct __ns1__deleteKeywordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteKeywordResponse(soap, &a->ns1__deleteKeywordResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteKeywordResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteKeywordResponse *a, const char *type)
{
	if (a->ns1__deleteKeywordResponse_)
		soap_element_result(soap, "ns1:deleteKeywordResponse");
	if (soap_out_PointerTons1__deleteKeywordResponse(soap, "ns1:deleteKeywordResponse", -1, &a->ns1__deleteKeywordResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteKeywordResponse * SOAP_FMAC4 soap_in___ns1__deleteKeywordResponse(struct soap *soap, const char *tag, struct __ns1__deleteKeywordResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteKeywordResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteKeywordResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteKeywordResponse, sizeof(struct __ns1__deleteKeywordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteKeywordResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteKeywordResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteKeywordResponse(soap, "ns1:deleteKeywordResponse", &a->ns1__deleteKeywordResponse_, "ns1:deleteKeywordResponse"))
				{	soap_flag_ns1__deleteKeywordResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteKeywordResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteKeywordResponse(struct soap *soap, const struct __ns1__deleteKeywordResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteKeywordResponse(soap, tag?tag:"-ns1:deleteKeywordResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteKeywordResponse * SOAP_FMAC4 soap_get___ns1__deleteKeywordResponse(struct soap *soap, struct __ns1__deleteKeywordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteKeywordResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteKeywordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteKeywordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteKeywordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteKeywordResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteKeywordResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteKeywordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteKeywordResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteKeywordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteKeywordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteKeywordResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteKeywordResponse*)p = *(struct __ns1__deleteKeywordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeKeyword(struct soap *soap, struct __ns1__removeKeyword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeKeyword_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeKeyword(struct soap *soap, const struct __ns1__removeKeyword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeKeyword(soap, &a->ns1__removeKeyword_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeKeyword(struct soap *soap, const char *tag, int id, const struct __ns1__removeKeyword *a, const char *type)
{
	if (soap_out_PointerTons1__removeKeyword(soap, "ns1:removeKeyword", -1, &a->ns1__removeKeyword_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeKeyword * SOAP_FMAC4 soap_in___ns1__removeKeyword(struct soap *soap, const char *tag, struct __ns1__removeKeyword *a, const char *type)
{
	size_t soap_flag_ns1__removeKeyword_ = 1;
	short soap_flag;
	a = (struct __ns1__removeKeyword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeKeyword, sizeof(struct __ns1__removeKeyword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeKeyword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeKeyword_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeKeyword(soap, "ns1:removeKeyword", &a->ns1__removeKeyword_, "ns1:removeKeyword"))
				{	soap_flag_ns1__removeKeyword_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeKeyword(struct soap *soap, const struct __ns1__removeKeyword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeKeyword(soap, tag?tag:"-ns1:removeKeyword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeKeyword * SOAP_FMAC4 soap_get___ns1__removeKeyword(struct soap *soap, struct __ns1__removeKeyword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeKeyword * SOAP_FMAC2 soap_instantiate___ns1__removeKeyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeKeyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeKeyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeKeyword);
		if (size)
			*size = sizeof(struct __ns1__removeKeyword);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeKeyword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeKeyword);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeKeyword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeKeyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeKeyword %p -> %p\n", q, p));
	*(struct __ns1__removeKeyword*)p = *(struct __ns1__removeKeyword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeKeywordResponse(struct soap *soap, struct __ns1__removeKeywordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeKeywordResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeKeywordResponse(struct soap *soap, const struct __ns1__removeKeywordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeKeywordResponse(soap, &a->ns1__removeKeywordResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeKeywordResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeKeywordResponse *a, const char *type)
{
	if (a->ns1__removeKeywordResponse_)
		soap_element_result(soap, "ns1:removeKeywordResponse");
	if (soap_out_PointerTons1__removeKeywordResponse(soap, "ns1:removeKeywordResponse", -1, &a->ns1__removeKeywordResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeKeywordResponse * SOAP_FMAC4 soap_in___ns1__removeKeywordResponse(struct soap *soap, const char *tag, struct __ns1__removeKeywordResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeKeywordResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeKeywordResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeKeywordResponse, sizeof(struct __ns1__removeKeywordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeKeywordResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeKeywordResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeKeywordResponse(soap, "ns1:removeKeywordResponse", &a->ns1__removeKeywordResponse_, "ns1:removeKeywordResponse"))
				{	soap_flag_ns1__removeKeywordResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeKeywordResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeKeywordResponse(struct soap *soap, const struct __ns1__removeKeywordResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeKeywordResponse(soap, tag?tag:"-ns1:removeKeywordResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeKeywordResponse * SOAP_FMAC4 soap_get___ns1__removeKeywordResponse(struct soap *soap, struct __ns1__removeKeywordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeKeywordResponse * SOAP_FMAC2 soap_instantiate___ns1__removeKeywordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeKeywordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeKeywordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeKeywordResponse);
		if (size)
			*size = sizeof(struct __ns1__removeKeywordResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeKeywordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeKeywordResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeKeywordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeKeywordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeKeywordResponse %p -> %p\n", q, p));
	*(struct __ns1__removeKeywordResponse*)p = *(struct __ns1__removeKeywordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyInvestigation(struct soap *soap, struct __ns1__modifyInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyInvestigation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyInvestigation(struct soap *soap, const struct __ns1__modifyInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyInvestigation(soap, &a->ns1__modifyInvestigation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyInvestigation(struct soap *soap, const char *tag, int id, const struct __ns1__modifyInvestigation *a, const char *type)
{
	if (soap_out_PointerTons1__modifyInvestigation(soap, "ns1:modifyInvestigation", -1, &a->ns1__modifyInvestigation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigation * SOAP_FMAC4 soap_in___ns1__modifyInvestigation(struct soap *soap, const char *tag, struct __ns1__modifyInvestigation *a, const char *type)
{
	size_t soap_flag_ns1__modifyInvestigation_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyInvestigation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyInvestigation, sizeof(struct __ns1__modifyInvestigation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyInvestigation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyInvestigation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyInvestigation(soap, "ns1:modifyInvestigation", &a->ns1__modifyInvestigation_, "ns1:modifyInvestigation"))
				{	soap_flag_ns1__modifyInvestigation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyInvestigation(struct soap *soap, const struct __ns1__modifyInvestigation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyInvestigation(soap, tag?tag:"-ns1:modifyInvestigation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigation * SOAP_FMAC4 soap_get___ns1__modifyInvestigation(struct soap *soap, struct __ns1__modifyInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyInvestigation * SOAP_FMAC2 soap_instantiate___ns1__modifyInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigation);
		if (size)
			*size = sizeof(struct __ns1__modifyInvestigation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyInvestigation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyInvestigation %p -> %p\n", q, p));
	*(struct __ns1__modifyInvestigation*)p = *(struct __ns1__modifyInvestigation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyInvestigationResponse(struct soap *soap, struct __ns1__modifyInvestigationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyInvestigationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyInvestigationResponse(struct soap *soap, const struct __ns1__modifyInvestigationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyInvestigationResponse(soap, &a->ns1__modifyInvestigationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyInvestigationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifyInvestigationResponse *a, const char *type)
{
	if (a->ns1__modifyInvestigationResponse_)
		soap_element_result(soap, "ns1:modifyInvestigationResponse");
	if (soap_out_PointerTons1__modifyInvestigationResponse(soap, "ns1:modifyInvestigationResponse", -1, &a->ns1__modifyInvestigationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigationResponse * SOAP_FMAC4 soap_in___ns1__modifyInvestigationResponse(struct soap *soap, const char *tag, struct __ns1__modifyInvestigationResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifyInvestigationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyInvestigationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyInvestigationResponse, sizeof(struct __ns1__modifyInvestigationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyInvestigationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyInvestigationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyInvestigationResponse(soap, "ns1:modifyInvestigationResponse", &a->ns1__modifyInvestigationResponse_, "ns1:modifyInvestigationResponse"))
				{	soap_flag_ns1__modifyInvestigationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifyInvestigationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyInvestigationResponse(struct soap *soap, const struct __ns1__modifyInvestigationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyInvestigationResponse(soap, tag?tag:"-ns1:modifyInvestigationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyInvestigationResponse * SOAP_FMAC4 soap_get___ns1__modifyInvestigationResponse(struct soap *soap, struct __ns1__modifyInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyInvestigationResponse * SOAP_FMAC2 soap_instantiate___ns1__modifyInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigationResponse);
		if (size)
			*size = sizeof(struct __ns1__modifyInvestigationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyInvestigationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyInvestigationResponse %p -> %p\n", q, p));
	*(struct __ns1__modifyInvestigationResponse*)p = *(struct __ns1__modifyInvestigationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteInvestigation(struct soap *soap, struct __ns1__deleteInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteInvestigation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteInvestigation(struct soap *soap, const struct __ns1__deleteInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteInvestigation(soap, &a->ns1__deleteInvestigation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteInvestigation(struct soap *soap, const char *tag, int id, const struct __ns1__deleteInvestigation *a, const char *type)
{
	if (soap_out_PointerTons1__deleteInvestigation(soap, "ns1:deleteInvestigation", -1, &a->ns1__deleteInvestigation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigation * SOAP_FMAC4 soap_in___ns1__deleteInvestigation(struct soap *soap, const char *tag, struct __ns1__deleteInvestigation *a, const char *type)
{
	size_t soap_flag_ns1__deleteInvestigation_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteInvestigation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteInvestigation, sizeof(struct __ns1__deleteInvestigation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteInvestigation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteInvestigation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteInvestigation(soap, "ns1:deleteInvestigation", &a->ns1__deleteInvestigation_, "ns1:deleteInvestigation"))
				{	soap_flag_ns1__deleteInvestigation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteInvestigation(struct soap *soap, const struct __ns1__deleteInvestigation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteInvestigation(soap, tag?tag:"-ns1:deleteInvestigation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigation * SOAP_FMAC4 soap_get___ns1__deleteInvestigation(struct soap *soap, struct __ns1__deleteInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteInvestigation * SOAP_FMAC2 soap_instantiate___ns1__deleteInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigation);
		if (size)
			*size = sizeof(struct __ns1__deleteInvestigation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteInvestigation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteInvestigation %p -> %p\n", q, p));
	*(struct __ns1__deleteInvestigation*)p = *(struct __ns1__deleteInvestigation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteInvestigationResponse(struct soap *soap, struct __ns1__deleteInvestigationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteInvestigationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteInvestigationResponse(struct soap *soap, const struct __ns1__deleteInvestigationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteInvestigationResponse(soap, &a->ns1__deleteInvestigationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteInvestigationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteInvestigationResponse *a, const char *type)
{
	if (a->ns1__deleteInvestigationResponse_)
		soap_element_result(soap, "ns1:deleteInvestigationResponse");
	if (soap_out_PointerTons1__deleteInvestigationResponse(soap, "ns1:deleteInvestigationResponse", -1, &a->ns1__deleteInvestigationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigationResponse * SOAP_FMAC4 soap_in___ns1__deleteInvestigationResponse(struct soap *soap, const char *tag, struct __ns1__deleteInvestigationResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteInvestigationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteInvestigationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteInvestigationResponse, sizeof(struct __ns1__deleteInvestigationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteInvestigationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteInvestigationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteInvestigationResponse(soap, "ns1:deleteInvestigationResponse", &a->ns1__deleteInvestigationResponse_, "ns1:deleteInvestigationResponse"))
				{	soap_flag_ns1__deleteInvestigationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteInvestigationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteInvestigationResponse(struct soap *soap, const struct __ns1__deleteInvestigationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteInvestigationResponse(soap, tag?tag:"-ns1:deleteInvestigationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteInvestigationResponse * SOAP_FMAC4 soap_get___ns1__deleteInvestigationResponse(struct soap *soap, struct __ns1__deleteInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteInvestigationResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigationResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteInvestigationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteInvestigationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteInvestigationResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteInvestigationResponse*)p = *(struct __ns1__deleteInvestigationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeInvestigation(struct soap *soap, struct __ns1__removeInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeInvestigation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeInvestigation(struct soap *soap, const struct __ns1__removeInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeInvestigation(soap, &a->ns1__removeInvestigation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeInvestigation(struct soap *soap, const char *tag, int id, const struct __ns1__removeInvestigation *a, const char *type)
{
	if (soap_out_PointerTons1__removeInvestigation(soap, "ns1:removeInvestigation", -1, &a->ns1__removeInvestigation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigation * SOAP_FMAC4 soap_in___ns1__removeInvestigation(struct soap *soap, const char *tag, struct __ns1__removeInvestigation *a, const char *type)
{
	size_t soap_flag_ns1__removeInvestigation_ = 1;
	short soap_flag;
	a = (struct __ns1__removeInvestigation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeInvestigation, sizeof(struct __ns1__removeInvestigation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeInvestigation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeInvestigation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeInvestigation(soap, "ns1:removeInvestigation", &a->ns1__removeInvestigation_, "ns1:removeInvestigation"))
				{	soap_flag_ns1__removeInvestigation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeInvestigation(struct soap *soap, const struct __ns1__removeInvestigation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeInvestigation(soap, tag?tag:"-ns1:removeInvestigation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigation * SOAP_FMAC4 soap_get___ns1__removeInvestigation(struct soap *soap, struct __ns1__removeInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeInvestigation * SOAP_FMAC2 soap_instantiate___ns1__removeInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigation);
		if (size)
			*size = sizeof(struct __ns1__removeInvestigation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeInvestigation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeInvestigation %p -> %p\n", q, p));
	*(struct __ns1__removeInvestigation*)p = *(struct __ns1__removeInvestigation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeInvestigationResponse(struct soap *soap, struct __ns1__removeInvestigationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeInvestigationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeInvestigationResponse(struct soap *soap, const struct __ns1__removeInvestigationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeInvestigationResponse(soap, &a->ns1__removeInvestigationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeInvestigationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeInvestigationResponse *a, const char *type)
{
	if (a->ns1__removeInvestigationResponse_)
		soap_element_result(soap, "ns1:removeInvestigationResponse");
	if (soap_out_PointerTons1__removeInvestigationResponse(soap, "ns1:removeInvestigationResponse", -1, &a->ns1__removeInvestigationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigationResponse * SOAP_FMAC4 soap_in___ns1__removeInvestigationResponse(struct soap *soap, const char *tag, struct __ns1__removeInvestigationResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeInvestigationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeInvestigationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeInvestigationResponse, sizeof(struct __ns1__removeInvestigationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeInvestigationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeInvestigationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeInvestigationResponse(soap, "ns1:removeInvestigationResponse", &a->ns1__removeInvestigationResponse_, "ns1:removeInvestigationResponse"))
				{	soap_flag_ns1__removeInvestigationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeInvestigationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeInvestigationResponse(struct soap *soap, const struct __ns1__removeInvestigationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeInvestigationResponse(soap, tag?tag:"-ns1:removeInvestigationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeInvestigationResponse * SOAP_FMAC4 soap_get___ns1__removeInvestigationResponse(struct soap *soap, struct __ns1__removeInvestigationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeInvestigationResponse * SOAP_FMAC2 soap_instantiate___ns1__removeInvestigationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeInvestigationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeInvestigationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigationResponse);
		if (size)
			*size = sizeof(struct __ns1__removeInvestigationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeInvestigationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeInvestigationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeInvestigationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeInvestigationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeInvestigationResponse %p -> %p\n", q, p));
	*(struct __ns1__removeInvestigationResponse*)p = *(struct __ns1__removeInvestigationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createInvestigation(struct soap *soap, struct __ns1__createInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createInvestigation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createInvestigation(struct soap *soap, const struct __ns1__createInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__createInvestigation(soap, &a->ns1__createInvestigation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createInvestigation(struct soap *soap, const char *tag, int id, const struct __ns1__createInvestigation *a, const char *type)
{
	if (soap_out_PointerTons1__createInvestigation(soap, "ns1:createInvestigation", -1, &a->ns1__createInvestigation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createInvestigation * SOAP_FMAC4 soap_in___ns1__createInvestigation(struct soap *soap, const char *tag, struct __ns1__createInvestigation *a, const char *type)
{
	size_t soap_flag_ns1__createInvestigation_ = 1;
	short soap_flag;
	a = (struct __ns1__createInvestigation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createInvestigation, sizeof(struct __ns1__createInvestigation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createInvestigation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createInvestigation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createInvestigation(soap, "ns1:createInvestigation", &a->ns1__createInvestigation_, "ns1:createInvestigation"))
				{	soap_flag_ns1__createInvestigation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createInvestigation(struct soap *soap, const struct __ns1__createInvestigation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createInvestigation(soap, tag?tag:"-ns1:createInvestigation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createInvestigation * SOAP_FMAC4 soap_get___ns1__createInvestigation(struct soap *soap, struct __ns1__createInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__createInvestigation * SOAP_FMAC2 soap_instantiate___ns1__createInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__createInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createInvestigation);
		if (size)
			*size = sizeof(struct __ns1__createInvestigation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__createInvestigation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__createInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createInvestigation %p -> %p\n", q, p));
	*(struct __ns1__createInvestigation*)p = *(struct __ns1__createInvestigation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getInvestigationsIncludes(struct soap *soap, struct __ns1__getInvestigationsIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getInvestigationsIncludes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getInvestigationsIncludes(struct soap *soap, const struct __ns1__getInvestigationsIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getInvestigationsIncludes(soap, &a->ns1__getInvestigationsIncludes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getInvestigationsIncludes(struct soap *soap, const char *tag, int id, const struct __ns1__getInvestigationsIncludes *a, const char *type)
{
	if (soap_out_PointerTons1__getInvestigationsIncludes(soap, "ns1:getInvestigationsIncludes", -1, &a->ns1__getInvestigationsIncludes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInvestigationsIncludes * SOAP_FMAC4 soap_in___ns1__getInvestigationsIncludes(struct soap *soap, const char *tag, struct __ns1__getInvestigationsIncludes *a, const char *type)
{
	size_t soap_flag_ns1__getInvestigationsIncludes_ = 1;
	short soap_flag;
	a = (struct __ns1__getInvestigationsIncludes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getInvestigationsIncludes, sizeof(struct __ns1__getInvestigationsIncludes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getInvestigationsIncludes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getInvestigationsIncludes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getInvestigationsIncludes(soap, "ns1:getInvestigationsIncludes", &a->ns1__getInvestigationsIncludes_, "ns1:getInvestigationsIncludes"))
				{	soap_flag_ns1__getInvestigationsIncludes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getInvestigationsIncludes(struct soap *soap, const struct __ns1__getInvestigationsIncludes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getInvestigationsIncludes(soap, tag?tag:"-ns1:getInvestigationsIncludes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInvestigationsIncludes * SOAP_FMAC4 soap_get___ns1__getInvestigationsIncludes(struct soap *soap, struct __ns1__getInvestigationsIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getInvestigationsIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getInvestigationsIncludes * SOAP_FMAC2 soap_instantiate___ns1__getInvestigationsIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getInvestigationsIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getInvestigationsIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getInvestigationsIncludes);
		if (size)
			*size = sizeof(struct __ns1__getInvestigationsIncludes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getInvestigationsIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getInvestigationsIncludes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getInvestigationsIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getInvestigationsIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getInvestigationsIncludes %p -> %p\n", q, p));
	*(struct __ns1__getInvestigationsIncludes*)p = *(struct __ns1__getInvestigationsIncludes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAuthorisation(struct soap *soap, struct __ns1__updateAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAuthorisation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAuthorisation(struct soap *soap, const struct __ns1__updateAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateAuthorisation(soap, &a->ns1__updateAuthorisation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAuthorisation(struct soap *soap, const char *tag, int id, const struct __ns1__updateAuthorisation *a, const char *type)
{
	if (soap_out_PointerTons1__updateAuthorisation(soap, "ns1:updateAuthorisation", -1, &a->ns1__updateAuthorisation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAuthorisation * SOAP_FMAC4 soap_in___ns1__updateAuthorisation(struct soap *soap, const char *tag, struct __ns1__updateAuthorisation *a, const char *type)
{
	size_t soap_flag_ns1__updateAuthorisation_ = 1;
	short soap_flag;
	a = (struct __ns1__updateAuthorisation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAuthorisation, sizeof(struct __ns1__updateAuthorisation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAuthorisation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAuthorisation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateAuthorisation(soap, "ns1:updateAuthorisation", &a->ns1__updateAuthorisation_, "ns1:updateAuthorisation"))
				{	soap_flag_ns1__updateAuthorisation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAuthorisation(struct soap *soap, const struct __ns1__updateAuthorisation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAuthorisation(soap, tag?tag:"-ns1:updateAuthorisation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAuthorisation * SOAP_FMAC4 soap_get___ns1__updateAuthorisation(struct soap *soap, struct __ns1__updateAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateAuthorisation * SOAP_FMAC2 soap_instantiate___ns1__updateAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateAuthorisation);
		if (size)
			*size = sizeof(struct __ns1__updateAuthorisation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateAuthorisation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateAuthorisation %p -> %p\n", q, p));
	*(struct __ns1__updateAuthorisation*)p = *(struct __ns1__updateAuthorisation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAuthorisationResponse(struct soap *soap, struct __ns1__updateAuthorisationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAuthorisationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAuthorisationResponse(struct soap *soap, const struct __ns1__updateAuthorisationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateAuthorisationResponse(soap, &a->ns1__updateAuthorisationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAuthorisationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__updateAuthorisationResponse *a, const char *type)
{
	if (a->ns1__updateAuthorisationResponse_)
		soap_element_result(soap, "ns1:updateAuthorisationResponse");
	if (soap_out_PointerTons1__updateAuthorisationResponse(soap, "ns1:updateAuthorisationResponse", -1, &a->ns1__updateAuthorisationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAuthorisationResponse * SOAP_FMAC4 soap_in___ns1__updateAuthorisationResponse(struct soap *soap, const char *tag, struct __ns1__updateAuthorisationResponse *a, const char *type)
{
	size_t soap_flag_ns1__updateAuthorisationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__updateAuthorisationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAuthorisationResponse, sizeof(struct __ns1__updateAuthorisationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAuthorisationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAuthorisationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateAuthorisationResponse(soap, "ns1:updateAuthorisationResponse", &a->ns1__updateAuthorisationResponse_, "ns1:updateAuthorisationResponse"))
				{	soap_flag_ns1__updateAuthorisationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:updateAuthorisationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAuthorisationResponse(struct soap *soap, const struct __ns1__updateAuthorisationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAuthorisationResponse(soap, tag?tag:"-ns1:updateAuthorisationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAuthorisationResponse * SOAP_FMAC4 soap_get___ns1__updateAuthorisationResponse(struct soap *soap, struct __ns1__updateAuthorisationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateAuthorisationResponse * SOAP_FMAC2 soap_instantiate___ns1__updateAuthorisationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateAuthorisationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateAuthorisationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateAuthorisationResponse);
		if (size)
			*size = sizeof(struct __ns1__updateAuthorisationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateAuthorisationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateAuthorisationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateAuthorisationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateAuthorisationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateAuthorisationResponse %p -> %p\n", q, p));
	*(struct __ns1__updateAuthorisationResponse*)p = *(struct __ns1__updateAuthorisationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeAuthorisation(struct soap *soap, struct __ns1__removeAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeAuthorisation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeAuthorisation(struct soap *soap, const struct __ns1__removeAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeAuthorisation(soap, &a->ns1__removeAuthorisation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeAuthorisation(struct soap *soap, const char *tag, int id, const struct __ns1__removeAuthorisation *a, const char *type)
{
	if (soap_out_PointerTons1__removeAuthorisation(soap, "ns1:removeAuthorisation", -1, &a->ns1__removeAuthorisation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeAuthorisation * SOAP_FMAC4 soap_in___ns1__removeAuthorisation(struct soap *soap, const char *tag, struct __ns1__removeAuthorisation *a, const char *type)
{
	size_t soap_flag_ns1__removeAuthorisation_ = 1;
	short soap_flag;
	a = (struct __ns1__removeAuthorisation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeAuthorisation, sizeof(struct __ns1__removeAuthorisation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeAuthorisation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeAuthorisation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeAuthorisation(soap, "ns1:removeAuthorisation", &a->ns1__removeAuthorisation_, "ns1:removeAuthorisation"))
				{	soap_flag_ns1__removeAuthorisation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeAuthorisation(struct soap *soap, const struct __ns1__removeAuthorisation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeAuthorisation(soap, tag?tag:"-ns1:removeAuthorisation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeAuthorisation * SOAP_FMAC4 soap_get___ns1__removeAuthorisation(struct soap *soap, struct __ns1__removeAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeAuthorisation * SOAP_FMAC2 soap_instantiate___ns1__removeAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeAuthorisation);
		if (size)
			*size = sizeof(struct __ns1__removeAuthorisation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeAuthorisation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeAuthorisation %p -> %p\n", q, p));
	*(struct __ns1__removeAuthorisation*)p = *(struct __ns1__removeAuthorisation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeAuthorisationResponse(struct soap *soap, struct __ns1__removeAuthorisationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeAuthorisationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeAuthorisationResponse(struct soap *soap, const struct __ns1__removeAuthorisationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeAuthorisationResponse(soap, &a->ns1__removeAuthorisationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeAuthorisationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeAuthorisationResponse *a, const char *type)
{
	if (a->ns1__removeAuthorisationResponse_)
		soap_element_result(soap, "ns1:removeAuthorisationResponse");
	if (soap_out_PointerTons1__removeAuthorisationResponse(soap, "ns1:removeAuthorisationResponse", -1, &a->ns1__removeAuthorisationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeAuthorisationResponse * SOAP_FMAC4 soap_in___ns1__removeAuthorisationResponse(struct soap *soap, const char *tag, struct __ns1__removeAuthorisationResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeAuthorisationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeAuthorisationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeAuthorisationResponse, sizeof(struct __ns1__removeAuthorisationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeAuthorisationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeAuthorisationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeAuthorisationResponse(soap, "ns1:removeAuthorisationResponse", &a->ns1__removeAuthorisationResponse_, "ns1:removeAuthorisationResponse"))
				{	soap_flag_ns1__removeAuthorisationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeAuthorisationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeAuthorisationResponse(struct soap *soap, const struct __ns1__removeAuthorisationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeAuthorisationResponse(soap, tag?tag:"-ns1:removeAuthorisationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeAuthorisationResponse * SOAP_FMAC4 soap_get___ns1__removeAuthorisationResponse(struct soap *soap, struct __ns1__removeAuthorisationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeAuthorisationResponse * SOAP_FMAC2 soap_instantiate___ns1__removeAuthorisationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeAuthorisationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeAuthorisationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeAuthorisationResponse);
		if (size)
			*size = sizeof(struct __ns1__removeAuthorisationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeAuthorisationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeAuthorisationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeAuthorisationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeAuthorisationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeAuthorisationResponse %p -> %p\n", q, p));
	*(struct __ns1__removeAuthorisationResponse*)p = *(struct __ns1__removeAuthorisationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteAuthorisation(struct soap *soap, struct __ns1__deleteAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteAuthorisation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteAuthorisation(struct soap *soap, const struct __ns1__deleteAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteAuthorisation(soap, &a->ns1__deleteAuthorisation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteAuthorisation(struct soap *soap, const char *tag, int id, const struct __ns1__deleteAuthorisation *a, const char *type)
{
	if (soap_out_PointerTons1__deleteAuthorisation(soap, "ns1:deleteAuthorisation", -1, &a->ns1__deleteAuthorisation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteAuthorisation * SOAP_FMAC4 soap_in___ns1__deleteAuthorisation(struct soap *soap, const char *tag, struct __ns1__deleteAuthorisation *a, const char *type)
{
	size_t soap_flag_ns1__deleteAuthorisation_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteAuthorisation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteAuthorisation, sizeof(struct __ns1__deleteAuthorisation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteAuthorisation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteAuthorisation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteAuthorisation(soap, "ns1:deleteAuthorisation", &a->ns1__deleteAuthorisation_, "ns1:deleteAuthorisation"))
				{	soap_flag_ns1__deleteAuthorisation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteAuthorisation(struct soap *soap, const struct __ns1__deleteAuthorisation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteAuthorisation(soap, tag?tag:"-ns1:deleteAuthorisation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteAuthorisation * SOAP_FMAC4 soap_get___ns1__deleteAuthorisation(struct soap *soap, struct __ns1__deleteAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteAuthorisation * SOAP_FMAC2 soap_instantiate___ns1__deleteAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteAuthorisation);
		if (size)
			*size = sizeof(struct __ns1__deleteAuthorisation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteAuthorisation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteAuthorisation %p -> %p\n", q, p));
	*(struct __ns1__deleteAuthorisation*)p = *(struct __ns1__deleteAuthorisation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteAuthorisationResponse(struct soap *soap, struct __ns1__deleteAuthorisationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteAuthorisationResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteAuthorisationResponse(struct soap *soap, const struct __ns1__deleteAuthorisationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteAuthorisationResponse(soap, &a->ns1__deleteAuthorisationResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteAuthorisationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteAuthorisationResponse *a, const char *type)
{
	if (a->ns1__deleteAuthorisationResponse_)
		soap_element_result(soap, "ns1:deleteAuthorisationResponse");
	if (soap_out_PointerTons1__deleteAuthorisationResponse(soap, "ns1:deleteAuthorisationResponse", -1, &a->ns1__deleteAuthorisationResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteAuthorisationResponse * SOAP_FMAC4 soap_in___ns1__deleteAuthorisationResponse(struct soap *soap, const char *tag, struct __ns1__deleteAuthorisationResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteAuthorisationResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteAuthorisationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteAuthorisationResponse, sizeof(struct __ns1__deleteAuthorisationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteAuthorisationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteAuthorisationResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteAuthorisationResponse(soap, "ns1:deleteAuthorisationResponse", &a->ns1__deleteAuthorisationResponse_, "ns1:deleteAuthorisationResponse"))
				{	soap_flag_ns1__deleteAuthorisationResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteAuthorisationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteAuthorisationResponse(struct soap *soap, const struct __ns1__deleteAuthorisationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteAuthorisationResponse(soap, tag?tag:"-ns1:deleteAuthorisationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteAuthorisationResponse * SOAP_FMAC4 soap_get___ns1__deleteAuthorisationResponse(struct soap *soap, struct __ns1__deleteAuthorisationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteAuthorisationResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteAuthorisationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteAuthorisationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteAuthorisationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteAuthorisationResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteAuthorisationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteAuthorisationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteAuthorisationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteAuthorisationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteAuthorisationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteAuthorisationResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteAuthorisationResponse*)p = *(struct __ns1__deleteAuthorisationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addAuthorisation(struct soap *soap, struct __ns1__addAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addAuthorisation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addAuthorisation(struct soap *soap, const struct __ns1__addAuthorisation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addAuthorisation(soap, &a->ns1__addAuthorisation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addAuthorisation(struct soap *soap, const char *tag, int id, const struct __ns1__addAuthorisation *a, const char *type)
{
	if (soap_out_PointerTons1__addAuthorisation(soap, "ns1:addAuthorisation", -1, &a->ns1__addAuthorisation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addAuthorisation * SOAP_FMAC4 soap_in___ns1__addAuthorisation(struct soap *soap, const char *tag, struct __ns1__addAuthorisation *a, const char *type)
{
	size_t soap_flag_ns1__addAuthorisation_ = 1;
	short soap_flag;
	a = (struct __ns1__addAuthorisation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addAuthorisation, sizeof(struct __ns1__addAuthorisation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addAuthorisation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addAuthorisation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addAuthorisation(soap, "ns1:addAuthorisation", &a->ns1__addAuthorisation_, "ns1:addAuthorisation"))
				{	soap_flag_ns1__addAuthorisation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addAuthorisation(struct soap *soap, const struct __ns1__addAuthorisation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addAuthorisation(soap, tag?tag:"-ns1:addAuthorisation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addAuthorisation * SOAP_FMAC4 soap_get___ns1__addAuthorisation(struct soap *soap, struct __ns1__addAuthorisation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addAuthorisation * SOAP_FMAC2 soap_instantiate___ns1__addAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addAuthorisation);
		if (size)
			*size = sizeof(struct __ns1__addAuthorisation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addAuthorisation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addAuthorisation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addAuthorisation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addAuthorisation %p -> %p\n", q, p));
	*(struct __ns1__addAuthorisation*)p = *(struct __ns1__addAuthorisation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAuthorisations(struct soap *soap, struct __ns1__getAuthorisations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAuthorisations_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAuthorisations(struct soap *soap, const struct __ns1__getAuthorisations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getAuthorisations(soap, &a->ns1__getAuthorisations_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAuthorisations(struct soap *soap, const char *tag, int id, const struct __ns1__getAuthorisations *a, const char *type)
{
	if (soap_out_PointerTons1__getAuthorisations(soap, "ns1:getAuthorisations", -1, &a->ns1__getAuthorisations_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAuthorisations * SOAP_FMAC4 soap_in___ns1__getAuthorisations(struct soap *soap, const char *tag, struct __ns1__getAuthorisations *a, const char *type)
{
	size_t soap_flag_ns1__getAuthorisations_ = 1;
	short soap_flag;
	a = (struct __ns1__getAuthorisations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAuthorisations, sizeof(struct __ns1__getAuthorisations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAuthorisations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAuthorisations_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getAuthorisations(soap, "ns1:getAuthorisations", &a->ns1__getAuthorisations_, "ns1:getAuthorisations"))
				{	soap_flag_ns1__getAuthorisations_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAuthorisations(struct soap *soap, const struct __ns1__getAuthorisations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAuthorisations(soap, tag?tag:"-ns1:getAuthorisations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAuthorisations * SOAP_FMAC4 soap_get___ns1__getAuthorisations(struct soap *soap, struct __ns1__getAuthorisations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAuthorisations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAuthorisations * SOAP_FMAC2 soap_instantiate___ns1__getAuthorisations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAuthorisations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAuthorisations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAuthorisations);
		if (size)
			*size = sizeof(struct __ns1__getAuthorisations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAuthorisations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAuthorisations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAuthorisations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAuthorisations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAuthorisations %p -> %p\n", q, p));
	*(struct __ns1__getAuthorisations*)p = *(struct __ns1__getAuthorisations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataFileParameter(struct soap *soap, struct __ns1__deleteDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataFileParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataFileParameter(struct soap *soap, const struct __ns1__deleteDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataFileParameter(soap, &a->ns1__deleteDataFileParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataFileParameter(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataFileParameter *a, const char *type)
{
	if (soap_out_PointerTons1__deleteDataFileParameter(soap, "ns1:deleteDataFileParameter", -1, &a->ns1__deleteDataFileParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFileParameter * SOAP_FMAC4 soap_in___ns1__deleteDataFileParameter(struct soap *soap, const char *tag, struct __ns1__deleteDataFileParameter *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataFileParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataFileParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataFileParameter, sizeof(struct __ns1__deleteDataFileParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataFileParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataFileParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataFileParameter(soap, "ns1:deleteDataFileParameter", &a->ns1__deleteDataFileParameter_, "ns1:deleteDataFileParameter"))
				{	soap_flag_ns1__deleteDataFileParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataFileParameter(struct soap *soap, const struct __ns1__deleteDataFileParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataFileParameter(soap, tag?tag:"-ns1:deleteDataFileParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFileParameter * SOAP_FMAC4 soap_get___ns1__deleteDataFileParameter(struct soap *soap, struct __ns1__deleteDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataFileParameter * SOAP_FMAC2 soap_instantiate___ns1__deleteDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFileParameter);
		if (size)
			*size = sizeof(struct __ns1__deleteDataFileParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataFileParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataFileParameter %p -> %p\n", q, p));
	*(struct __ns1__deleteDataFileParameter*)p = *(struct __ns1__deleteDataFileParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataFileParameterResponse(struct soap *soap, struct __ns1__deleteDataFileParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataFileParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataFileParameterResponse(struct soap *soap, const struct __ns1__deleteDataFileParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataFileParameterResponse(soap, &a->ns1__deleteDataFileParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataFileParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataFileParameterResponse *a, const char *type)
{
	if (a->ns1__deleteDataFileParameterResponse_)
		soap_element_result(soap, "ns1:deleteDataFileParameterResponse");
	if (soap_out_PointerTons1__deleteDataFileParameterResponse(soap, "ns1:deleteDataFileParameterResponse", -1, &a->ns1__deleteDataFileParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFileParameterResponse * SOAP_FMAC4 soap_in___ns1__deleteDataFileParameterResponse(struct soap *soap, const char *tag, struct __ns1__deleteDataFileParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataFileParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataFileParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataFileParameterResponse, sizeof(struct __ns1__deleteDataFileParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataFileParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataFileParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataFileParameterResponse(soap, "ns1:deleteDataFileParameterResponse", &a->ns1__deleteDataFileParameterResponse_, "ns1:deleteDataFileParameterResponse"))
				{	soap_flag_ns1__deleteDataFileParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteDataFileParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataFileParameterResponse(struct soap *soap, const struct __ns1__deleteDataFileParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataFileParameterResponse(soap, tag?tag:"-ns1:deleteDataFileParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFileParameterResponse * SOAP_FMAC4 soap_get___ns1__deleteDataFileParameterResponse(struct soap *soap, struct __ns1__deleteDataFileParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataFileParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteDataFileParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataFileParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataFileParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFileParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteDataFileParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFileParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataFileParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataFileParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataFileParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataFileParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteDataFileParameterResponse*)p = *(struct __ns1__deleteDataFileParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataFileParameter(struct soap *soap, struct __ns1__removeDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataFileParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataFileParameter(struct soap *soap, const struct __ns1__removeDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataFileParameter(soap, &a->ns1__removeDataFileParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataFileParameter(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataFileParameter *a, const char *type)
{
	if (soap_out_PointerTons1__removeDataFileParameter(soap, "ns1:removeDataFileParameter", -1, &a->ns1__removeDataFileParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFileParameter * SOAP_FMAC4 soap_in___ns1__removeDataFileParameter(struct soap *soap, const char *tag, struct __ns1__removeDataFileParameter *a, const char *type)
{
	size_t soap_flag_ns1__removeDataFileParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataFileParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataFileParameter, sizeof(struct __ns1__removeDataFileParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataFileParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataFileParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataFileParameter(soap, "ns1:removeDataFileParameter", &a->ns1__removeDataFileParameter_, "ns1:removeDataFileParameter"))
				{	soap_flag_ns1__removeDataFileParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataFileParameter(struct soap *soap, const struct __ns1__removeDataFileParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataFileParameter(soap, tag?tag:"-ns1:removeDataFileParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFileParameter * SOAP_FMAC4 soap_get___ns1__removeDataFileParameter(struct soap *soap, struct __ns1__removeDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataFileParameter * SOAP_FMAC2 soap_instantiate___ns1__removeDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFileParameter);
		if (size)
			*size = sizeof(struct __ns1__removeDataFileParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataFileParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataFileParameter %p -> %p\n", q, p));
	*(struct __ns1__removeDataFileParameter*)p = *(struct __ns1__removeDataFileParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataFileParameterResponse(struct soap *soap, struct __ns1__removeDataFileParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataFileParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataFileParameterResponse(struct soap *soap, const struct __ns1__removeDataFileParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataFileParameterResponse(soap, &a->ns1__removeDataFileParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataFileParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataFileParameterResponse *a, const char *type)
{
	if (a->ns1__removeDataFileParameterResponse_)
		soap_element_result(soap, "ns1:removeDataFileParameterResponse");
	if (soap_out_PointerTons1__removeDataFileParameterResponse(soap, "ns1:removeDataFileParameterResponse", -1, &a->ns1__removeDataFileParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFileParameterResponse * SOAP_FMAC4 soap_in___ns1__removeDataFileParameterResponse(struct soap *soap, const char *tag, struct __ns1__removeDataFileParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeDataFileParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataFileParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataFileParameterResponse, sizeof(struct __ns1__removeDataFileParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataFileParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataFileParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataFileParameterResponse(soap, "ns1:removeDataFileParameterResponse", &a->ns1__removeDataFileParameterResponse_, "ns1:removeDataFileParameterResponse"))
				{	soap_flag_ns1__removeDataFileParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeDataFileParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataFileParameterResponse(struct soap *soap, const struct __ns1__removeDataFileParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataFileParameterResponse(soap, tag?tag:"-ns1:removeDataFileParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFileParameterResponse * SOAP_FMAC4 soap_get___ns1__removeDataFileParameterResponse(struct soap *soap, struct __ns1__removeDataFileParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataFileParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__removeDataFileParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataFileParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataFileParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFileParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__removeDataFileParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFileParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataFileParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataFileParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataFileParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataFileParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__removeDataFileParameterResponse*)p = *(struct __ns1__removeDataFileParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataFileParameter(struct soap *soap, struct __ns1__modifyDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataFileParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataFileParameter(struct soap *soap, const struct __ns1__modifyDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataFileParameter(soap, &a->ns1__modifyDataFileParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataFileParameter(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataFileParameter *a, const char *type)
{
	if (soap_out_PointerTons1__modifyDataFileParameter(soap, "ns1:modifyDataFileParameter", -1, &a->ns1__modifyDataFileParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFileParameter * SOAP_FMAC4 soap_in___ns1__modifyDataFileParameter(struct soap *soap, const char *tag, struct __ns1__modifyDataFileParameter *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataFileParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataFileParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataFileParameter, sizeof(struct __ns1__modifyDataFileParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataFileParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataFileParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataFileParameter(soap, "ns1:modifyDataFileParameter", &a->ns1__modifyDataFileParameter_, "ns1:modifyDataFileParameter"))
				{	soap_flag_ns1__modifyDataFileParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataFileParameter(struct soap *soap, const struct __ns1__modifyDataFileParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataFileParameter(soap, tag?tag:"-ns1:modifyDataFileParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFileParameter * SOAP_FMAC4 soap_get___ns1__modifyDataFileParameter(struct soap *soap, struct __ns1__modifyDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataFileParameter * SOAP_FMAC2 soap_instantiate___ns1__modifyDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFileParameter);
		if (size)
			*size = sizeof(struct __ns1__modifyDataFileParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataFileParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataFileParameter %p -> %p\n", q, p));
	*(struct __ns1__modifyDataFileParameter*)p = *(struct __ns1__modifyDataFileParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataFileParameterResponse(struct soap *soap, struct __ns1__modifyDataFileParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataFileParameterResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataFileParameterResponse(struct soap *soap, const struct __ns1__modifyDataFileParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataFileParameterResponse(soap, &a->ns1__modifyDataFileParameterResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataFileParameterResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataFileParameterResponse *a, const char *type)
{
	if (a->ns1__modifyDataFileParameterResponse_)
		soap_element_result(soap, "ns1:modifyDataFileParameterResponse");
	if (soap_out_PointerTons1__modifyDataFileParameterResponse(soap, "ns1:modifyDataFileParameterResponse", -1, &a->ns1__modifyDataFileParameterResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFileParameterResponse * SOAP_FMAC4 soap_in___ns1__modifyDataFileParameterResponse(struct soap *soap, const char *tag, struct __ns1__modifyDataFileParameterResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataFileParameterResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataFileParameterResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataFileParameterResponse, sizeof(struct __ns1__modifyDataFileParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataFileParameterResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataFileParameterResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataFileParameterResponse(soap, "ns1:modifyDataFileParameterResponse", &a->ns1__modifyDataFileParameterResponse_, "ns1:modifyDataFileParameterResponse"))
				{	soap_flag_ns1__modifyDataFileParameterResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifyDataFileParameterResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataFileParameterResponse(struct soap *soap, const struct __ns1__modifyDataFileParameterResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataFileParameterResponse(soap, tag?tag:"-ns1:modifyDataFileParameterResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFileParameterResponse * SOAP_FMAC4 soap_get___ns1__modifyDataFileParameterResponse(struct soap *soap, struct __ns1__modifyDataFileParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataFileParameterResponse * SOAP_FMAC2 soap_instantiate___ns1__modifyDataFileParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataFileParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataFileParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFileParameterResponse);
		if (size)
			*size = sizeof(struct __ns1__modifyDataFileParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFileParameterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataFileParameterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataFileParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataFileParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataFileParameterResponse %p -> %p\n", q, p));
	*(struct __ns1__modifyDataFileParameterResponse*)p = *(struct __ns1__modifyDataFileParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDataFileParameters(struct soap *soap, struct __ns1__addDataFileParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDataFileParameters_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDataFileParameters(struct soap *soap, const struct __ns1__addDataFileParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addDataFileParameters(soap, &a->ns1__addDataFileParameters_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDataFileParameters(struct soap *soap, const char *tag, int id, const struct __ns1__addDataFileParameters *a, const char *type)
{
	if (soap_out_PointerTons1__addDataFileParameters(soap, "ns1:addDataFileParameters", -1, &a->ns1__addDataFileParameters_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataFileParameters * SOAP_FMAC4 soap_in___ns1__addDataFileParameters(struct soap *soap, const char *tag, struct __ns1__addDataFileParameters *a, const char *type)
{
	size_t soap_flag_ns1__addDataFileParameters_ = 1;
	short soap_flag;
	a = (struct __ns1__addDataFileParameters *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDataFileParameters, sizeof(struct __ns1__addDataFileParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDataFileParameters(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDataFileParameters_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addDataFileParameters(soap, "ns1:addDataFileParameters", &a->ns1__addDataFileParameters_, "ns1:addDataFileParameters"))
				{	soap_flag_ns1__addDataFileParameters_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDataFileParameters(struct soap *soap, const struct __ns1__addDataFileParameters *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDataFileParameters(soap, tag?tag:"-ns1:addDataFileParameters", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataFileParameters * SOAP_FMAC4 soap_get___ns1__addDataFileParameters(struct soap *soap, struct __ns1__addDataFileParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDataFileParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addDataFileParameters * SOAP_FMAC2 soap_instantiate___ns1__addDataFileParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addDataFileParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addDataFileParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataFileParameters);
		if (size)
			*size = sizeof(struct __ns1__addDataFileParameters);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataFileParameters[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addDataFileParameters);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addDataFileParameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addDataFileParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addDataFileParameters %p -> %p\n", q, p));
	*(struct __ns1__addDataFileParameters*)p = *(struct __ns1__addDataFileParameters*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataFile(struct soap *soap, struct __ns1__modifyDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataFile_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataFile(struct soap *soap, const struct __ns1__modifyDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataFile(soap, &a->ns1__modifyDataFile_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataFile(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataFile *a, const char *type)
{
	if (soap_out_PointerTons1__modifyDataFile(soap, "ns1:modifyDataFile", -1, &a->ns1__modifyDataFile_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFile * SOAP_FMAC4 soap_in___ns1__modifyDataFile(struct soap *soap, const char *tag, struct __ns1__modifyDataFile *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataFile_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataFile, sizeof(struct __ns1__modifyDataFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataFile(soap, "ns1:modifyDataFile", &a->ns1__modifyDataFile_, "ns1:modifyDataFile"))
				{	soap_flag_ns1__modifyDataFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataFile(struct soap *soap, const struct __ns1__modifyDataFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataFile(soap, tag?tag:"-ns1:modifyDataFile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFile * SOAP_FMAC4 soap_get___ns1__modifyDataFile(struct soap *soap, struct __ns1__modifyDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataFile * SOAP_FMAC2 soap_instantiate___ns1__modifyDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFile);
		if (size)
			*size = sizeof(struct __ns1__modifyDataFile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataFile %p -> %p\n", q, p));
	*(struct __ns1__modifyDataFile*)p = *(struct __ns1__modifyDataFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyDataFileResponse(struct soap *soap, struct __ns1__modifyDataFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyDataFileResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyDataFileResponse(struct soap *soap, const struct __ns1__modifyDataFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyDataFileResponse(soap, &a->ns1__modifyDataFileResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyDataFileResponse(struct soap *soap, const char *tag, int id, const struct __ns1__modifyDataFileResponse *a, const char *type)
{
	if (a->ns1__modifyDataFileResponse_)
		soap_element_result(soap, "ns1:modifyDataFileResponse");
	if (soap_out_PointerTons1__modifyDataFileResponse(soap, "ns1:modifyDataFileResponse", -1, &a->ns1__modifyDataFileResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFileResponse * SOAP_FMAC4 soap_in___ns1__modifyDataFileResponse(struct soap *soap, const char *tag, struct __ns1__modifyDataFileResponse *a, const char *type)
{
	size_t soap_flag_ns1__modifyDataFileResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__modifyDataFileResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyDataFileResponse, sizeof(struct __ns1__modifyDataFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyDataFileResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyDataFileResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyDataFileResponse(soap, "ns1:modifyDataFileResponse", &a->ns1__modifyDataFileResponse_, "ns1:modifyDataFileResponse"))
				{	soap_flag_ns1__modifyDataFileResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:modifyDataFileResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyDataFileResponse(struct soap *soap, const struct __ns1__modifyDataFileResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyDataFileResponse(soap, tag?tag:"-ns1:modifyDataFileResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyDataFileResponse * SOAP_FMAC4 soap_get___ns1__modifyDataFileResponse(struct soap *soap, struct __ns1__modifyDataFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__modifyDataFileResponse * SOAP_FMAC2 soap_instantiate___ns1__modifyDataFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__modifyDataFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__modifyDataFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFileResponse);
		if (size)
			*size = sizeof(struct __ns1__modifyDataFileResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__modifyDataFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__modifyDataFileResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__modifyDataFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__modifyDataFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__modifyDataFileResponse %p -> %p\n", q, p));
	*(struct __ns1__modifyDataFileResponse*)p = *(struct __ns1__modifyDataFileResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataFile(struct soap *soap, struct __ns1__removeDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataFile_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataFile(struct soap *soap, const struct __ns1__removeDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataFile(soap, &a->ns1__removeDataFile_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataFile(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataFile *a, const char *type)
{
	if (soap_out_PointerTons1__removeDataFile(soap, "ns1:removeDataFile", -1, &a->ns1__removeDataFile_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFile * SOAP_FMAC4 soap_in___ns1__removeDataFile(struct soap *soap, const char *tag, struct __ns1__removeDataFile *a, const char *type)
{
	size_t soap_flag_ns1__removeDataFile_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataFile, sizeof(struct __ns1__removeDataFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataFile(soap, "ns1:removeDataFile", &a->ns1__removeDataFile_, "ns1:removeDataFile"))
				{	soap_flag_ns1__removeDataFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataFile(struct soap *soap, const struct __ns1__removeDataFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataFile(soap, tag?tag:"-ns1:removeDataFile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFile * SOAP_FMAC4 soap_get___ns1__removeDataFile(struct soap *soap, struct __ns1__removeDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataFile * SOAP_FMAC2 soap_instantiate___ns1__removeDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFile);
		if (size)
			*size = sizeof(struct __ns1__removeDataFile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataFile %p -> %p\n", q, p));
	*(struct __ns1__removeDataFile*)p = *(struct __ns1__removeDataFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeDataFileResponse(struct soap *soap, struct __ns1__removeDataFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeDataFileResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeDataFileResponse(struct soap *soap, const struct __ns1__removeDataFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeDataFileResponse(soap, &a->ns1__removeDataFileResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeDataFileResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeDataFileResponse *a, const char *type)
{
	if (a->ns1__removeDataFileResponse_)
		soap_element_result(soap, "ns1:removeDataFileResponse");
	if (soap_out_PointerTons1__removeDataFileResponse(soap, "ns1:removeDataFileResponse", -1, &a->ns1__removeDataFileResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFileResponse * SOAP_FMAC4 soap_in___ns1__removeDataFileResponse(struct soap *soap, const char *tag, struct __ns1__removeDataFileResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeDataFileResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeDataFileResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeDataFileResponse, sizeof(struct __ns1__removeDataFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeDataFileResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeDataFileResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeDataFileResponse(soap, "ns1:removeDataFileResponse", &a->ns1__removeDataFileResponse_, "ns1:removeDataFileResponse"))
				{	soap_flag_ns1__removeDataFileResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeDataFileResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeDataFileResponse(struct soap *soap, const struct __ns1__removeDataFileResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeDataFileResponse(soap, tag?tag:"-ns1:removeDataFileResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeDataFileResponse * SOAP_FMAC4 soap_get___ns1__removeDataFileResponse(struct soap *soap, struct __ns1__removeDataFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeDataFileResponse * SOAP_FMAC2 soap_instantiate___ns1__removeDataFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeDataFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeDataFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFileResponse);
		if (size)
			*size = sizeof(struct __ns1__removeDataFileResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeDataFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeDataFileResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeDataFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeDataFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeDataFileResponse %p -> %p\n", q, p));
	*(struct __ns1__removeDataFileResponse*)p = *(struct __ns1__removeDataFileResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataFile(struct soap *soap, struct __ns1__deleteDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataFile_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataFile(struct soap *soap, const struct __ns1__deleteDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataFile(soap, &a->ns1__deleteDataFile_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataFile(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataFile *a, const char *type)
{
	if (soap_out_PointerTons1__deleteDataFile(soap, "ns1:deleteDataFile", -1, &a->ns1__deleteDataFile_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFile * SOAP_FMAC4 soap_in___ns1__deleteDataFile(struct soap *soap, const char *tag, struct __ns1__deleteDataFile *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataFile_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataFile, sizeof(struct __ns1__deleteDataFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataFile(soap, "ns1:deleteDataFile", &a->ns1__deleteDataFile_, "ns1:deleteDataFile"))
				{	soap_flag_ns1__deleteDataFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataFile(struct soap *soap, const struct __ns1__deleteDataFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataFile(soap, tag?tag:"-ns1:deleteDataFile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFile * SOAP_FMAC4 soap_get___ns1__deleteDataFile(struct soap *soap, struct __ns1__deleteDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataFile * SOAP_FMAC2 soap_instantiate___ns1__deleteDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFile);
		if (size)
			*size = sizeof(struct __ns1__deleteDataFile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataFile %p -> %p\n", q, p));
	*(struct __ns1__deleteDataFile*)p = *(struct __ns1__deleteDataFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDataFileResponse(struct soap *soap, struct __ns1__deleteDataFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDataFileResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDataFileResponse(struct soap *soap, const struct __ns1__deleteDataFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDataFileResponse(soap, &a->ns1__deleteDataFileResponse_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDataFileResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDataFileResponse *a, const char *type)
{
	if (a->ns1__deleteDataFileResponse_)
		soap_element_result(soap, "ns1:deleteDataFileResponse");
	if (soap_out_PointerTons1__deleteDataFileResponse(soap, "ns1:deleteDataFileResponse", -1, &a->ns1__deleteDataFileResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFileResponse * SOAP_FMAC4 soap_in___ns1__deleteDataFileResponse(struct soap *soap, const char *tag, struct __ns1__deleteDataFileResponse *a, const char *type)
{
	size_t soap_flag_ns1__deleteDataFileResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDataFileResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDataFileResponse, sizeof(struct __ns1__deleteDataFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDataFileResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDataFileResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDataFileResponse(soap, "ns1:deleteDataFileResponse", &a->ns1__deleteDataFileResponse_, "ns1:deleteDataFileResponse"))
				{	soap_flag_ns1__deleteDataFileResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:deleteDataFileResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDataFileResponse(struct soap *soap, const struct __ns1__deleteDataFileResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDataFileResponse(soap, tag?tag:"-ns1:deleteDataFileResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDataFileResponse * SOAP_FMAC4 soap_get___ns1__deleteDataFileResponse(struct soap *soap, struct __ns1__deleteDataFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteDataFileResponse * SOAP_FMAC2 soap_instantiate___ns1__deleteDataFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDataFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDataFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFileResponse);
		if (size)
			*size = sizeof(struct __ns1__deleteDataFileResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteDataFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDataFileResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDataFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDataFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDataFileResponse %p -> %p\n", q, p));
	*(struct __ns1__deleteDataFileResponse*)p = *(struct __ns1__deleteDataFileResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createDataFiles(struct soap *soap, struct __ns1__createDataFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createDataFiles_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createDataFiles(struct soap *soap, const struct __ns1__createDataFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__createDataFiles(soap, &a->ns1__createDataFiles_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createDataFiles(struct soap *soap, const char *tag, int id, const struct __ns1__createDataFiles *a, const char *type)
{
	if (soap_out_PointerTons1__createDataFiles(soap, "ns1:createDataFiles", -1, &a->ns1__createDataFiles_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataFiles * SOAP_FMAC4 soap_in___ns1__createDataFiles(struct soap *soap, const char *tag, struct __ns1__createDataFiles *a, const char *type)
{
	size_t soap_flag_ns1__createDataFiles_ = 1;
	short soap_flag;
	a = (struct __ns1__createDataFiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createDataFiles, sizeof(struct __ns1__createDataFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createDataFiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createDataFiles_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createDataFiles(soap, "ns1:createDataFiles", &a->ns1__createDataFiles_, "ns1:createDataFiles"))
				{	soap_flag_ns1__createDataFiles_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createDataFiles(struct soap *soap, const struct __ns1__createDataFiles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createDataFiles(soap, tag?tag:"-ns1:createDataFiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataFiles * SOAP_FMAC4 soap_get___ns1__createDataFiles(struct soap *soap, struct __ns1__createDataFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createDataFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__createDataFiles * SOAP_FMAC2 soap_instantiate___ns1__createDataFiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createDataFiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__createDataFiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataFiles);
		if (size)
			*size = sizeof(struct __ns1__createDataFiles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataFiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__createDataFiles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__createDataFiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createDataFiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createDataFiles %p -> %p\n", q, p));
	*(struct __ns1__createDataFiles*)p = *(struct __ns1__createDataFiles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createDataFile(struct soap *soap, struct __ns1__createDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createDataFile_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createDataFile(struct soap *soap, const struct __ns1__createDataFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__createDataFile(soap, &a->ns1__createDataFile_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createDataFile(struct soap *soap, const char *tag, int id, const struct __ns1__createDataFile *a, const char *type)
{
	if (soap_out_PointerTons1__createDataFile(soap, "ns1:createDataFile", -1, &a->ns1__createDataFile_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataFile * SOAP_FMAC4 soap_in___ns1__createDataFile(struct soap *soap, const char *tag, struct __ns1__createDataFile *a, const char *type)
{
	size_t soap_flag_ns1__createDataFile_ = 1;
	short soap_flag;
	a = (struct __ns1__createDataFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createDataFile, sizeof(struct __ns1__createDataFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createDataFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createDataFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createDataFile(soap, "ns1:createDataFile", &a->ns1__createDataFile_, "ns1:createDataFile"))
				{	soap_flag_ns1__createDataFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createDataFile(struct soap *soap, const struct __ns1__createDataFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createDataFile(soap, tag?tag:"-ns1:createDataFile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDataFile * SOAP_FMAC4 soap_get___ns1__createDataFile(struct soap *soap, struct __ns1__createDataFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__createDataFile * SOAP_FMAC2 soap_instantiate___ns1__createDataFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createDataFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__createDataFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataFile);
		if (size)
			*size = sizeof(struct __ns1__createDataFile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__createDataFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__createDataFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__createDataFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createDataFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createDataFile %p -> %p\n", q, p));
	*(struct __ns1__createDataFile*)p = *(struct __ns1__createDataFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDatafiles(struct soap *soap, struct __ns1__getDatafiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDatafiles_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDatafiles(struct soap *soap, const struct __ns1__getDatafiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDatafiles(soap, &a->ns1__getDatafiles_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDatafiles(struct soap *soap, const char *tag, int id, const struct __ns1__getDatafiles *a, const char *type)
{
	if (soap_out_PointerTons1__getDatafiles(soap, "ns1:getDatafiles", -1, &a->ns1__getDatafiles_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatafiles * SOAP_FMAC4 soap_in___ns1__getDatafiles(struct soap *soap, const char *tag, struct __ns1__getDatafiles *a, const char *type)
{
	size_t soap_flag_ns1__getDatafiles_ = 1;
	short soap_flag;
	a = (struct __ns1__getDatafiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDatafiles, sizeof(struct __ns1__getDatafiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDatafiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDatafiles_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDatafiles(soap, "ns1:getDatafiles", &a->ns1__getDatafiles_, "ns1:getDatafiles"))
				{	soap_flag_ns1__getDatafiles_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDatafiles(struct soap *soap, const struct __ns1__getDatafiles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDatafiles(soap, tag?tag:"-ns1:getDatafiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatafiles * SOAP_FMAC4 soap_get___ns1__getDatafiles(struct soap *soap, struct __ns1__getDatafiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDatafiles * SOAP_FMAC2 soap_instantiate___ns1__getDatafiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDatafiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDatafiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatafiles);
		if (size)
			*size = sizeof(struct __ns1__getDatafiles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatafiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDatafiles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDatafiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDatafiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDatafiles %p -> %p\n", q, p));
	*(struct __ns1__getDatafiles*)p = *(struct __ns1__getDatafiles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ingestMetadata(struct soap *soap, struct __ns1__ingestMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ingestMetadata_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ingestMetadata(struct soap *soap, const struct __ns1__ingestMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ingestMetadata(soap, &a->ns1__ingestMetadata_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ingestMetadata(struct soap *soap, const char *tag, int id, const struct __ns1__ingestMetadata *a, const char *type)
{
	if (soap_out_PointerTons1__ingestMetadata(soap, "ns1:ingestMetadata", -1, &a->ns1__ingestMetadata_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ingestMetadata * SOAP_FMAC4 soap_in___ns1__ingestMetadata(struct soap *soap, const char *tag, struct __ns1__ingestMetadata *a, const char *type)
{
	size_t soap_flag_ns1__ingestMetadata_ = 1;
	short soap_flag;
	a = (struct __ns1__ingestMetadata *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ingestMetadata, sizeof(struct __ns1__ingestMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ingestMetadata(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ingestMetadata_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ingestMetadata(soap, "ns1:ingestMetadata", &a->ns1__ingestMetadata_, "ns1:ingestMetadata"))
				{	soap_flag_ns1__ingestMetadata_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ingestMetadata(struct soap *soap, const struct __ns1__ingestMetadata *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ingestMetadata(soap, tag?tag:"-ns1:ingestMetadata", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ingestMetadata * SOAP_FMAC4 soap_get___ns1__ingestMetadata(struct soap *soap, struct __ns1__ingestMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ingestMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ingestMetadata * SOAP_FMAC2 soap_instantiate___ns1__ingestMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ingestMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ingestMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ingestMetadata);
		if (size)
			*size = sizeof(struct __ns1__ingestMetadata);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ingestMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__ingestMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__ingestMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ingestMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ingestMetadata %p -> %p\n", q, p));
	*(struct __ns1__ingestMetadata*)p = *(struct __ns1__ingestMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUserDetails(struct soap *soap, struct __ns1__getUserDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getUserDetails_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUserDetails(struct soap *soap, const struct __ns1__getUserDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getUserDetails(soap, &a->ns1__getUserDetails_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUserDetails(struct soap *soap, const char *tag, int id, const struct __ns1__getUserDetails *a, const char *type)
{
	if (soap_out_PointerTons1__getUserDetails(soap, "ns1:getUserDetails", -1, &a->ns1__getUserDetails_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserDetails * SOAP_FMAC4 soap_in___ns1__getUserDetails(struct soap *soap, const char *tag, struct __ns1__getUserDetails *a, const char *type)
{
	size_t soap_flag_ns1__getUserDetails_ = 1;
	short soap_flag;
	a = (struct __ns1__getUserDetails *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getUserDetails, sizeof(struct __ns1__getUserDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getUserDetails(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getUserDetails_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getUserDetails(soap, "ns1:getUserDetails", &a->ns1__getUserDetails_, "ns1:getUserDetails"))
				{	soap_flag_ns1__getUserDetails_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUserDetails(struct soap *soap, const struct __ns1__getUserDetails *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getUserDetails(soap, tag?tag:"-ns1:getUserDetails", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserDetails * SOAP_FMAC4 soap_get___ns1__getUserDetails(struct soap *soap, struct __ns1__getUserDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getUserDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getUserDetails * SOAP_FMAC2 soap_instantiate___ns1__getUserDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUserDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getUserDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getUserDetails);
		if (size)
			*size = sizeof(struct __ns1__getUserDetails);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getUserDetails[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getUserDetails);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getUserDetails*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getUserDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getUserDetails %p -> %p\n", q, p));
	*(struct __ns1__getUserDetails*)p = *(struct __ns1__getUserDetails*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDataFileParameter(struct soap *soap, struct __ns1__addDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDataFileParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDataFileParameter(struct soap *soap, const struct __ns1__addDataFileParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addDataFileParameter(soap, &a->ns1__addDataFileParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDataFileParameter(struct soap *soap, const char *tag, int id, const struct __ns1__addDataFileParameter *a, const char *type)
{
	if (soap_out_PointerTons1__addDataFileParameter(soap, "ns1:addDataFileParameter", -1, &a->ns1__addDataFileParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataFileParameter * SOAP_FMAC4 soap_in___ns1__addDataFileParameter(struct soap *soap, const char *tag, struct __ns1__addDataFileParameter *a, const char *type)
{
	size_t soap_flag_ns1__addDataFileParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__addDataFileParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDataFileParameter, sizeof(struct __ns1__addDataFileParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDataFileParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDataFileParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addDataFileParameter(soap, "ns1:addDataFileParameter", &a->ns1__addDataFileParameter_, "ns1:addDataFileParameter"))
				{	soap_flag_ns1__addDataFileParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDataFileParameter(struct soap *soap, const struct __ns1__addDataFileParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDataFileParameter(soap, tag?tag:"-ns1:addDataFileParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDataFileParameter * SOAP_FMAC4 soap_get___ns1__addDataFileParameter(struct soap *soap, struct __ns1__addDataFileParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addDataFileParameter * SOAP_FMAC2 soap_instantiate___ns1__addDataFileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addDataFileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addDataFileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataFileParameter);
		if (size)
			*size = sizeof(struct __ns1__addDataFileParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addDataFileParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addDataFileParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addDataFileParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addDataFileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addDataFileParameter %p -> %p\n", q, p));
	*(struct __ns1__addDataFileParameter*)p = *(struct __ns1__addDataFileParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDatafile(struct soap *soap, struct __ns1__getDatafile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDatafile_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDatafile(struct soap *soap, const struct __ns1__getDatafile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDatafile(soap, &a->ns1__getDatafile_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDatafile(struct soap *soap, const char *tag, int id, const struct __ns1__getDatafile *a, const char *type)
{
	if (soap_out_PointerTons1__getDatafile(soap, "ns1:getDatafile", -1, &a->ns1__getDatafile_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatafile * SOAP_FMAC4 soap_in___ns1__getDatafile(struct soap *soap, const char *tag, struct __ns1__getDatafile *a, const char *type)
{
	size_t soap_flag_ns1__getDatafile_ = 1;
	short soap_flag;
	a = (struct __ns1__getDatafile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDatafile, sizeof(struct __ns1__getDatafile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDatafile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDatafile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDatafile(soap, "ns1:getDatafile", &a->ns1__getDatafile_, "ns1:getDatafile"))
				{	soap_flag_ns1__getDatafile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDatafile(struct soap *soap, const struct __ns1__getDatafile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDatafile(soap, tag?tag:"-ns1:getDatafile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatafile * SOAP_FMAC4 soap_get___ns1__getDatafile(struct soap *soap, struct __ns1__getDatafile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDatafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDatafile * SOAP_FMAC2 soap_instantiate___ns1__getDatafile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDatafile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDatafile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatafile);
		if (size)
			*size = sizeof(struct __ns1__getDatafile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatafile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDatafile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDatafile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDatafile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDatafile %p -> %p\n", q, p));
	*(struct __ns1__getDatafile*)p = *(struct __ns1__getDatafile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDatasetIncludes(struct soap *soap, struct __ns1__getDatasetIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDatasetIncludes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDatasetIncludes(struct soap *soap, const struct __ns1__getDatasetIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDatasetIncludes(soap, &a->ns1__getDatasetIncludes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDatasetIncludes(struct soap *soap, const char *tag, int id, const struct __ns1__getDatasetIncludes *a, const char *type)
{
	if (soap_out_PointerTons1__getDatasetIncludes(soap, "ns1:getDatasetIncludes", -1, &a->ns1__getDatasetIncludes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatasetIncludes * SOAP_FMAC4 soap_in___ns1__getDatasetIncludes(struct soap *soap, const char *tag, struct __ns1__getDatasetIncludes *a, const char *type)
{
	size_t soap_flag_ns1__getDatasetIncludes_ = 1;
	short soap_flag;
	a = (struct __ns1__getDatasetIncludes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDatasetIncludes, sizeof(struct __ns1__getDatasetIncludes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDatasetIncludes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDatasetIncludes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDatasetIncludes(soap, "ns1:getDatasetIncludes", &a->ns1__getDatasetIncludes_, "ns1:getDatasetIncludes"))
				{	soap_flag_ns1__getDatasetIncludes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDatasetIncludes(struct soap *soap, const struct __ns1__getDatasetIncludes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDatasetIncludes(soap, tag?tag:"-ns1:getDatasetIncludes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDatasetIncludes * SOAP_FMAC4 soap_get___ns1__getDatasetIncludes(struct soap *soap, struct __ns1__getDatasetIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDatasetIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDatasetIncludes * SOAP_FMAC2 soap_instantiate___ns1__getDatasetIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDatasetIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDatasetIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatasetIncludes);
		if (size)
			*size = sizeof(struct __ns1__getDatasetIncludes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDatasetIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDatasetIncludes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDatasetIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDatasetIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDatasetIncludes %p -> %p\n", q, p));
	*(struct __ns1__getDatasetIncludes*)p = *(struct __ns1__getDatasetIncludes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDataset(struct soap *soap, struct __ns1__getDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDataset_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDataset(struct soap *soap, const struct __ns1__getDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDataset(soap, &a->ns1__getDataset_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDataset(struct soap *soap, const char *tag, int id, const struct __ns1__getDataset *a, const char *type)
{
	if (soap_out_PointerTons1__getDataset(soap, "ns1:getDataset", -1, &a->ns1__getDataset_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDataset * SOAP_FMAC4 soap_in___ns1__getDataset(struct soap *soap, const char *tag, struct __ns1__getDataset *a, const char *type)
{
	size_t soap_flag_ns1__getDataset_ = 1;
	short soap_flag;
	a = (struct __ns1__getDataset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDataset, sizeof(struct __ns1__getDataset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDataset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDataset_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDataset(soap, "ns1:getDataset", &a->ns1__getDataset_, "ns1:getDataset"))
				{	soap_flag_ns1__getDataset_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDataset(struct soap *soap, const struct __ns1__getDataset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDataset(soap, tag?tag:"-ns1:getDataset", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDataset * SOAP_FMAC4 soap_get___ns1__getDataset(struct soap *soap, struct __ns1__getDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDataset * SOAP_FMAC2 soap_instantiate___ns1__getDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDataset);
		if (size)
			*size = sizeof(struct __ns1__getDataset);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDataset[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDataset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDataset %p -> %p\n", q, p));
	*(struct __ns1__getDataset*)p = *(struct __ns1__getDataset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getInvestigationIncludes(struct soap *soap, struct __ns1__getInvestigationIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getInvestigationIncludes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getInvestigationIncludes(struct soap *soap, const struct __ns1__getInvestigationIncludes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getInvestigationIncludes(soap, &a->ns1__getInvestigationIncludes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getInvestigationIncludes(struct soap *soap, const char *tag, int id, const struct __ns1__getInvestigationIncludes *a, const char *type)
{
	if (soap_out_PointerTons1__getInvestigationIncludes(soap, "ns1:getInvestigationIncludes", -1, &a->ns1__getInvestigationIncludes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInvestigationIncludes * SOAP_FMAC4 soap_in___ns1__getInvestigationIncludes(struct soap *soap, const char *tag, struct __ns1__getInvestigationIncludes *a, const char *type)
{
	size_t soap_flag_ns1__getInvestigationIncludes_ = 1;
	short soap_flag;
	a = (struct __ns1__getInvestigationIncludes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getInvestigationIncludes, sizeof(struct __ns1__getInvestigationIncludes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getInvestigationIncludes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getInvestigationIncludes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getInvestigationIncludes(soap, "ns1:getInvestigationIncludes", &a->ns1__getInvestigationIncludes_, "ns1:getInvestigationIncludes"))
				{	soap_flag_ns1__getInvestigationIncludes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getInvestigationIncludes(struct soap *soap, const struct __ns1__getInvestigationIncludes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getInvestigationIncludes(soap, tag?tag:"-ns1:getInvestigationIncludes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInvestigationIncludes * SOAP_FMAC4 soap_get___ns1__getInvestigationIncludes(struct soap *soap, struct __ns1__getInvestigationIncludes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getInvestigationIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getInvestigationIncludes * SOAP_FMAC2 soap_instantiate___ns1__getInvestigationIncludes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getInvestigationIncludes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getInvestigationIncludes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getInvestigationIncludes);
		if (size)
			*size = sizeof(struct __ns1__getInvestigationIncludes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getInvestigationIncludes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getInvestigationIncludes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getInvestigationIncludes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getInvestigationIncludes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getInvestigationIncludes %p -> %p\n", q, p));
	*(struct __ns1__getInvestigationIncludes*)p = *(struct __ns1__getInvestigationIncludes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getInvestigation(struct soap *soap, struct __ns1__getInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getInvestigation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getInvestigation(struct soap *soap, const struct __ns1__getInvestigation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getInvestigation(soap, &a->ns1__getInvestigation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getInvestigation(struct soap *soap, const char *tag, int id, const struct __ns1__getInvestigation *a, const char *type)
{
	if (soap_out_PointerTons1__getInvestigation(soap, "ns1:getInvestigation", -1, &a->ns1__getInvestigation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInvestigation * SOAP_FMAC4 soap_in___ns1__getInvestigation(struct soap *soap, const char *tag, struct __ns1__getInvestigation *a, const char *type)
{
	size_t soap_flag_ns1__getInvestigation_ = 1;
	short soap_flag;
	a = (struct __ns1__getInvestigation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getInvestigation, sizeof(struct __ns1__getInvestigation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getInvestigation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getInvestigation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getInvestigation(soap, "ns1:getInvestigation", &a->ns1__getInvestigation_, "ns1:getInvestigation"))
				{	soap_flag_ns1__getInvestigation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getInvestigation(struct soap *soap, const struct __ns1__getInvestigation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getInvestigation(soap, tag?tag:"-ns1:getInvestigation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInvestigation * SOAP_FMAC4 soap_get___ns1__getInvestigation(struct soap *soap, struct __ns1__getInvestigation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getInvestigation * SOAP_FMAC2 soap_instantiate___ns1__getInvestigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getInvestigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getInvestigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getInvestigation);
		if (size)
			*size = sizeof(struct __ns1__getInvestigation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getInvestigation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getInvestigation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getInvestigation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getInvestigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getInvestigation %p -> %p\n", q, p));
	*(struct __ns1__getInvestigation*)p = *(struct __ns1__getInvestigation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addInvestigator(struct soap *soap, struct __ns1__addInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addInvestigator_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addInvestigator(struct soap *soap, const struct __ns1__addInvestigator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addInvestigator(soap, &a->ns1__addInvestigator_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addInvestigator(struct soap *soap, const char *tag, int id, const struct __ns1__addInvestigator *a, const char *type)
{
	if (soap_out_PointerTons1__addInvestigator(soap, "ns1:addInvestigator", -1, &a->ns1__addInvestigator_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addInvestigator * SOAP_FMAC4 soap_in___ns1__addInvestigator(struct soap *soap, const char *tag, struct __ns1__addInvestigator *a, const char *type)
{
	size_t soap_flag_ns1__addInvestigator_ = 1;
	short soap_flag;
	a = (struct __ns1__addInvestigator *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addInvestigator, sizeof(struct __ns1__addInvestigator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addInvestigator(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addInvestigator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addInvestigator(soap, "ns1:addInvestigator", &a->ns1__addInvestigator_, "ns1:addInvestigator"))
				{	soap_flag_ns1__addInvestigator_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addInvestigator(struct soap *soap, const struct __ns1__addInvestigator *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addInvestigator(soap, tag?tag:"-ns1:addInvestigator", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addInvestigator * SOAP_FMAC4 soap_get___ns1__addInvestigator(struct soap *soap, struct __ns1__addInvestigator *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addInvestigator * SOAP_FMAC2 soap_instantiate___ns1__addInvestigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addInvestigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addInvestigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addInvestigator);
		if (size)
			*size = sizeof(struct __ns1__addInvestigator);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addInvestigator[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addInvestigator);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addInvestigator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addInvestigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addInvestigator %p -> %p\n", q, p));
	*(struct __ns1__addInvestigator*)p = *(struct __ns1__addInvestigator*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addKeyword(struct soap *soap, struct __ns1__addKeyword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addKeyword_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addKeyword(struct soap *soap, const struct __ns1__addKeyword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addKeyword(soap, &a->ns1__addKeyword_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addKeyword(struct soap *soap, const char *tag, int id, const struct __ns1__addKeyword *a, const char *type)
{
	if (soap_out_PointerTons1__addKeyword(soap, "ns1:addKeyword", -1, &a->ns1__addKeyword_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addKeyword * SOAP_FMAC4 soap_in___ns1__addKeyword(struct soap *soap, const char *tag, struct __ns1__addKeyword *a, const char *type)
{
	size_t soap_flag_ns1__addKeyword_ = 1;
	short soap_flag;
	a = (struct __ns1__addKeyword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addKeyword, sizeof(struct __ns1__addKeyword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addKeyword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addKeyword_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addKeyword(soap, "ns1:addKeyword", &a->ns1__addKeyword_, "ns1:addKeyword"))
				{	soap_flag_ns1__addKeyword_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addKeyword(struct soap *soap, const struct __ns1__addKeyword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addKeyword(soap, tag?tag:"-ns1:addKeyword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addKeyword * SOAP_FMAC4 soap_get___ns1__addKeyword(struct soap *soap, struct __ns1__addKeyword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addKeyword * SOAP_FMAC2 soap_instantiate___ns1__addKeyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addKeyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addKeyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addKeyword);
		if (size)
			*size = sizeof(struct __ns1__addKeyword);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addKeyword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addKeyword);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addKeyword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addKeyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addKeyword %p -> %p\n", q, p));
	*(struct __ns1__addKeyword*)p = *(struct __ns1__addKeyword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addPublication(struct soap *soap, struct __ns1__addPublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addPublication_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addPublication(struct soap *soap, const struct __ns1__addPublication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addPublication(soap, &a->ns1__addPublication_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addPublication(struct soap *soap, const char *tag, int id, const struct __ns1__addPublication *a, const char *type)
{
	if (soap_out_PointerTons1__addPublication(soap, "ns1:addPublication", -1, &a->ns1__addPublication_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addPublication * SOAP_FMAC4 soap_in___ns1__addPublication(struct soap *soap, const char *tag, struct __ns1__addPublication *a, const char *type)
{
	size_t soap_flag_ns1__addPublication_ = 1;
	short soap_flag;
	a = (struct __ns1__addPublication *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addPublication, sizeof(struct __ns1__addPublication), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addPublication(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addPublication_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addPublication(soap, "ns1:addPublication", &a->ns1__addPublication_, "ns1:addPublication"))
				{	soap_flag_ns1__addPublication_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addPublication(struct soap *soap, const struct __ns1__addPublication *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addPublication(soap, tag?tag:"-ns1:addPublication", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addPublication * SOAP_FMAC4 soap_get___ns1__addPublication(struct soap *soap, struct __ns1__addPublication *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addPublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addPublication * SOAP_FMAC2 soap_instantiate___ns1__addPublication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addPublication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addPublication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addPublication);
		if (size)
			*size = sizeof(struct __ns1__addPublication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addPublication[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addPublication);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addPublication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addPublication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addPublication %p -> %p\n", q, p));
	*(struct __ns1__addPublication*)p = *(struct __ns1__addPublication*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addSampleParameter(struct soap *soap, struct __ns1__addSampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addSampleParameter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addSampleParameter(struct soap *soap, const struct __ns1__addSampleParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addSampleParameter(soap, &a->ns1__addSampleParameter_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addSampleParameter(struct soap *soap, const char *tag, int id, const struct __ns1__addSampleParameter *a, const char *type)
{
	if (soap_out_PointerTons1__addSampleParameter(soap, "ns1:addSampleParameter", -1, &a->ns1__addSampleParameter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addSampleParameter * SOAP_FMAC4 soap_in___ns1__addSampleParameter(struct soap *soap, const char *tag, struct __ns1__addSampleParameter *a, const char *type)
{
	size_t soap_flag_ns1__addSampleParameter_ = 1;
	short soap_flag;
	a = (struct __ns1__addSampleParameter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addSampleParameter, sizeof(struct __ns1__addSampleParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addSampleParameter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addSampleParameter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addSampleParameter(soap, "ns1:addSampleParameter", &a->ns1__addSampleParameter_, "ns1:addSampleParameter"))
				{	soap_flag_ns1__addSampleParameter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addSampleParameter(struct soap *soap, const struct __ns1__addSampleParameter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addSampleParameter(soap, tag?tag:"-ns1:addSampleParameter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addSampleParameter * SOAP_FMAC4 soap_get___ns1__addSampleParameter(struct soap *soap, struct __ns1__addSampleParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addSampleParameter * SOAP_FMAC2 soap_instantiate___ns1__addSampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addSampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addSampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addSampleParameter);
		if (size)
			*size = sizeof(struct __ns1__addSampleParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addSampleParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addSampleParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addSampleParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addSampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addSampleParameter %p -> %p\n", q, p));
	*(struct __ns1__addSampleParameter*)p = *(struct __ns1__addSampleParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logout(struct soap *soap, struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__logout_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logout(struct soap *soap, const struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__logout(soap, &a->ns1__logout_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logout(struct soap *soap, const char *tag, int id, const struct __ns1__logout *a, const char *type)
{
	if (soap_out_PointerTons1__logout(soap, "ns1:logout", -1, &a->ns1__logout_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_in___ns1__logout(struct soap *soap, const char *tag, struct __ns1__logout *a, const char *type)
{
	size_t soap_flag_ns1__logout_ = 1;
	short soap_flag;
	a = (struct __ns1__logout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logout, sizeof(struct __ns1__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__logout_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__logout(soap, "ns1:logout", &a->ns1__logout_, "ns1:logout"))
				{	soap_flag_ns1__logout_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logout(struct soap *soap, const struct __ns1__logout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__logout(soap, tag?tag:"-ns1:logout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_get___ns1__logout(struct soap *soap, struct __ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__logout * SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__logout);
		if (size)
			*size = sizeof(struct __ns1__logout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__logout);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__logout %p -> %p\n", q, p));
	*(struct __ns1__logout*)p = *(struct __ns1__logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addSample(struct soap *soap, struct __ns1__addSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addSample_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addSample(struct soap *soap, const struct __ns1__addSample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addSample(soap, &a->ns1__addSample_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addSample(struct soap *soap, const char *tag, int id, const struct __ns1__addSample *a, const char *type)
{
	if (soap_out_PointerTons1__addSample(soap, "ns1:addSample", -1, &a->ns1__addSample_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addSample * SOAP_FMAC4 soap_in___ns1__addSample(struct soap *soap, const char *tag, struct __ns1__addSample *a, const char *type)
{
	size_t soap_flag_ns1__addSample_ = 1;
	short soap_flag;
	a = (struct __ns1__addSample *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addSample, sizeof(struct __ns1__addSample), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addSample(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addSample_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addSample(soap, "ns1:addSample", &a->ns1__addSample_, "ns1:addSample"))
				{	soap_flag_ns1__addSample_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addSample(struct soap *soap, const struct __ns1__addSample *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addSample(soap, tag?tag:"-ns1:addSample", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addSample * SOAP_FMAC4 soap_get___ns1__addSample(struct soap *soap, struct __ns1__addSample *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addSample * SOAP_FMAC2 soap_instantiate___ns1__addSample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addSample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addSample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addSample);
		if (size)
			*size = sizeof(struct __ns1__addSample);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addSample[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addSample);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addSample*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addSample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addSample %p -> %p\n", q, p));
	*(struct __ns1__addSample*)p = *(struct __ns1__addSample*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__loginLifetime(struct soap *soap, struct __ns1__loginLifetime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loginLifetime_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__loginLifetime(struct soap *soap, const struct __ns1__loginLifetime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__loginLifetime(soap, &a->ns1__loginLifetime_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__loginLifetime(struct soap *soap, const char *tag, int id, const struct __ns1__loginLifetime *a, const char *type)
{
	if (soap_out_PointerTons1__loginLifetime(soap, "ns1:loginLifetime", -1, &a->ns1__loginLifetime_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loginLifetime * SOAP_FMAC4 soap_in___ns1__loginLifetime(struct soap *soap, const char *tag, struct __ns1__loginLifetime *a, const char *type)
{
	size_t soap_flag_ns1__loginLifetime_ = 1;
	short soap_flag;
	a = (struct __ns1__loginLifetime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__loginLifetime, sizeof(struct __ns1__loginLifetime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__loginLifetime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loginLifetime_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__loginLifetime(soap, "ns1:loginLifetime", &a->ns1__loginLifetime_, "ns1:loginLifetime"))
				{	soap_flag_ns1__loginLifetime_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__loginLifetime(struct soap *soap, const struct __ns1__loginLifetime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__loginLifetime(soap, tag?tag:"-ns1:loginLifetime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loginLifetime * SOAP_FMAC4 soap_get___ns1__loginLifetime(struct soap *soap, struct __ns1__loginLifetime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__loginLifetime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__loginLifetime * SOAP_FMAC2 soap_instantiate___ns1__loginLifetime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__loginLifetime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__loginLifetime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__loginLifetime);
		if (size)
			*size = sizeof(struct __ns1__loginLifetime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__loginLifetime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__loginLifetime);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__loginLifetime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__loginLifetime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__loginLifetime %p -> %p\n", q, p));
	*(struct __ns1__loginLifetime*)p = *(struct __ns1__loginLifetime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__login(struct soap *soap, struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__login_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__login(struct soap *soap, const struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__login(soap, &a->ns1__login_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__login(struct soap *soap, const char *tag, int id, const struct __ns1__login *a, const char *type)
{
	if (soap_out_PointerTons1__login(soap, "ns1:login", -1, &a->ns1__login_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_in___ns1__login(struct soap *soap, const char *tag, struct __ns1__login *a, const char *type)
{
	size_t soap_flag_ns1__login_ = 1;
	short soap_flag;
	a = (struct __ns1__login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__login, sizeof(struct __ns1__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__login_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__login(soap, "ns1:login", &a->ns1__login_, "ns1:login"))
				{	soap_flag_ns1__login_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__login(struct soap *soap, const struct __ns1__login *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__login(soap, tag?tag:"-ns1:login", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_get___ns1__login(struct soap *soap, struct __ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__login * SOAP_FMAC2 soap_instantiate___ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__login);
		if (size)
			*size = sizeof(struct __ns1__login);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__login[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__login);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__login %p -> %p\n", q, p));
	*(struct __ns1__login*)p = *(struct __ns1__login*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ICATAPIException_ = NULL;
	a->ns1__InsufficientPrivilegesException_ = NULL;
	a->ns1__NoSuchObjectFoundException_ = NULL;
	a->ns1__NoSuchUserException_ = NULL;
	a->ns1__SessionException = NULL;
	a->ns1__ValidationException_ = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ICATAPIException(soap, &a->ns1__ICATAPIException_);
	soap_serialize_PointerTons1__InsufficientPrivilegesException(soap, &a->ns1__InsufficientPrivilegesException_);
	soap_serialize_PointerTons1__NoSuchObjectFoundException(soap, &a->ns1__NoSuchObjectFoundException_);
	soap_serialize_PointerTons1__NoSuchUserException(soap, &a->ns1__NoSuchUserException_);
	soap_serialize_PointerTons3__SessionException(soap, &a->ns1__SessionException);
	soap_serialize_PointerTons1__ValidationException(soap, &a->ns1__ValidationException_);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons1__ICATAPIException(soap, "ns1:ICATAPIException", -1, &a->ns1__ICATAPIException_, ""))
		return soap->error;
	if (soap_out_PointerTons1__InsufficientPrivilegesException(soap, "ns1:InsufficientPrivilegesException", -1, &a->ns1__InsufficientPrivilegesException_, ""))
		return soap->error;
	if (soap_out_PointerTons1__NoSuchObjectFoundException(soap, "ns1:NoSuchObjectFoundException", -1, &a->ns1__NoSuchObjectFoundException_, ""))
		return soap->error;
	if (soap_out_PointerTons1__NoSuchUserException(soap, "ns1:NoSuchUserException", -1, &a->ns1__NoSuchUserException_, ""))
		return soap->error;
	if (soap_out_PointerTons3__SessionException(soap, "ns1:SessionException", -1, &a->ns1__SessionException, ""))
		return soap->error;
	if (soap_out_PointerTons1__ValidationException(soap, "ns1:ValidationException", -1, &a->ns1__ValidationException_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__ICATAPIException_ = 1;
	size_t soap_flag_ns1__InsufficientPrivilegesException_ = 1;
	size_t soap_flag_ns1__NoSuchObjectFoundException_ = 1;
	size_t soap_flag_ns1__NoSuchUserException_ = 1;
	size_t soap_flag_ns1__SessionException = 1;
	size_t soap_flag_ns1__ValidationException_ = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ICATAPIException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ICATAPIException(soap, "ns1:ICATAPIException", &a->ns1__ICATAPIException_, "ns1:ICATAPIException"))
				{	soap_flag_ns1__ICATAPIException_--;
					continue;
				}
			if (soap_flag_ns1__InsufficientPrivilegesException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__InsufficientPrivilegesException(soap, "ns1:InsufficientPrivilegesException", &a->ns1__InsufficientPrivilegesException_, "ns1:InsufficientPrivilegesException"))
				{	soap_flag_ns1__InsufficientPrivilegesException_--;
					continue;
				}
			if (soap_flag_ns1__NoSuchObjectFoundException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NoSuchObjectFoundException(soap, "ns1:NoSuchObjectFoundException", &a->ns1__NoSuchObjectFoundException_, "ns1:NoSuchObjectFoundException"))
				{	soap_flag_ns1__NoSuchObjectFoundException_--;
					continue;
				}
			if (soap_flag_ns1__NoSuchUserException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NoSuchUserException(soap, "ns1:NoSuchUserException", &a->ns1__NoSuchUserException_, "ns1:NoSuchUserException"))
				{	soap_flag_ns1__NoSuchUserException_--;
					continue;
				}
			if (soap_flag_ns1__SessionException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__SessionException(soap, "ns1:SessionException", &a->ns1__SessionException, "ns3:SessionException"))
				{	soap_flag_ns1__SessionException--;
					continue;
				}
			if (soap_flag_ns1__ValidationException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ValidationException(soap, "ns1:ValidationException", &a->ns1__ValidationException_, "ns1:ValidationException"))
				{	soap_flag_ns1__ValidationException_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getICATAPIVersionResponse(struct soap *soap, ns1__getICATAPIVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getICATAPIVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getICATAPIVersionResponse(struct soap *soap, const char *tag, int id, ns1__getICATAPIVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getICATAPIVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getICATAPIVersionResponse ** SOAP_FMAC4 soap_in_PointerTons1__getICATAPIVersionResponse(struct soap *soap, const char *tag, ns1__getICATAPIVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getICATAPIVersionResponse **)soap_malloc(soap, sizeof(ns1__getICATAPIVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getICATAPIVersionResponse *)soap_instantiate_ns1__getICATAPIVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getICATAPIVersionResponse ** p = (ns1__getICATAPIVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getICATAPIVersionResponse, sizeof(ns1__getICATAPIVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getICATAPIVersionResponse(struct soap *soap, ns1__getICATAPIVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getICATAPIVersionResponse);
	if (soap_out_PointerTons1__getICATAPIVersionResponse(soap, tag?tag:"ns1:getICATAPIVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getICATAPIVersionResponse ** SOAP_FMAC4 soap_get_PointerTons1__getICATAPIVersionResponse(struct soap *soap, ns1__getICATAPIVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getICATAPIVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getICATAPIVersion(struct soap *soap, ns1__getICATAPIVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getICATAPIVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getICATAPIVersion(struct soap *soap, const char *tag, int id, ns1__getICATAPIVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getICATAPIVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getICATAPIVersion ** SOAP_FMAC4 soap_in_PointerTons1__getICATAPIVersion(struct soap *soap, const char *tag, ns1__getICATAPIVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getICATAPIVersion **)soap_malloc(soap, sizeof(ns1__getICATAPIVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getICATAPIVersion *)soap_instantiate_ns1__getICATAPIVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getICATAPIVersion ** p = (ns1__getICATAPIVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getICATAPIVersion, sizeof(ns1__getICATAPIVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getICATAPIVersion(struct soap *soap, ns1__getICATAPIVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getICATAPIVersion);
	if (soap_out_PointerTons1__getICATAPIVersion(soap, tag?tag:"ns1:getICATAPIVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getICATAPIVersion ** SOAP_FMAC4 soap_get_PointerTons1__getICATAPIVersion(struct soap *soap, ns1__getICATAPIVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getICATAPIVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listFacilityCyclesResponse(struct soap *soap, ns1__listFacilityCyclesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listFacilityCyclesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listFacilityCyclesResponse(struct soap *soap, const char *tag, int id, ns1__listFacilityCyclesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listFacilityCyclesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listFacilityCyclesResponse ** SOAP_FMAC4 soap_in_PointerTons1__listFacilityCyclesResponse(struct soap *soap, const char *tag, ns1__listFacilityCyclesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listFacilityCyclesResponse **)soap_malloc(soap, sizeof(ns1__listFacilityCyclesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listFacilityCyclesResponse *)soap_instantiate_ns1__listFacilityCyclesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listFacilityCyclesResponse ** p = (ns1__listFacilityCyclesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listFacilityCyclesResponse, sizeof(ns1__listFacilityCyclesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listFacilityCyclesResponse(struct soap *soap, ns1__listFacilityCyclesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listFacilityCyclesResponse);
	if (soap_out_PointerTons1__listFacilityCyclesResponse(soap, tag?tag:"ns1:listFacilityCyclesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listFacilityCyclesResponse ** SOAP_FMAC4 soap_get_PointerTons1__listFacilityCyclesResponse(struct soap *soap, ns1__listFacilityCyclesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listFacilityCyclesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listFacilityCycles(struct soap *soap, ns1__listFacilityCycles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listFacilityCycles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listFacilityCycles(struct soap *soap, const char *tag, int id, ns1__listFacilityCycles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listFacilityCycles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listFacilityCycles ** SOAP_FMAC4 soap_in_PointerTons1__listFacilityCycles(struct soap *soap, const char *tag, ns1__listFacilityCycles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listFacilityCycles **)soap_malloc(soap, sizeof(ns1__listFacilityCycles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listFacilityCycles *)soap_instantiate_ns1__listFacilityCycles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listFacilityCycles ** p = (ns1__listFacilityCycles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listFacilityCycles, sizeof(ns1__listFacilityCycles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listFacilityCycles(struct soap *soap, ns1__listFacilityCycles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listFacilityCycles);
	if (soap_out_PointerTons1__listFacilityCycles(soap, tag?tag:"ns1:listFacilityCycles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listFacilityCycles ** SOAP_FMAC4 soap_get_PointerTons1__listFacilityCycles(struct soap *soap, ns1__listFacilityCycles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listFacilityCycles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getFacilityUserByFederalIdResponse(struct soap *soap, ns1__getFacilityUserByFederalIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getFacilityUserByFederalIdResponse(struct soap *soap, const char *tag, int id, ns1__getFacilityUserByFederalIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalIdResponse ** SOAP_FMAC4 soap_in_PointerTons1__getFacilityUserByFederalIdResponse(struct soap *soap, const char *tag, ns1__getFacilityUserByFederalIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getFacilityUserByFederalIdResponse **)soap_malloc(soap, sizeof(ns1__getFacilityUserByFederalIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getFacilityUserByFederalIdResponse *)soap_instantiate_ns1__getFacilityUserByFederalIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getFacilityUserByFederalIdResponse ** p = (ns1__getFacilityUserByFederalIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse, sizeof(ns1__getFacilityUserByFederalIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getFacilityUserByFederalIdResponse(struct soap *soap, ns1__getFacilityUserByFederalIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getFacilityUserByFederalIdResponse);
	if (soap_out_PointerTons1__getFacilityUserByFederalIdResponse(soap, tag?tag:"ns1:getFacilityUserByFederalIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalIdResponse ** SOAP_FMAC4 soap_get_PointerTons1__getFacilityUserByFederalIdResponse(struct soap *soap, ns1__getFacilityUserByFederalIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getFacilityUserByFederalIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getFacilityUserByFederalId(struct soap *soap, ns1__getFacilityUserByFederalId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getFacilityUserByFederalId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getFacilityUserByFederalId(struct soap *soap, const char *tag, int id, ns1__getFacilityUserByFederalId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getFacilityUserByFederalId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalId ** SOAP_FMAC4 soap_in_PointerTons1__getFacilityUserByFederalId(struct soap *soap, const char *tag, ns1__getFacilityUserByFederalId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getFacilityUserByFederalId **)soap_malloc(soap, sizeof(ns1__getFacilityUserByFederalId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getFacilityUserByFederalId *)soap_instantiate_ns1__getFacilityUserByFederalId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getFacilityUserByFederalId ** p = (ns1__getFacilityUserByFederalId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFederalId, sizeof(ns1__getFacilityUserByFederalId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getFacilityUserByFederalId(struct soap *soap, ns1__getFacilityUserByFederalId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getFacilityUserByFederalId);
	if (soap_out_PointerTons1__getFacilityUserByFederalId(soap, tag?tag:"ns1:getFacilityUserByFederalId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getFacilityUserByFederalId ** SOAP_FMAC4 soap_get_PointerTons1__getFacilityUserByFederalId(struct soap *soap, ns1__getFacilityUserByFederalId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getFacilityUserByFederalId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, ns1__getFacilityUserByFacilityUserIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, const char *tag, int id, ns1__getFacilityUserByFacilityUserIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserIdResponse ** SOAP_FMAC4 soap_in_PointerTons1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, const char *tag, ns1__getFacilityUserByFacilityUserIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getFacilityUserByFacilityUserIdResponse **)soap_malloc(soap, sizeof(ns1__getFacilityUserByFacilityUserIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getFacilityUserByFacilityUserIdResponse *)soap_instantiate_ns1__getFacilityUserByFacilityUserIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getFacilityUserByFacilityUserIdResponse ** p = (ns1__getFacilityUserByFacilityUserIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse, sizeof(ns1__getFacilityUserByFacilityUserIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, ns1__getFacilityUserByFacilityUserIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserIdResponse);
	if (soap_out_PointerTons1__getFacilityUserByFacilityUserIdResponse(soap, tag?tag:"ns1:getFacilityUserByFacilityUserIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserIdResponse ** SOAP_FMAC4 soap_get_PointerTons1__getFacilityUserByFacilityUserIdResponse(struct soap *soap, ns1__getFacilityUserByFacilityUserIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getFacilityUserByFacilityUserIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getFacilityUserByFacilityUserId(struct soap *soap, ns1__getFacilityUserByFacilityUserId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getFacilityUserByFacilityUserId(struct soap *soap, const char *tag, int id, ns1__getFacilityUserByFacilityUserId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserId ** SOAP_FMAC4 soap_in_PointerTons1__getFacilityUserByFacilityUserId(struct soap *soap, const char *tag, ns1__getFacilityUserByFacilityUserId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getFacilityUserByFacilityUserId **)soap_malloc(soap, sizeof(ns1__getFacilityUserByFacilityUserId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getFacilityUserByFacilityUserId *)soap_instantiate_ns1__getFacilityUserByFacilityUserId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getFacilityUserByFacilityUserId ** p = (ns1__getFacilityUserByFacilityUserId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId, sizeof(ns1__getFacilityUserByFacilityUserId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getFacilityUserByFacilityUserId(struct soap *soap, ns1__getFacilityUserByFacilityUserId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getFacilityUserByFacilityUserId);
	if (soap_out_PointerTons1__getFacilityUserByFacilityUserId(soap, tag?tag:"ns1:getFacilityUserByFacilityUserId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getFacilityUserByFacilityUserId ** SOAP_FMAC4 soap_get_PointerTons1__getFacilityUserByFacilityUserId(struct soap *soap, ns1__getFacilityUserByFacilityUserId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getFacilityUserByFacilityUserId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchDatasetsBySampleResponse(struct soap *soap, ns1__searchDatasetsBySampleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchDatasetsBySampleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchDatasetsBySampleResponse(struct soap *soap, const char *tag, int id, ns1__searchDatasetsBySampleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchDatasetsBySampleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchDatasetsBySampleResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchDatasetsBySampleResponse(struct soap *soap, const char *tag, ns1__searchDatasetsBySampleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchDatasetsBySampleResponse **)soap_malloc(soap, sizeof(ns1__searchDatasetsBySampleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchDatasetsBySampleResponse *)soap_instantiate_ns1__searchDatasetsBySampleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchDatasetsBySampleResponse ** p = (ns1__searchDatasetsBySampleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchDatasetsBySampleResponse, sizeof(ns1__searchDatasetsBySampleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchDatasetsBySampleResponse(struct soap *soap, ns1__searchDatasetsBySampleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchDatasetsBySampleResponse);
	if (soap_out_PointerTons1__searchDatasetsBySampleResponse(soap, tag?tag:"ns1:searchDatasetsBySampleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchDatasetsBySampleResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchDatasetsBySampleResponse(struct soap *soap, ns1__searchDatasetsBySampleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchDatasetsBySampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchDatasetsBySample(struct soap *soap, ns1__searchDatasetsBySample *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchDatasetsBySample))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchDatasetsBySample(struct soap *soap, const char *tag, int id, ns1__searchDatasetsBySample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchDatasetsBySample);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchDatasetsBySample ** SOAP_FMAC4 soap_in_PointerTons1__searchDatasetsBySample(struct soap *soap, const char *tag, ns1__searchDatasetsBySample **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchDatasetsBySample **)soap_malloc(soap, sizeof(ns1__searchDatasetsBySample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchDatasetsBySample *)soap_instantiate_ns1__searchDatasetsBySample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchDatasetsBySample ** p = (ns1__searchDatasetsBySample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchDatasetsBySample, sizeof(ns1__searchDatasetsBySample), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchDatasetsBySample(struct soap *soap, ns1__searchDatasetsBySample *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchDatasetsBySample);
	if (soap_out_PointerTons1__searchDatasetsBySample(soap, tag?tag:"ns1:searchDatasetsBySample", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchDatasetsBySample ** SOAP_FMAC4 soap_get_PointerTons1__searchDatasetsBySample(struct soap *soap, ns1__searchDatasetsBySample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchDatasetsBySample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkDatasetDownloadAccessResponse(struct soap *soap, ns1__checkDatasetDownloadAccessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkDatasetDownloadAccessResponse(struct soap *soap, const char *tag, int id, ns1__checkDatasetDownloadAccessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccessResponse ** SOAP_FMAC4 soap_in_PointerTons1__checkDatasetDownloadAccessResponse(struct soap *soap, const char *tag, ns1__checkDatasetDownloadAccessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkDatasetDownloadAccessResponse **)soap_malloc(soap, sizeof(ns1__checkDatasetDownloadAccessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkDatasetDownloadAccessResponse *)soap_instantiate_ns1__checkDatasetDownloadAccessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkDatasetDownloadAccessResponse ** p = (ns1__checkDatasetDownloadAccessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse, sizeof(ns1__checkDatasetDownloadAccessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkDatasetDownloadAccessResponse(struct soap *soap, ns1__checkDatasetDownloadAccessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkDatasetDownloadAccessResponse);
	if (soap_out_PointerTons1__checkDatasetDownloadAccessResponse(soap, tag?tag:"ns1:checkDatasetDownloadAccessResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccessResponse ** SOAP_FMAC4 soap_get_PointerTons1__checkDatasetDownloadAccessResponse(struct soap *soap, ns1__checkDatasetDownloadAccessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkDatasetDownloadAccessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkDatasetDownloadAccess(struct soap *soap, ns1__checkDatasetDownloadAccess *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkDatasetDownloadAccess))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkDatasetDownloadAccess(struct soap *soap, const char *tag, int id, ns1__checkDatasetDownloadAccess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkDatasetDownloadAccess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccess ** SOAP_FMAC4 soap_in_PointerTons1__checkDatasetDownloadAccess(struct soap *soap, const char *tag, ns1__checkDatasetDownloadAccess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkDatasetDownloadAccess **)soap_malloc(soap, sizeof(ns1__checkDatasetDownloadAccess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkDatasetDownloadAccess *)soap_instantiate_ns1__checkDatasetDownloadAccess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkDatasetDownloadAccess ** p = (ns1__checkDatasetDownloadAccess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatasetDownloadAccess, sizeof(ns1__checkDatasetDownloadAccess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkDatasetDownloadAccess(struct soap *soap, ns1__checkDatasetDownloadAccess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkDatasetDownloadAccess);
	if (soap_out_PointerTons1__checkDatasetDownloadAccess(soap, tag?tag:"ns1:checkDatasetDownloadAccess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__checkDatasetDownloadAccess ** SOAP_FMAC4 soap_get_PointerTons1__checkDatasetDownloadAccess(struct soap *soap, ns1__checkDatasetDownloadAccess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkDatasetDownloadAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkDatafileDownloadAccessResponse(struct soap *soap, ns1__checkDatafileDownloadAccessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkDatafileDownloadAccessResponse(struct soap *soap, const char *tag, int id, ns1__checkDatafileDownloadAccessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccessResponse ** SOAP_FMAC4 soap_in_PointerTons1__checkDatafileDownloadAccessResponse(struct soap *soap, const char *tag, ns1__checkDatafileDownloadAccessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkDatafileDownloadAccessResponse **)soap_malloc(soap, sizeof(ns1__checkDatafileDownloadAccessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkDatafileDownloadAccessResponse *)soap_instantiate_ns1__checkDatafileDownloadAccessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkDatafileDownloadAccessResponse ** p = (ns1__checkDatafileDownloadAccessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse, sizeof(ns1__checkDatafileDownloadAccessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkDatafileDownloadAccessResponse(struct soap *soap, ns1__checkDatafileDownloadAccessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkDatafileDownloadAccessResponse);
	if (soap_out_PointerTons1__checkDatafileDownloadAccessResponse(soap, tag?tag:"ns1:checkDatafileDownloadAccessResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccessResponse ** SOAP_FMAC4 soap_get_PointerTons1__checkDatafileDownloadAccessResponse(struct soap *soap, ns1__checkDatafileDownloadAccessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkDatafileDownloadAccessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkDatafileDownloadAccess(struct soap *soap, ns1__checkDatafileDownloadAccess *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkDatafileDownloadAccess))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkDatafileDownloadAccess(struct soap *soap, const char *tag, int id, ns1__checkDatafileDownloadAccess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkDatafileDownloadAccess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccess ** SOAP_FMAC4 soap_in_PointerTons1__checkDatafileDownloadAccess(struct soap *soap, const char *tag, ns1__checkDatafileDownloadAccess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkDatafileDownloadAccess **)soap_malloc(soap, sizeof(ns1__checkDatafileDownloadAccess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkDatafileDownloadAccess *)soap_instantiate_ns1__checkDatafileDownloadAccess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkDatafileDownloadAccess ** p = (ns1__checkDatafileDownloadAccess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatafileDownloadAccess, sizeof(ns1__checkDatafileDownloadAccess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkDatafileDownloadAccess(struct soap *soap, ns1__checkDatafileDownloadAccess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkDatafileDownloadAccess);
	if (soap_out_PointerTons1__checkDatafileDownloadAccess(soap, tag?tag:"ns1:checkDatafileDownloadAccess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__checkDatafileDownloadAccess ** SOAP_FMAC4 soap_get_PointerTons1__checkDatafileDownloadAccess(struct soap *soap, ns1__checkDatafileDownloadAccess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkDatafileDownloadAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadDatasetResponse(struct soap *soap, ns1__downloadDatasetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadDatasetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadDatasetResponse(struct soap *soap, const char *tag, int id, ns1__downloadDatasetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadDatasetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadDatasetResponse ** SOAP_FMAC4 soap_in_PointerTons1__downloadDatasetResponse(struct soap *soap, const char *tag, ns1__downloadDatasetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadDatasetResponse **)soap_malloc(soap, sizeof(ns1__downloadDatasetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadDatasetResponse *)soap_instantiate_ns1__downloadDatasetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadDatasetResponse ** p = (ns1__downloadDatasetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatasetResponse, sizeof(ns1__downloadDatasetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadDatasetResponse(struct soap *soap, ns1__downloadDatasetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadDatasetResponse);
	if (soap_out_PointerTons1__downloadDatasetResponse(soap, tag?tag:"ns1:downloadDatasetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadDatasetResponse ** SOAP_FMAC4 soap_get_PointerTons1__downloadDatasetResponse(struct soap *soap, ns1__downloadDatasetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadDatasetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadDataset(struct soap *soap, ns1__downloadDataset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadDataset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadDataset(struct soap *soap, const char *tag, int id, ns1__downloadDataset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadDataset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadDataset ** SOAP_FMAC4 soap_in_PointerTons1__downloadDataset(struct soap *soap, const char *tag, ns1__downloadDataset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadDataset **)soap_malloc(soap, sizeof(ns1__downloadDataset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadDataset *)soap_instantiate_ns1__downloadDataset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadDataset ** p = (ns1__downloadDataset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDataset, sizeof(ns1__downloadDataset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadDataset(struct soap *soap, ns1__downloadDataset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadDataset);
	if (soap_out_PointerTons1__downloadDataset(soap, tag?tag:"ns1:downloadDataset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadDataset ** SOAP_FMAC4 soap_get_PointerTons1__downloadDataset(struct soap *soap, ns1__downloadDataset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadDataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadDatafilesResponse(struct soap *soap, ns1__downloadDatafilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadDatafilesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadDatafilesResponse(struct soap *soap, const char *tag, int id, ns1__downloadDatafilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadDatafilesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadDatafilesResponse ** SOAP_FMAC4 soap_in_PointerTons1__downloadDatafilesResponse(struct soap *soap, const char *tag, ns1__downloadDatafilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadDatafilesResponse **)soap_malloc(soap, sizeof(ns1__downloadDatafilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadDatafilesResponse *)soap_instantiate_ns1__downloadDatafilesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadDatafilesResponse ** p = (ns1__downloadDatafilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafilesResponse, sizeof(ns1__downloadDatafilesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadDatafilesResponse(struct soap *soap, ns1__downloadDatafilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadDatafilesResponse);
	if (soap_out_PointerTons1__downloadDatafilesResponse(soap, tag?tag:"ns1:downloadDatafilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadDatafilesResponse ** SOAP_FMAC4 soap_get_PointerTons1__downloadDatafilesResponse(struct soap *soap, ns1__downloadDatafilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadDatafilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadDatafiles(struct soap *soap, ns1__downloadDatafiles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadDatafiles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadDatafiles(struct soap *soap, const char *tag, int id, ns1__downloadDatafiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadDatafiles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadDatafiles ** SOAP_FMAC4 soap_in_PointerTons1__downloadDatafiles(struct soap *soap, const char *tag, ns1__downloadDatafiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadDatafiles **)soap_malloc(soap, sizeof(ns1__downloadDatafiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadDatafiles *)soap_instantiate_ns1__downloadDatafiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadDatafiles ** p = (ns1__downloadDatafiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafiles, sizeof(ns1__downloadDatafiles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadDatafiles(struct soap *soap, ns1__downloadDatafiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadDatafiles);
	if (soap_out_PointerTons1__downloadDatafiles(soap, tag?tag:"ns1:downloadDatafiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadDatafiles ** SOAP_FMAC4 soap_get_PointerTons1__downloadDatafiles(struct soap *soap, ns1__downloadDatafiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadDatafileResponse(struct soap *soap, ns1__downloadDatafileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadDatafileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadDatafileResponse(struct soap *soap, const char *tag, int id, ns1__downloadDatafileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadDatafileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadDatafileResponse ** SOAP_FMAC4 soap_in_PointerTons1__downloadDatafileResponse(struct soap *soap, const char *tag, ns1__downloadDatafileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadDatafileResponse **)soap_malloc(soap, sizeof(ns1__downloadDatafileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadDatafileResponse *)soap_instantiate_ns1__downloadDatafileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadDatafileResponse ** p = (ns1__downloadDatafileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafileResponse, sizeof(ns1__downloadDatafileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadDatafileResponse(struct soap *soap, ns1__downloadDatafileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadDatafileResponse);
	if (soap_out_PointerTons1__downloadDatafileResponse(soap, tag?tag:"ns1:downloadDatafileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadDatafileResponse ** SOAP_FMAC4 soap_get_PointerTons1__downloadDatafileResponse(struct soap *soap, ns1__downloadDatafileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadDatafileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadDatafile(struct soap *soap, ns1__downloadDatafile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadDatafile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadDatafile(struct soap *soap, const char *tag, int id, ns1__downloadDatafile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadDatafile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadDatafile ** SOAP_FMAC4 soap_in_PointerTons1__downloadDatafile(struct soap *soap, const char *tag, ns1__downloadDatafile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadDatafile **)soap_malloc(soap, sizeof(ns1__downloadDatafile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadDatafile *)soap_instantiate_ns1__downloadDatafile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadDatafile ** p = (ns1__downloadDatafile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafile, sizeof(ns1__downloadDatafile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadDatafile(struct soap *soap, ns1__downloadDatafile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadDatafile);
	if (soap_out_PointerTons1__downloadDatafile(soap, tag?tag:"ns1:downloadDatafile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadDatafile ** SOAP_FMAC4 soap_get_PointerTons1__downloadDatafile(struct soap *soap, ns1__downloadDatafile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadDatafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listParametersResponse(struct soap *soap, ns1__listParametersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listParametersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listParametersResponse(struct soap *soap, const char *tag, int id, ns1__listParametersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listParametersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listParametersResponse ** SOAP_FMAC4 soap_in_PointerTons1__listParametersResponse(struct soap *soap, const char *tag, ns1__listParametersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listParametersResponse **)soap_malloc(soap, sizeof(ns1__listParametersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listParametersResponse *)soap_instantiate_ns1__listParametersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listParametersResponse ** p = (ns1__listParametersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listParametersResponse, sizeof(ns1__listParametersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listParametersResponse(struct soap *soap, ns1__listParametersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listParametersResponse);
	if (soap_out_PointerTons1__listParametersResponse(soap, tag?tag:"ns1:listParametersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listParametersResponse ** SOAP_FMAC4 soap_get_PointerTons1__listParametersResponse(struct soap *soap, ns1__listParametersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listParameters(struct soap *soap, ns1__listParameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listParameters))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listParameters(struct soap *soap, const char *tag, int id, ns1__listParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listParameters);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listParameters ** SOAP_FMAC4 soap_in_PointerTons1__listParameters(struct soap *soap, const char *tag, ns1__listParameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listParameters **)soap_malloc(soap, sizeof(ns1__listParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listParameters *)soap_instantiate_ns1__listParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listParameters ** p = (ns1__listParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listParameters, sizeof(ns1__listParameters), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listParameters(struct soap *soap, ns1__listParameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listParameters);
	if (soap_out_PointerTons1__listParameters(soap, tag?tag:"ns1:listParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listParameters ** SOAP_FMAC4 soap_get_PointerTons1__listParameters(struct soap *soap, ns1__listParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listInvestigationTypesResponse(struct soap *soap, ns1__listInvestigationTypesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listInvestigationTypesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listInvestigationTypesResponse(struct soap *soap, const char *tag, int id, ns1__listInvestigationTypesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listInvestigationTypesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listInvestigationTypesResponse ** SOAP_FMAC4 soap_in_PointerTons1__listInvestigationTypesResponse(struct soap *soap, const char *tag, ns1__listInvestigationTypesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listInvestigationTypesResponse **)soap_malloc(soap, sizeof(ns1__listInvestigationTypesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listInvestigationTypesResponse *)soap_instantiate_ns1__listInvestigationTypesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listInvestigationTypesResponse ** p = (ns1__listInvestigationTypesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInvestigationTypesResponse, sizeof(ns1__listInvestigationTypesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listInvestigationTypesResponse(struct soap *soap, ns1__listInvestigationTypesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listInvestigationTypesResponse);
	if (soap_out_PointerTons1__listInvestigationTypesResponse(soap, tag?tag:"ns1:listInvestigationTypesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listInvestigationTypesResponse ** SOAP_FMAC4 soap_get_PointerTons1__listInvestigationTypesResponse(struct soap *soap, ns1__listInvestigationTypesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listInvestigationTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listInvestigationTypes(struct soap *soap, ns1__listInvestigationTypes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listInvestigationTypes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listInvestigationTypes(struct soap *soap, const char *tag, int id, ns1__listInvestigationTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listInvestigationTypes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listInvestigationTypes ** SOAP_FMAC4 soap_in_PointerTons1__listInvestigationTypes(struct soap *soap, const char *tag, ns1__listInvestigationTypes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listInvestigationTypes **)soap_malloc(soap, sizeof(ns1__listInvestigationTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listInvestigationTypes *)soap_instantiate_ns1__listInvestigationTypes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listInvestigationTypes ** p = (ns1__listInvestigationTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInvestigationTypes, sizeof(ns1__listInvestigationTypes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listInvestigationTypes(struct soap *soap, ns1__listInvestigationTypes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listInvestigationTypes);
	if (soap_out_PointerTons1__listInvestigationTypes(soap, tag?tag:"ns1:listInvestigationTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listInvestigationTypes ** SOAP_FMAC4 soap_get_PointerTons1__listInvestigationTypes(struct soap *soap, ns1__listInvestigationTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listInvestigationTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listRolesResponse(struct soap *soap, ns1__listRolesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listRolesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listRolesResponse(struct soap *soap, const char *tag, int id, ns1__listRolesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listRolesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listRolesResponse ** SOAP_FMAC4 soap_in_PointerTons1__listRolesResponse(struct soap *soap, const char *tag, ns1__listRolesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listRolesResponse **)soap_malloc(soap, sizeof(ns1__listRolesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listRolesResponse *)soap_instantiate_ns1__listRolesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listRolesResponse ** p = (ns1__listRolesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listRolesResponse, sizeof(ns1__listRolesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listRolesResponse(struct soap *soap, ns1__listRolesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listRolesResponse);
	if (soap_out_PointerTons1__listRolesResponse(soap, tag?tag:"ns1:listRolesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listRolesResponse ** SOAP_FMAC4 soap_get_PointerTons1__listRolesResponse(struct soap *soap, ns1__listRolesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listRolesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listRoles(struct soap *soap, ns1__listRoles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listRoles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listRoles(struct soap *soap, const char *tag, int id, ns1__listRoles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listRoles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listRoles ** SOAP_FMAC4 soap_in_PointerTons1__listRoles(struct soap *soap, const char *tag, ns1__listRoles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listRoles **)soap_malloc(soap, sizeof(ns1__listRoles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listRoles *)soap_instantiate_ns1__listRoles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listRoles ** p = (ns1__listRoles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listRoles, sizeof(ns1__listRoles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listRoles(struct soap *soap, ns1__listRoles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listRoles);
	if (soap_out_PointerTons1__listRoles(soap, tag?tag:"ns1:listRoles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listRoles ** SOAP_FMAC4 soap_get_PointerTons1__listRoles(struct soap *soap, ns1__listRoles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listRoles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listInstrumentsResponse(struct soap *soap, ns1__listInstrumentsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listInstrumentsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listInstrumentsResponse(struct soap *soap, const char *tag, int id, ns1__listInstrumentsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listInstrumentsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listInstrumentsResponse ** SOAP_FMAC4 soap_in_PointerTons1__listInstrumentsResponse(struct soap *soap, const char *tag, ns1__listInstrumentsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listInstrumentsResponse **)soap_malloc(soap, sizeof(ns1__listInstrumentsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listInstrumentsResponse *)soap_instantiate_ns1__listInstrumentsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listInstrumentsResponse ** p = (ns1__listInstrumentsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInstrumentsResponse, sizeof(ns1__listInstrumentsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listInstrumentsResponse(struct soap *soap, ns1__listInstrumentsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listInstrumentsResponse);
	if (soap_out_PointerTons1__listInstrumentsResponse(soap, tag?tag:"ns1:listInstrumentsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listInstrumentsResponse ** SOAP_FMAC4 soap_get_PointerTons1__listInstrumentsResponse(struct soap *soap, ns1__listInstrumentsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listInstrumentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listInstruments(struct soap *soap, ns1__listInstruments *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listInstruments))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listInstruments(struct soap *soap, const char *tag, int id, ns1__listInstruments *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listInstruments);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listInstruments ** SOAP_FMAC4 soap_in_PointerTons1__listInstruments(struct soap *soap, const char *tag, ns1__listInstruments **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listInstruments **)soap_malloc(soap, sizeof(ns1__listInstruments *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listInstruments *)soap_instantiate_ns1__listInstruments(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listInstruments ** p = (ns1__listInstruments **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInstruments, sizeof(ns1__listInstruments), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listInstruments(struct soap *soap, ns1__listInstruments *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listInstruments);
	if (soap_out_PointerTons1__listInstruments(soap, tag?tag:"ns1:listInstruments", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listInstruments ** SOAP_FMAC4 soap_get_PointerTons1__listInstruments(struct soap *soap, ns1__listInstruments **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listInstruments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserSurnamePaginationResponse(struct soap *soap, ns1__searchByUserSurnamePaginationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserSurnamePaginationResponse(struct soap *soap, const char *tag, int id, ns1__searchByUserSurnamePaginationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserSurnamePaginationResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserSurnamePaginationResponse(struct soap *soap, const char *tag, ns1__searchByUserSurnamePaginationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserSurnamePaginationResponse **)soap_malloc(soap, sizeof(ns1__searchByUserSurnamePaginationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserSurnamePaginationResponse *)soap_instantiate_ns1__searchByUserSurnamePaginationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserSurnamePaginationResponse ** p = (ns1__searchByUserSurnamePaginationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse, sizeof(ns1__searchByUserSurnamePaginationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserSurnamePaginationResponse(struct soap *soap, ns1__searchByUserSurnamePaginationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserSurnamePaginationResponse);
	if (soap_out_PointerTons1__searchByUserSurnamePaginationResponse(soap, tag?tag:"ns1:searchByUserSurnamePaginationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserSurnamePaginationResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserSurnamePaginationResponse(struct soap *soap, ns1__searchByUserSurnamePaginationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserSurnamePaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserSurnamePagination(struct soap *soap, ns1__searchByUserSurnamePagination *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserSurnamePagination))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserSurnamePagination(struct soap *soap, const char *tag, int id, ns1__searchByUserSurnamePagination *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserSurnamePagination);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserSurnamePagination ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserSurnamePagination(struct soap *soap, const char *tag, ns1__searchByUserSurnamePagination **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserSurnamePagination **)soap_malloc(soap, sizeof(ns1__searchByUserSurnamePagination *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserSurnamePagination *)soap_instantiate_ns1__searchByUserSurnamePagination(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserSurnamePagination ** p = (ns1__searchByUserSurnamePagination **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurnamePagination, sizeof(ns1__searchByUserSurnamePagination), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserSurnamePagination(struct soap *soap, ns1__searchByUserSurnamePagination *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserSurnamePagination);
	if (soap_out_PointerTons1__searchByUserSurnamePagination(soap, tag?tag:"ns1:searchByUserSurnamePagination", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserSurnamePagination ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserSurnamePagination(struct soap *soap, ns1__searchByUserSurnamePagination **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserSurnamePagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserSurnameResponse(struct soap *soap, ns1__searchByUserSurnameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserSurnameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserSurnameResponse(struct soap *soap, const char *tag, int id, ns1__searchByUserSurnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserSurnameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserSurnameResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserSurnameResponse(struct soap *soap, const char *tag, ns1__searchByUserSurnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserSurnameResponse **)soap_malloc(soap, sizeof(ns1__searchByUserSurnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserSurnameResponse *)soap_instantiate_ns1__searchByUserSurnameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserSurnameResponse ** p = (ns1__searchByUserSurnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurnameResponse, sizeof(ns1__searchByUserSurnameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserSurnameResponse(struct soap *soap, ns1__searchByUserSurnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserSurnameResponse);
	if (soap_out_PointerTons1__searchByUserSurnameResponse(soap, tag?tag:"ns1:searchByUserSurnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserSurnameResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserSurnameResponse(struct soap *soap, ns1__searchByUserSurnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserSurnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserSurname(struct soap *soap, ns1__searchByUserSurname *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserSurname))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserSurname(struct soap *soap, const char *tag, int id, ns1__searchByUserSurname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserSurname);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserSurname ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserSurname(struct soap *soap, const char *tag, ns1__searchByUserSurname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserSurname **)soap_malloc(soap, sizeof(ns1__searchByUserSurname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserSurname *)soap_instantiate_ns1__searchByUserSurname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserSurname ** p = (ns1__searchByUserSurname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurname, sizeof(ns1__searchByUserSurname), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserSurname(struct soap *soap, ns1__searchByUserSurname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserSurname);
	if (soap_out_PointerTons1__searchByUserSurname(soap, tag?tag:"ns1:searchByUserSurname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserSurname ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserSurname(struct soap *soap, ns1__searchByUserSurname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserSurname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserIDPaginationResponse(struct soap *soap, ns1__searchByUserIDPaginationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserIDPaginationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserIDPaginationResponse(struct soap *soap, const char *tag, int id, ns1__searchByUserIDPaginationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserIDPaginationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserIDPaginationResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserIDPaginationResponse(struct soap *soap, const char *tag, ns1__searchByUserIDPaginationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserIDPaginationResponse **)soap_malloc(soap, sizeof(ns1__searchByUserIDPaginationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserIDPaginationResponse *)soap_instantiate_ns1__searchByUserIDPaginationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserIDPaginationResponse ** p = (ns1__searchByUserIDPaginationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserIDPaginationResponse, sizeof(ns1__searchByUserIDPaginationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserIDPaginationResponse(struct soap *soap, ns1__searchByUserIDPaginationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserIDPaginationResponse);
	if (soap_out_PointerTons1__searchByUserIDPaginationResponse(soap, tag?tag:"ns1:searchByUserIDPaginationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserIDPaginationResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserIDPaginationResponse(struct soap *soap, ns1__searchByUserIDPaginationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserIDPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserIDPagination(struct soap *soap, ns1__searchByUserIDPagination *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserIDPagination))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserIDPagination(struct soap *soap, const char *tag, int id, ns1__searchByUserIDPagination *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserIDPagination);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserIDPagination ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserIDPagination(struct soap *soap, const char *tag, ns1__searchByUserIDPagination **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserIDPagination **)soap_malloc(soap, sizeof(ns1__searchByUserIDPagination *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserIDPagination *)soap_instantiate_ns1__searchByUserIDPagination(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserIDPagination ** p = (ns1__searchByUserIDPagination **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserIDPagination, sizeof(ns1__searchByUserIDPagination), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserIDPagination(struct soap *soap, ns1__searchByUserIDPagination *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserIDPagination);
	if (soap_out_PointerTons1__searchByUserIDPagination(soap, tag?tag:"ns1:searchByUserIDPagination", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserIDPagination ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserIDPagination(struct soap *soap, ns1__searchByUserIDPagination **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserIDPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserIDResponse(struct soap *soap, ns1__searchByUserIDResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserIDResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserIDResponse(struct soap *soap, const char *tag, int id, ns1__searchByUserIDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserIDResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserIDResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserIDResponse(struct soap *soap, const char *tag, ns1__searchByUserIDResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserIDResponse **)soap_malloc(soap, sizeof(ns1__searchByUserIDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserIDResponse *)soap_instantiate_ns1__searchByUserIDResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserIDResponse ** p = (ns1__searchByUserIDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserIDResponse, sizeof(ns1__searchByUserIDResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserIDResponse(struct soap *soap, ns1__searchByUserIDResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserIDResponse);
	if (soap_out_PointerTons1__searchByUserIDResponse(soap, tag?tag:"ns1:searchByUserIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserIDResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserIDResponse(struct soap *soap, ns1__searchByUserIDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByUserID(struct soap *soap, ns1__searchByUserID *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByUserID))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByUserID(struct soap *soap, const char *tag, int id, ns1__searchByUserID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByUserID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByUserID ** SOAP_FMAC4 soap_in_PointerTons1__searchByUserID(struct soap *soap, const char *tag, ns1__searchByUserID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByUserID **)soap_malloc(soap, sizeof(ns1__searchByUserID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByUserID *)soap_instantiate_ns1__searchByUserID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByUserID ** p = (ns1__searchByUserID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserID, sizeof(ns1__searchByUserID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByUserID(struct soap *soap, ns1__searchByUserID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByUserID);
	if (soap_out_PointerTons1__searchByUserID(soap, tag?tag:"ns1:searchByUserID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByUserID ** SOAP_FMAC4 soap_get_PointerTons1__searchByUserID(struct soap *soap, ns1__searchByUserID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByUserID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, ns1__getMyInvestigationsIncludesPaginationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, const char *tag, int id, ns1__getMyInvestigationsIncludesPaginationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPaginationResponse ** SOAP_FMAC4 soap_in_PointerTons1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludesPaginationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyInvestigationsIncludesPaginationResponse **)soap_malloc(soap, sizeof(ns1__getMyInvestigationsIncludesPaginationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyInvestigationsIncludesPaginationResponse *)soap_instantiate_ns1__getMyInvestigationsIncludesPaginationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyInvestigationsIncludesPaginationResponse ** p = (ns1__getMyInvestigationsIncludesPaginationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse, sizeof(ns1__getMyInvestigationsIncludesPaginationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, ns1__getMyInvestigationsIncludesPaginationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPaginationResponse);
	if (soap_out_PointerTons1__getMyInvestigationsIncludesPaginationResponse(soap, tag?tag:"ns1:getMyInvestigationsIncludesPaginationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPaginationResponse ** SOAP_FMAC4 soap_get_PointerTons1__getMyInvestigationsIncludesPaginationResponse(struct soap *soap, ns1__getMyInvestigationsIncludesPaginationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyInvestigationsIncludesPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyInvestigationsIncludesPagination(struct soap *soap, ns1__getMyInvestigationsIncludesPagination *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyInvestigationsIncludesPagination(struct soap *soap, const char *tag, int id, ns1__getMyInvestigationsIncludesPagination *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPagination ** SOAP_FMAC4 soap_in_PointerTons1__getMyInvestigationsIncludesPagination(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludesPagination **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyInvestigationsIncludesPagination **)soap_malloc(soap, sizeof(ns1__getMyInvestigationsIncludesPagination *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyInvestigationsIncludesPagination *)soap_instantiate_ns1__getMyInvestigationsIncludesPagination(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyInvestigationsIncludesPagination ** p = (ns1__getMyInvestigationsIncludesPagination **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination, sizeof(ns1__getMyInvestigationsIncludesPagination), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyInvestigationsIncludesPagination(struct soap *soap, ns1__getMyInvestigationsIncludesPagination *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesPagination);
	if (soap_out_PointerTons1__getMyInvestigationsIncludesPagination(soap, tag?tag:"ns1:getMyInvestigationsIncludesPagination", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesPagination ** SOAP_FMAC4 soap_get_PointerTons1__getMyInvestigationsIncludesPagination(struct soap *soap, ns1__getMyInvestigationsIncludesPagination **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyInvestigationsIncludesPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyInvestigationsIncludesResponse(struct soap *soap, ns1__getMyInvestigationsIncludesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyInvestigationsIncludesResponse(struct soap *soap, const char *tag, int id, ns1__getMyInvestigationsIncludesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getMyInvestigationsIncludesResponse(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyInvestigationsIncludesResponse **)soap_malloc(soap, sizeof(ns1__getMyInvestigationsIncludesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyInvestigationsIncludesResponse *)soap_instantiate_ns1__getMyInvestigationsIncludesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyInvestigationsIncludesResponse ** p = (ns1__getMyInvestigationsIncludesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse, sizeof(ns1__getMyInvestigationsIncludesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyInvestigationsIncludesResponse(struct soap *soap, ns1__getMyInvestigationsIncludesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyInvestigationsIncludesResponse);
	if (soap_out_PointerTons1__getMyInvestigationsIncludesResponse(soap, tag?tag:"ns1:getMyInvestigationsIncludesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getMyInvestigationsIncludesResponse(struct soap *soap, ns1__getMyInvestigationsIncludesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyInvestigationsIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyInvestigationsIncludes(struct soap *soap, ns1__getMyInvestigationsIncludes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyInvestigationsIncludes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyInvestigationsIncludes(struct soap *soap, const char *tag, int id, ns1__getMyInvestigationsIncludes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyInvestigationsIncludes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludes ** SOAP_FMAC4 soap_in_PointerTons1__getMyInvestigationsIncludes(struct soap *soap, const char *tag, ns1__getMyInvestigationsIncludes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyInvestigationsIncludes **)soap_malloc(soap, sizeof(ns1__getMyInvestigationsIncludes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyInvestigationsIncludes *)soap_instantiate_ns1__getMyInvestigationsIncludes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyInvestigationsIncludes ** p = (ns1__getMyInvestigationsIncludes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludes, sizeof(ns1__getMyInvestigationsIncludes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyInvestigationsIncludes(struct soap *soap, ns1__getMyInvestigationsIncludes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyInvestigationsIncludes);
	if (soap_out_PointerTons1__getMyInvestigationsIncludes(soap, tag?tag:"ns1:getMyInvestigationsIncludes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyInvestigationsIncludes ** SOAP_FMAC4 soap_get_PointerTons1__getMyInvestigationsIncludes(struct soap *soap, ns1__getMyInvestigationsIncludes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyInvestigationsIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyInvestigationsResponse(struct soap *soap, ns1__getMyInvestigationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyInvestigationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyInvestigationsResponse(struct soap *soap, const char *tag, int id, ns1__getMyInvestigationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyInvestigationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyInvestigationsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getMyInvestigationsResponse(struct soap *soap, const char *tag, ns1__getMyInvestigationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyInvestigationsResponse **)soap_malloc(soap, sizeof(ns1__getMyInvestigationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyInvestigationsResponse *)soap_instantiate_ns1__getMyInvestigationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyInvestigationsResponse ** p = (ns1__getMyInvestigationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsResponse, sizeof(ns1__getMyInvestigationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyInvestigationsResponse(struct soap *soap, ns1__getMyInvestigationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyInvestigationsResponse);
	if (soap_out_PointerTons1__getMyInvestigationsResponse(soap, tag?tag:"ns1:getMyInvestigationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyInvestigationsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getMyInvestigationsResponse(struct soap *soap, ns1__getMyInvestigationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyInvestigationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyInvestigations(struct soap *soap, ns1__getMyInvestigations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyInvestigations))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyInvestigations(struct soap *soap, const char *tag, int id, ns1__getMyInvestigations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyInvestigations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyInvestigations ** SOAP_FMAC4 soap_in_PointerTons1__getMyInvestigations(struct soap *soap, const char *tag, ns1__getMyInvestigations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyInvestigations **)soap_malloc(soap, sizeof(ns1__getMyInvestigations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyInvestigations *)soap_instantiate_ns1__getMyInvestigations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyInvestigations ** p = (ns1__getMyInvestigations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigations, sizeof(ns1__getMyInvestigations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyInvestigations(struct soap *soap, ns1__getMyInvestigations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyInvestigations);
	if (soap_out_PointerTons1__getMyInvestigations(soap, tag?tag:"ns1:getMyInvestigations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyInvestigations ** SOAP_FMAC4 soap_get_PointerTons1__getMyInvestigations(struct soap *soap, ns1__getMyInvestigations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyInvestigations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByKeywordsAllResponse(struct soap *soap, ns1__searchByKeywordsAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByKeywordsAllResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByKeywordsAllResponse(struct soap *soap, const char *tag, int id, ns1__searchByKeywordsAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByKeywordsAllResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByKeywordsAllResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByKeywordsAllResponse(struct soap *soap, const char *tag, ns1__searchByKeywordsAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByKeywordsAllResponse **)soap_malloc(soap, sizeof(ns1__searchByKeywordsAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByKeywordsAllResponse *)soap_instantiate_ns1__searchByKeywordsAllResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByKeywordsAllResponse ** p = (ns1__searchByKeywordsAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywordsAllResponse, sizeof(ns1__searchByKeywordsAllResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByKeywordsAllResponse(struct soap *soap, ns1__searchByKeywordsAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByKeywordsAllResponse);
	if (soap_out_PointerTons1__searchByKeywordsAllResponse(soap, tag?tag:"ns1:searchByKeywordsAllResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByKeywordsAllResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByKeywordsAllResponse(struct soap *soap, ns1__searchByKeywordsAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByKeywordsAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByKeywordsAll(struct soap *soap, ns1__searchByKeywordsAll *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByKeywordsAll))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByKeywordsAll(struct soap *soap, const char *tag, int id, ns1__searchByKeywordsAll *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByKeywordsAll);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByKeywordsAll ** SOAP_FMAC4 soap_in_PointerTons1__searchByKeywordsAll(struct soap *soap, const char *tag, ns1__searchByKeywordsAll **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByKeywordsAll **)soap_malloc(soap, sizeof(ns1__searchByKeywordsAll *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByKeywordsAll *)soap_instantiate_ns1__searchByKeywordsAll(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByKeywordsAll ** p = (ns1__searchByKeywordsAll **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywordsAll, sizeof(ns1__searchByKeywordsAll), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByKeywordsAll(struct soap *soap, ns1__searchByKeywordsAll *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByKeywordsAll);
	if (soap_out_PointerTons1__searchByKeywordsAll(soap, tag?tag:"ns1:searchByKeywordsAll", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByKeywordsAll ** SOAP_FMAC4 soap_get_PointerTons1__searchByKeywordsAll(struct soap *soap, ns1__searchByKeywordsAll **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByKeywordsAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByKeywordsResponse(struct soap *soap, ns1__searchByKeywordsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByKeywordsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByKeywordsResponse(struct soap *soap, const char *tag, int id, ns1__searchByKeywordsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByKeywordsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByKeywordsResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByKeywordsResponse(struct soap *soap, const char *tag, ns1__searchByKeywordsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByKeywordsResponse **)soap_malloc(soap, sizeof(ns1__searchByKeywordsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByKeywordsResponse *)soap_instantiate_ns1__searchByKeywordsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByKeywordsResponse ** p = (ns1__searchByKeywordsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywordsResponse, sizeof(ns1__searchByKeywordsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByKeywordsResponse(struct soap *soap, ns1__searchByKeywordsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByKeywordsResponse);
	if (soap_out_PointerTons1__searchByKeywordsResponse(soap, tag?tag:"ns1:searchByKeywordsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByKeywordsResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByKeywordsResponse(struct soap *soap, ns1__searchByKeywordsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByKeywordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByKeywords(struct soap *soap, ns1__searchByKeywords *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByKeywords))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByKeywords(struct soap *soap, const char *tag, int id, ns1__searchByKeywords *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByKeywords);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByKeywords ** SOAP_FMAC4 soap_in_PointerTons1__searchByKeywords(struct soap *soap, const char *tag, ns1__searchByKeywords **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByKeywords **)soap_malloc(soap, sizeof(ns1__searchByKeywords *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByKeywords *)soap_instantiate_ns1__searchByKeywords(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByKeywords ** p = (ns1__searchByKeywords **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywords, sizeof(ns1__searchByKeywords), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByKeywords(struct soap *soap, ns1__searchByKeywords *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByKeywords);
	if (soap_out_PointerTons1__searchByKeywords(soap, tag?tag:"ns1:searchByKeywords", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByKeywords ** SOAP_FMAC4 soap_get_PointerTons1__searchByKeywords(struct soap *soap, ns1__searchByKeywords **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByKeywords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByAdvancedPaginationResponse(struct soap *soap, ns1__searchByAdvancedPaginationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByAdvancedPaginationResponse(struct soap *soap, const char *tag, int id, ns1__searchByAdvancedPaginationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByAdvancedPaginationResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByAdvancedPaginationResponse(struct soap *soap, const char *tag, ns1__searchByAdvancedPaginationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByAdvancedPaginationResponse **)soap_malloc(soap, sizeof(ns1__searchByAdvancedPaginationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByAdvancedPaginationResponse *)soap_instantiate_ns1__searchByAdvancedPaginationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByAdvancedPaginationResponse ** p = (ns1__searchByAdvancedPaginationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse, sizeof(ns1__searchByAdvancedPaginationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByAdvancedPaginationResponse(struct soap *soap, ns1__searchByAdvancedPaginationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByAdvancedPaginationResponse);
	if (soap_out_PointerTons1__searchByAdvancedPaginationResponse(soap, tag?tag:"ns1:searchByAdvancedPaginationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByAdvancedPaginationResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByAdvancedPaginationResponse(struct soap *soap, ns1__searchByAdvancedPaginationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByAdvancedPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByAdvancedPagination(struct soap *soap, ns1__searchByAdvancedPagination *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByAdvancedPagination))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByAdvancedPagination(struct soap *soap, const char *tag, int id, ns1__searchByAdvancedPagination *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByAdvancedPagination);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByAdvancedPagination ** SOAP_FMAC4 soap_in_PointerTons1__searchByAdvancedPagination(struct soap *soap, const char *tag, ns1__searchByAdvancedPagination **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByAdvancedPagination **)soap_malloc(soap, sizeof(ns1__searchByAdvancedPagination *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByAdvancedPagination *)soap_instantiate_ns1__searchByAdvancedPagination(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByAdvancedPagination ** p = (ns1__searchByAdvancedPagination **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvancedPagination, sizeof(ns1__searchByAdvancedPagination), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByAdvancedPagination(struct soap *soap, ns1__searchByAdvancedPagination *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByAdvancedPagination);
	if (soap_out_PointerTons1__searchByAdvancedPagination(soap, tag?tag:"ns1:searchByAdvancedPagination", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByAdvancedPagination ** SOAP_FMAC4 soap_get_PointerTons1__searchByAdvancedPagination(struct soap *soap, ns1__searchByAdvancedPagination **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByAdvancedPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByAdvancedResponse(struct soap *soap, ns1__searchByAdvancedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByAdvancedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByAdvancedResponse(struct soap *soap, const char *tag, int id, ns1__searchByAdvancedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByAdvancedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByAdvancedResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByAdvancedResponse(struct soap *soap, const char *tag, ns1__searchByAdvancedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByAdvancedResponse **)soap_malloc(soap, sizeof(ns1__searchByAdvancedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByAdvancedResponse *)soap_instantiate_ns1__searchByAdvancedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByAdvancedResponse ** p = (ns1__searchByAdvancedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvancedResponse, sizeof(ns1__searchByAdvancedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByAdvancedResponse(struct soap *soap, ns1__searchByAdvancedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByAdvancedResponse);
	if (soap_out_PointerTons1__searchByAdvancedResponse(soap, tag?tag:"ns1:searchByAdvancedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByAdvancedResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByAdvancedResponse(struct soap *soap, ns1__searchByAdvancedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByAdvancedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByAdvanced(struct soap *soap, ns1__searchByAdvanced *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByAdvanced))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByAdvanced(struct soap *soap, const char *tag, int id, ns1__searchByAdvanced *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByAdvanced);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByAdvanced ** SOAP_FMAC4 soap_in_PointerTons1__searchByAdvanced(struct soap *soap, const char *tag, ns1__searchByAdvanced **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByAdvanced **)soap_malloc(soap, sizeof(ns1__searchByAdvanced *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByAdvanced *)soap_instantiate_ns1__searchByAdvanced(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByAdvanced ** p = (ns1__searchByAdvanced **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvanced, sizeof(ns1__searchByAdvanced), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByAdvanced(struct soap *soap, ns1__searchByAdvanced *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByAdvanced);
	if (soap_out_PointerTons1__searchByAdvanced(soap, tag?tag:"ns1:searchByAdvanced", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByAdvanced ** SOAP_FMAC4 soap_get_PointerTons1__searchByAdvanced(struct soap *soap, ns1__searchByAdvanced **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByAdvanced(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setDataSetSampleResponse(struct soap *soap, ns1__setDataSetSampleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setDataSetSampleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setDataSetSampleResponse(struct soap *soap, const char *tag, int id, ns1__setDataSetSampleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setDataSetSampleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setDataSetSampleResponse ** SOAP_FMAC4 soap_in_PointerTons1__setDataSetSampleResponse(struct soap *soap, const char *tag, ns1__setDataSetSampleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setDataSetSampleResponse **)soap_malloc(soap, sizeof(ns1__setDataSetSampleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setDataSetSampleResponse *)soap_instantiate_ns1__setDataSetSampleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setDataSetSampleResponse ** p = (ns1__setDataSetSampleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setDataSetSampleResponse, sizeof(ns1__setDataSetSampleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setDataSetSampleResponse(struct soap *soap, ns1__setDataSetSampleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setDataSetSampleResponse);
	if (soap_out_PointerTons1__setDataSetSampleResponse(soap, tag?tag:"ns1:setDataSetSampleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__setDataSetSampleResponse ** SOAP_FMAC4 soap_get_PointerTons1__setDataSetSampleResponse(struct soap *soap, ns1__setDataSetSampleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setDataSetSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setDataSetSample(struct soap *soap, ns1__setDataSetSample *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setDataSetSample))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setDataSetSample(struct soap *soap, const char *tag, int id, ns1__setDataSetSample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setDataSetSample);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setDataSetSample ** SOAP_FMAC4 soap_in_PointerTons1__setDataSetSample(struct soap *soap, const char *tag, ns1__setDataSetSample **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setDataSetSample **)soap_malloc(soap, sizeof(ns1__setDataSetSample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setDataSetSample *)soap_instantiate_ns1__setDataSetSample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setDataSetSample ** p = (ns1__setDataSetSample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setDataSetSample, sizeof(ns1__setDataSetSample), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setDataSetSample(struct soap *soap, ns1__setDataSetSample *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setDataSetSample);
	if (soap_out_PointerTons1__setDataSetSample(soap, tag?tag:"ns1:setDataSetSample", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__setDataSetSample ** SOAP_FMAC4 soap_get_PointerTons1__setDataSetSample(struct soap *soap, ns1__setDataSetSample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setDataSetSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataSetParameterResponse(struct soap *soap, ns1__deleteDataSetParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataSetParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataSetParameterResponse(struct soap *soap, const char *tag, int id, ns1__deleteDataSetParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataSetParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataSetParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataSetParameterResponse(struct soap *soap, const char *tag, ns1__deleteDataSetParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataSetParameterResponse **)soap_malloc(soap, sizeof(ns1__deleteDataSetParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataSetParameterResponse *)soap_instantiate_ns1__deleteDataSetParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataSetParameterResponse ** p = (ns1__deleteDataSetParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSetParameterResponse, sizeof(ns1__deleteDataSetParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataSetParameterResponse(struct soap *soap, ns1__deleteDataSetParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataSetParameterResponse);
	if (soap_out_PointerTons1__deleteDataSetParameterResponse(soap, tag?tag:"ns1:deleteDataSetParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataSetParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataSetParameterResponse(struct soap *soap, ns1__deleteDataSetParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataSetParameter(struct soap *soap, ns1__deleteDataSetParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataSetParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataSetParameter(struct soap *soap, const char *tag, int id, ns1__deleteDataSetParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataSetParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataSetParameter ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataSetParameter(struct soap *soap, const char *tag, ns1__deleteDataSetParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataSetParameter **)soap_malloc(soap, sizeof(ns1__deleteDataSetParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataSetParameter *)soap_instantiate_ns1__deleteDataSetParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataSetParameter ** p = (ns1__deleteDataSetParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSetParameter, sizeof(ns1__deleteDataSetParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataSetParameter(struct soap *soap, ns1__deleteDataSetParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataSetParameter);
	if (soap_out_PointerTons1__deleteDataSetParameter(soap, tag?tag:"ns1:deleteDataSetParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataSetParameter ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataSetParameter(struct soap *soap, ns1__deleteDataSetParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataSetParameterResponse(struct soap *soap, ns1__removeDataSetParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataSetParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataSetParameterResponse(struct soap *soap, const char *tag, int id, ns1__removeDataSetParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataSetParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataSetParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeDataSetParameterResponse(struct soap *soap, const char *tag, ns1__removeDataSetParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataSetParameterResponse **)soap_malloc(soap, sizeof(ns1__removeDataSetParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataSetParameterResponse *)soap_instantiate_ns1__removeDataSetParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataSetParameterResponse ** p = (ns1__removeDataSetParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSetParameterResponse, sizeof(ns1__removeDataSetParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataSetParameterResponse(struct soap *soap, ns1__removeDataSetParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataSetParameterResponse);
	if (soap_out_PointerTons1__removeDataSetParameterResponse(soap, tag?tag:"ns1:removeDataSetParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataSetParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeDataSetParameterResponse(struct soap *soap, ns1__removeDataSetParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataSetParameter(struct soap *soap, ns1__removeDataSetParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataSetParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataSetParameter(struct soap *soap, const char *tag, int id, ns1__removeDataSetParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataSetParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataSetParameter ** SOAP_FMAC4 soap_in_PointerTons1__removeDataSetParameter(struct soap *soap, const char *tag, ns1__removeDataSetParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataSetParameter **)soap_malloc(soap, sizeof(ns1__removeDataSetParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataSetParameter *)soap_instantiate_ns1__removeDataSetParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataSetParameter ** p = (ns1__removeDataSetParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSetParameter, sizeof(ns1__removeDataSetParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataSetParameter(struct soap *soap, ns1__removeDataSetParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataSetParameter);
	if (soap_out_PointerTons1__removeDataSetParameter(soap, tag?tag:"ns1:removeDataSetParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataSetParameter ** SOAP_FMAC4 soap_get_PointerTons1__removeDataSetParameter(struct soap *soap, ns1__removeDataSetParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataSetParameterResponse(struct soap *soap, ns1__modifyDataSetParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataSetParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataSetParameterResponse(struct soap *soap, const char *tag, int id, ns1__modifyDataSetParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataSetParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataSetParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataSetParameterResponse(struct soap *soap, const char *tag, ns1__modifyDataSetParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataSetParameterResponse **)soap_malloc(soap, sizeof(ns1__modifyDataSetParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataSetParameterResponse *)soap_instantiate_ns1__modifyDataSetParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataSetParameterResponse ** p = (ns1__modifyDataSetParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSetParameterResponse, sizeof(ns1__modifyDataSetParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataSetParameterResponse(struct soap *soap, ns1__modifyDataSetParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataSetParameterResponse);
	if (soap_out_PointerTons1__modifyDataSetParameterResponse(soap, tag?tag:"ns1:modifyDataSetParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataSetParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataSetParameterResponse(struct soap *soap, ns1__modifyDataSetParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataSetParameter(struct soap *soap, ns1__modifyDataSetParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataSetParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataSetParameter(struct soap *soap, const char *tag, int id, ns1__modifyDataSetParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataSetParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataSetParameter ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataSetParameter(struct soap *soap, const char *tag, ns1__modifyDataSetParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataSetParameter **)soap_malloc(soap, sizeof(ns1__modifyDataSetParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataSetParameter *)soap_instantiate_ns1__modifyDataSetParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataSetParameter ** p = (ns1__modifyDataSetParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSetParameter, sizeof(ns1__modifyDataSetParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataSetParameter(struct soap *soap, ns1__modifyDataSetParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataSetParameter);
	if (soap_out_PointerTons1__modifyDataSetParameter(soap, tag?tag:"ns1:modifyDataSetParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataSetParameter ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataSetParameter(struct soap *soap, ns1__modifyDataSetParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataSetParametersResponse(struct soap *soap, ns1__addDataSetParametersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataSetParametersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataSetParametersResponse(struct soap *soap, const char *tag, int id, ns1__addDataSetParametersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataSetParametersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataSetParametersResponse ** SOAP_FMAC4 soap_in_PointerTons1__addDataSetParametersResponse(struct soap *soap, const char *tag, ns1__addDataSetParametersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataSetParametersResponse **)soap_malloc(soap, sizeof(ns1__addDataSetParametersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataSetParametersResponse *)soap_instantiate_ns1__addDataSetParametersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataSetParametersResponse ** p = (ns1__addDataSetParametersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParametersResponse, sizeof(ns1__addDataSetParametersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataSetParametersResponse(struct soap *soap, ns1__addDataSetParametersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataSetParametersResponse);
	if (soap_out_PointerTons1__addDataSetParametersResponse(soap, tag?tag:"ns1:addDataSetParametersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataSetParametersResponse ** SOAP_FMAC4 soap_get_PointerTons1__addDataSetParametersResponse(struct soap *soap, ns1__addDataSetParametersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataSetParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataSetParameters(struct soap *soap, ns1__addDataSetParameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataSetParameters))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataSetParameters(struct soap *soap, const char *tag, int id, ns1__addDataSetParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataSetParameters);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataSetParameters ** SOAP_FMAC4 soap_in_PointerTons1__addDataSetParameters(struct soap *soap, const char *tag, ns1__addDataSetParameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataSetParameters **)soap_malloc(soap, sizeof(ns1__addDataSetParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataSetParameters *)soap_instantiate_ns1__addDataSetParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataSetParameters ** p = (ns1__addDataSetParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParameters, sizeof(ns1__addDataSetParameters), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataSetParameters(struct soap *soap, ns1__addDataSetParameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataSetParameters);
	if (soap_out_PointerTons1__addDataSetParameters(soap, tag?tag:"ns1:addDataSetParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataSetParameters ** SOAP_FMAC4 soap_get_PointerTons1__addDataSetParameters(struct soap *soap, ns1__addDataSetParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataSetParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataSetParameterResponse(struct soap *soap, ns1__addDataSetParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataSetParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataSetParameterResponse(struct soap *soap, const char *tag, int id, ns1__addDataSetParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataSetParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataSetParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__addDataSetParameterResponse(struct soap *soap, const char *tag, ns1__addDataSetParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataSetParameterResponse **)soap_malloc(soap, sizeof(ns1__addDataSetParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataSetParameterResponse *)soap_instantiate_ns1__addDataSetParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataSetParameterResponse ** p = (ns1__addDataSetParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParameterResponse, sizeof(ns1__addDataSetParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataSetParameterResponse(struct soap *soap, ns1__addDataSetParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataSetParameterResponse);
	if (soap_out_PointerTons1__addDataSetParameterResponse(soap, tag?tag:"ns1:addDataSetParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataSetParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__addDataSetParameterResponse(struct soap *soap, ns1__addDataSetParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataSetParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataSetParameter(struct soap *soap, ns1__addDataSetParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataSetParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataSetParameter(struct soap *soap, const char *tag, int id, ns1__addDataSetParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataSetParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataSetParameter ** SOAP_FMAC4 soap_in_PointerTons1__addDataSetParameter(struct soap *soap, const char *tag, ns1__addDataSetParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataSetParameter **)soap_malloc(soap, sizeof(ns1__addDataSetParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataSetParameter *)soap_instantiate_ns1__addDataSetParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataSetParameter ** p = (ns1__addDataSetParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParameter, sizeof(ns1__addDataSetParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataSetParameter(struct soap *soap, ns1__addDataSetParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataSetParameter);
	if (soap_out_PointerTons1__addDataSetParameter(soap, tag?tag:"ns1:addDataSetParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataSetParameter ** SOAP_FMAC4 soap_get_PointerTons1__addDataSetParameter(struct soap *soap, ns1__addDataSetParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataSetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataSetResponse(struct soap *soap, ns1__modifyDataSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataSetResponse(struct soap *soap, const char *tag, int id, ns1__modifyDataSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataSetResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataSetResponse(struct soap *soap, const char *tag, ns1__modifyDataSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataSetResponse **)soap_malloc(soap, sizeof(ns1__modifyDataSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataSetResponse *)soap_instantiate_ns1__modifyDataSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataSetResponse ** p = (ns1__modifyDataSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSetResponse, sizeof(ns1__modifyDataSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataSetResponse(struct soap *soap, ns1__modifyDataSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataSetResponse);
	if (soap_out_PointerTons1__modifyDataSetResponse(soap, tag?tag:"ns1:modifyDataSetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataSetResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataSetResponse(struct soap *soap, ns1__modifyDataSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataSet(struct soap *soap, ns1__modifyDataSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataSet(struct soap *soap, const char *tag, int id, ns1__modifyDataSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataSet ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataSet(struct soap *soap, const char *tag, ns1__modifyDataSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataSet **)soap_malloc(soap, sizeof(ns1__modifyDataSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataSet *)soap_instantiate_ns1__modifyDataSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataSet ** p = (ns1__modifyDataSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSet, sizeof(ns1__modifyDataSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataSet(struct soap *soap, ns1__modifyDataSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataSet);
	if (soap_out_PointerTons1__modifyDataSet(soap, tag?tag:"ns1:modifyDataSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataSet ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataSet(struct soap *soap, ns1__modifyDataSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataSetResponse(struct soap *soap, ns1__deleteDataSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataSetResponse(struct soap *soap, const char *tag, int id, ns1__deleteDataSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataSetResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataSetResponse(struct soap *soap, const char *tag, ns1__deleteDataSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataSetResponse **)soap_malloc(soap, sizeof(ns1__deleteDataSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataSetResponse *)soap_instantiate_ns1__deleteDataSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataSetResponse ** p = (ns1__deleteDataSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSetResponse, sizeof(ns1__deleteDataSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataSetResponse(struct soap *soap, ns1__deleteDataSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataSetResponse);
	if (soap_out_PointerTons1__deleteDataSetResponse(soap, tag?tag:"ns1:deleteDataSetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataSetResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataSetResponse(struct soap *soap, ns1__deleteDataSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataSet(struct soap *soap, ns1__deleteDataSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataSet(struct soap *soap, const char *tag, int id, ns1__deleteDataSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataSet ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataSet(struct soap *soap, const char *tag, ns1__deleteDataSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataSet **)soap_malloc(soap, sizeof(ns1__deleteDataSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataSet *)soap_instantiate_ns1__deleteDataSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataSet ** p = (ns1__deleteDataSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSet, sizeof(ns1__deleteDataSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataSet(struct soap *soap, ns1__deleteDataSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataSet);
	if (soap_out_PointerTons1__deleteDataSet(soap, tag?tag:"ns1:deleteDataSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataSet ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataSet(struct soap *soap, ns1__deleteDataSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataSetResponse(struct soap *soap, ns1__removeDataSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataSetResponse(struct soap *soap, const char *tag, int id, ns1__removeDataSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataSetResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeDataSetResponse(struct soap *soap, const char *tag, ns1__removeDataSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataSetResponse **)soap_malloc(soap, sizeof(ns1__removeDataSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataSetResponse *)soap_instantiate_ns1__removeDataSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataSetResponse ** p = (ns1__removeDataSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSetResponse, sizeof(ns1__removeDataSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataSetResponse(struct soap *soap, ns1__removeDataSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataSetResponse);
	if (soap_out_PointerTons1__removeDataSetResponse(soap, tag?tag:"ns1:removeDataSetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataSetResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeDataSetResponse(struct soap *soap, ns1__removeDataSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataSet(struct soap *soap, ns1__removeDataSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataSet(struct soap *soap, const char *tag, int id, ns1__removeDataSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataSet ** SOAP_FMAC4 soap_in_PointerTons1__removeDataSet(struct soap *soap, const char *tag, ns1__removeDataSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataSet **)soap_malloc(soap, sizeof(ns1__removeDataSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataSet *)soap_instantiate_ns1__removeDataSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataSet ** p = (ns1__removeDataSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSet, sizeof(ns1__removeDataSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataSet(struct soap *soap, ns1__removeDataSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataSet);
	if (soap_out_PointerTons1__removeDataSet(soap, tag?tag:"ns1:removeDataSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataSet ** SOAP_FMAC4 soap_get_PointerTons1__removeDataSet(struct soap *soap, ns1__removeDataSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataSetsResponse(struct soap *soap, ns1__createDataSetsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataSetsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataSetsResponse(struct soap *soap, const char *tag, int id, ns1__createDataSetsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataSetsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataSetsResponse ** SOAP_FMAC4 soap_in_PointerTons1__createDataSetsResponse(struct soap *soap, const char *tag, ns1__createDataSetsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataSetsResponse **)soap_malloc(soap, sizeof(ns1__createDataSetsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataSetsResponse *)soap_instantiate_ns1__createDataSetsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataSetsResponse ** p = (ns1__createDataSetsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSetsResponse, sizeof(ns1__createDataSetsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataSetsResponse(struct soap *soap, ns1__createDataSetsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataSetsResponse);
	if (soap_out_PointerTons1__createDataSetsResponse(soap, tag?tag:"ns1:createDataSetsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataSetsResponse ** SOAP_FMAC4 soap_get_PointerTons1__createDataSetsResponse(struct soap *soap, ns1__createDataSetsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataSetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataSets(struct soap *soap, ns1__createDataSets *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataSets))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataSets(struct soap *soap, const char *tag, int id, ns1__createDataSets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataSets);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataSets ** SOAP_FMAC4 soap_in_PointerTons1__createDataSets(struct soap *soap, const char *tag, ns1__createDataSets **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataSets **)soap_malloc(soap, sizeof(ns1__createDataSets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataSets *)soap_instantiate_ns1__createDataSets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataSets ** p = (ns1__createDataSets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSets, sizeof(ns1__createDataSets), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataSets(struct soap *soap, ns1__createDataSets *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataSets);
	if (soap_out_PointerTons1__createDataSets(soap, tag?tag:"ns1:createDataSets", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataSets ** SOAP_FMAC4 soap_get_PointerTons1__createDataSets(struct soap *soap, ns1__createDataSets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataSets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataSetResponse(struct soap *soap, ns1__createDataSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataSetResponse(struct soap *soap, const char *tag, int id, ns1__createDataSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataSetResponse ** SOAP_FMAC4 soap_in_PointerTons1__createDataSetResponse(struct soap *soap, const char *tag, ns1__createDataSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataSetResponse **)soap_malloc(soap, sizeof(ns1__createDataSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataSetResponse *)soap_instantiate_ns1__createDataSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataSetResponse ** p = (ns1__createDataSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSetResponse, sizeof(ns1__createDataSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataSetResponse(struct soap *soap, ns1__createDataSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataSetResponse);
	if (soap_out_PointerTons1__createDataSetResponse(soap, tag?tag:"ns1:createDataSetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataSetResponse ** SOAP_FMAC4 soap_get_PointerTons1__createDataSetResponse(struct soap *soap, ns1__createDataSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataSet(struct soap *soap, ns1__createDataSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataSet(struct soap *soap, const char *tag, int id, ns1__createDataSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataSet ** SOAP_FMAC4 soap_in_PointerTons1__createDataSet(struct soap *soap, const char *tag, ns1__createDataSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataSet **)soap_malloc(soap, sizeof(ns1__createDataSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataSet *)soap_instantiate_ns1__createDataSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataSet ** p = (ns1__createDataSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSet, sizeof(ns1__createDataSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataSet(struct soap *soap, ns1__createDataSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataSet);
	if (soap_out_PointerTons1__createDataSet(soap, tag?tag:"ns1:createDataSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataSet ** SOAP_FMAC4 soap_get_PointerTons1__createDataSet(struct soap *soap, ns1__createDataSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatasetsResponse(struct soap *soap, ns1__getDatasetsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatasetsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatasetsResponse(struct soap *soap, const char *tag, int id, ns1__getDatasetsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatasetsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatasetsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDatasetsResponse(struct soap *soap, const char *tag, ns1__getDatasetsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatasetsResponse **)soap_malloc(soap, sizeof(ns1__getDatasetsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatasetsResponse *)soap_instantiate_ns1__getDatasetsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatasetsResponse ** p = (ns1__getDatasetsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetsResponse, sizeof(ns1__getDatasetsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatasetsResponse(struct soap *soap, ns1__getDatasetsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatasetsResponse);
	if (soap_out_PointerTons1__getDatasetsResponse(soap, tag?tag:"ns1:getDatasetsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatasetsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDatasetsResponse(struct soap *soap, ns1__getDatasetsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatasetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatasets(struct soap *soap, ns1__getDatasets *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatasets))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatasets(struct soap *soap, const char *tag, int id, ns1__getDatasets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatasets);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatasets ** SOAP_FMAC4 soap_in_PointerTons1__getDatasets(struct soap *soap, const char *tag, ns1__getDatasets **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatasets **)soap_malloc(soap, sizeof(ns1__getDatasets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatasets *)soap_instantiate_ns1__getDatasets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatasets ** p = (ns1__getDatasets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasets, sizeof(ns1__getDatasets), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatasets(struct soap *soap, ns1__getDatasets *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatasets);
	if (soap_out_PointerTons1__getDatasets(soap, tag?tag:"ns1:getDatasets", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatasets ** SOAP_FMAC4 soap_get_PointerTons1__getDatasets(struct soap *soap, ns1__getDatasets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatasets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listDatasetStatusResponse(struct soap *soap, ns1__listDatasetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listDatasetStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listDatasetStatusResponse(struct soap *soap, const char *tag, int id, ns1__listDatasetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listDatasetStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listDatasetStatusResponse ** SOAP_FMAC4 soap_in_PointerTons1__listDatasetStatusResponse(struct soap *soap, const char *tag, ns1__listDatasetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listDatasetStatusResponse **)soap_malloc(soap, sizeof(ns1__listDatasetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listDatasetStatusResponse *)soap_instantiate_ns1__listDatasetStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listDatasetStatusResponse ** p = (ns1__listDatasetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetStatusResponse, sizeof(ns1__listDatasetStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listDatasetStatusResponse(struct soap *soap, ns1__listDatasetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listDatasetStatusResponse);
	if (soap_out_PointerTons1__listDatasetStatusResponse(soap, tag?tag:"ns1:listDatasetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listDatasetStatusResponse ** SOAP_FMAC4 soap_get_PointerTons1__listDatasetStatusResponse(struct soap *soap, ns1__listDatasetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listDatasetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listDatasetStatus(struct soap *soap, ns1__listDatasetStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listDatasetStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listDatasetStatus(struct soap *soap, const char *tag, int id, ns1__listDatasetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listDatasetStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listDatasetStatus ** SOAP_FMAC4 soap_in_PointerTons1__listDatasetStatus(struct soap *soap, const char *tag, ns1__listDatasetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listDatasetStatus **)soap_malloc(soap, sizeof(ns1__listDatasetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listDatasetStatus *)soap_instantiate_ns1__listDatasetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listDatasetStatus ** p = (ns1__listDatasetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetStatus, sizeof(ns1__listDatasetStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listDatasetStatus(struct soap *soap, ns1__listDatasetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listDatasetStatus);
	if (soap_out_PointerTons1__listDatasetStatus(soap, tag?tag:"ns1:listDatasetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listDatasetStatus ** SOAP_FMAC4 soap_get_PointerTons1__listDatasetStatus(struct soap *soap, ns1__listDatasetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listDatasetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listDatasetTypesResponse(struct soap *soap, ns1__listDatasetTypesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listDatasetTypesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listDatasetTypesResponse(struct soap *soap, const char *tag, int id, ns1__listDatasetTypesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listDatasetTypesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listDatasetTypesResponse ** SOAP_FMAC4 soap_in_PointerTons1__listDatasetTypesResponse(struct soap *soap, const char *tag, ns1__listDatasetTypesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listDatasetTypesResponse **)soap_malloc(soap, sizeof(ns1__listDatasetTypesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listDatasetTypesResponse *)soap_instantiate_ns1__listDatasetTypesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listDatasetTypesResponse ** p = (ns1__listDatasetTypesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetTypesResponse, sizeof(ns1__listDatasetTypesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listDatasetTypesResponse(struct soap *soap, ns1__listDatasetTypesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listDatasetTypesResponse);
	if (soap_out_PointerTons1__listDatasetTypesResponse(soap, tag?tag:"ns1:listDatasetTypesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listDatasetTypesResponse ** SOAP_FMAC4 soap_get_PointerTons1__listDatasetTypesResponse(struct soap *soap, ns1__listDatasetTypesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listDatasetTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listDatasetTypes(struct soap *soap, ns1__listDatasetTypes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listDatasetTypes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listDatasetTypes(struct soap *soap, const char *tag, int id, ns1__listDatasetTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listDatasetTypes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listDatasetTypes ** SOAP_FMAC4 soap_in_PointerTons1__listDatasetTypes(struct soap *soap, const char *tag, ns1__listDatasetTypes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listDatasetTypes **)soap_malloc(soap, sizeof(ns1__listDatasetTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listDatasetTypes *)soap_instantiate_ns1__listDatasetTypes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listDatasetTypes ** p = (ns1__listDatasetTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetTypes, sizeof(ns1__listDatasetTypes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listDatasetTypes(struct soap *soap, ns1__listDatasetTypes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listDatasetTypes);
	if (soap_out_PointerTons1__listDatasetTypes(soap, tag?tag:"ns1:listDatasetTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listDatasetTypes ** SOAP_FMAC4 soap_get_PointerTons1__listDatasetTypes(struct soap *soap, ns1__listDatasetTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listDatasetTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchSamplesBySampleNameResponse(struct soap *soap, ns1__searchSamplesBySampleNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchSamplesBySampleNameResponse(struct soap *soap, const char *tag, int id, ns1__searchSamplesBySampleNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchSamplesBySampleNameResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchSamplesBySampleNameResponse(struct soap *soap, const char *tag, ns1__searchSamplesBySampleNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchSamplesBySampleNameResponse **)soap_malloc(soap, sizeof(ns1__searchSamplesBySampleNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchSamplesBySampleNameResponse *)soap_instantiate_ns1__searchSamplesBySampleNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchSamplesBySampleNameResponse ** p = (ns1__searchSamplesBySampleNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse, sizeof(ns1__searchSamplesBySampleNameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchSamplesBySampleNameResponse(struct soap *soap, ns1__searchSamplesBySampleNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchSamplesBySampleNameResponse);
	if (soap_out_PointerTons1__searchSamplesBySampleNameResponse(soap, tag?tag:"ns1:searchSamplesBySampleNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchSamplesBySampleNameResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchSamplesBySampleNameResponse(struct soap *soap, ns1__searchSamplesBySampleNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchSamplesBySampleNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchSamplesBySampleName(struct soap *soap, ns1__searchSamplesBySampleName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchSamplesBySampleName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchSamplesBySampleName(struct soap *soap, const char *tag, int id, ns1__searchSamplesBySampleName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchSamplesBySampleName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchSamplesBySampleName ** SOAP_FMAC4 soap_in_PointerTons1__searchSamplesBySampleName(struct soap *soap, const char *tag, ns1__searchSamplesBySampleName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchSamplesBySampleName **)soap_malloc(soap, sizeof(ns1__searchSamplesBySampleName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchSamplesBySampleName *)soap_instantiate_ns1__searchSamplesBySampleName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchSamplesBySampleName ** p = (ns1__searchSamplesBySampleName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchSamplesBySampleName, sizeof(ns1__searchSamplesBySampleName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchSamplesBySampleName(struct soap *soap, ns1__searchSamplesBySampleName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchSamplesBySampleName);
	if (soap_out_PointerTons1__searchSamplesBySampleName(soap, tag?tag:"ns1:searchSamplesBySampleName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchSamplesBySampleName ** SOAP_FMAC4 soap_get_PointerTons1__searchSamplesBySampleName(struct soap *soap, ns1__searchSamplesBySampleName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchSamplesBySampleName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listDatafileFormatsResponse(struct soap *soap, ns1__listDatafileFormatsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listDatafileFormatsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listDatafileFormatsResponse(struct soap *soap, const char *tag, int id, ns1__listDatafileFormatsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listDatafileFormatsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listDatafileFormatsResponse ** SOAP_FMAC4 soap_in_PointerTons1__listDatafileFormatsResponse(struct soap *soap, const char *tag, ns1__listDatafileFormatsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listDatafileFormatsResponse **)soap_malloc(soap, sizeof(ns1__listDatafileFormatsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listDatafileFormatsResponse *)soap_instantiate_ns1__listDatafileFormatsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listDatafileFormatsResponse ** p = (ns1__listDatafileFormatsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatafileFormatsResponse, sizeof(ns1__listDatafileFormatsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listDatafileFormatsResponse(struct soap *soap, ns1__listDatafileFormatsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listDatafileFormatsResponse);
	if (soap_out_PointerTons1__listDatafileFormatsResponse(soap, tag?tag:"ns1:listDatafileFormatsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listDatafileFormatsResponse ** SOAP_FMAC4 soap_get_PointerTons1__listDatafileFormatsResponse(struct soap *soap, ns1__listDatafileFormatsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listDatafileFormatsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listDatafileFormats(struct soap *soap, ns1__listDatafileFormats *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listDatafileFormats))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listDatafileFormats(struct soap *soap, const char *tag, int id, ns1__listDatafileFormats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listDatafileFormats);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listDatafileFormats ** SOAP_FMAC4 soap_in_PointerTons1__listDatafileFormats(struct soap *soap, const char *tag, ns1__listDatafileFormats **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listDatafileFormats **)soap_malloc(soap, sizeof(ns1__listDatafileFormats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listDatafileFormats *)soap_instantiate_ns1__listDatafileFormats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listDatafileFormats ** p = (ns1__listDatafileFormats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatafileFormats, sizeof(ns1__listDatafileFormats), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listDatafileFormats(struct soap *soap, ns1__listDatafileFormats *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listDatafileFormats);
	if (soap_out_PointerTons1__listDatafileFormats(soap, tag?tag:"ns1:listDatafileFormats", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listDatafileFormats ** SOAP_FMAC4 soap_get_PointerTons1__listDatafileFormats(struct soap *soap, ns1__listDatafileFormats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listDatafileFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByRunNumberPaginationResponse(struct soap *soap, ns1__searchByRunNumberPaginationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByRunNumberPaginationResponse(struct soap *soap, const char *tag, int id, ns1__searchByRunNumberPaginationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByRunNumberPaginationResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByRunNumberPaginationResponse(struct soap *soap, const char *tag, ns1__searchByRunNumberPaginationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByRunNumberPaginationResponse **)soap_malloc(soap, sizeof(ns1__searchByRunNumberPaginationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByRunNumberPaginationResponse *)soap_instantiate_ns1__searchByRunNumberPaginationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByRunNumberPaginationResponse ** p = (ns1__searchByRunNumberPaginationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse, sizeof(ns1__searchByRunNumberPaginationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByRunNumberPaginationResponse(struct soap *soap, ns1__searchByRunNumberPaginationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByRunNumberPaginationResponse);
	if (soap_out_PointerTons1__searchByRunNumberPaginationResponse(soap, tag?tag:"ns1:searchByRunNumberPaginationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByRunNumberPaginationResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByRunNumberPaginationResponse(struct soap *soap, ns1__searchByRunNumberPaginationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByRunNumberPaginationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByRunNumberPagination(struct soap *soap, ns1__searchByRunNumberPagination *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByRunNumberPagination))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByRunNumberPagination(struct soap *soap, const char *tag, int id, ns1__searchByRunNumberPagination *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByRunNumberPagination);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByRunNumberPagination ** SOAP_FMAC4 soap_in_PointerTons1__searchByRunNumberPagination(struct soap *soap, const char *tag, ns1__searchByRunNumberPagination **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByRunNumberPagination **)soap_malloc(soap, sizeof(ns1__searchByRunNumberPagination *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByRunNumberPagination *)soap_instantiate_ns1__searchByRunNumberPagination(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByRunNumberPagination ** p = (ns1__searchByRunNumberPagination **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumberPagination, sizeof(ns1__searchByRunNumberPagination), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByRunNumberPagination(struct soap *soap, ns1__searchByRunNumberPagination *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByRunNumberPagination);
	if (soap_out_PointerTons1__searchByRunNumberPagination(soap, tag?tag:"ns1:searchByRunNumberPagination", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByRunNumberPagination ** SOAP_FMAC4 soap_get_PointerTons1__searchByRunNumberPagination(struct soap *soap, ns1__searchByRunNumberPagination **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByRunNumberPagination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByRunNumberResponse(struct soap *soap, ns1__searchByRunNumberResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByRunNumberResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByRunNumberResponse(struct soap *soap, const char *tag, int id, ns1__searchByRunNumberResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByRunNumberResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByRunNumberResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchByRunNumberResponse(struct soap *soap, const char *tag, ns1__searchByRunNumberResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByRunNumberResponse **)soap_malloc(soap, sizeof(ns1__searchByRunNumberResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByRunNumberResponse *)soap_instantiate_ns1__searchByRunNumberResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByRunNumberResponse ** p = (ns1__searchByRunNumberResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumberResponse, sizeof(ns1__searchByRunNumberResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByRunNumberResponse(struct soap *soap, ns1__searchByRunNumberResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByRunNumberResponse);
	if (soap_out_PointerTons1__searchByRunNumberResponse(soap, tag?tag:"ns1:searchByRunNumberResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByRunNumberResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchByRunNumberResponse(struct soap *soap, ns1__searchByRunNumberResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByRunNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchByRunNumber(struct soap *soap, ns1__searchByRunNumber *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchByRunNumber))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchByRunNumber(struct soap *soap, const char *tag, int id, ns1__searchByRunNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchByRunNumber);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchByRunNumber ** SOAP_FMAC4 soap_in_PointerTons1__searchByRunNumber(struct soap *soap, const char *tag, ns1__searchByRunNumber **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchByRunNumber **)soap_malloc(soap, sizeof(ns1__searchByRunNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchByRunNumber *)soap_instantiate_ns1__searchByRunNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchByRunNumber ** p = (ns1__searchByRunNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumber, sizeof(ns1__searchByRunNumber), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchByRunNumber(struct soap *soap, ns1__searchByRunNumber *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchByRunNumber);
	if (soap_out_PointerTons1__searchByRunNumber(soap, tag?tag:"ns1:searchByRunNumber", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchByRunNumber ** SOAP_FMAC4 soap_get_PointerTons1__searchByRunNumber(struct soap *soap, ns1__searchByRunNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchByRunNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAllKeywordsResponse(struct soap *soap, ns1__getAllKeywordsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAllKeywordsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAllKeywordsResponse(struct soap *soap, const char *tag, int id, ns1__getAllKeywordsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAllKeywordsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAllKeywordsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getAllKeywordsResponse(struct soap *soap, const char *tag, ns1__getAllKeywordsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAllKeywordsResponse **)soap_malloc(soap, sizeof(ns1__getAllKeywordsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAllKeywordsResponse *)soap_instantiate_ns1__getAllKeywordsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAllKeywordsResponse ** p = (ns1__getAllKeywordsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAllKeywordsResponse, sizeof(ns1__getAllKeywordsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAllKeywordsResponse(struct soap *soap, ns1__getAllKeywordsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAllKeywordsResponse);
	if (soap_out_PointerTons1__getAllKeywordsResponse(soap, tag?tag:"ns1:getAllKeywordsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAllKeywordsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getAllKeywordsResponse(struct soap *soap, ns1__getAllKeywordsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAllKeywordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAllKeywords(struct soap *soap, ns1__getAllKeywords *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAllKeywords))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAllKeywords(struct soap *soap, const char *tag, int id, ns1__getAllKeywords *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAllKeywords);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAllKeywords ** SOAP_FMAC4 soap_in_PointerTons1__getAllKeywords(struct soap *soap, const char *tag, ns1__getAllKeywords **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAllKeywords **)soap_malloc(soap, sizeof(ns1__getAllKeywords *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAllKeywords *)soap_instantiate_ns1__getAllKeywords(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAllKeywords ** p = (ns1__getAllKeywords **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAllKeywords, sizeof(ns1__getAllKeywords), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAllKeywords(struct soap *soap, ns1__getAllKeywords *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAllKeywords);
	if (soap_out_PointerTons1__getAllKeywords(soap, tag?tag:"ns1:getAllKeywords", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAllKeywords ** SOAP_FMAC4 soap_get_PointerTons1__getAllKeywords(struct soap *soap, ns1__getAllKeywords **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAllKeywords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUserTypeResponse(struct soap *soap, ns1__getKeywordsForUserTypeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUserTypeResponse(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUserTypeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserTypeResponse ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUserTypeResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserTypeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUserTypeResponse **)soap_malloc(soap, sizeof(ns1__getKeywordsForUserTypeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUserTypeResponse *)soap_instantiate_ns1__getKeywordsForUserTypeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUserTypeResponse ** p = (ns1__getKeywordsForUserTypeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse, sizeof(ns1__getKeywordsForUserTypeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUserTypeResponse(struct soap *soap, ns1__getKeywordsForUserTypeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUserTypeResponse);
	if (soap_out_PointerTons1__getKeywordsForUserTypeResponse(soap, tag?tag:"ns1:getKeywordsForUserTypeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUserTypeResponse ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUserTypeResponse(struct soap *soap, ns1__getKeywordsForUserTypeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUserTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUserType(struct soap *soap, ns1__getKeywordsForUserType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUserType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUserType(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUserType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUserType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserType ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUserType(struct soap *soap, const char *tag, ns1__getKeywordsForUserType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUserType **)soap_malloc(soap, sizeof(ns1__getKeywordsForUserType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUserType *)soap_instantiate_ns1__getKeywordsForUserType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUserType ** p = (ns1__getKeywordsForUserType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserType, sizeof(ns1__getKeywordsForUserType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUserType(struct soap *soap, ns1__getKeywordsForUserType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUserType);
	if (soap_out_PointerTons1__getKeywordsForUserType(soap, tag?tag:"ns1:getKeywordsForUserType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUserType ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUserType(struct soap *soap, ns1__getKeywordsForUserType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUserMaxResponse(struct soap *soap, ns1__getKeywordsForUserMaxResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUserMaxResponse(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUserMaxResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserMaxResponse ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUserMaxResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserMaxResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUserMaxResponse **)soap_malloc(soap, sizeof(ns1__getKeywordsForUserMaxResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUserMaxResponse *)soap_instantiate_ns1__getKeywordsForUserMaxResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUserMaxResponse ** p = (ns1__getKeywordsForUserMaxResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse, sizeof(ns1__getKeywordsForUserMaxResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUserMaxResponse(struct soap *soap, ns1__getKeywordsForUserMaxResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUserMaxResponse);
	if (soap_out_PointerTons1__getKeywordsForUserMaxResponse(soap, tag?tag:"ns1:getKeywordsForUserMaxResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUserMaxResponse ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUserMaxResponse(struct soap *soap, ns1__getKeywordsForUserMaxResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUserMaxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUserMax(struct soap *soap, ns1__getKeywordsForUserMax *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUserMax))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUserMax(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUserMax *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUserMax);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserMax ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUserMax(struct soap *soap, const char *tag, ns1__getKeywordsForUserMax **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUserMax **)soap_malloc(soap, sizeof(ns1__getKeywordsForUserMax *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUserMax *)soap_instantiate_ns1__getKeywordsForUserMax(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUserMax ** p = (ns1__getKeywordsForUserMax **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserMax, sizeof(ns1__getKeywordsForUserMax), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUserMax(struct soap *soap, ns1__getKeywordsForUserMax *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUserMax);
	if (soap_out_PointerTons1__getKeywordsForUserMax(soap, tag?tag:"ns1:getKeywordsForUserMax", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUserMax ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUserMax(struct soap *soap, ns1__getKeywordsForUserMax **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUserMax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, ns1__getKeywordsForUserStartWithMaxResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUserStartWithMaxResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMaxResponse ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserStartWithMaxResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUserStartWithMaxResponse **)soap_malloc(soap, sizeof(ns1__getKeywordsForUserStartWithMaxResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUserStartWithMaxResponse *)soap_instantiate_ns1__getKeywordsForUserStartWithMaxResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUserStartWithMaxResponse ** p = (ns1__getKeywordsForUserStartWithMaxResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse, sizeof(ns1__getKeywordsForUserStartWithMaxResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, ns1__getKeywordsForUserStartWithMaxResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMaxResponse);
	if (soap_out_PointerTons1__getKeywordsForUserStartWithMaxResponse(soap, tag?tag:"ns1:getKeywordsForUserStartWithMaxResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMaxResponse ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUserStartWithMaxResponse(struct soap *soap, ns1__getKeywordsForUserStartWithMaxResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUserStartWithMaxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUserStartWithMax(struct soap *soap, ns1__getKeywordsForUserStartWithMax *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUserStartWithMax(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUserStartWithMax *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMax ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUserStartWithMax(struct soap *soap, const char *tag, ns1__getKeywordsForUserStartWithMax **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUserStartWithMax **)soap_malloc(soap, sizeof(ns1__getKeywordsForUserStartWithMax *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUserStartWithMax *)soap_instantiate_ns1__getKeywordsForUserStartWithMax(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUserStartWithMax ** p = (ns1__getKeywordsForUserStartWithMax **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax, sizeof(ns1__getKeywordsForUserStartWithMax), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUserStartWithMax(struct soap *soap, ns1__getKeywordsForUserStartWithMax *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUserStartWithMax);
	if (soap_out_PointerTons1__getKeywordsForUserStartWithMax(soap, tag?tag:"ns1:getKeywordsForUserStartWithMax", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUserStartWithMax ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUserStartWithMax(struct soap *soap, ns1__getKeywordsForUserStartWithMax **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUserStartWithMax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUserResponse(struct soap *soap, ns1__getKeywordsForUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUserResponse(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUserResponse ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUserResponse(struct soap *soap, const char *tag, ns1__getKeywordsForUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUserResponse **)soap_malloc(soap, sizeof(ns1__getKeywordsForUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUserResponse *)soap_instantiate_ns1__getKeywordsForUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUserResponse ** p = (ns1__getKeywordsForUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserResponse, sizeof(ns1__getKeywordsForUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUserResponse(struct soap *soap, ns1__getKeywordsForUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUserResponse);
	if (soap_out_PointerTons1__getKeywordsForUserResponse(soap, tag?tag:"ns1:getKeywordsForUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUserResponse ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUserResponse(struct soap *soap, ns1__getKeywordsForUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getKeywordsForUser(struct soap *soap, ns1__getKeywordsForUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getKeywordsForUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getKeywordsForUser(struct soap *soap, const char *tag, int id, ns1__getKeywordsForUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getKeywordsForUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getKeywordsForUser ** SOAP_FMAC4 soap_in_PointerTons1__getKeywordsForUser(struct soap *soap, const char *tag, ns1__getKeywordsForUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getKeywordsForUser **)soap_malloc(soap, sizeof(ns1__getKeywordsForUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getKeywordsForUser *)soap_instantiate_ns1__getKeywordsForUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getKeywordsForUser ** p = (ns1__getKeywordsForUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUser, sizeof(ns1__getKeywordsForUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getKeywordsForUser(struct soap *soap, ns1__getKeywordsForUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getKeywordsForUser);
	if (soap_out_PointerTons1__getKeywordsForUser(soap, tag?tag:"ns1:getKeywordsForUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getKeywordsForUser ** SOAP_FMAC4 soap_get_PointerTons1__getKeywordsForUser(struct soap *soap, ns1__getKeywordsForUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getKeywordsForUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifySampleParameterResponse(struct soap *soap, ns1__modifySampleParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifySampleParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifySampleParameterResponse(struct soap *soap, const char *tag, int id, ns1__modifySampleParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifySampleParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifySampleParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifySampleParameterResponse(struct soap *soap, const char *tag, ns1__modifySampleParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifySampleParameterResponse **)soap_malloc(soap, sizeof(ns1__modifySampleParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifySampleParameterResponse *)soap_instantiate_ns1__modifySampleParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifySampleParameterResponse ** p = (ns1__modifySampleParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySampleParameterResponse, sizeof(ns1__modifySampleParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifySampleParameterResponse(struct soap *soap, ns1__modifySampleParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifySampleParameterResponse);
	if (soap_out_PointerTons1__modifySampleParameterResponse(soap, tag?tag:"ns1:modifySampleParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifySampleParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifySampleParameterResponse(struct soap *soap, ns1__modifySampleParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifySampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifySampleParameter(struct soap *soap, ns1__modifySampleParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifySampleParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifySampleParameter(struct soap *soap, const char *tag, int id, ns1__modifySampleParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifySampleParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifySampleParameter ** SOAP_FMAC4 soap_in_PointerTons1__modifySampleParameter(struct soap *soap, const char *tag, ns1__modifySampleParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifySampleParameter **)soap_malloc(soap, sizeof(ns1__modifySampleParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifySampleParameter *)soap_instantiate_ns1__modifySampleParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifySampleParameter ** p = (ns1__modifySampleParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySampleParameter, sizeof(ns1__modifySampleParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifySampleParameter(struct soap *soap, ns1__modifySampleParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifySampleParameter);
	if (soap_out_PointerTons1__modifySampleParameter(soap, tag?tag:"ns1:modifySampleParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifySampleParameter ** SOAP_FMAC4 soap_get_PointerTons1__modifySampleParameter(struct soap *soap, ns1__modifySampleParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifySampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteSampleParameterResponse(struct soap *soap, ns1__deleteSampleParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteSampleParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteSampleParameterResponse(struct soap *soap, const char *tag, int id, ns1__deleteSampleParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteSampleParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteSampleParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteSampleParameterResponse(struct soap *soap, const char *tag, ns1__deleteSampleParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteSampleParameterResponse **)soap_malloc(soap, sizeof(ns1__deleteSampleParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteSampleParameterResponse *)soap_instantiate_ns1__deleteSampleParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteSampleParameterResponse ** p = (ns1__deleteSampleParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSampleParameterResponse, sizeof(ns1__deleteSampleParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteSampleParameterResponse(struct soap *soap, ns1__deleteSampleParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteSampleParameterResponse);
	if (soap_out_PointerTons1__deleteSampleParameterResponse(soap, tag?tag:"ns1:deleteSampleParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteSampleParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteSampleParameterResponse(struct soap *soap, ns1__deleteSampleParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteSampleParameter(struct soap *soap, ns1__deleteSampleParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteSampleParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteSampleParameter(struct soap *soap, const char *tag, int id, ns1__deleteSampleParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteSampleParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteSampleParameter ** SOAP_FMAC4 soap_in_PointerTons1__deleteSampleParameter(struct soap *soap, const char *tag, ns1__deleteSampleParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteSampleParameter **)soap_malloc(soap, sizeof(ns1__deleteSampleParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteSampleParameter *)soap_instantiate_ns1__deleteSampleParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteSampleParameter ** p = (ns1__deleteSampleParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSampleParameter, sizeof(ns1__deleteSampleParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteSampleParameter(struct soap *soap, ns1__deleteSampleParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteSampleParameter);
	if (soap_out_PointerTons1__deleteSampleParameter(soap, tag?tag:"ns1:deleteSampleParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteSampleParameter ** SOAP_FMAC4 soap_get_PointerTons1__deleteSampleParameter(struct soap *soap, ns1__deleteSampleParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeSampleParameterResponse(struct soap *soap, ns1__removeSampleParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeSampleParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeSampleParameterResponse(struct soap *soap, const char *tag, int id, ns1__removeSampleParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeSampleParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeSampleParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeSampleParameterResponse(struct soap *soap, const char *tag, ns1__removeSampleParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeSampleParameterResponse **)soap_malloc(soap, sizeof(ns1__removeSampleParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeSampleParameterResponse *)soap_instantiate_ns1__removeSampleParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeSampleParameterResponse ** p = (ns1__removeSampleParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSampleParameterResponse, sizeof(ns1__removeSampleParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeSampleParameterResponse(struct soap *soap, ns1__removeSampleParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeSampleParameterResponse);
	if (soap_out_PointerTons1__removeSampleParameterResponse(soap, tag?tag:"ns1:removeSampleParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeSampleParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeSampleParameterResponse(struct soap *soap, ns1__removeSampleParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeSampleParameter(struct soap *soap, ns1__removeSampleParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeSampleParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeSampleParameter(struct soap *soap, const char *tag, int id, ns1__removeSampleParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeSampleParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeSampleParameter ** SOAP_FMAC4 soap_in_PointerTons1__removeSampleParameter(struct soap *soap, const char *tag, ns1__removeSampleParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeSampleParameter **)soap_malloc(soap, sizeof(ns1__removeSampleParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeSampleParameter *)soap_instantiate_ns1__removeSampleParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeSampleParameter ** p = (ns1__removeSampleParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSampleParameter, sizeof(ns1__removeSampleParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeSampleParameter(struct soap *soap, ns1__removeSampleParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeSampleParameter);
	if (soap_out_PointerTons1__removeSampleParameter(soap, tag?tag:"ns1:removeSampleParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeSampleParameter ** SOAP_FMAC4 soap_get_PointerTons1__removeSampleParameter(struct soap *soap, ns1__removeSampleParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifySampleResponse(struct soap *soap, ns1__modifySampleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifySampleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifySampleResponse(struct soap *soap, const char *tag, int id, ns1__modifySampleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifySampleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifySampleResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifySampleResponse(struct soap *soap, const char *tag, ns1__modifySampleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifySampleResponse **)soap_malloc(soap, sizeof(ns1__modifySampleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifySampleResponse *)soap_instantiate_ns1__modifySampleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifySampleResponse ** p = (ns1__modifySampleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySampleResponse, sizeof(ns1__modifySampleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifySampleResponse(struct soap *soap, ns1__modifySampleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifySampleResponse);
	if (soap_out_PointerTons1__modifySampleResponse(soap, tag?tag:"ns1:modifySampleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifySampleResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifySampleResponse(struct soap *soap, ns1__modifySampleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifySampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifySample(struct soap *soap, ns1__modifySample *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifySample))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifySample(struct soap *soap, const char *tag, int id, ns1__modifySample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifySample);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifySample ** SOAP_FMAC4 soap_in_PointerTons1__modifySample(struct soap *soap, const char *tag, ns1__modifySample **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifySample **)soap_malloc(soap, sizeof(ns1__modifySample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifySample *)soap_instantiate_ns1__modifySample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifySample ** p = (ns1__modifySample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySample, sizeof(ns1__modifySample), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifySample(struct soap *soap, ns1__modifySample *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifySample);
	if (soap_out_PointerTons1__modifySample(soap, tag?tag:"ns1:modifySample", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifySample ** SOAP_FMAC4 soap_get_PointerTons1__modifySample(struct soap *soap, ns1__modifySample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifySample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteSampleResponse(struct soap *soap, ns1__deleteSampleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteSampleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteSampleResponse(struct soap *soap, const char *tag, int id, ns1__deleteSampleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteSampleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteSampleResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteSampleResponse(struct soap *soap, const char *tag, ns1__deleteSampleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteSampleResponse **)soap_malloc(soap, sizeof(ns1__deleteSampleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteSampleResponse *)soap_instantiate_ns1__deleteSampleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteSampleResponse ** p = (ns1__deleteSampleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSampleResponse, sizeof(ns1__deleteSampleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteSampleResponse(struct soap *soap, ns1__deleteSampleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteSampleResponse);
	if (soap_out_PointerTons1__deleteSampleResponse(soap, tag?tag:"ns1:deleteSampleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteSampleResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteSampleResponse(struct soap *soap, ns1__deleteSampleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteSample(struct soap *soap, ns1__deleteSample *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteSample))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteSample(struct soap *soap, const char *tag, int id, ns1__deleteSample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteSample);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteSample ** SOAP_FMAC4 soap_in_PointerTons1__deleteSample(struct soap *soap, const char *tag, ns1__deleteSample **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteSample **)soap_malloc(soap, sizeof(ns1__deleteSample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteSample *)soap_instantiate_ns1__deleteSample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteSample ** p = (ns1__deleteSample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSample, sizeof(ns1__deleteSample), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteSample(struct soap *soap, ns1__deleteSample *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteSample);
	if (soap_out_PointerTons1__deleteSample(soap, tag?tag:"ns1:deleteSample", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteSample ** SOAP_FMAC4 soap_get_PointerTons1__deleteSample(struct soap *soap, ns1__deleteSample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeSampleResponse(struct soap *soap, ns1__removeSampleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeSampleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeSampleResponse(struct soap *soap, const char *tag, int id, ns1__removeSampleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeSampleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeSampleResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeSampleResponse(struct soap *soap, const char *tag, ns1__removeSampleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeSampleResponse **)soap_malloc(soap, sizeof(ns1__removeSampleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeSampleResponse *)soap_instantiate_ns1__removeSampleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeSampleResponse ** p = (ns1__removeSampleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSampleResponse, sizeof(ns1__removeSampleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeSampleResponse(struct soap *soap, ns1__removeSampleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeSampleResponse);
	if (soap_out_PointerTons1__removeSampleResponse(soap, tag?tag:"ns1:removeSampleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeSampleResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeSampleResponse(struct soap *soap, ns1__removeSampleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeSample(struct soap *soap, ns1__removeSample *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeSample))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeSample(struct soap *soap, const char *tag, int id, ns1__removeSample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeSample);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeSample ** SOAP_FMAC4 soap_in_PointerTons1__removeSample(struct soap *soap, const char *tag, ns1__removeSample **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeSample **)soap_malloc(soap, sizeof(ns1__removeSample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeSample *)soap_instantiate_ns1__removeSample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeSample ** p = (ns1__removeSample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSample, sizeof(ns1__removeSample), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeSample(struct soap *soap, ns1__removeSample *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeSample);
	if (soap_out_PointerTons1__removeSample(soap, tag?tag:"ns1:removeSample", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeSample ** SOAP_FMAC4 soap_get_PointerTons1__removeSample(struct soap *soap, ns1__removeSample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteInvestigatorResponse(struct soap *soap, ns1__deleteInvestigatorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteInvestigatorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteInvestigatorResponse(struct soap *soap, const char *tag, int id, ns1__deleteInvestigatorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteInvestigatorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteInvestigatorResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteInvestigatorResponse(struct soap *soap, const char *tag, ns1__deleteInvestigatorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteInvestigatorResponse **)soap_malloc(soap, sizeof(ns1__deleteInvestigatorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteInvestigatorResponse *)soap_instantiate_ns1__deleteInvestigatorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteInvestigatorResponse ** p = (ns1__deleteInvestigatorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigatorResponse, sizeof(ns1__deleteInvestigatorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteInvestigatorResponse(struct soap *soap, ns1__deleteInvestigatorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteInvestigatorResponse);
	if (soap_out_PointerTons1__deleteInvestigatorResponse(soap, tag?tag:"ns1:deleteInvestigatorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteInvestigatorResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteInvestigatorResponse(struct soap *soap, ns1__deleteInvestigatorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteInvestigator(struct soap *soap, ns1__deleteInvestigator *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteInvestigator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteInvestigator(struct soap *soap, const char *tag, int id, ns1__deleteInvestigator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteInvestigator);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteInvestigator ** SOAP_FMAC4 soap_in_PointerTons1__deleteInvestigator(struct soap *soap, const char *tag, ns1__deleteInvestigator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteInvestigator **)soap_malloc(soap, sizeof(ns1__deleteInvestigator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteInvestigator *)soap_instantiate_ns1__deleteInvestigator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteInvestigator ** p = (ns1__deleteInvestigator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigator, sizeof(ns1__deleteInvestigator), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteInvestigator(struct soap *soap, ns1__deleteInvestigator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteInvestigator);
	if (soap_out_PointerTons1__deleteInvestigator(soap, tag?tag:"ns1:deleteInvestigator", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteInvestigator ** SOAP_FMAC4 soap_get_PointerTons1__deleteInvestigator(struct soap *soap, ns1__deleteInvestigator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyInvestigatorResponse(struct soap *soap, ns1__modifyInvestigatorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyInvestigatorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyInvestigatorResponse(struct soap *soap, const char *tag, int id, ns1__modifyInvestigatorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyInvestigatorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyInvestigatorResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifyInvestigatorResponse(struct soap *soap, const char *tag, ns1__modifyInvestigatorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyInvestigatorResponse **)soap_malloc(soap, sizeof(ns1__modifyInvestigatorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyInvestigatorResponse *)soap_instantiate_ns1__modifyInvestigatorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyInvestigatorResponse ** p = (ns1__modifyInvestigatorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigatorResponse, sizeof(ns1__modifyInvestigatorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyInvestigatorResponse(struct soap *soap, ns1__modifyInvestigatorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyInvestigatorResponse);
	if (soap_out_PointerTons1__modifyInvestigatorResponse(soap, tag?tag:"ns1:modifyInvestigatorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyInvestigatorResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifyInvestigatorResponse(struct soap *soap, ns1__modifyInvestigatorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyInvestigator(struct soap *soap, ns1__modifyInvestigator *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyInvestigator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyInvestigator(struct soap *soap, const char *tag, int id, ns1__modifyInvestigator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyInvestigator);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyInvestigator ** SOAP_FMAC4 soap_in_PointerTons1__modifyInvestigator(struct soap *soap, const char *tag, ns1__modifyInvestigator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyInvestigator **)soap_malloc(soap, sizeof(ns1__modifyInvestigator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyInvestigator *)soap_instantiate_ns1__modifyInvestigator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyInvestigator ** p = (ns1__modifyInvestigator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigator, sizeof(ns1__modifyInvestigator), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyInvestigator(struct soap *soap, ns1__modifyInvestigator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyInvestigator);
	if (soap_out_PointerTons1__modifyInvestigator(soap, tag?tag:"ns1:modifyInvestigator", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyInvestigator ** SOAP_FMAC4 soap_get_PointerTons1__modifyInvestigator(struct soap *soap, ns1__modifyInvestigator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeInvestigatorResponse(struct soap *soap, ns1__removeInvestigatorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeInvestigatorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeInvestigatorResponse(struct soap *soap, const char *tag, int id, ns1__removeInvestigatorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeInvestigatorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeInvestigatorResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeInvestigatorResponse(struct soap *soap, const char *tag, ns1__removeInvestigatorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeInvestigatorResponse **)soap_malloc(soap, sizeof(ns1__removeInvestigatorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeInvestigatorResponse *)soap_instantiate_ns1__removeInvestigatorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeInvestigatorResponse ** p = (ns1__removeInvestigatorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigatorResponse, sizeof(ns1__removeInvestigatorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeInvestigatorResponse(struct soap *soap, ns1__removeInvestigatorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeInvestigatorResponse);
	if (soap_out_PointerTons1__removeInvestigatorResponse(soap, tag?tag:"ns1:removeInvestigatorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeInvestigatorResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeInvestigatorResponse(struct soap *soap, ns1__removeInvestigatorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeInvestigator(struct soap *soap, ns1__removeInvestigator *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeInvestigator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeInvestigator(struct soap *soap, const char *tag, int id, ns1__removeInvestigator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeInvestigator);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeInvestigator ** SOAP_FMAC4 soap_in_PointerTons1__removeInvestigator(struct soap *soap, const char *tag, ns1__removeInvestigator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeInvestigator **)soap_malloc(soap, sizeof(ns1__removeInvestigator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeInvestigator *)soap_instantiate_ns1__removeInvestigator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeInvestigator ** p = (ns1__removeInvestigator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigator, sizeof(ns1__removeInvestigator), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeInvestigator(struct soap *soap, ns1__removeInvestigator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeInvestigator);
	if (soap_out_PointerTons1__removeInvestigator(soap, tag?tag:"ns1:removeInvestigator", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeInvestigator ** SOAP_FMAC4 soap_get_PointerTons1__removeInvestigator(struct soap *soap, ns1__removeInvestigator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyPublicationResponse(struct soap *soap, ns1__modifyPublicationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyPublicationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyPublicationResponse(struct soap *soap, const char *tag, int id, ns1__modifyPublicationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyPublicationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyPublicationResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifyPublicationResponse(struct soap *soap, const char *tag, ns1__modifyPublicationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyPublicationResponse **)soap_malloc(soap, sizeof(ns1__modifyPublicationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyPublicationResponse *)soap_instantiate_ns1__modifyPublicationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyPublicationResponse ** p = (ns1__modifyPublicationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyPublicationResponse, sizeof(ns1__modifyPublicationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyPublicationResponse(struct soap *soap, ns1__modifyPublicationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyPublicationResponse);
	if (soap_out_PointerTons1__modifyPublicationResponse(soap, tag?tag:"ns1:modifyPublicationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyPublicationResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifyPublicationResponse(struct soap *soap, ns1__modifyPublicationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyPublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyPublication(struct soap *soap, ns1__modifyPublication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyPublication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyPublication(struct soap *soap, const char *tag, int id, ns1__modifyPublication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyPublication);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyPublication ** SOAP_FMAC4 soap_in_PointerTons1__modifyPublication(struct soap *soap, const char *tag, ns1__modifyPublication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyPublication **)soap_malloc(soap, sizeof(ns1__modifyPublication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyPublication *)soap_instantiate_ns1__modifyPublication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyPublication ** p = (ns1__modifyPublication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyPublication, sizeof(ns1__modifyPublication), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyPublication(struct soap *soap, ns1__modifyPublication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyPublication);
	if (soap_out_PointerTons1__modifyPublication(soap, tag?tag:"ns1:modifyPublication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyPublication ** SOAP_FMAC4 soap_get_PointerTons1__modifyPublication(struct soap *soap, ns1__modifyPublication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyPublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deletePublicationResponse(struct soap *soap, ns1__deletePublicationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deletePublicationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deletePublicationResponse(struct soap *soap, const char *tag, int id, ns1__deletePublicationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deletePublicationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deletePublicationResponse ** SOAP_FMAC4 soap_in_PointerTons1__deletePublicationResponse(struct soap *soap, const char *tag, ns1__deletePublicationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deletePublicationResponse **)soap_malloc(soap, sizeof(ns1__deletePublicationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deletePublicationResponse *)soap_instantiate_ns1__deletePublicationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deletePublicationResponse ** p = (ns1__deletePublicationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deletePublicationResponse, sizeof(ns1__deletePublicationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deletePublicationResponse(struct soap *soap, ns1__deletePublicationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deletePublicationResponse);
	if (soap_out_PointerTons1__deletePublicationResponse(soap, tag?tag:"ns1:deletePublicationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deletePublicationResponse ** SOAP_FMAC4 soap_get_PointerTons1__deletePublicationResponse(struct soap *soap, ns1__deletePublicationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deletePublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deletePublication(struct soap *soap, ns1__deletePublication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deletePublication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deletePublication(struct soap *soap, const char *tag, int id, ns1__deletePublication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deletePublication);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deletePublication ** SOAP_FMAC4 soap_in_PointerTons1__deletePublication(struct soap *soap, const char *tag, ns1__deletePublication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deletePublication **)soap_malloc(soap, sizeof(ns1__deletePublication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deletePublication *)soap_instantiate_ns1__deletePublication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deletePublication ** p = (ns1__deletePublication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deletePublication, sizeof(ns1__deletePublication), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deletePublication(struct soap *soap, ns1__deletePublication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deletePublication);
	if (soap_out_PointerTons1__deletePublication(soap, tag?tag:"ns1:deletePublication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deletePublication ** SOAP_FMAC4 soap_get_PointerTons1__deletePublication(struct soap *soap, ns1__deletePublication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deletePublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removePublicationResponse(struct soap *soap, ns1__removePublicationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removePublicationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removePublicationResponse(struct soap *soap, const char *tag, int id, ns1__removePublicationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removePublicationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removePublicationResponse ** SOAP_FMAC4 soap_in_PointerTons1__removePublicationResponse(struct soap *soap, const char *tag, ns1__removePublicationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removePublicationResponse **)soap_malloc(soap, sizeof(ns1__removePublicationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removePublicationResponse *)soap_instantiate_ns1__removePublicationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removePublicationResponse ** p = (ns1__removePublicationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removePublicationResponse, sizeof(ns1__removePublicationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removePublicationResponse(struct soap *soap, ns1__removePublicationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removePublicationResponse);
	if (soap_out_PointerTons1__removePublicationResponse(soap, tag?tag:"ns1:removePublicationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removePublicationResponse ** SOAP_FMAC4 soap_get_PointerTons1__removePublicationResponse(struct soap *soap, ns1__removePublicationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removePublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removePublication(struct soap *soap, ns1__removePublication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removePublication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removePublication(struct soap *soap, const char *tag, int id, ns1__removePublication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removePublication);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removePublication ** SOAP_FMAC4 soap_in_PointerTons1__removePublication(struct soap *soap, const char *tag, ns1__removePublication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removePublication **)soap_malloc(soap, sizeof(ns1__removePublication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removePublication *)soap_instantiate_ns1__removePublication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removePublication ** p = (ns1__removePublication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removePublication, sizeof(ns1__removePublication), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removePublication(struct soap *soap, ns1__removePublication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removePublication);
	if (soap_out_PointerTons1__removePublication(soap, tag?tag:"ns1:removePublication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removePublication ** SOAP_FMAC4 soap_get_PointerTons1__removePublication(struct soap *soap, ns1__removePublication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removePublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteKeywordResponse(struct soap *soap, ns1__deleteKeywordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteKeywordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteKeywordResponse(struct soap *soap, const char *tag, int id, ns1__deleteKeywordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteKeywordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteKeywordResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteKeywordResponse(struct soap *soap, const char *tag, ns1__deleteKeywordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteKeywordResponse **)soap_malloc(soap, sizeof(ns1__deleteKeywordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteKeywordResponse *)soap_instantiate_ns1__deleteKeywordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteKeywordResponse ** p = (ns1__deleteKeywordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteKeywordResponse, sizeof(ns1__deleteKeywordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteKeywordResponse(struct soap *soap, ns1__deleteKeywordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteKeywordResponse);
	if (soap_out_PointerTons1__deleteKeywordResponse(soap, tag?tag:"ns1:deleteKeywordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteKeywordResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteKeywordResponse(struct soap *soap, ns1__deleteKeywordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteKeyword(struct soap *soap, ns1__deleteKeyword *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteKeyword))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteKeyword(struct soap *soap, const char *tag, int id, ns1__deleteKeyword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteKeyword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteKeyword ** SOAP_FMAC4 soap_in_PointerTons1__deleteKeyword(struct soap *soap, const char *tag, ns1__deleteKeyword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteKeyword **)soap_malloc(soap, sizeof(ns1__deleteKeyword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteKeyword *)soap_instantiate_ns1__deleteKeyword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteKeyword ** p = (ns1__deleteKeyword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteKeyword, sizeof(ns1__deleteKeyword), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteKeyword(struct soap *soap, ns1__deleteKeyword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteKeyword);
	if (soap_out_PointerTons1__deleteKeyword(soap, tag?tag:"ns1:deleteKeyword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteKeyword ** SOAP_FMAC4 soap_get_PointerTons1__deleteKeyword(struct soap *soap, ns1__deleteKeyword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeKeywordResponse(struct soap *soap, ns1__removeKeywordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeKeywordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeKeywordResponse(struct soap *soap, const char *tag, int id, ns1__removeKeywordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeKeywordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeKeywordResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeKeywordResponse(struct soap *soap, const char *tag, ns1__removeKeywordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeKeywordResponse **)soap_malloc(soap, sizeof(ns1__removeKeywordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeKeywordResponse *)soap_instantiate_ns1__removeKeywordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeKeywordResponse ** p = (ns1__removeKeywordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeKeywordResponse, sizeof(ns1__removeKeywordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeKeywordResponse(struct soap *soap, ns1__removeKeywordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeKeywordResponse);
	if (soap_out_PointerTons1__removeKeywordResponse(soap, tag?tag:"ns1:removeKeywordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeKeywordResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeKeywordResponse(struct soap *soap, ns1__removeKeywordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeKeyword(struct soap *soap, ns1__removeKeyword *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeKeyword))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeKeyword(struct soap *soap, const char *tag, int id, ns1__removeKeyword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeKeyword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeKeyword ** SOAP_FMAC4 soap_in_PointerTons1__removeKeyword(struct soap *soap, const char *tag, ns1__removeKeyword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeKeyword **)soap_malloc(soap, sizeof(ns1__removeKeyword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeKeyword *)soap_instantiate_ns1__removeKeyword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeKeyword ** p = (ns1__removeKeyword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeKeyword, sizeof(ns1__removeKeyword), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeKeyword(struct soap *soap, ns1__removeKeyword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeKeyword);
	if (soap_out_PointerTons1__removeKeyword(soap, tag?tag:"ns1:removeKeyword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeKeyword ** SOAP_FMAC4 soap_get_PointerTons1__removeKeyword(struct soap *soap, ns1__removeKeyword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyInvestigationResponse(struct soap *soap, ns1__modifyInvestigationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyInvestigationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyInvestigationResponse(struct soap *soap, const char *tag, int id, ns1__modifyInvestigationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyInvestigationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyInvestigationResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifyInvestigationResponse(struct soap *soap, const char *tag, ns1__modifyInvestigationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyInvestigationResponse **)soap_malloc(soap, sizeof(ns1__modifyInvestigationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyInvestigationResponse *)soap_instantiate_ns1__modifyInvestigationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyInvestigationResponse ** p = (ns1__modifyInvestigationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigationResponse, sizeof(ns1__modifyInvestigationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyInvestigationResponse(struct soap *soap, ns1__modifyInvestigationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyInvestigationResponse);
	if (soap_out_PointerTons1__modifyInvestigationResponse(soap, tag?tag:"ns1:modifyInvestigationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyInvestigationResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifyInvestigationResponse(struct soap *soap, ns1__modifyInvestigationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyInvestigation(struct soap *soap, ns1__modifyInvestigation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyInvestigation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyInvestigation(struct soap *soap, const char *tag, int id, ns1__modifyInvestigation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyInvestigation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyInvestigation ** SOAP_FMAC4 soap_in_PointerTons1__modifyInvestigation(struct soap *soap, const char *tag, ns1__modifyInvestigation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyInvestigation **)soap_malloc(soap, sizeof(ns1__modifyInvestigation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyInvestigation *)soap_instantiate_ns1__modifyInvestigation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyInvestigation ** p = (ns1__modifyInvestigation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigation, sizeof(ns1__modifyInvestigation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyInvestigation(struct soap *soap, ns1__modifyInvestigation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyInvestigation);
	if (soap_out_PointerTons1__modifyInvestigation(soap, tag?tag:"ns1:modifyInvestigation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyInvestigation ** SOAP_FMAC4 soap_get_PointerTons1__modifyInvestigation(struct soap *soap, ns1__modifyInvestigation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteInvestigationResponse(struct soap *soap, ns1__deleteInvestigationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteInvestigationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteInvestigationResponse(struct soap *soap, const char *tag, int id, ns1__deleteInvestigationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteInvestigationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteInvestigationResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteInvestigationResponse(struct soap *soap, const char *tag, ns1__deleteInvestigationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteInvestigationResponse **)soap_malloc(soap, sizeof(ns1__deleteInvestigationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteInvestigationResponse *)soap_instantiate_ns1__deleteInvestigationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteInvestigationResponse ** p = (ns1__deleteInvestigationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigationResponse, sizeof(ns1__deleteInvestigationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteInvestigationResponse(struct soap *soap, ns1__deleteInvestigationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteInvestigationResponse);
	if (soap_out_PointerTons1__deleteInvestigationResponse(soap, tag?tag:"ns1:deleteInvestigationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteInvestigationResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteInvestigationResponse(struct soap *soap, ns1__deleteInvestigationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteInvestigation(struct soap *soap, ns1__deleteInvestigation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteInvestigation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteInvestigation(struct soap *soap, const char *tag, int id, ns1__deleteInvestigation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteInvestigation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteInvestigation ** SOAP_FMAC4 soap_in_PointerTons1__deleteInvestigation(struct soap *soap, const char *tag, ns1__deleteInvestigation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteInvestigation **)soap_malloc(soap, sizeof(ns1__deleteInvestigation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteInvestigation *)soap_instantiate_ns1__deleteInvestigation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteInvestigation ** p = (ns1__deleteInvestigation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigation, sizeof(ns1__deleteInvestigation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteInvestigation(struct soap *soap, ns1__deleteInvestigation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteInvestigation);
	if (soap_out_PointerTons1__deleteInvestigation(soap, tag?tag:"ns1:deleteInvestigation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteInvestigation ** SOAP_FMAC4 soap_get_PointerTons1__deleteInvestigation(struct soap *soap, ns1__deleteInvestigation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeInvestigationResponse(struct soap *soap, ns1__removeInvestigationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeInvestigationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeInvestigationResponse(struct soap *soap, const char *tag, int id, ns1__removeInvestigationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeInvestigationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeInvestigationResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeInvestigationResponse(struct soap *soap, const char *tag, ns1__removeInvestigationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeInvestigationResponse **)soap_malloc(soap, sizeof(ns1__removeInvestigationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeInvestigationResponse *)soap_instantiate_ns1__removeInvestigationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeInvestigationResponse ** p = (ns1__removeInvestigationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigationResponse, sizeof(ns1__removeInvestigationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeInvestigationResponse(struct soap *soap, ns1__removeInvestigationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeInvestigationResponse);
	if (soap_out_PointerTons1__removeInvestigationResponse(soap, tag?tag:"ns1:removeInvestigationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeInvestigationResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeInvestigationResponse(struct soap *soap, ns1__removeInvestigationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeInvestigation(struct soap *soap, ns1__removeInvestigation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeInvestigation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeInvestigation(struct soap *soap, const char *tag, int id, ns1__removeInvestigation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeInvestigation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeInvestigation ** SOAP_FMAC4 soap_in_PointerTons1__removeInvestigation(struct soap *soap, const char *tag, ns1__removeInvestigation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeInvestigation **)soap_malloc(soap, sizeof(ns1__removeInvestigation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeInvestigation *)soap_instantiate_ns1__removeInvestigation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeInvestigation ** p = (ns1__removeInvestigation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigation, sizeof(ns1__removeInvestigation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeInvestigation(struct soap *soap, ns1__removeInvestigation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeInvestigation);
	if (soap_out_PointerTons1__removeInvestigation(soap, tag?tag:"ns1:removeInvestigation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeInvestigation ** SOAP_FMAC4 soap_get_PointerTons1__removeInvestigation(struct soap *soap, ns1__removeInvestigation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createInvestigationResponse(struct soap *soap, ns1__createInvestigationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createInvestigationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createInvestigationResponse(struct soap *soap, const char *tag, int id, ns1__createInvestigationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createInvestigationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createInvestigationResponse ** SOAP_FMAC4 soap_in_PointerTons1__createInvestigationResponse(struct soap *soap, const char *tag, ns1__createInvestigationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createInvestigationResponse **)soap_malloc(soap, sizeof(ns1__createInvestigationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createInvestigationResponse *)soap_instantiate_ns1__createInvestigationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createInvestigationResponse ** p = (ns1__createInvestigationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createInvestigationResponse, sizeof(ns1__createInvestigationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createInvestigationResponse(struct soap *soap, ns1__createInvestigationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createInvestigationResponse);
	if (soap_out_PointerTons1__createInvestigationResponse(soap, tag?tag:"ns1:createInvestigationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createInvestigationResponse ** SOAP_FMAC4 soap_get_PointerTons1__createInvestigationResponse(struct soap *soap, ns1__createInvestigationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createInvestigation(struct soap *soap, ns1__createInvestigation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createInvestigation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createInvestigation(struct soap *soap, const char *tag, int id, ns1__createInvestigation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createInvestigation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createInvestigation ** SOAP_FMAC4 soap_in_PointerTons1__createInvestigation(struct soap *soap, const char *tag, ns1__createInvestigation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createInvestigation **)soap_malloc(soap, sizeof(ns1__createInvestigation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createInvestigation *)soap_instantiate_ns1__createInvestigation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createInvestigation ** p = (ns1__createInvestigation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createInvestigation, sizeof(ns1__createInvestigation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createInvestigation(struct soap *soap, ns1__createInvestigation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createInvestigation);
	if (soap_out_PointerTons1__createInvestigation(soap, tag?tag:"ns1:createInvestigation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createInvestigation ** SOAP_FMAC4 soap_get_PointerTons1__createInvestigation(struct soap *soap, ns1__createInvestigation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getInvestigationsIncludesResponse(struct soap *soap, ns1__getInvestigationsIncludesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getInvestigationsIncludesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getInvestigationsIncludesResponse(struct soap *soap, const char *tag, int id, ns1__getInvestigationsIncludesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getInvestigationsIncludesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getInvestigationsIncludesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getInvestigationsIncludesResponse(struct soap *soap, const char *tag, ns1__getInvestigationsIncludesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getInvestigationsIncludesResponse **)soap_malloc(soap, sizeof(ns1__getInvestigationsIncludesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getInvestigationsIncludesResponse *)soap_instantiate_ns1__getInvestigationsIncludesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getInvestigationsIncludesResponse ** p = (ns1__getInvestigationsIncludesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationsIncludesResponse, sizeof(ns1__getInvestigationsIncludesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getInvestigationsIncludesResponse(struct soap *soap, ns1__getInvestigationsIncludesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getInvestigationsIncludesResponse);
	if (soap_out_PointerTons1__getInvestigationsIncludesResponse(soap, tag?tag:"ns1:getInvestigationsIncludesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getInvestigationsIncludesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getInvestigationsIncludesResponse(struct soap *soap, ns1__getInvestigationsIncludesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getInvestigationsIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getInvestigationsIncludes(struct soap *soap, ns1__getInvestigationsIncludes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getInvestigationsIncludes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getInvestigationsIncludes(struct soap *soap, const char *tag, int id, ns1__getInvestigationsIncludes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getInvestigationsIncludes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getInvestigationsIncludes ** SOAP_FMAC4 soap_in_PointerTons1__getInvestigationsIncludes(struct soap *soap, const char *tag, ns1__getInvestigationsIncludes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getInvestigationsIncludes **)soap_malloc(soap, sizeof(ns1__getInvestigationsIncludes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getInvestigationsIncludes *)soap_instantiate_ns1__getInvestigationsIncludes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getInvestigationsIncludes ** p = (ns1__getInvestigationsIncludes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationsIncludes, sizeof(ns1__getInvestigationsIncludes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getInvestigationsIncludes(struct soap *soap, ns1__getInvestigationsIncludes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getInvestigationsIncludes);
	if (soap_out_PointerTons1__getInvestigationsIncludes(soap, tag?tag:"ns1:getInvestigationsIncludes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getInvestigationsIncludes ** SOAP_FMAC4 soap_get_PointerTons1__getInvestigationsIncludes(struct soap *soap, ns1__getInvestigationsIncludes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getInvestigationsIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateAuthorisationResponse(struct soap *soap, ns1__updateAuthorisationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateAuthorisationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateAuthorisationResponse(struct soap *soap, const char *tag, int id, ns1__updateAuthorisationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateAuthorisationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateAuthorisationResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateAuthorisationResponse(struct soap *soap, const char *tag, ns1__updateAuthorisationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateAuthorisationResponse **)soap_malloc(soap, sizeof(ns1__updateAuthorisationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateAuthorisationResponse *)soap_instantiate_ns1__updateAuthorisationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateAuthorisationResponse ** p = (ns1__updateAuthorisationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateAuthorisationResponse, sizeof(ns1__updateAuthorisationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateAuthorisationResponse(struct soap *soap, ns1__updateAuthorisationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateAuthorisationResponse);
	if (soap_out_PointerTons1__updateAuthorisationResponse(soap, tag?tag:"ns1:updateAuthorisationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateAuthorisationResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateAuthorisationResponse(struct soap *soap, ns1__updateAuthorisationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateAuthorisation(struct soap *soap, ns1__updateAuthorisation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateAuthorisation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateAuthorisation(struct soap *soap, const char *tag, int id, ns1__updateAuthorisation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateAuthorisation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateAuthorisation ** SOAP_FMAC4 soap_in_PointerTons1__updateAuthorisation(struct soap *soap, const char *tag, ns1__updateAuthorisation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateAuthorisation **)soap_malloc(soap, sizeof(ns1__updateAuthorisation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateAuthorisation *)soap_instantiate_ns1__updateAuthorisation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateAuthorisation ** p = (ns1__updateAuthorisation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateAuthorisation, sizeof(ns1__updateAuthorisation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateAuthorisation(struct soap *soap, ns1__updateAuthorisation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateAuthorisation);
	if (soap_out_PointerTons1__updateAuthorisation(soap, tag?tag:"ns1:updateAuthorisation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateAuthorisation ** SOAP_FMAC4 soap_get_PointerTons1__updateAuthorisation(struct soap *soap, ns1__updateAuthorisation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeAuthorisationResponse(struct soap *soap, ns1__removeAuthorisationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeAuthorisationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeAuthorisationResponse(struct soap *soap, const char *tag, int id, ns1__removeAuthorisationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeAuthorisationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeAuthorisationResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeAuthorisationResponse(struct soap *soap, const char *tag, ns1__removeAuthorisationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeAuthorisationResponse **)soap_malloc(soap, sizeof(ns1__removeAuthorisationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeAuthorisationResponse *)soap_instantiate_ns1__removeAuthorisationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeAuthorisationResponse ** p = (ns1__removeAuthorisationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeAuthorisationResponse, sizeof(ns1__removeAuthorisationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeAuthorisationResponse(struct soap *soap, ns1__removeAuthorisationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeAuthorisationResponse);
	if (soap_out_PointerTons1__removeAuthorisationResponse(soap, tag?tag:"ns1:removeAuthorisationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeAuthorisationResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeAuthorisationResponse(struct soap *soap, ns1__removeAuthorisationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeAuthorisation(struct soap *soap, ns1__removeAuthorisation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeAuthorisation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeAuthorisation(struct soap *soap, const char *tag, int id, ns1__removeAuthorisation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeAuthorisation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeAuthorisation ** SOAP_FMAC4 soap_in_PointerTons1__removeAuthorisation(struct soap *soap, const char *tag, ns1__removeAuthorisation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeAuthorisation **)soap_malloc(soap, sizeof(ns1__removeAuthorisation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeAuthorisation *)soap_instantiate_ns1__removeAuthorisation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeAuthorisation ** p = (ns1__removeAuthorisation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeAuthorisation, sizeof(ns1__removeAuthorisation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeAuthorisation(struct soap *soap, ns1__removeAuthorisation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeAuthorisation);
	if (soap_out_PointerTons1__removeAuthorisation(soap, tag?tag:"ns1:removeAuthorisation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeAuthorisation ** SOAP_FMAC4 soap_get_PointerTons1__removeAuthorisation(struct soap *soap, ns1__removeAuthorisation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteAuthorisationResponse(struct soap *soap, ns1__deleteAuthorisationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteAuthorisationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteAuthorisationResponse(struct soap *soap, const char *tag, int id, ns1__deleteAuthorisationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteAuthorisationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteAuthorisationResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteAuthorisationResponse(struct soap *soap, const char *tag, ns1__deleteAuthorisationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteAuthorisationResponse **)soap_malloc(soap, sizeof(ns1__deleteAuthorisationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteAuthorisationResponse *)soap_instantiate_ns1__deleteAuthorisationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteAuthorisationResponse ** p = (ns1__deleteAuthorisationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteAuthorisationResponse, sizeof(ns1__deleteAuthorisationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteAuthorisationResponse(struct soap *soap, ns1__deleteAuthorisationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteAuthorisationResponse);
	if (soap_out_PointerTons1__deleteAuthorisationResponse(soap, tag?tag:"ns1:deleteAuthorisationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteAuthorisationResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteAuthorisationResponse(struct soap *soap, ns1__deleteAuthorisationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteAuthorisation(struct soap *soap, ns1__deleteAuthorisation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteAuthorisation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteAuthorisation(struct soap *soap, const char *tag, int id, ns1__deleteAuthorisation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteAuthorisation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteAuthorisation ** SOAP_FMAC4 soap_in_PointerTons1__deleteAuthorisation(struct soap *soap, const char *tag, ns1__deleteAuthorisation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteAuthorisation **)soap_malloc(soap, sizeof(ns1__deleteAuthorisation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteAuthorisation *)soap_instantiate_ns1__deleteAuthorisation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteAuthorisation ** p = (ns1__deleteAuthorisation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteAuthorisation, sizeof(ns1__deleteAuthorisation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteAuthorisation(struct soap *soap, ns1__deleteAuthorisation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteAuthorisation);
	if (soap_out_PointerTons1__deleteAuthorisation(soap, tag?tag:"ns1:deleteAuthorisation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteAuthorisation ** SOAP_FMAC4 soap_get_PointerTons1__deleteAuthorisation(struct soap *soap, ns1__deleteAuthorisation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addAuthorisationResponse(struct soap *soap, ns1__addAuthorisationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addAuthorisationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addAuthorisationResponse(struct soap *soap, const char *tag, int id, ns1__addAuthorisationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addAuthorisationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addAuthorisationResponse ** SOAP_FMAC4 soap_in_PointerTons1__addAuthorisationResponse(struct soap *soap, const char *tag, ns1__addAuthorisationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addAuthorisationResponse **)soap_malloc(soap, sizeof(ns1__addAuthorisationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addAuthorisationResponse *)soap_instantiate_ns1__addAuthorisationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addAuthorisationResponse ** p = (ns1__addAuthorisationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addAuthorisationResponse, sizeof(ns1__addAuthorisationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addAuthorisationResponse(struct soap *soap, ns1__addAuthorisationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addAuthorisationResponse);
	if (soap_out_PointerTons1__addAuthorisationResponse(soap, tag?tag:"ns1:addAuthorisationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addAuthorisationResponse ** SOAP_FMAC4 soap_get_PointerTons1__addAuthorisationResponse(struct soap *soap, ns1__addAuthorisationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addAuthorisationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addAuthorisation(struct soap *soap, ns1__addAuthorisation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addAuthorisation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addAuthorisation(struct soap *soap, const char *tag, int id, ns1__addAuthorisation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addAuthorisation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addAuthorisation ** SOAP_FMAC4 soap_in_PointerTons1__addAuthorisation(struct soap *soap, const char *tag, ns1__addAuthorisation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addAuthorisation **)soap_malloc(soap, sizeof(ns1__addAuthorisation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addAuthorisation *)soap_instantiate_ns1__addAuthorisation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addAuthorisation ** p = (ns1__addAuthorisation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addAuthorisation, sizeof(ns1__addAuthorisation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addAuthorisation(struct soap *soap, ns1__addAuthorisation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addAuthorisation);
	if (soap_out_PointerTons1__addAuthorisation(soap, tag?tag:"ns1:addAuthorisation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addAuthorisation ** SOAP_FMAC4 soap_get_PointerTons1__addAuthorisation(struct soap *soap, ns1__addAuthorisation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAuthorisationsResponse(struct soap *soap, ns1__getAuthorisationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAuthorisationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAuthorisationsResponse(struct soap *soap, const char *tag, int id, ns1__getAuthorisationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAuthorisationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAuthorisationsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getAuthorisationsResponse(struct soap *soap, const char *tag, ns1__getAuthorisationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAuthorisationsResponse **)soap_malloc(soap, sizeof(ns1__getAuthorisationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAuthorisationsResponse *)soap_instantiate_ns1__getAuthorisationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAuthorisationsResponse ** p = (ns1__getAuthorisationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAuthorisationsResponse, sizeof(ns1__getAuthorisationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAuthorisationsResponse(struct soap *soap, ns1__getAuthorisationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAuthorisationsResponse);
	if (soap_out_PointerTons1__getAuthorisationsResponse(soap, tag?tag:"ns1:getAuthorisationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAuthorisationsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getAuthorisationsResponse(struct soap *soap, ns1__getAuthorisationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAuthorisationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAuthorisations(struct soap *soap, ns1__getAuthorisations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAuthorisations))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAuthorisations(struct soap *soap, const char *tag, int id, ns1__getAuthorisations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAuthorisations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAuthorisations ** SOAP_FMAC4 soap_in_PointerTons1__getAuthorisations(struct soap *soap, const char *tag, ns1__getAuthorisations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAuthorisations **)soap_malloc(soap, sizeof(ns1__getAuthorisations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAuthorisations *)soap_instantiate_ns1__getAuthorisations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAuthorisations ** p = (ns1__getAuthorisations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAuthorisations, sizeof(ns1__getAuthorisations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAuthorisations(struct soap *soap, ns1__getAuthorisations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAuthorisations);
	if (soap_out_PointerTons1__getAuthorisations(soap, tag?tag:"ns1:getAuthorisations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAuthorisations ** SOAP_FMAC4 soap_get_PointerTons1__getAuthorisations(struct soap *soap, ns1__getAuthorisations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAuthorisations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataFileParameterResponse(struct soap *soap, ns1__deleteDataFileParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataFileParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataFileParameterResponse(struct soap *soap, const char *tag, int id, ns1__deleteDataFileParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataFileParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataFileParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataFileParameterResponse(struct soap *soap, const char *tag, ns1__deleteDataFileParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataFileParameterResponse **)soap_malloc(soap, sizeof(ns1__deleteDataFileParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataFileParameterResponse *)soap_instantiate_ns1__deleteDataFileParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataFileParameterResponse ** p = (ns1__deleteDataFileParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFileParameterResponse, sizeof(ns1__deleteDataFileParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataFileParameterResponse(struct soap *soap, ns1__deleteDataFileParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataFileParameterResponse);
	if (soap_out_PointerTons1__deleteDataFileParameterResponse(soap, tag?tag:"ns1:deleteDataFileParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataFileParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataFileParameterResponse(struct soap *soap, ns1__deleteDataFileParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataFileParameter(struct soap *soap, ns1__deleteDataFileParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataFileParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataFileParameter(struct soap *soap, const char *tag, int id, ns1__deleteDataFileParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataFileParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataFileParameter ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataFileParameter(struct soap *soap, const char *tag, ns1__deleteDataFileParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataFileParameter **)soap_malloc(soap, sizeof(ns1__deleteDataFileParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataFileParameter *)soap_instantiate_ns1__deleteDataFileParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataFileParameter ** p = (ns1__deleteDataFileParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFileParameter, sizeof(ns1__deleteDataFileParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataFileParameter(struct soap *soap, ns1__deleteDataFileParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataFileParameter);
	if (soap_out_PointerTons1__deleteDataFileParameter(soap, tag?tag:"ns1:deleteDataFileParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataFileParameter ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataFileParameter(struct soap *soap, ns1__deleteDataFileParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataFileParameterResponse(struct soap *soap, ns1__removeDataFileParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataFileParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataFileParameterResponse(struct soap *soap, const char *tag, int id, ns1__removeDataFileParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataFileParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataFileParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeDataFileParameterResponse(struct soap *soap, const char *tag, ns1__removeDataFileParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataFileParameterResponse **)soap_malloc(soap, sizeof(ns1__removeDataFileParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataFileParameterResponse *)soap_instantiate_ns1__removeDataFileParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataFileParameterResponse ** p = (ns1__removeDataFileParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFileParameterResponse, sizeof(ns1__removeDataFileParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataFileParameterResponse(struct soap *soap, ns1__removeDataFileParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataFileParameterResponse);
	if (soap_out_PointerTons1__removeDataFileParameterResponse(soap, tag?tag:"ns1:removeDataFileParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataFileParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeDataFileParameterResponse(struct soap *soap, ns1__removeDataFileParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataFileParameter(struct soap *soap, ns1__removeDataFileParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataFileParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataFileParameter(struct soap *soap, const char *tag, int id, ns1__removeDataFileParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataFileParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataFileParameter ** SOAP_FMAC4 soap_in_PointerTons1__removeDataFileParameter(struct soap *soap, const char *tag, ns1__removeDataFileParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataFileParameter **)soap_malloc(soap, sizeof(ns1__removeDataFileParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataFileParameter *)soap_instantiate_ns1__removeDataFileParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataFileParameter ** p = (ns1__removeDataFileParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFileParameter, sizeof(ns1__removeDataFileParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataFileParameter(struct soap *soap, ns1__removeDataFileParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataFileParameter);
	if (soap_out_PointerTons1__removeDataFileParameter(soap, tag?tag:"ns1:removeDataFileParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataFileParameter ** SOAP_FMAC4 soap_get_PointerTons1__removeDataFileParameter(struct soap *soap, ns1__removeDataFileParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataFileParameterResponse(struct soap *soap, ns1__modifyDataFileParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataFileParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataFileParameterResponse(struct soap *soap, const char *tag, int id, ns1__modifyDataFileParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataFileParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataFileParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataFileParameterResponse(struct soap *soap, const char *tag, ns1__modifyDataFileParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataFileParameterResponse **)soap_malloc(soap, sizeof(ns1__modifyDataFileParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataFileParameterResponse *)soap_instantiate_ns1__modifyDataFileParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataFileParameterResponse ** p = (ns1__modifyDataFileParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFileParameterResponse, sizeof(ns1__modifyDataFileParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataFileParameterResponse(struct soap *soap, ns1__modifyDataFileParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataFileParameterResponse);
	if (soap_out_PointerTons1__modifyDataFileParameterResponse(soap, tag?tag:"ns1:modifyDataFileParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataFileParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataFileParameterResponse(struct soap *soap, ns1__modifyDataFileParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataFileParameter(struct soap *soap, ns1__modifyDataFileParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataFileParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataFileParameter(struct soap *soap, const char *tag, int id, ns1__modifyDataFileParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataFileParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataFileParameter ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataFileParameter(struct soap *soap, const char *tag, ns1__modifyDataFileParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataFileParameter **)soap_malloc(soap, sizeof(ns1__modifyDataFileParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataFileParameter *)soap_instantiate_ns1__modifyDataFileParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataFileParameter ** p = (ns1__modifyDataFileParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFileParameter, sizeof(ns1__modifyDataFileParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataFileParameter(struct soap *soap, ns1__modifyDataFileParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataFileParameter);
	if (soap_out_PointerTons1__modifyDataFileParameter(soap, tag?tag:"ns1:modifyDataFileParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataFileParameter ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataFileParameter(struct soap *soap, ns1__modifyDataFileParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataFileParametersResponse(struct soap *soap, ns1__addDataFileParametersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataFileParametersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataFileParametersResponse(struct soap *soap, const char *tag, int id, ns1__addDataFileParametersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataFileParametersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataFileParametersResponse ** SOAP_FMAC4 soap_in_PointerTons1__addDataFileParametersResponse(struct soap *soap, const char *tag, ns1__addDataFileParametersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataFileParametersResponse **)soap_malloc(soap, sizeof(ns1__addDataFileParametersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataFileParametersResponse *)soap_instantiate_ns1__addDataFileParametersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataFileParametersResponse ** p = (ns1__addDataFileParametersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParametersResponse, sizeof(ns1__addDataFileParametersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataFileParametersResponse(struct soap *soap, ns1__addDataFileParametersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataFileParametersResponse);
	if (soap_out_PointerTons1__addDataFileParametersResponse(soap, tag?tag:"ns1:addDataFileParametersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataFileParametersResponse ** SOAP_FMAC4 soap_get_PointerTons1__addDataFileParametersResponse(struct soap *soap, ns1__addDataFileParametersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataFileParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataFileParameters(struct soap *soap, ns1__addDataFileParameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataFileParameters))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataFileParameters(struct soap *soap, const char *tag, int id, ns1__addDataFileParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataFileParameters);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataFileParameters ** SOAP_FMAC4 soap_in_PointerTons1__addDataFileParameters(struct soap *soap, const char *tag, ns1__addDataFileParameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataFileParameters **)soap_malloc(soap, sizeof(ns1__addDataFileParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataFileParameters *)soap_instantiate_ns1__addDataFileParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataFileParameters ** p = (ns1__addDataFileParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParameters, sizeof(ns1__addDataFileParameters), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataFileParameters(struct soap *soap, ns1__addDataFileParameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataFileParameters);
	if (soap_out_PointerTons1__addDataFileParameters(soap, tag?tag:"ns1:addDataFileParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataFileParameters ** SOAP_FMAC4 soap_get_PointerTons1__addDataFileParameters(struct soap *soap, ns1__addDataFileParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataFileParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataFileResponse(struct soap *soap, ns1__modifyDataFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataFileResponse(struct soap *soap, const char *tag, int id, ns1__modifyDataFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataFileResponse(struct soap *soap, const char *tag, ns1__modifyDataFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataFileResponse **)soap_malloc(soap, sizeof(ns1__modifyDataFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataFileResponse *)soap_instantiate_ns1__modifyDataFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataFileResponse ** p = (ns1__modifyDataFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFileResponse, sizeof(ns1__modifyDataFileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataFileResponse(struct soap *soap, ns1__modifyDataFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataFileResponse);
	if (soap_out_PointerTons1__modifyDataFileResponse(soap, tag?tag:"ns1:modifyDataFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataFileResponse(struct soap *soap, ns1__modifyDataFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyDataFile(struct soap *soap, ns1__modifyDataFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyDataFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyDataFile(struct soap *soap, const char *tag, int id, ns1__modifyDataFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyDataFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__modifyDataFile ** SOAP_FMAC4 soap_in_PointerTons1__modifyDataFile(struct soap *soap, const char *tag, ns1__modifyDataFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__modifyDataFile **)soap_malloc(soap, sizeof(ns1__modifyDataFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__modifyDataFile *)soap_instantiate_ns1__modifyDataFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__modifyDataFile ** p = (ns1__modifyDataFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFile, sizeof(ns1__modifyDataFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyDataFile(struct soap *soap, ns1__modifyDataFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyDataFile);
	if (soap_out_PointerTons1__modifyDataFile(soap, tag?tag:"ns1:modifyDataFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__modifyDataFile ** SOAP_FMAC4 soap_get_PointerTons1__modifyDataFile(struct soap *soap, ns1__modifyDataFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataFileResponse(struct soap *soap, ns1__removeDataFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataFileResponse(struct soap *soap, const char *tag, int id, ns1__removeDataFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeDataFileResponse(struct soap *soap, const char *tag, ns1__removeDataFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataFileResponse **)soap_malloc(soap, sizeof(ns1__removeDataFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataFileResponse *)soap_instantiate_ns1__removeDataFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataFileResponse ** p = (ns1__removeDataFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFileResponse, sizeof(ns1__removeDataFileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataFileResponse(struct soap *soap, ns1__removeDataFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataFileResponse);
	if (soap_out_PointerTons1__removeDataFileResponse(soap, tag?tag:"ns1:removeDataFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeDataFileResponse(struct soap *soap, ns1__removeDataFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeDataFile(struct soap *soap, ns1__removeDataFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeDataFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeDataFile(struct soap *soap, const char *tag, int id, ns1__removeDataFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeDataFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeDataFile ** SOAP_FMAC4 soap_in_PointerTons1__removeDataFile(struct soap *soap, const char *tag, ns1__removeDataFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeDataFile **)soap_malloc(soap, sizeof(ns1__removeDataFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeDataFile *)soap_instantiate_ns1__removeDataFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeDataFile ** p = (ns1__removeDataFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFile, sizeof(ns1__removeDataFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeDataFile(struct soap *soap, ns1__removeDataFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeDataFile);
	if (soap_out_PointerTons1__removeDataFile(soap, tag?tag:"ns1:removeDataFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeDataFile ** SOAP_FMAC4 soap_get_PointerTons1__removeDataFile(struct soap *soap, ns1__removeDataFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataFileResponse(struct soap *soap, ns1__deleteDataFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataFileResponse(struct soap *soap, const char *tag, int id, ns1__deleteDataFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataFileResponse(struct soap *soap, const char *tag, ns1__deleteDataFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataFileResponse **)soap_malloc(soap, sizeof(ns1__deleteDataFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataFileResponse *)soap_instantiate_ns1__deleteDataFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataFileResponse ** p = (ns1__deleteDataFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFileResponse, sizeof(ns1__deleteDataFileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataFileResponse(struct soap *soap, ns1__deleteDataFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataFileResponse);
	if (soap_out_PointerTons1__deleteDataFileResponse(soap, tag?tag:"ns1:deleteDataFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataFileResponse(struct soap *soap, ns1__deleteDataFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDataFile(struct soap *soap, ns1__deleteDataFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDataFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDataFile(struct soap *soap, const char *tag, int id, ns1__deleteDataFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDataFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDataFile ** SOAP_FMAC4 soap_in_PointerTons1__deleteDataFile(struct soap *soap, const char *tag, ns1__deleteDataFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDataFile **)soap_malloc(soap, sizeof(ns1__deleteDataFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDataFile *)soap_instantiate_ns1__deleteDataFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDataFile ** p = (ns1__deleteDataFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFile, sizeof(ns1__deleteDataFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDataFile(struct soap *soap, ns1__deleteDataFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDataFile);
	if (soap_out_PointerTons1__deleteDataFile(soap, tag?tag:"ns1:deleteDataFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteDataFile ** SOAP_FMAC4 soap_get_PointerTons1__deleteDataFile(struct soap *soap, ns1__deleteDataFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataFilesResponse(struct soap *soap, ns1__createDataFilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataFilesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataFilesResponse(struct soap *soap, const char *tag, int id, ns1__createDataFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataFilesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataFilesResponse ** SOAP_FMAC4 soap_in_PointerTons1__createDataFilesResponse(struct soap *soap, const char *tag, ns1__createDataFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataFilesResponse **)soap_malloc(soap, sizeof(ns1__createDataFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataFilesResponse *)soap_instantiate_ns1__createDataFilesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataFilesResponse ** p = (ns1__createDataFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFilesResponse, sizeof(ns1__createDataFilesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataFilesResponse(struct soap *soap, ns1__createDataFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataFilesResponse);
	if (soap_out_PointerTons1__createDataFilesResponse(soap, tag?tag:"ns1:createDataFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataFilesResponse ** SOAP_FMAC4 soap_get_PointerTons1__createDataFilesResponse(struct soap *soap, ns1__createDataFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataFiles(struct soap *soap, ns1__createDataFiles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataFiles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataFiles(struct soap *soap, const char *tag, int id, ns1__createDataFiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataFiles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataFiles ** SOAP_FMAC4 soap_in_PointerTons1__createDataFiles(struct soap *soap, const char *tag, ns1__createDataFiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataFiles **)soap_malloc(soap, sizeof(ns1__createDataFiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataFiles *)soap_instantiate_ns1__createDataFiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataFiles ** p = (ns1__createDataFiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFiles, sizeof(ns1__createDataFiles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataFiles(struct soap *soap, ns1__createDataFiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataFiles);
	if (soap_out_PointerTons1__createDataFiles(soap, tag?tag:"ns1:createDataFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataFiles ** SOAP_FMAC4 soap_get_PointerTons1__createDataFiles(struct soap *soap, ns1__createDataFiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataFileResponse(struct soap *soap, ns1__createDataFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataFileResponse(struct soap *soap, const char *tag, int id, ns1__createDataFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__createDataFileResponse(struct soap *soap, const char *tag, ns1__createDataFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataFileResponse **)soap_malloc(soap, sizeof(ns1__createDataFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataFileResponse *)soap_instantiate_ns1__createDataFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataFileResponse ** p = (ns1__createDataFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFileResponse, sizeof(ns1__createDataFileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataFileResponse(struct soap *soap, ns1__createDataFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataFileResponse);
	if (soap_out_PointerTons1__createDataFileResponse(soap, tag?tag:"ns1:createDataFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__createDataFileResponse(struct soap *soap, ns1__createDataFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDataFile(struct soap *soap, ns1__createDataFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDataFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDataFile(struct soap *soap, const char *tag, int id, ns1__createDataFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDataFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDataFile ** SOAP_FMAC4 soap_in_PointerTons1__createDataFile(struct soap *soap, const char *tag, ns1__createDataFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDataFile **)soap_malloc(soap, sizeof(ns1__createDataFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDataFile *)soap_instantiate_ns1__createDataFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDataFile ** p = (ns1__createDataFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFile, sizeof(ns1__createDataFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDataFile(struct soap *soap, ns1__createDataFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDataFile);
	if (soap_out_PointerTons1__createDataFile(soap, tag?tag:"ns1:createDataFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createDataFile ** SOAP_FMAC4 soap_get_PointerTons1__createDataFile(struct soap *soap, ns1__createDataFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDataFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatafilesResponse(struct soap *soap, ns1__getDatafilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatafilesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatafilesResponse(struct soap *soap, const char *tag, int id, ns1__getDatafilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatafilesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatafilesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDatafilesResponse(struct soap *soap, const char *tag, ns1__getDatafilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatafilesResponse **)soap_malloc(soap, sizeof(ns1__getDatafilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatafilesResponse *)soap_instantiate_ns1__getDatafilesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatafilesResponse ** p = (ns1__getDatafilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafilesResponse, sizeof(ns1__getDatafilesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatafilesResponse(struct soap *soap, ns1__getDatafilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatafilesResponse);
	if (soap_out_PointerTons1__getDatafilesResponse(soap, tag?tag:"ns1:getDatafilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatafilesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDatafilesResponse(struct soap *soap, ns1__getDatafilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatafilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatafiles(struct soap *soap, ns1__getDatafiles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatafiles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatafiles(struct soap *soap, const char *tag, int id, ns1__getDatafiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatafiles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatafiles ** SOAP_FMAC4 soap_in_PointerTons1__getDatafiles(struct soap *soap, const char *tag, ns1__getDatafiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatafiles **)soap_malloc(soap, sizeof(ns1__getDatafiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatafiles *)soap_instantiate_ns1__getDatafiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatafiles ** p = (ns1__getDatafiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafiles, sizeof(ns1__getDatafiles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatafiles(struct soap *soap, ns1__getDatafiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatafiles);
	if (soap_out_PointerTons1__getDatafiles(soap, tag?tag:"ns1:getDatafiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatafiles ** SOAP_FMAC4 soap_get_PointerTons1__getDatafiles(struct soap *soap, ns1__getDatafiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ingestMetadataResponse(struct soap *soap, ns1__ingestMetadataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ingestMetadataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ingestMetadataResponse(struct soap *soap, const char *tag, int id, ns1__ingestMetadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ingestMetadataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ingestMetadataResponse ** SOAP_FMAC4 soap_in_PointerTons1__ingestMetadataResponse(struct soap *soap, const char *tag, ns1__ingestMetadataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ingestMetadataResponse **)soap_malloc(soap, sizeof(ns1__ingestMetadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ingestMetadataResponse *)soap_instantiate_ns1__ingestMetadataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ingestMetadataResponse ** p = (ns1__ingestMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ingestMetadataResponse, sizeof(ns1__ingestMetadataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ingestMetadataResponse(struct soap *soap, ns1__ingestMetadataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ingestMetadataResponse);
	if (soap_out_PointerTons1__ingestMetadataResponse(soap, tag?tag:"ns1:ingestMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ingestMetadataResponse ** SOAP_FMAC4 soap_get_PointerTons1__ingestMetadataResponse(struct soap *soap, ns1__ingestMetadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ingestMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ingestMetadata(struct soap *soap, ns1__ingestMetadata *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ingestMetadata))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ingestMetadata(struct soap *soap, const char *tag, int id, ns1__ingestMetadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ingestMetadata);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ingestMetadata ** SOAP_FMAC4 soap_in_PointerTons1__ingestMetadata(struct soap *soap, const char *tag, ns1__ingestMetadata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ingestMetadata **)soap_malloc(soap, sizeof(ns1__ingestMetadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ingestMetadata *)soap_instantiate_ns1__ingestMetadata(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ingestMetadata ** p = (ns1__ingestMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ingestMetadata, sizeof(ns1__ingestMetadata), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ingestMetadata(struct soap *soap, ns1__ingestMetadata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ingestMetadata);
	if (soap_out_PointerTons1__ingestMetadata(soap, tag?tag:"ns1:ingestMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ingestMetadata ** SOAP_FMAC4 soap_get_PointerTons1__ingestMetadata(struct soap *soap, ns1__ingestMetadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ingestMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getUserDetailsResponse(struct soap *soap, ns1__getUserDetailsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getUserDetailsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getUserDetailsResponse(struct soap *soap, const char *tag, int id, ns1__getUserDetailsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getUserDetailsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getUserDetailsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getUserDetailsResponse(struct soap *soap, const char *tag, ns1__getUserDetailsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getUserDetailsResponse **)soap_malloc(soap, sizeof(ns1__getUserDetailsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getUserDetailsResponse *)soap_instantiate_ns1__getUserDetailsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getUserDetailsResponse ** p = (ns1__getUserDetailsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getUserDetailsResponse, sizeof(ns1__getUserDetailsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getUserDetailsResponse(struct soap *soap, ns1__getUserDetailsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getUserDetailsResponse);
	if (soap_out_PointerTons1__getUserDetailsResponse(soap, tag?tag:"ns1:getUserDetailsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getUserDetailsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getUserDetailsResponse(struct soap *soap, ns1__getUserDetailsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getUserDetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getUserDetails(struct soap *soap, ns1__getUserDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getUserDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getUserDetails(struct soap *soap, const char *tag, int id, ns1__getUserDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getUserDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getUserDetails ** SOAP_FMAC4 soap_in_PointerTons1__getUserDetails(struct soap *soap, const char *tag, ns1__getUserDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getUserDetails **)soap_malloc(soap, sizeof(ns1__getUserDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getUserDetails *)soap_instantiate_ns1__getUserDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getUserDetails ** p = (ns1__getUserDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getUserDetails, sizeof(ns1__getUserDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getUserDetails(struct soap *soap, ns1__getUserDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getUserDetails);
	if (soap_out_PointerTons1__getUserDetails(soap, tag?tag:"ns1:getUserDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getUserDetails ** SOAP_FMAC4 soap_get_PointerTons1__getUserDetails(struct soap *soap, ns1__getUserDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getUserDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataFileParameterResponse(struct soap *soap, ns1__addDataFileParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataFileParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataFileParameterResponse(struct soap *soap, const char *tag, int id, ns1__addDataFileParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataFileParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataFileParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__addDataFileParameterResponse(struct soap *soap, const char *tag, ns1__addDataFileParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataFileParameterResponse **)soap_malloc(soap, sizeof(ns1__addDataFileParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataFileParameterResponse *)soap_instantiate_ns1__addDataFileParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataFileParameterResponse ** p = (ns1__addDataFileParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParameterResponse, sizeof(ns1__addDataFileParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataFileParameterResponse(struct soap *soap, ns1__addDataFileParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataFileParameterResponse);
	if (soap_out_PointerTons1__addDataFileParameterResponse(soap, tag?tag:"ns1:addDataFileParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataFileParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__addDataFileParameterResponse(struct soap *soap, ns1__addDataFileParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataFileParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addDataFileParameter(struct soap *soap, ns1__addDataFileParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addDataFileParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addDataFileParameter(struct soap *soap, const char *tag, int id, ns1__addDataFileParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addDataFileParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addDataFileParameter ** SOAP_FMAC4 soap_in_PointerTons1__addDataFileParameter(struct soap *soap, const char *tag, ns1__addDataFileParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addDataFileParameter **)soap_malloc(soap, sizeof(ns1__addDataFileParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addDataFileParameter *)soap_instantiate_ns1__addDataFileParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addDataFileParameter ** p = (ns1__addDataFileParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParameter, sizeof(ns1__addDataFileParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addDataFileParameter(struct soap *soap, ns1__addDataFileParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addDataFileParameter);
	if (soap_out_PointerTons1__addDataFileParameter(soap, tag?tag:"ns1:addDataFileParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addDataFileParameter ** SOAP_FMAC4 soap_get_PointerTons1__addDataFileParameter(struct soap *soap, ns1__addDataFileParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addDataFileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatafileResponse(struct soap *soap, ns1__getDatafileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatafileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatafileResponse(struct soap *soap, const char *tag, int id, ns1__getDatafileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatafileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatafileResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDatafileResponse(struct soap *soap, const char *tag, ns1__getDatafileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatafileResponse **)soap_malloc(soap, sizeof(ns1__getDatafileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatafileResponse *)soap_instantiate_ns1__getDatafileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatafileResponse ** p = (ns1__getDatafileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafileResponse, sizeof(ns1__getDatafileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatafileResponse(struct soap *soap, ns1__getDatafileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatafileResponse);
	if (soap_out_PointerTons1__getDatafileResponse(soap, tag?tag:"ns1:getDatafileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatafileResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDatafileResponse(struct soap *soap, ns1__getDatafileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatafileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatafile(struct soap *soap, ns1__getDatafile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatafile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatafile(struct soap *soap, const char *tag, int id, ns1__getDatafile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatafile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatafile ** SOAP_FMAC4 soap_in_PointerTons1__getDatafile(struct soap *soap, const char *tag, ns1__getDatafile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatafile **)soap_malloc(soap, sizeof(ns1__getDatafile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatafile *)soap_instantiate_ns1__getDatafile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatafile ** p = (ns1__getDatafile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafile, sizeof(ns1__getDatafile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatafile(struct soap *soap, ns1__getDatafile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatafile);
	if (soap_out_PointerTons1__getDatafile(soap, tag?tag:"ns1:getDatafile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatafile ** SOAP_FMAC4 soap_get_PointerTons1__getDatafile(struct soap *soap, ns1__getDatafile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatasetIncludesResponse(struct soap *soap, ns1__getDatasetIncludesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatasetIncludesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatasetIncludesResponse(struct soap *soap, const char *tag, int id, ns1__getDatasetIncludesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatasetIncludesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatasetIncludesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDatasetIncludesResponse(struct soap *soap, const char *tag, ns1__getDatasetIncludesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatasetIncludesResponse **)soap_malloc(soap, sizeof(ns1__getDatasetIncludesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatasetIncludesResponse *)soap_instantiate_ns1__getDatasetIncludesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatasetIncludesResponse ** p = (ns1__getDatasetIncludesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetIncludesResponse, sizeof(ns1__getDatasetIncludesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatasetIncludesResponse(struct soap *soap, ns1__getDatasetIncludesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatasetIncludesResponse);
	if (soap_out_PointerTons1__getDatasetIncludesResponse(soap, tag?tag:"ns1:getDatasetIncludesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatasetIncludesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDatasetIncludesResponse(struct soap *soap, ns1__getDatasetIncludesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatasetIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatasetIncludes(struct soap *soap, ns1__getDatasetIncludes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatasetIncludes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatasetIncludes(struct soap *soap, const char *tag, int id, ns1__getDatasetIncludes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatasetIncludes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatasetIncludes ** SOAP_FMAC4 soap_in_PointerTons1__getDatasetIncludes(struct soap *soap, const char *tag, ns1__getDatasetIncludes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatasetIncludes **)soap_malloc(soap, sizeof(ns1__getDatasetIncludes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatasetIncludes *)soap_instantiate_ns1__getDatasetIncludes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatasetIncludes ** p = (ns1__getDatasetIncludes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetIncludes, sizeof(ns1__getDatasetIncludes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatasetIncludes(struct soap *soap, ns1__getDatasetIncludes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatasetIncludes);
	if (soap_out_PointerTons1__getDatasetIncludes(soap, tag?tag:"ns1:getDatasetIncludes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatasetIncludes ** SOAP_FMAC4 soap_get_PointerTons1__getDatasetIncludes(struct soap *soap, ns1__getDatasetIncludes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatasetIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDatasetResponse(struct soap *soap, ns1__getDatasetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDatasetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDatasetResponse(struct soap *soap, const char *tag, int id, ns1__getDatasetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDatasetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDatasetResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDatasetResponse(struct soap *soap, const char *tag, ns1__getDatasetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDatasetResponse **)soap_malloc(soap, sizeof(ns1__getDatasetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDatasetResponse *)soap_instantiate_ns1__getDatasetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDatasetResponse ** p = (ns1__getDatasetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetResponse, sizeof(ns1__getDatasetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDatasetResponse(struct soap *soap, ns1__getDatasetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDatasetResponse);
	if (soap_out_PointerTons1__getDatasetResponse(soap, tag?tag:"ns1:getDatasetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDatasetResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDatasetResponse(struct soap *soap, ns1__getDatasetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDatasetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDataset(struct soap *soap, ns1__getDataset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDataset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDataset(struct soap *soap, const char *tag, int id, ns1__getDataset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDataset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDataset ** SOAP_FMAC4 soap_in_PointerTons1__getDataset(struct soap *soap, const char *tag, ns1__getDataset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDataset **)soap_malloc(soap, sizeof(ns1__getDataset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDataset *)soap_instantiate_ns1__getDataset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDataset ** p = (ns1__getDataset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDataset, sizeof(ns1__getDataset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDataset(struct soap *soap, ns1__getDataset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDataset);
	if (soap_out_PointerTons1__getDataset(soap, tag?tag:"ns1:getDataset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDataset ** SOAP_FMAC4 soap_get_PointerTons1__getDataset(struct soap *soap, ns1__getDataset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getInvestigationIncludesResponse(struct soap *soap, ns1__getInvestigationIncludesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getInvestigationIncludesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getInvestigationIncludesResponse(struct soap *soap, const char *tag, int id, ns1__getInvestigationIncludesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getInvestigationIncludesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getInvestigationIncludesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getInvestigationIncludesResponse(struct soap *soap, const char *tag, ns1__getInvestigationIncludesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getInvestigationIncludesResponse **)soap_malloc(soap, sizeof(ns1__getInvestigationIncludesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getInvestigationIncludesResponse *)soap_instantiate_ns1__getInvestigationIncludesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getInvestigationIncludesResponse ** p = (ns1__getInvestigationIncludesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationIncludesResponse, sizeof(ns1__getInvestigationIncludesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getInvestigationIncludesResponse(struct soap *soap, ns1__getInvestigationIncludesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getInvestigationIncludesResponse);
	if (soap_out_PointerTons1__getInvestigationIncludesResponse(soap, tag?tag:"ns1:getInvestigationIncludesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getInvestigationIncludesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getInvestigationIncludesResponse(struct soap *soap, ns1__getInvestigationIncludesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getInvestigationIncludesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getInvestigationIncludes(struct soap *soap, ns1__getInvestigationIncludes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getInvestigationIncludes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getInvestigationIncludes(struct soap *soap, const char *tag, int id, ns1__getInvestigationIncludes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getInvestigationIncludes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getInvestigationIncludes ** SOAP_FMAC4 soap_in_PointerTons1__getInvestigationIncludes(struct soap *soap, const char *tag, ns1__getInvestigationIncludes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getInvestigationIncludes **)soap_malloc(soap, sizeof(ns1__getInvestigationIncludes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getInvestigationIncludes *)soap_instantiate_ns1__getInvestigationIncludes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getInvestigationIncludes ** p = (ns1__getInvestigationIncludes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationIncludes, sizeof(ns1__getInvestigationIncludes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getInvestigationIncludes(struct soap *soap, ns1__getInvestigationIncludes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getInvestigationIncludes);
	if (soap_out_PointerTons1__getInvestigationIncludes(soap, tag?tag:"ns1:getInvestigationIncludes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getInvestigationIncludes ** SOAP_FMAC4 soap_get_PointerTons1__getInvestigationIncludes(struct soap *soap, ns1__getInvestigationIncludes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getInvestigationIncludes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getInvestigationResponse(struct soap *soap, ns1__getInvestigationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getInvestigationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getInvestigationResponse(struct soap *soap, const char *tag, int id, ns1__getInvestigationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getInvestigationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getInvestigationResponse ** SOAP_FMAC4 soap_in_PointerTons1__getInvestigationResponse(struct soap *soap, const char *tag, ns1__getInvestigationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getInvestigationResponse **)soap_malloc(soap, sizeof(ns1__getInvestigationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getInvestigationResponse *)soap_instantiate_ns1__getInvestigationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getInvestigationResponse ** p = (ns1__getInvestigationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationResponse, sizeof(ns1__getInvestigationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getInvestigationResponse(struct soap *soap, ns1__getInvestigationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getInvestigationResponse);
	if (soap_out_PointerTons1__getInvestigationResponse(soap, tag?tag:"ns1:getInvestigationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getInvestigationResponse ** SOAP_FMAC4 soap_get_PointerTons1__getInvestigationResponse(struct soap *soap, ns1__getInvestigationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getInvestigationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getInvestigation(struct soap *soap, ns1__getInvestigation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getInvestigation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getInvestigation(struct soap *soap, const char *tag, int id, ns1__getInvestigation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getInvestigation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getInvestigation ** SOAP_FMAC4 soap_in_PointerTons1__getInvestigation(struct soap *soap, const char *tag, ns1__getInvestigation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getInvestigation **)soap_malloc(soap, sizeof(ns1__getInvestigation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getInvestigation *)soap_instantiate_ns1__getInvestigation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getInvestigation ** p = (ns1__getInvestigation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigation, sizeof(ns1__getInvestigation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getInvestigation(struct soap *soap, ns1__getInvestigation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getInvestigation);
	if (soap_out_PointerTons1__getInvestigation(soap, tag?tag:"ns1:getInvestigation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getInvestigation ** SOAP_FMAC4 soap_get_PointerTons1__getInvestigation(struct soap *soap, ns1__getInvestigation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getInvestigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addInvestigatorResponse(struct soap *soap, ns1__addInvestigatorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addInvestigatorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addInvestigatorResponse(struct soap *soap, const char *tag, int id, ns1__addInvestigatorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addInvestigatorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addInvestigatorResponse ** SOAP_FMAC4 soap_in_PointerTons1__addInvestigatorResponse(struct soap *soap, const char *tag, ns1__addInvestigatorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addInvestigatorResponse **)soap_malloc(soap, sizeof(ns1__addInvestigatorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addInvestigatorResponse *)soap_instantiate_ns1__addInvestigatorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addInvestigatorResponse ** p = (ns1__addInvestigatorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addInvestigatorResponse, sizeof(ns1__addInvestigatorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addInvestigatorResponse(struct soap *soap, ns1__addInvestigatorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addInvestigatorResponse);
	if (soap_out_PointerTons1__addInvestigatorResponse(soap, tag?tag:"ns1:addInvestigatorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addInvestigatorResponse ** SOAP_FMAC4 soap_get_PointerTons1__addInvestigatorResponse(struct soap *soap, ns1__addInvestigatorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addInvestigatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addInvestigator(struct soap *soap, ns1__addInvestigator *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addInvestigator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addInvestigator(struct soap *soap, const char *tag, int id, ns1__addInvestigator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addInvestigator);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addInvestigator ** SOAP_FMAC4 soap_in_PointerTons1__addInvestigator(struct soap *soap, const char *tag, ns1__addInvestigator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addInvestigator **)soap_malloc(soap, sizeof(ns1__addInvestigator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addInvestigator *)soap_instantiate_ns1__addInvestigator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addInvestigator ** p = (ns1__addInvestigator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addInvestigator, sizeof(ns1__addInvestigator), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addInvestigator(struct soap *soap, ns1__addInvestigator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addInvestigator);
	if (soap_out_PointerTons1__addInvestigator(soap, tag?tag:"ns1:addInvestigator", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addInvestigator ** SOAP_FMAC4 soap_get_PointerTons1__addInvestigator(struct soap *soap, ns1__addInvestigator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addInvestigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addKeywordResponse(struct soap *soap, ns1__addKeywordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addKeywordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addKeywordResponse(struct soap *soap, const char *tag, int id, ns1__addKeywordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addKeywordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addKeywordResponse ** SOAP_FMAC4 soap_in_PointerTons1__addKeywordResponse(struct soap *soap, const char *tag, ns1__addKeywordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addKeywordResponse **)soap_malloc(soap, sizeof(ns1__addKeywordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addKeywordResponse *)soap_instantiate_ns1__addKeywordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addKeywordResponse ** p = (ns1__addKeywordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addKeywordResponse, sizeof(ns1__addKeywordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addKeywordResponse(struct soap *soap, ns1__addKeywordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addKeywordResponse);
	if (soap_out_PointerTons1__addKeywordResponse(soap, tag?tag:"ns1:addKeywordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addKeywordResponse ** SOAP_FMAC4 soap_get_PointerTons1__addKeywordResponse(struct soap *soap, ns1__addKeywordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addKeywordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addKeyword(struct soap *soap, ns1__addKeyword *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addKeyword))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addKeyword(struct soap *soap, const char *tag, int id, ns1__addKeyword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addKeyword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addKeyword ** SOAP_FMAC4 soap_in_PointerTons1__addKeyword(struct soap *soap, const char *tag, ns1__addKeyword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addKeyword **)soap_malloc(soap, sizeof(ns1__addKeyword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addKeyword *)soap_instantiate_ns1__addKeyword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addKeyword ** p = (ns1__addKeyword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addKeyword, sizeof(ns1__addKeyword), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addKeyword(struct soap *soap, ns1__addKeyword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addKeyword);
	if (soap_out_PointerTons1__addKeyword(soap, tag?tag:"ns1:addKeyword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addKeyword ** SOAP_FMAC4 soap_get_PointerTons1__addKeyword(struct soap *soap, ns1__addKeyword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addKeyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addPublicationResponse(struct soap *soap, ns1__addPublicationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addPublicationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addPublicationResponse(struct soap *soap, const char *tag, int id, ns1__addPublicationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addPublicationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addPublicationResponse ** SOAP_FMAC4 soap_in_PointerTons1__addPublicationResponse(struct soap *soap, const char *tag, ns1__addPublicationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addPublicationResponse **)soap_malloc(soap, sizeof(ns1__addPublicationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addPublicationResponse *)soap_instantiate_ns1__addPublicationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addPublicationResponse ** p = (ns1__addPublicationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addPublicationResponse, sizeof(ns1__addPublicationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addPublicationResponse(struct soap *soap, ns1__addPublicationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addPublicationResponse);
	if (soap_out_PointerTons1__addPublicationResponse(soap, tag?tag:"ns1:addPublicationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addPublicationResponse ** SOAP_FMAC4 soap_get_PointerTons1__addPublicationResponse(struct soap *soap, ns1__addPublicationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addPublicationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addPublication(struct soap *soap, ns1__addPublication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addPublication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addPublication(struct soap *soap, const char *tag, int id, ns1__addPublication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addPublication);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addPublication ** SOAP_FMAC4 soap_in_PointerTons1__addPublication(struct soap *soap, const char *tag, ns1__addPublication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addPublication **)soap_malloc(soap, sizeof(ns1__addPublication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addPublication *)soap_instantiate_ns1__addPublication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addPublication ** p = (ns1__addPublication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addPublication, sizeof(ns1__addPublication), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addPublication(struct soap *soap, ns1__addPublication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addPublication);
	if (soap_out_PointerTons1__addPublication(soap, tag?tag:"ns1:addPublication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addPublication ** SOAP_FMAC4 soap_get_PointerTons1__addPublication(struct soap *soap, ns1__addPublication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addPublication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addSampleParameterResponse(struct soap *soap, ns1__addSampleParameterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addSampleParameterResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addSampleParameterResponse(struct soap *soap, const char *tag, int id, ns1__addSampleParameterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addSampleParameterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addSampleParameterResponse ** SOAP_FMAC4 soap_in_PointerTons1__addSampleParameterResponse(struct soap *soap, const char *tag, ns1__addSampleParameterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addSampleParameterResponse **)soap_malloc(soap, sizeof(ns1__addSampleParameterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addSampleParameterResponse *)soap_instantiate_ns1__addSampleParameterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addSampleParameterResponse ** p = (ns1__addSampleParameterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSampleParameterResponse, sizeof(ns1__addSampleParameterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addSampleParameterResponse(struct soap *soap, ns1__addSampleParameterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addSampleParameterResponse);
	if (soap_out_PointerTons1__addSampleParameterResponse(soap, tag?tag:"ns1:addSampleParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addSampleParameterResponse ** SOAP_FMAC4 soap_get_PointerTons1__addSampleParameterResponse(struct soap *soap, ns1__addSampleParameterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addSampleParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addSampleParameter(struct soap *soap, ns1__addSampleParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addSampleParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addSampleParameter(struct soap *soap, const char *tag, int id, ns1__addSampleParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addSampleParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addSampleParameter ** SOAP_FMAC4 soap_in_PointerTons1__addSampleParameter(struct soap *soap, const char *tag, ns1__addSampleParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addSampleParameter **)soap_malloc(soap, sizeof(ns1__addSampleParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addSampleParameter *)soap_instantiate_ns1__addSampleParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addSampleParameter ** p = (ns1__addSampleParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSampleParameter, sizeof(ns1__addSampleParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addSampleParameter(struct soap *soap, ns1__addSampleParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addSampleParameter);
	if (soap_out_PointerTons1__addSampleParameter(soap, tag?tag:"ns1:addSampleParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addSampleParameter ** SOAP_FMAC4 soap_get_PointerTons1__addSampleParameter(struct soap *soap, ns1__addSampleParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addSampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logoutResponse(struct soap *soap, const char *tag, int id, ns1__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logoutResponse ** SOAP_FMAC4 soap_in_PointerTons1__logoutResponse(struct soap *soap, const char *tag, ns1__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__logoutResponse **)soap_malloc(soap, sizeof(ns1__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__logoutResponse *)soap_instantiate_ns1__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__logoutResponse ** p = (ns1__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logoutResponse);
	if (soap_out_PointerTons1__logoutResponse(soap, tag?tag:"ns1:logoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logoutResponse ** SOAP_FMAC4 soap_get_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logout(struct soap *soap, ns1__logout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logout(struct soap *soap, const char *tag, int id, ns1__logout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_in_PointerTons1__logout(struct soap *soap, const char *tag, ns1__logout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__logout **)soap_malloc(soap, sizeof(ns1__logout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__logout *)soap_instantiate_ns1__logout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__logout ** p = (ns1__logout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logout(struct soap *soap, ns1__logout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logout);
	if (soap_out_PointerTons1__logout(soap, tag?tag:"ns1:logout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_get_PointerTons1__logout(struct soap *soap, ns1__logout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addSampleResponse(struct soap *soap, ns1__addSampleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addSampleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addSampleResponse(struct soap *soap, const char *tag, int id, ns1__addSampleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addSampleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addSampleResponse ** SOAP_FMAC4 soap_in_PointerTons1__addSampleResponse(struct soap *soap, const char *tag, ns1__addSampleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addSampleResponse **)soap_malloc(soap, sizeof(ns1__addSampleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addSampleResponse *)soap_instantiate_ns1__addSampleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addSampleResponse ** p = (ns1__addSampleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSampleResponse, sizeof(ns1__addSampleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addSampleResponse(struct soap *soap, ns1__addSampleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addSampleResponse);
	if (soap_out_PointerTons1__addSampleResponse(soap, tag?tag:"ns1:addSampleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addSampleResponse ** SOAP_FMAC4 soap_get_PointerTons1__addSampleResponse(struct soap *soap, ns1__addSampleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addSampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addSample(struct soap *soap, ns1__addSample *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addSample))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addSample(struct soap *soap, const char *tag, int id, ns1__addSample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addSample);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addSample ** SOAP_FMAC4 soap_in_PointerTons1__addSample(struct soap *soap, const char *tag, ns1__addSample **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addSample **)soap_malloc(soap, sizeof(ns1__addSample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addSample *)soap_instantiate_ns1__addSample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addSample ** p = (ns1__addSample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSample, sizeof(ns1__addSample), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addSample(struct soap *soap, ns1__addSample *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addSample);
	if (soap_out_PointerTons1__addSample(soap, tag?tag:"ns1:addSample", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__addSample ** SOAP_FMAC4 soap_get_PointerTons1__addSample(struct soap *soap, ns1__addSample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addSample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loginLifetimeResponse(struct soap *soap, ns1__loginLifetimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loginLifetimeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loginLifetimeResponse(struct soap *soap, const char *tag, int id, ns1__loginLifetimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loginLifetimeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__loginLifetimeResponse ** SOAP_FMAC4 soap_in_PointerTons1__loginLifetimeResponse(struct soap *soap, const char *tag, ns1__loginLifetimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__loginLifetimeResponse **)soap_malloc(soap, sizeof(ns1__loginLifetimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__loginLifetimeResponse *)soap_instantiate_ns1__loginLifetimeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__loginLifetimeResponse ** p = (ns1__loginLifetimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginLifetimeResponse, sizeof(ns1__loginLifetimeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loginLifetimeResponse(struct soap *soap, ns1__loginLifetimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__loginLifetimeResponse);
	if (soap_out_PointerTons1__loginLifetimeResponse(soap, tag?tag:"ns1:loginLifetimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__loginLifetimeResponse ** SOAP_FMAC4 soap_get_PointerTons1__loginLifetimeResponse(struct soap *soap, ns1__loginLifetimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loginLifetimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loginLifetime(struct soap *soap, ns1__loginLifetime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loginLifetime))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loginLifetime(struct soap *soap, const char *tag, int id, ns1__loginLifetime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loginLifetime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__loginLifetime ** SOAP_FMAC4 soap_in_PointerTons1__loginLifetime(struct soap *soap, const char *tag, ns1__loginLifetime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__loginLifetime **)soap_malloc(soap, sizeof(ns1__loginLifetime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__loginLifetime *)soap_instantiate_ns1__loginLifetime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__loginLifetime ** p = (ns1__loginLifetime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginLifetime, sizeof(ns1__loginLifetime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loginLifetime(struct soap *soap, ns1__loginLifetime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__loginLifetime);
	if (soap_out_PointerTons1__loginLifetime(soap, tag?tag:"ns1:loginLifetime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__loginLifetime ** SOAP_FMAC4 soap_get_PointerTons1__loginLifetime(struct soap *soap, ns1__loginLifetime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loginLifetime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loginResponse(struct soap *soap, const char *tag, int id, ns1__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTons1__loginResponse(struct soap *soap, const char *tag, ns1__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__loginResponse **)soap_malloc(soap, sizeof(ns1__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__loginResponse *)soap_instantiate_ns1__loginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__loginResponse ** p = (ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginResponse, sizeof(ns1__loginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__loginResponse);
	if (soap_out_PointerTons1__loginResponse(soap, tag?tag:"ns1:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__login(struct soap *soap, ns1__login *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__login))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__login(struct soap *soap, const char *tag, int id, ns1__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__login);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__login ** SOAP_FMAC4 soap_in_PointerTons1__login(struct soap *soap, const char *tag, ns1__login **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__login **)soap_malloc(soap, sizeof(ns1__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__login *)soap_instantiate_ns1__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__login ** p = (ns1__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__login, sizeof(ns1__login), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__login(struct soap *soap, ns1__login *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__login);
	if (soap_out_PointerTons1__login(soap, tag?tag:"ns1:login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__login ** SOAP_FMAC4 soap_get_PointerTons1__login(struct soap *soap, ns1__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValidationException(struct soap *soap, ns1__ValidationException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValidationException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValidationException(struct soap *soap, const char *tag, int id, ns1__ValidationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValidationException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ValidationException ** SOAP_FMAC4 soap_in_PointerTons1__ValidationException(struct soap *soap, const char *tag, ns1__ValidationException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValidationException **)soap_malloc(soap, sizeof(ns1__ValidationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValidationException *)soap_instantiate_ns1__ValidationException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ValidationException ** p = (ns1__ValidationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValidationException, sizeof(ns1__ValidationException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValidationException(struct soap *soap, ns1__ValidationException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ValidationException);
	if (soap_out_PointerTons1__ValidationException(soap, tag?tag:"ns1:ValidationException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValidationException ** SOAP_FMAC4 soap_get_PointerTons1__ValidationException(struct soap *soap, ns1__ValidationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValidationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SessionException(struct soap *soap, ns3__SessionException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__SessionException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SessionException(struct soap *soap, const char *tag, int id, ns3__SessionException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__SessionException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__SessionException ** SOAP_FMAC4 soap_in_PointerTons3__SessionException(struct soap *soap, const char *tag, ns3__SessionException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__SessionException **)soap_malloc(soap, sizeof(ns3__SessionException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__SessionException *)soap_instantiate_ns3__SessionException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__SessionException ** p = (ns3__SessionException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SessionException, sizeof(ns3__SessionException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SessionException(struct soap *soap, ns3__SessionException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__SessionException);
	if (soap_out_PointerTons3__SessionException(soap, tag?tag:"ns3:SessionException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__SessionException ** SOAP_FMAC4 soap_get_PointerTons3__SessionException(struct soap *soap, ns3__SessionException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__SessionException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NoSuchUserException(struct soap *soap, ns1__NoSuchUserException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NoSuchUserException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NoSuchUserException(struct soap *soap, const char *tag, int id, ns1__NoSuchUserException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NoSuchUserException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NoSuchUserException ** SOAP_FMAC4 soap_in_PointerTons1__NoSuchUserException(struct soap *soap, const char *tag, ns1__NoSuchUserException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NoSuchUserException **)soap_malloc(soap, sizeof(ns1__NoSuchUserException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NoSuchUserException *)soap_instantiate_ns1__NoSuchUserException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__NoSuchUserException ** p = (ns1__NoSuchUserException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoSuchUserException, sizeof(ns1__NoSuchUserException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NoSuchUserException(struct soap *soap, ns1__NoSuchUserException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NoSuchUserException);
	if (soap_out_PointerTons1__NoSuchUserException(soap, tag?tag:"ns1:NoSuchUserException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NoSuchUserException ** SOAP_FMAC4 soap_get_PointerTons1__NoSuchUserException(struct soap *soap, ns1__NoSuchUserException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NoSuchUserException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NoSuchObjectFoundException(struct soap *soap, ns1__NoSuchObjectFoundException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NoSuchObjectFoundException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NoSuchObjectFoundException(struct soap *soap, const char *tag, int id, ns1__NoSuchObjectFoundException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NoSuchObjectFoundException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NoSuchObjectFoundException ** SOAP_FMAC4 soap_in_PointerTons1__NoSuchObjectFoundException(struct soap *soap, const char *tag, ns1__NoSuchObjectFoundException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NoSuchObjectFoundException **)soap_malloc(soap, sizeof(ns1__NoSuchObjectFoundException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NoSuchObjectFoundException *)soap_instantiate_ns1__NoSuchObjectFoundException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__NoSuchObjectFoundException ** p = (ns1__NoSuchObjectFoundException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoSuchObjectFoundException, sizeof(ns1__NoSuchObjectFoundException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NoSuchObjectFoundException(struct soap *soap, ns1__NoSuchObjectFoundException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NoSuchObjectFoundException);
	if (soap_out_PointerTons1__NoSuchObjectFoundException(soap, tag?tag:"ns1:NoSuchObjectFoundException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NoSuchObjectFoundException ** SOAP_FMAC4 soap_get_PointerTons1__NoSuchObjectFoundException(struct soap *soap, ns1__NoSuchObjectFoundException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NoSuchObjectFoundException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InsufficientPrivilegesException(struct soap *soap, ns1__InsufficientPrivilegesException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InsufficientPrivilegesException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InsufficientPrivilegesException(struct soap *soap, const char *tag, int id, ns1__InsufficientPrivilegesException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InsufficientPrivilegesException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__InsufficientPrivilegesException ** SOAP_FMAC4 soap_in_PointerTons1__InsufficientPrivilegesException(struct soap *soap, const char *tag, ns1__InsufficientPrivilegesException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InsufficientPrivilegesException **)soap_malloc(soap, sizeof(ns1__InsufficientPrivilegesException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InsufficientPrivilegesException *)soap_instantiate_ns1__InsufficientPrivilegesException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__InsufficientPrivilegesException ** p = (ns1__InsufficientPrivilegesException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InsufficientPrivilegesException, sizeof(ns1__InsufficientPrivilegesException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InsufficientPrivilegesException(struct soap *soap, ns1__InsufficientPrivilegesException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__InsufficientPrivilegesException);
	if (soap_out_PointerTons1__InsufficientPrivilegesException(soap, tag?tag:"ns1:InsufficientPrivilegesException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InsufficientPrivilegesException ** SOAP_FMAC4 soap_get_PointerTons1__InsufficientPrivilegesException(struct soap *soap, ns1__InsufficientPrivilegesException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InsufficientPrivilegesException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ICATAPIException(struct soap *soap, ns1__ICATAPIException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ICATAPIException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ICATAPIException(struct soap *soap, const char *tag, int id, ns1__ICATAPIException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ICATAPIException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ICATAPIException ** SOAP_FMAC4 soap_in_PointerTons1__ICATAPIException(struct soap *soap, const char *tag, ns1__ICATAPIException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ICATAPIException **)soap_malloc(soap, sizeof(ns1__ICATAPIException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ICATAPIException *)soap_instantiate_ns1__ICATAPIException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ICATAPIException ** p = (ns1__ICATAPIException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ICATAPIException, sizeof(ns1__ICATAPIException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ICATAPIException(struct soap *soap, ns1__ICATAPIException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ICATAPIException);
	if (soap_out_PointerTons1__ICATAPIException(soap, tag?tag:"ns1:ICATAPIException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ICATAPIException ** SOAP_FMAC4 soap_get_PointerTons1__ICATAPIException(struct soap *soap, ns1__ICATAPIException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ICATAPIException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__shiftPK(struct soap *soap, ns1__shiftPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__shiftPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__shiftPK(struct soap *soap, const char *tag, int id, ns1__shiftPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__shiftPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__shiftPK ** SOAP_FMAC4 soap_in_PointerTons1__shiftPK(struct soap *soap, const char *tag, ns1__shiftPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__shiftPK **)soap_malloc(soap, sizeof(ns1__shiftPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__shiftPK *)soap_instantiate_ns1__shiftPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__shiftPK ** p = (ns1__shiftPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__shiftPK, sizeof(ns1__shiftPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__shiftPK(struct soap *soap, ns1__shiftPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__shiftPK);
	if (soap_out_PointerTons1__shiftPK(soap, tag?tag:"ns1:shiftPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__shiftPK ** SOAP_FMAC4 soap_get_PointerTons1__shiftPK(struct soap *soap, ns1__shiftPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__shiftPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__shift(struct soap *soap, ns1__shift *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__shift))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__shift(struct soap *soap, const char *tag, int id, ns1__shift *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__shift);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__shift ** SOAP_FMAC4 soap_in_PointerTons1__shift(struct soap *soap, const char *tag, ns1__shift **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__shift **)soap_malloc(soap, sizeof(ns1__shift *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__shift *)soap_instantiate_ns1__shift(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__shift ** p = (ns1__shift **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__shift, sizeof(ns1__shift), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__shift(struct soap *soap, ns1__shift *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__shift);
	if (soap_out_PointerTons1__shift(soap, tag?tag:"ns1:shift", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__shift ** SOAP_FMAC4 soap_get_PointerTons1__shift(struct soap *soap, ns1__shift **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__shift(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__parameterPK(struct soap *soap, ns1__parameterPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__parameterPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__parameterPK(struct soap *soap, const char *tag, int id, ns1__parameterPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__parameterPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__parameterPK ** SOAP_FMAC4 soap_in_PointerTons1__parameterPK(struct soap *soap, const char *tag, ns1__parameterPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__parameterPK **)soap_malloc(soap, sizeof(ns1__parameterPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__parameterPK *)soap_instantiate_ns1__parameterPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__parameterPK ** p = (ns1__parameterPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__parameterPK, sizeof(ns1__parameterPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__parameterPK(struct soap *soap, ns1__parameterPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__parameterPK);
	if (soap_out_PointerTons1__parameterPK(soap, tag?tag:"ns1:parameterPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__parameterPK ** SOAP_FMAC4 soap_get_PointerTons1__parameterPK(struct soap *soap, ns1__parameterPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__parameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__relatedDatafilesPK(struct soap *soap, ns1__relatedDatafilesPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__relatedDatafilesPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__relatedDatafilesPK(struct soap *soap, const char *tag, int id, ns1__relatedDatafilesPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__relatedDatafilesPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__relatedDatafilesPK ** SOAP_FMAC4 soap_in_PointerTons1__relatedDatafilesPK(struct soap *soap, const char *tag, ns1__relatedDatafilesPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__relatedDatafilesPK **)soap_malloc(soap, sizeof(ns1__relatedDatafilesPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__relatedDatafilesPK *)soap_instantiate_ns1__relatedDatafilesPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__relatedDatafilesPK ** p = (ns1__relatedDatafilesPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__relatedDatafilesPK, sizeof(ns1__relatedDatafilesPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__relatedDatafilesPK(struct soap *soap, ns1__relatedDatafilesPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__relatedDatafilesPK);
	if (soap_out_PointerTons1__relatedDatafilesPK(soap, tag?tag:"ns1:relatedDatafilesPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__relatedDatafilesPK ** SOAP_FMAC4 soap_get_PointerTons1__relatedDatafilesPK(struct soap *soap, ns1__relatedDatafilesPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__relatedDatafilesPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafileFormatPK(struct soap *soap, ns1__datafileFormatPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__datafileFormatPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafileFormatPK(struct soap *soap, const char *tag, int id, ns1__datafileFormatPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datafileFormatPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafileFormatPK ** SOAP_FMAC4 soap_in_PointerTons1__datafileFormatPK(struct soap *soap, const char *tag, ns1__datafileFormatPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__datafileFormatPK **)soap_malloc(soap, sizeof(ns1__datafileFormatPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__datafileFormatPK *)soap_instantiate_ns1__datafileFormatPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__datafileFormatPK ** p = (ns1__datafileFormatPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileFormatPK, sizeof(ns1__datafileFormatPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafileFormatPK(struct soap *soap, ns1__datafileFormatPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datafileFormatPK);
	if (soap_out_PointerTons1__datafileFormatPK(soap, tag?tag:"ns1:datafileFormatPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafileFormatPK ** SOAP_FMAC4 soap_get_PointerTons1__datafileFormatPK(struct soap *soap, ns1__datafileFormatPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datafileFormatPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__relatedDatafiles(struct soap *soap, ns1__relatedDatafiles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__relatedDatafiles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__relatedDatafiles(struct soap *soap, const char *tag, int id, ns1__relatedDatafiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__relatedDatafiles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__relatedDatafiles ** SOAP_FMAC4 soap_in_PointerTons1__relatedDatafiles(struct soap *soap, const char *tag, ns1__relatedDatafiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__relatedDatafiles **)soap_malloc(soap, sizeof(ns1__relatedDatafiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__relatedDatafiles *)soap_instantiate_ns1__relatedDatafiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__relatedDatafiles ** p = (ns1__relatedDatafiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__relatedDatafiles, sizeof(ns1__relatedDatafiles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__relatedDatafiles(struct soap *soap, ns1__relatedDatafiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__relatedDatafiles);
	if (soap_out_PointerTons1__relatedDatafiles(soap, tag?tag:"ns1:relatedDatafiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__relatedDatafiles ** SOAP_FMAC4 soap_get_PointerTons1__relatedDatafiles(struct soap *soap, ns1__relatedDatafiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__relatedDatafiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafileInclude(struct soap *soap, enum ns1__datafileInclude *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__datafileInclude);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafileInclude(struct soap *soap, const char *tag, int id, enum ns1__datafileInclude *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datafileInclude);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__datafileInclude(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__datafileInclude ** SOAP_FMAC4 soap_in_PointerTons1__datafileInclude(struct soap *soap, const char *tag, enum ns1__datafileInclude **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__datafileInclude **)soap_malloc(soap, sizeof(enum ns1__datafileInclude *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__datafileInclude(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__datafileInclude **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileInclude, sizeof(enum ns1__datafileInclude), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafileInclude(struct soap *soap, enum ns1__datafileInclude *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datafileInclude);
	if (soap_out_PointerTons1__datafileInclude(soap, tag?tag:"ns1:datafileInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__datafileInclude ** SOAP_FMAC4 soap_get_PointerTons1__datafileInclude(struct soap *soap, enum ns1__datafileInclude **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datafileInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__parameter(struct soap *soap, ns1__parameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__parameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__parameter(struct soap *soap, const char *tag, int id, ns1__parameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__parameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__parameter ** SOAP_FMAC4 soap_in_PointerTons1__parameter(struct soap *soap, const char *tag, ns1__parameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__parameter **)soap_malloc(soap, sizeof(ns1__parameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__parameter *)soap_instantiate_ns1__parameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__parameter ** p = (ns1__parameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__parameter, sizeof(ns1__parameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__parameter(struct soap *soap, ns1__parameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__parameter);
	if (soap_out_PointerTons1__parameter(soap, tag?tag:"ns1:parameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__parameter ** SOAP_FMAC4 soap_get_PointerTons1__parameter(struct soap *soap, ns1__parameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datasetInclude(struct soap *soap, enum ns1__datasetInclude *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__datasetInclude);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datasetInclude(struct soap *soap, const char *tag, int id, enum ns1__datasetInclude *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datasetInclude);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__datasetInclude(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__datasetInclude ** SOAP_FMAC4 soap_in_PointerTons1__datasetInclude(struct soap *soap, const char *tag, enum ns1__datasetInclude **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__datasetInclude **)soap_malloc(soap, sizeof(enum ns1__datasetInclude *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__datasetInclude(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__datasetInclude **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datasetInclude, sizeof(enum ns1__datasetInclude), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datasetInclude(struct soap *soap, enum ns1__datasetInclude *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datasetInclude);
	if (soap_out_PointerTons1__datasetInclude(soap, tag?tag:"ns1:datasetInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__datasetInclude ** SOAP_FMAC4 soap_get_PointerTons1__datasetInclude(struct soap *soap, enum ns1__datasetInclude **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datasetInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafileFormat(struct soap *soap, ns1__datafileFormat *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__datafileFormat))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafileFormat(struct soap *soap, const char *tag, int id, ns1__datafileFormat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datafileFormat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafileFormat ** SOAP_FMAC4 soap_in_PointerTons1__datafileFormat(struct soap *soap, const char *tag, ns1__datafileFormat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__datafileFormat **)soap_malloc(soap, sizeof(ns1__datafileFormat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__datafileFormat *)soap_instantiate_ns1__datafileFormat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__datafileFormat ** p = (ns1__datafileFormat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileFormat, sizeof(ns1__datafileFormat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafileFormat(struct soap *soap, ns1__datafileFormat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datafileFormat);
	if (soap_out_PointerTons1__datafileFormat(soap, tag?tag:"ns1:datafileFormat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafileFormat ** SOAP_FMAC4 soap_get_PointerTons1__datafileFormat(struct soap *soap, ns1__datafileFormat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datafileFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__advancedSearchDetails(struct soap *soap, ns1__advancedSearchDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__advancedSearchDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__advancedSearchDetails(struct soap *soap, const char *tag, int id, ns1__advancedSearchDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__advancedSearchDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__advancedSearchDetails ** SOAP_FMAC4 soap_in_PointerTons1__advancedSearchDetails(struct soap *soap, const char *tag, ns1__advancedSearchDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__advancedSearchDetails **)soap_malloc(soap, sizeof(ns1__advancedSearchDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__advancedSearchDetails *)soap_instantiate_ns1__advancedSearchDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__advancedSearchDetails ** p = (ns1__advancedSearchDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__advancedSearchDetails, sizeof(ns1__advancedSearchDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__advancedSearchDetails(struct soap *soap, ns1__advancedSearchDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__advancedSearchDetails);
	if (soap_out_PointerTons1__advancedSearchDetails(soap, tag?tag:"ns1:advancedSearchDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__advancedSearchDetails ** SOAP_FMAC4 soap_get_PointerTons1__advancedSearchDetails(struct soap *soap, ns1__advancedSearchDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__advancedSearchDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__keyword(struct soap *soap, ns1__keyword *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__keyword))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__keyword(struct soap *soap, const char *tag, int id, ns1__keyword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__keyword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__keyword ** SOAP_FMAC4 soap_in_PointerTons1__keyword(struct soap *soap, const char *tag, ns1__keyword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__keyword **)soap_malloc(soap, sizeof(ns1__keyword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__keyword *)soap_instantiate_ns1__keyword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__keyword ** p = (ns1__keyword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keyword, sizeof(ns1__keyword), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__keyword(struct soap *soap, ns1__keyword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__keyword);
	if (soap_out_PointerTons1__keyword(soap, tag?tag:"ns1:keyword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__keyword ** SOAP_FMAC4 soap_get_PointerTons1__keyword(struct soap *soap, ns1__keyword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__keyword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__icatAuthorisation(struct soap *soap, ns1__icatAuthorisation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__icatAuthorisation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__icatAuthorisation(struct soap *soap, const char *tag, int id, ns1__icatAuthorisation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__icatAuthorisation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__icatAuthorisation ** SOAP_FMAC4 soap_in_PointerTons1__icatAuthorisation(struct soap *soap, const char *tag, ns1__icatAuthorisation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__icatAuthorisation **)soap_malloc(soap, sizeof(ns1__icatAuthorisation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__icatAuthorisation *)soap_instantiate_ns1__icatAuthorisation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__icatAuthorisation ** p = (ns1__icatAuthorisation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__icatAuthorisation, sizeof(ns1__icatAuthorisation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__icatAuthorisation(struct soap *soap, ns1__icatAuthorisation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__icatAuthorisation);
	if (soap_out_PointerTons1__icatAuthorisation(soap, tag?tag:"ns1:icatAuthorisation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__icatAuthorisation ** SOAP_FMAC4 soap_get_PointerTons1__icatAuthorisation(struct soap *soap, ns1__icatAuthorisation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__icatAuthorisation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__elementType(struct soap *soap, enum ns1__elementType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__elementType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__elementType(struct soap *soap, const char *tag, int id, enum ns1__elementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__elementType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__elementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__elementType ** SOAP_FMAC4 soap_in_PointerTons1__elementType(struct soap *soap, const char *tag, enum ns1__elementType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__elementType **)soap_malloc(soap, sizeof(enum ns1__elementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__elementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__elementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__elementType, sizeof(enum ns1__elementType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__elementType(struct soap *soap, enum ns1__elementType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__elementType);
	if (soap_out_PointerTons1__elementType(soap, tag?tag:"ns1:elementType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__elementType ** SOAP_FMAC4 soap_get_PointerTons1__elementType(struct soap *soap, enum ns1__elementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__elementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datasetParameter(struct soap *soap, ns1__datasetParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__datasetParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datasetParameter(struct soap *soap, const char *tag, int id, ns1__datasetParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datasetParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datasetParameter ** SOAP_FMAC4 soap_in_PointerTons1__datasetParameter(struct soap *soap, const char *tag, ns1__datasetParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__datasetParameter **)soap_malloc(soap, sizeof(ns1__datasetParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__datasetParameter *)soap_instantiate_ns1__datasetParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__datasetParameter ** p = (ns1__datasetParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datasetParameter, sizeof(ns1__datasetParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datasetParameter(struct soap *soap, ns1__datasetParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datasetParameter);
	if (soap_out_PointerTons1__datasetParameter(soap, tag?tag:"ns1:datasetParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datasetParameter ** SOAP_FMAC4 soap_get_PointerTons1__datasetParameter(struct soap *soap, ns1__datasetParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datasetParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sampleParameterPK(struct soap *soap, ns1__sampleParameterPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sampleParameterPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sampleParameterPK(struct soap *soap, const char *tag, int id, ns1__sampleParameterPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sampleParameterPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sampleParameterPK ** SOAP_FMAC4 soap_in_PointerTons1__sampleParameterPK(struct soap *soap, const char *tag, ns1__sampleParameterPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sampleParameterPK **)soap_malloc(soap, sizeof(ns1__sampleParameterPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sampleParameterPK *)soap_instantiate_ns1__sampleParameterPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sampleParameterPK ** p = (ns1__sampleParameterPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sampleParameterPK, sizeof(ns1__sampleParameterPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sampleParameterPK(struct soap *soap, ns1__sampleParameterPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sampleParameterPK);
	if (soap_out_PointerTons1__sampleParameterPK(soap, tag?tag:"ns1:sampleParameterPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sampleParameterPK ** SOAP_FMAC4 soap_get_PointerTons1__sampleParameterPK(struct soap *soap, ns1__sampleParameterPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sampleParameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigator(struct soap *soap, ns1__investigator *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__investigator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigator(struct soap *soap, const char *tag, int id, ns1__investigator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__investigator);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigator ** SOAP_FMAC4 soap_in_PointerTons1__investigator(struct soap *soap, const char *tag, ns1__investigator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__investigator **)soap_malloc(soap, sizeof(ns1__investigator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__investigator *)soap_instantiate_ns1__investigator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__investigator ** p = (ns1__investigator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigator, sizeof(ns1__investigator), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigator(struct soap *soap, ns1__investigator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__investigator);
	if (soap_out_PointerTons1__investigator(soap, tag?tag:"ns1:investigator", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigator ** SOAP_FMAC4 soap_get_PointerTons1__investigator(struct soap *soap, ns1__investigator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__investigator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafileParameterPK(struct soap *soap, ns1__datafileParameterPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__datafileParameterPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafileParameterPK(struct soap *soap, const char *tag, int id, ns1__datafileParameterPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datafileParameterPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafileParameterPK ** SOAP_FMAC4 soap_in_PointerTons1__datafileParameterPK(struct soap *soap, const char *tag, ns1__datafileParameterPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__datafileParameterPK **)soap_malloc(soap, sizeof(ns1__datafileParameterPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__datafileParameterPK *)soap_instantiate_ns1__datafileParameterPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__datafileParameterPK ** p = (ns1__datafileParameterPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileParameterPK, sizeof(ns1__datafileParameterPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafileParameterPK(struct soap *soap, ns1__datafileParameterPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datafileParameterPK);
	if (soap_out_PointerTons1__datafileParameterPK(soap, tag?tag:"ns1:datafileParameterPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafileParameterPK ** SOAP_FMAC4 soap_get_PointerTons1__datafileParameterPK(struct soap *soap, ns1__datafileParameterPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datafileParameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__publication(struct soap *soap, ns1__publication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__publication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__publication(struct soap *soap, const char *tag, int id, ns1__publication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__publication);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__publication ** SOAP_FMAC4 soap_in_PointerTons1__publication(struct soap *soap, const char *tag, ns1__publication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__publication **)soap_malloc(soap, sizeof(ns1__publication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__publication *)soap_instantiate_ns1__publication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__publication ** p = (ns1__publication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__publication, sizeof(ns1__publication), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__publication(struct soap *soap, ns1__publication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__publication);
	if (soap_out_PointerTons1__publication(soap, tag?tag:"ns1:publication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__publication ** SOAP_FMAC4 soap_get_PointerTons1__publication(struct soap *soap, ns1__publication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__publication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datasetParameterPK(struct soap *soap, ns1__datasetParameterPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__datasetParameterPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datasetParameterPK(struct soap *soap, const char *tag, int id, ns1__datasetParameterPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datasetParameterPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datasetParameterPK ** SOAP_FMAC4 soap_in_PointerTons1__datasetParameterPK(struct soap *soap, const char *tag, ns1__datasetParameterPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__datasetParameterPK **)soap_malloc(soap, sizeof(ns1__datasetParameterPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__datasetParameterPK *)soap_instantiate_ns1__datasetParameterPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__datasetParameterPK ** p = (ns1__datasetParameterPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datasetParameterPK, sizeof(ns1__datasetParameterPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datasetParameterPK(struct soap *soap, ns1__datasetParameterPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datasetParameterPK);
	if (soap_out_PointerTons1__datasetParameterPK(soap, tag?tag:"ns1:datasetParameterPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datasetParameterPK ** SOAP_FMAC4 soap_get_PointerTons1__datasetParameterPK(struct soap *soap, ns1__datasetParameterPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datasetParameterPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigationInclude(struct soap *soap, enum ns1__investigationInclude *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__investigationInclude);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigationInclude(struct soap *soap, const char *tag, int id, enum ns1__investigationInclude *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__investigationInclude);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__investigationInclude(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__investigationInclude ** SOAP_FMAC4 soap_in_PointerTons1__investigationInclude(struct soap *soap, const char *tag, enum ns1__investigationInclude **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__investigationInclude **)soap_malloc(soap, sizeof(enum ns1__investigationInclude *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__investigationInclude(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__investigationInclude **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigationInclude, sizeof(enum ns1__investigationInclude), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigationInclude(struct soap *soap, enum ns1__investigationInclude *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__investigationInclude);
	if (soap_out_PointerTons1__investigationInclude(soap, tag?tag:"ns1:investigationInclude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__investigationInclude ** SOAP_FMAC4 soap_get_PointerTons1__investigationInclude(struct soap *soap, enum ns1__investigationInclude **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__investigationInclude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__keywordDetails(struct soap *soap, ns1__keywordDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__keywordDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__keywordDetails(struct soap *soap, const char *tag, int id, ns1__keywordDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__keywordDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__keywordDetails ** SOAP_FMAC4 soap_in_PointerTons1__keywordDetails(struct soap *soap, const char *tag, ns1__keywordDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__keywordDetails **)soap_malloc(soap, sizeof(ns1__keywordDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__keywordDetails *)soap_instantiate_ns1__keywordDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__keywordDetails ** p = (ns1__keywordDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keywordDetails, sizeof(ns1__keywordDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__keywordDetails(struct soap *soap, ns1__keywordDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__keywordDetails);
	if (soap_out_PointerTons1__keywordDetails(soap, tag?tag:"ns1:keywordDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__keywordDetails ** SOAP_FMAC4 soap_get_PointerTons1__keywordDetails(struct soap *soap, ns1__keywordDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__keywordDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigation(struct soap *soap, ns1__investigation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__investigation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigation(struct soap *soap, const char *tag, int id, ns1__investigation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__investigation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigation ** SOAP_FMAC4 soap_in_PointerTons1__investigation(struct soap *soap, const char *tag, ns1__investigation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__investigation **)soap_malloc(soap, sizeof(ns1__investigation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__investigation *)soap_instantiate_ns1__investigation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__investigation ** p = (ns1__investigation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigation, sizeof(ns1__investigation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigation(struct soap *soap, ns1__investigation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__investigation);
	if (soap_out_PointerTons1__investigation(soap, tag?tag:"ns1:investigation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigation ** SOAP_FMAC4 soap_get_PointerTons1__investigation(struct soap *soap, ns1__investigation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__investigation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__double, sizeof(xsd__double), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__float, sizeof(xsd__float), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__int, sizeof(xsd__int), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__long, sizeof(xsd__long), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileInclude_, sizeof(ns1__datafileInclude_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keywordType_, sizeof(ns1__keywordType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigationInclude_, sizeof(ns1__investigationInclude_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__elementType_, sizeof(ns1__elementType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datasetInclude_, sizeof(ns1__datasetInclude_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetTypes, sizeof(ns1__listDatasetTypes), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetTypesResponse, sizeof(ns1__listDatasetTypesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchSamplesBySampleName, sizeof(ns1__searchSamplesBySampleName), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchSamplesBySampleNameResponse, sizeof(ns1__searchSamplesBySampleNameResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__entityBaseBean, sizeof(ns1__entityBaseBean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__entityPrimaryKeyBaseBean, sizeof(ns1__entityPrimaryKeyBaseBean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSample, sizeof(ns1__removeSample), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSampleResponse, sizeof(ns1__removeSampleResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InsufficientPrivilegesException, sizeof(ns1__InsufficientPrivilegesException), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoSuchObjectFoundException, sizeof(ns1__NoSuchObjectFoundException), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInstruments, sizeof(ns1__listInstruments), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInstrumentsResponse, sizeof(ns1__listInstrumentsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFile, sizeof(ns1__createDataFile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFileResponse, sizeof(ns1__createDataFileResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValidationException, sizeof(ns1__ValidationException), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySample, sizeof(ns1__modifySample), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySampleResponse, sizeof(ns1__modifySampleResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFile, sizeof(ns1__removeDataFile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFileResponse, sizeof(ns1__removeDataFileResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeAuthorisation, sizeof(ns1__removeAuthorisation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeAuthorisationResponse, sizeof(ns1__removeAuthorisationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParameters, sizeof(ns1__addDataFileParameters), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParametersResponse, sizeof(ns1__addDataFileParametersResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listFacilityCycles, sizeof(ns1__listFacilityCycles), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listFacilityCyclesResponse, sizeof(ns1__listFacilityCyclesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDataset, sizeof(ns1__downloadDataset), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatasetResponse, sizeof(ns1__downloadDatasetResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFederalId, sizeof(ns1__getFacilityUserByFederalId), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse, sizeof(ns1__getFacilityUserByFederalIdResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigator, sizeof(ns1__removeInvestigator), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigatorResponse, sizeof(ns1__removeInvestigatorResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigation, sizeof(ns1__removeInvestigation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeInvestigationResponse, sizeof(ns1__removeInvestigationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeKeyword, sizeof(ns1__removeKeyword), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeKeywordResponse, sizeof(ns1__removeKeywordResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigation, sizeof(ns1__deleteInvestigation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigationResponse, sizeof(ns1__deleteInvestigationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSets, sizeof(ns1__createDataSets), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSetsResponse, sizeof(ns1__createDataSetsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removePublication, sizeof(ns1__removePublication), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removePublicationResponse, sizeof(ns1__removePublicationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAllKeywords, sizeof(ns1__getAllKeywords), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAllKeywordsResponse, sizeof(ns1__getAllKeywordsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getUserDetails, sizeof(ns1__getUserDetails), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getUserDetailsResponse, sizeof(ns1__getUserDetailsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userDetails, sizeof(ns1__userDetails), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoSuchUserException, sizeof(ns1__NoSuchUserException), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafiles, sizeof(ns1__downloadDatafiles), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafilesResponse, sizeof(ns1__downloadDatafilesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSet, sizeof(ns1__modifyDataSet), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSetResponse, sizeof(ns1__modifyDataSetResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSampleParameter, sizeof(ns1__addSampleParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSampleParameterResponse, sizeof(ns1__addSampleParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserId, sizeof(ns1__getFacilityUserByFacilityUserId), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse, sizeof(ns1__getFacilityUserByFacilityUserIdResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatafileDownloadAccess, sizeof(ns1__checkDatafileDownloadAccess), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse, sizeof(ns1__checkDatafileDownloadAccessResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadInfo, sizeof(ns1__downloadInfo), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFile, sizeof(ns1__deleteDataFile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFileResponse, sizeof(ns1__deleteDataFileResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurname, sizeof(ns1__searchByUserSurname), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurnameResponse, sizeof(ns1__searchByUserSurnameResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurnamePagination, sizeof(ns1__searchByUserSurnamePagination), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse, sizeof(ns1__searchByUserSurnamePaginationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatasetDownloadAccess, sizeof(ns1__checkDatasetDownloadAccess), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse, sizeof(ns1__checkDatasetDownloadAccessResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywords, sizeof(ns1__searchByKeywords), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywordsResponse, sizeof(ns1__searchByKeywordsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywordsAll, sizeof(ns1__searchByKeywordsAll), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keywordDetails, sizeof(ns1__keywordDetails), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByKeywordsAllResponse, sizeof(ns1__searchByKeywordsAllResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigations, sizeof(ns1__getMyInvestigations), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsResponse, sizeof(ns1__getMyInvestigationsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludes, sizeof(ns1__getMyInvestigationsIncludes), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse, sizeof(ns1__getMyInvestigationsIncludesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination, sizeof(ns1__getMyInvestigationsIncludesPagination), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse, sizeof(ns1__getMyInvestigationsIncludesPaginationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSetParameter, sizeof(ns1__removeDataSetParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSetParameterResponse, sizeof(ns1__removeDataSetParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyPublication, sizeof(ns1__modifyPublication), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyPublicationResponse, sizeof(ns1__modifyPublicationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserID, sizeof(ns1__searchByUserID), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserIDResponse, sizeof(ns1__searchByUserIDResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserIDPagination, sizeof(ns1__searchByUserIDPagination), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByUserIDPaginationResponse, sizeof(ns1__searchByUserIDPaginationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFileParameter, sizeof(ns1__removeDataFileParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataFileParameterResponse, sizeof(ns1__removeDataFileParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationsIncludes, sizeof(ns1__getInvestigationsIncludes), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationsIncludesResponse, sizeof(ns1__getInvestigationsIncludesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSet, sizeof(ns1__deleteDataSet), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSetResponse, sizeof(ns1__deleteDataSetResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafiles, sizeof(ns1__getDatafiles), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafilesResponse, sizeof(ns1__getDatafilesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getICATAPIVersion, sizeof(ns1__getICATAPIVersion), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getICATAPIVersionResponse, sizeof(ns1__getICATAPIVersionResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigator, sizeof(ns1__deleteInvestigator), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteInvestigatorResponse, sizeof(ns1__deleteInvestigatorResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addInvestigator, sizeof(ns1__addInvestigator), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addInvestigatorResponse, sizeof(ns1__addInvestigatorResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSet, sizeof(ns1__createDataSet), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataSetResponse, sizeof(ns1__createDataSetResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSampleParameter, sizeof(ns1__removeSampleParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeSampleParameterResponse, sizeof(ns1__removeSampleParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSetParameter, sizeof(ns1__deleteDataSetParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataSetParameterResponse, sizeof(ns1__deleteDataSetParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setDataSetSample, sizeof(ns1__setDataSetSample), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setDataSetSampleResponse, sizeof(ns1__setDataSetSampleResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafile, sizeof(ns1__downloadDatafile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadDatafileResponse, sizeof(ns1__downloadDatafileResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUser, sizeof(ns1__getKeywordsForUser), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserResponse, sizeof(ns1__getKeywordsForUserResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMax, sizeof(ns1__getKeywordsForUserStartWithMax), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse, sizeof(ns1__getKeywordsForUserStartWithMaxResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserMax, sizeof(ns1__getKeywordsForUserMax), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserMaxResponse, sizeof(ns1__getKeywordsForUserMaxResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserType, sizeof(ns1__getKeywordsForUserType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getKeywordsForUserTypeResponse, sizeof(ns1__getKeywordsForUserTypeResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInvestigationTypes, sizeof(ns1__listInvestigationTypes), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listInvestigationTypesResponse, sizeof(ns1__listInvestigationTypesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSetParameter, sizeof(ns1__modifyDataSetParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataSetParameterResponse, sizeof(ns1__modifyDataSetParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSet, sizeof(ns1__removeDataSet), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeDataSetResponse, sizeof(ns1__removeDataSetResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAuthorisations, sizeof(ns1__getAuthorisations), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAuthorisationsResponse, sizeof(ns1__getAuthorisationsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addKeyword, sizeof(ns1__addKeyword), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addKeywordResponse, sizeof(ns1__addKeywordResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigation, sizeof(ns1__modifyInvestigation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigationResponse, sizeof(ns1__modifyInvestigationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetStatus, sizeof(ns1__listDatasetStatus), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatasetStatusResponse, sizeof(ns1__listDatasetStatusResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSample, sizeof(ns1__deleteSample), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSampleResponse, sizeof(ns1__deleteSampleResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteKeyword, sizeof(ns1__deleteKeyword), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteKeywordResponse, sizeof(ns1__deleteKeywordResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParameters, sizeof(ns1__addDataSetParameters), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParametersResponse, sizeof(ns1__addDataSetParametersResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumber, sizeof(ns1__searchByRunNumber), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumberResponse, sizeof(ns1__searchByRunNumberResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumberPagination, sizeof(ns1__searchByRunNumberPagination), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByRunNumberPaginationResponse, sizeof(ns1__searchByRunNumberPaginationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvanced, sizeof(ns1__searchByAdvanced), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__advancedSearchDetails, sizeof(ns1__advancedSearchDetails), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvancedResponse, sizeof(ns1__searchByAdvancedResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvancedPagination, sizeof(ns1__searchByAdvancedPagination), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchByAdvancedPaginationResponse, sizeof(ns1__searchByAdvancedPaginationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatafileFormats, sizeof(ns1__listDatafileFormats), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listDatafileFormatsResponse, sizeof(ns1__listDatafileFormatsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySampleParameter, sizeof(ns1__modifySampleParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifySampleParameterResponse, sizeof(ns1__modifySampleParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigator, sizeof(ns1__modifyInvestigator), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyInvestigatorResponse, sizeof(ns1__modifyInvestigatorResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFiles, sizeof(ns1__createDataFiles), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDataFilesResponse, sizeof(ns1__createDataFilesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParameter, sizeof(ns1__addDataSetParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataSetParameterResponse, sizeof(ns1__addDataSetParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addAuthorisation, sizeof(ns1__addAuthorisation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addAuthorisationResponse, sizeof(ns1__addAuthorisationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSample, sizeof(ns1__addSample), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addSampleResponse, sizeof(ns1__addSampleResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deletePublication, sizeof(ns1__deletePublication), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deletePublicationResponse, sizeof(ns1__deletePublicationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginLifetime, sizeof(ns1__loginLifetime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginLifetimeResponse, sizeof(ns1__loginLifetimeResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__login, sizeof(ns1__login), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginResponse, sizeof(ns1__loginResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteAuthorisation, sizeof(ns1__deleteAuthorisation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteAuthorisationResponse, sizeof(ns1__deleteAuthorisationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateAuthorisation, sizeof(ns1__updateAuthorisation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateAuthorisationResponse, sizeof(ns1__updateAuthorisationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetIncludes, sizeof(ns1__getDatasetIncludes), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetIncludesResponse, sizeof(ns1__getDatasetIncludesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDataset, sizeof(ns1__getDataset), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetResponse, sizeof(ns1__getDatasetResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listRoles, sizeof(ns1__listRoles), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listRolesResponse, sizeof(ns1__listRolesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ingestMetadata, sizeof(ns1__ingestMetadata), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ingestMetadataResponse, sizeof(ns1__ingestMetadataResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ICATAPIException, sizeof(ns1__ICATAPIException), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafile, sizeof(ns1__getDatafile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatafileResponse, sizeof(ns1__getDatafileResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFile, sizeof(ns1__modifyDataFile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFileResponse, sizeof(ns1__modifyDataFileResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationIncludes, sizeof(ns1__getInvestigationIncludes), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationIncludesResponse, sizeof(ns1__getInvestigationIncludesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigation, sizeof(ns1__getInvestigation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getInvestigationResponse, sizeof(ns1__getInvestigationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFileParameter, sizeof(ns1__deleteDataFileParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDataFileParameterResponse, sizeof(ns1__deleteDataFileParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createInvestigation, sizeof(ns1__createInvestigation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createInvestigationResponse, sizeof(ns1__createInvestigationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addPublication, sizeof(ns1__addPublication), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addPublicationResponse, sizeof(ns1__addPublicationResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchDatasetsBySample, sizeof(ns1__searchDatasetsBySample), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchDatasetsBySampleResponse, sizeof(ns1__searchDatasetsBySampleResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParameter, sizeof(ns1__addDataFileParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addDataFileParameterResponse, sizeof(ns1__addDataFileParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSampleParameter, sizeof(ns1__deleteSampleParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSampleParameterResponse, sizeof(ns1__deleteSampleParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFileParameter, sizeof(ns1__modifyDataFileParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyDataFileParameterResponse, sizeof(ns1__modifyDataFileParameterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listParameters, sizeof(ns1__listParameters), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listParametersResponse, sizeof(ns1__listParametersResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasets, sizeof(ns1__getDatasets), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDatasetsResponse, sizeof(ns1__getDatasetsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SessionException, sizeof(ns3__SessionException), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sample, sizeof(ns1__sample), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sampleParameter, sizeof(ns1__sampleParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sampleParameterPK, sizeof(ns1__sampleParameterPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__icatRole, sizeof(ns1__icatRole), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafile, sizeof(ns1__datafile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileFormat, sizeof(ns1__datafileFormat), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileFormatPK, sizeof(ns1__datafileFormatPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileParameter, sizeof(ns1__datafileParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileParameterPK, sizeof(ns1__datafileParameterPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__relatedDatafiles, sizeof(ns1__relatedDatafiles), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__relatedDatafilesPK, sizeof(ns1__relatedDatafilesPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__facilityCycle, sizeof(ns1__facilityCycle), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__facilityUser, sizeof(ns1__facilityUser), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigatorPK, sizeof(ns1__investigatorPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keywordPK, sizeof(ns1__keywordPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__dataset, sizeof(ns1__dataset), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datasetParameter, sizeof(ns1__datasetParameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datasetParameterPK, sizeof(ns1__datasetParameterPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__parameter, sizeof(ns1__parameter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__parameterPK, sizeof(ns1__parameterPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigation, sizeof(ns1__investigation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigator, sizeof(ns1__investigator), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keyword, sizeof(ns1__keyword), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__publication, sizeof(ns1__publication), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__shift, sizeof(ns1__shift), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__shiftPK, sizeof(ns1__shiftPK), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__icatAuthorisation, sizeof(ns1__icatAuthorisation), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadInfo(struct soap *soap, ns1__downloadInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadInfo(struct soap *soap, const char *tag, int id, ns1__downloadInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadInfo ** SOAP_FMAC4 soap_in_PointerTons1__downloadInfo(struct soap *soap, const char *tag, ns1__downloadInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadInfo **)soap_malloc(soap, sizeof(ns1__downloadInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadInfo *)soap_instantiate_ns1__downloadInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadInfo ** p = (ns1__downloadInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadInfo, sizeof(ns1__downloadInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadInfo(struct soap *soap, ns1__downloadInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadInfo);
	if (soap_out_PointerTons1__downloadInfo(soap, tag?tag:"ns1:downloadInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadInfo ** SOAP_FMAC4 soap_get_PointerTons1__downloadInfo(struct soap *soap, ns1__downloadInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sampleParameter(struct soap *soap, ns1__sampleParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sampleParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sampleParameter(struct soap *soap, const char *tag, int id, ns1__sampleParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sampleParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sampleParameter ** SOAP_FMAC4 soap_in_PointerTons1__sampleParameter(struct soap *soap, const char *tag, ns1__sampleParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sampleParameter **)soap_malloc(soap, sizeof(ns1__sampleParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sampleParameter *)soap_instantiate_ns1__sampleParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sampleParameter ** p = (ns1__sampleParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sampleParameter, sizeof(ns1__sampleParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sampleParameter(struct soap *soap, ns1__sampleParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sampleParameter);
	if (soap_out_PointerTons1__sampleParameter(soap, tag?tag:"ns1:sampleParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sampleParameter ** SOAP_FMAC4 soap_get_PointerTons1__sampleParameter(struct soap *soap, ns1__sampleParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sampleParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userDetails(struct soap *soap, ns1__userDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userDetails))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userDetails(struct soap *soap, const char *tag, int id, ns1__userDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userDetails);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__userDetails ** SOAP_FMAC4 soap_in_PointerTons1__userDetails(struct soap *soap, const char *tag, ns1__userDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__userDetails **)soap_malloc(soap, sizeof(ns1__userDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__userDetails *)soap_instantiate_ns1__userDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__userDetails ** p = (ns1__userDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userDetails, sizeof(ns1__userDetails), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userDetails(struct soap *soap, ns1__userDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__userDetails);
	if (soap_out_PointerTons1__userDetails(soap, tag?tag:"ns1:userDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__userDetails ** SOAP_FMAC4 soap_get_PointerTons1__userDetails(struct soap *soap, ns1__userDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__userDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__keywordType(struct soap *soap, enum ns1__keywordType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__keywordType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__keywordType(struct soap *soap, const char *tag, int id, enum ns1__keywordType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__keywordType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__keywordType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__keywordType ** SOAP_FMAC4 soap_in_PointerTons1__keywordType(struct soap *soap, const char *tag, enum ns1__keywordType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__keywordType **)soap_malloc(soap, sizeof(enum ns1__keywordType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__keywordType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__keywordType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keywordType, sizeof(enum ns1__keywordType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__keywordType(struct soap *soap, enum ns1__keywordType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__keywordType);
	if (soap_out_PointerTons1__keywordType(soap, tag?tag:"ns1:keywordType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__keywordType ** SOAP_FMAC4 soap_get_PointerTons1__keywordType(struct soap *soap, enum ns1__keywordType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__keywordType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dataset(struct soap *soap, ns1__dataset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__dataset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dataset(struct soap *soap, const char *tag, int id, ns1__dataset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__dataset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dataset ** SOAP_FMAC4 soap_in_PointerTons1__dataset(struct soap *soap, const char *tag, ns1__dataset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__dataset **)soap_malloc(soap, sizeof(ns1__dataset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__dataset *)soap_instantiate_ns1__dataset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__dataset ** p = (ns1__dataset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__dataset, sizeof(ns1__dataset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dataset(struct soap *soap, ns1__dataset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__dataset);
	if (soap_out_PointerTons1__dataset(soap, tag?tag:"ns1:dataset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dataset ** SOAP_FMAC4 soap_get_PointerTons1__dataset(struct soap *soap, ns1__dataset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__dataset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__keywordPK(struct soap *soap, ns1__keywordPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__keywordPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__keywordPK(struct soap *soap, const char *tag, int id, ns1__keywordPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__keywordPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__keywordPK ** SOAP_FMAC4 soap_in_PointerTons1__keywordPK(struct soap *soap, const char *tag, ns1__keywordPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__keywordPK **)soap_malloc(soap, sizeof(ns1__keywordPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__keywordPK *)soap_instantiate_ns1__keywordPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__keywordPK ** p = (ns1__keywordPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__keywordPK, sizeof(ns1__keywordPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__keywordPK(struct soap *soap, ns1__keywordPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__keywordPK);
	if (soap_out_PointerTons1__keywordPK(soap, tag?tag:"ns1:keywordPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__keywordPK ** SOAP_FMAC4 soap_get_PointerTons1__keywordPK(struct soap *soap, ns1__keywordPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__keywordPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigatorPK(struct soap *soap, ns1__investigatorPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__investigatorPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigatorPK(struct soap *soap, const char *tag, int id, ns1__investigatorPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__investigatorPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigatorPK ** SOAP_FMAC4 soap_in_PointerTons1__investigatorPK(struct soap *soap, const char *tag, ns1__investigatorPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__investigatorPK **)soap_malloc(soap, sizeof(ns1__investigatorPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__investigatorPK *)soap_instantiate_ns1__investigatorPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__investigatorPK ** p = (ns1__investigatorPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__investigatorPK, sizeof(ns1__investigatorPK), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigatorPK(struct soap *soap, ns1__investigatorPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__investigatorPK);
	if (soap_out_PointerTons1__investigatorPK(soap, tag?tag:"ns1:investigatorPK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigatorPK ** SOAP_FMAC4 soap_get_PointerTons1__investigatorPK(struct soap *soap, ns1__investigatorPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__investigatorPK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__facilityUser(struct soap *soap, ns1__facilityUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__facilityUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__facilityUser(struct soap *soap, const char *tag, int id, ns1__facilityUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__facilityUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__facilityUser ** SOAP_FMAC4 soap_in_PointerTons1__facilityUser(struct soap *soap, const char *tag, ns1__facilityUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__facilityUser **)soap_malloc(soap, sizeof(ns1__facilityUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__facilityUser *)soap_instantiate_ns1__facilityUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__facilityUser ** p = (ns1__facilityUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__facilityUser, sizeof(ns1__facilityUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__facilityUser(struct soap *soap, ns1__facilityUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__facilityUser);
	if (soap_out_PointerTons1__facilityUser(soap, tag?tag:"ns1:facilityUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__facilityUser ** SOAP_FMAC4 soap_get_PointerTons1__facilityUser(struct soap *soap, ns1__facilityUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__facilityUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__facilityCycle(struct soap *soap, ns1__facilityCycle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__facilityCycle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__facilityCycle(struct soap *soap, const char *tag, int id, ns1__facilityCycle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__facilityCycle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__facilityCycle ** SOAP_FMAC4 soap_in_PointerTons1__facilityCycle(struct soap *soap, const char *tag, ns1__facilityCycle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__facilityCycle **)soap_malloc(soap, sizeof(ns1__facilityCycle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__facilityCycle *)soap_instantiate_ns1__facilityCycle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__facilityCycle ** p = (ns1__facilityCycle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__facilityCycle, sizeof(ns1__facilityCycle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__facilityCycle(struct soap *soap, ns1__facilityCycle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__facilityCycle);
	if (soap_out_PointerTons1__facilityCycle(soap, tag?tag:"ns1:facilityCycle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__facilityCycle ** SOAP_FMAC4 soap_get_PointerTons1__facilityCycle(struct soap *soap, ns1__facilityCycle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__facilityCycle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafileParameter(struct soap *soap, ns1__datafileParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__datafileParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafileParameter(struct soap *soap, const char *tag, int id, ns1__datafileParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datafileParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafileParameter ** SOAP_FMAC4 soap_in_PointerTons1__datafileParameter(struct soap *soap, const char *tag, ns1__datafileParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__datafileParameter **)soap_malloc(soap, sizeof(ns1__datafileParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__datafileParameter *)soap_instantiate_ns1__datafileParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__datafileParameter ** p = (ns1__datafileParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafileParameter, sizeof(ns1__datafileParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafileParameter(struct soap *soap, ns1__datafileParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datafileParameter);
	if (soap_out_PointerTons1__datafileParameter(soap, tag?tag:"ns1:datafileParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafileParameter ** SOAP_FMAC4 soap_get_PointerTons1__datafileParameter(struct soap *soap, ns1__datafileParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datafileParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafile(struct soap *soap, ns1__datafile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__datafile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafile(struct soap *soap, const char *tag, int id, ns1__datafile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__datafile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafile ** SOAP_FMAC4 soap_in_PointerTons1__datafile(struct soap *soap, const char *tag, ns1__datafile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__datafile **)soap_malloc(soap, sizeof(ns1__datafile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__datafile *)soap_instantiate_ns1__datafile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__datafile ** p = (ns1__datafile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__datafile, sizeof(ns1__datafile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafile(struct soap *soap, ns1__datafile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__datafile);
	if (soap_out_PointerTons1__datafile(soap, tag?tag:"ns1:datafile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafile ** SOAP_FMAC4 soap_get_PointerTons1__datafile(struct soap *soap, ns1__datafile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__datafile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__icatRole(struct soap *soap, ns1__icatRole *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__icatRole))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__icatRole(struct soap *soap, const char *tag, int id, ns1__icatRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__icatRole);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__icatRole ** SOAP_FMAC4 soap_in_PointerTons1__icatRole(struct soap *soap, const char *tag, ns1__icatRole **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__icatRole **)soap_malloc(soap, sizeof(ns1__icatRole *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__icatRole *)soap_instantiate_ns1__icatRole(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__icatRole ** p = (ns1__icatRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__icatRole, sizeof(ns1__icatRole), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__icatRole(struct soap *soap, ns1__icatRole *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__icatRole);
	if (soap_out_PointerTons1__icatRole(soap, tag?tag:"ns1:icatRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__icatRole ** SOAP_FMAC4 soap_get_PointerTons1__icatRole(struct soap *soap, ns1__icatRole **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__icatRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sample(struct soap *soap, ns1__sample *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sample))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sample(struct soap *soap, const char *tag, int id, ns1__sample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sample);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sample ** SOAP_FMAC4 soap_in_PointerTons1__sample(struct soap *soap, const char *tag, ns1__sample **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sample **)soap_malloc(soap, sizeof(ns1__sample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sample *)soap_instantiate_ns1__sample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sample ** p = (ns1__sample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sample, sizeof(ns1__sample), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sample(struct soap *soap, ns1__sample *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sample);
	if (soap_out_PointerTons1__sample(soap, tag?tag:"ns1:sample", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sample ** SOAP_FMAC4 soap_get_PointerTons1__sample(struct soap *soap, ns1__sample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, std::vector<ns1__shift * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, const std::vector<ns1__shift * >*a)
{
	for (std::vector<ns1__shift * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__shift(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, const char *tag, int id, const std::vector<ns1__shift * >*a, const char *type)
{
	for (std::vector<ns1__shift * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__shift(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__shift * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, const char *tag, std::vector<ns1__shift * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__shift(soap, -1)))
		return NULL;
	ns1__shift *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__shift, SOAP_TYPE_std__vectorTemplateOfPointerTons1__shift, sizeof(ns1__shift), 1))
				break;
			if (!soap_in_PointerTons1__shift(soap, tag, NULL, "ns1:shift"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__shift(soap, tag, &n, "ns1:shift"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__shift * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__shift(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__shift, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__shift * >);
		if (size)
			*size = sizeof(std::vector<ns1__shift * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__shift * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__shift * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__shift * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__shift * > %p -> %p\n", q, p));
	*(std::vector<ns1__shift * >*)p = *(std::vector<ns1__shift * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, std::vector<ns1__publication * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, const std::vector<ns1__publication * >*a)
{
	for (std::vector<ns1__publication * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__publication(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, const char *tag, int id, const std::vector<ns1__publication * >*a, const char *type)
{
	for (std::vector<ns1__publication * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__publication(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__publication * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, const char *tag, std::vector<ns1__publication * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__publication(soap, -1)))
		return NULL;
	ns1__publication *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__publication, SOAP_TYPE_std__vectorTemplateOfPointerTons1__publication, sizeof(ns1__publication), 1))
				break;
			if (!soap_in_PointerTons1__publication(soap, tag, NULL, "ns1:publication"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__publication(soap, tag, &n, "ns1:publication"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__publication * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__publication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__publication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__publication * >);
		if (size)
			*size = sizeof(std::vector<ns1__publication * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__publication * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__publication * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__publication * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__publication * > %p -> %p\n", q, p));
	*(std::vector<ns1__publication * >*)p = *(std::vector<ns1__publication * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, std::vector<ns1__keyword * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, const std::vector<ns1__keyword * >*a)
{
	for (std::vector<ns1__keyword * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__keyword(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, const char *tag, int id, const std::vector<ns1__keyword * >*a, const char *type)
{
	for (std::vector<ns1__keyword * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__keyword(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__keyword * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, const char *tag, std::vector<ns1__keyword * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__keyword(soap, -1)))
		return NULL;
	ns1__keyword *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__keyword, SOAP_TYPE_std__vectorTemplateOfPointerTons1__keyword, sizeof(ns1__keyword), 1))
				break;
			if (!soap_in_PointerTons1__keyword(soap, tag, NULL, "ns1:keyword"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__keyword(soap, tag, &n, "ns1:keyword"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__keyword * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__keyword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__keyword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__keyword * >);
		if (size)
			*size = sizeof(std::vector<ns1__keyword * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__keyword * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__keyword * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__keyword * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__keyword * > %p -> %p\n", q, p));
	*(std::vector<ns1__keyword * >*)p = *(std::vector<ns1__keyword * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__investigator(struct soap *soap, std::vector<ns1__investigator * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__investigator(struct soap *soap, const std::vector<ns1__investigator * >*a)
{
	for (std::vector<ns1__investigator * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__investigator(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__investigator(struct soap *soap, const char *tag, int id, const std::vector<ns1__investigator * >*a, const char *type)
{
	for (std::vector<ns1__investigator * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__investigator(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__investigator * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__investigator(struct soap *soap, const char *tag, std::vector<ns1__investigator * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__investigator(soap, -1)))
		return NULL;
	ns1__investigator *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__investigator, SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigator, sizeof(ns1__investigator), 1))
				break;
			if (!soap_in_PointerTons1__investigator(soap, tag, NULL, "ns1:investigator"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__investigator(soap, tag, &n, "ns1:investigator"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__investigator * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__investigator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__investigator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__investigator * >);
		if (size)
			*size = sizeof(std::vector<ns1__investigator * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__investigator * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__investigator * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__investigator * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__investigator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__investigator * > %p -> %p\n", q, p));
	*(std::vector<ns1__investigator * >*)p = *(std::vector<ns1__investigator * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__relatedDatafiles(struct soap *soap, std::vector<ns1__relatedDatafiles * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__relatedDatafiles(struct soap *soap, const std::vector<ns1__relatedDatafiles * >*a)
{
	for (std::vector<ns1__relatedDatafiles * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__relatedDatafiles(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__relatedDatafiles(struct soap *soap, const char *tag, int id, const std::vector<ns1__relatedDatafiles * >*a, const char *type)
{
	for (std::vector<ns1__relatedDatafiles * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__relatedDatafiles(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__relatedDatafiles * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__relatedDatafiles(struct soap *soap, const char *tag, std::vector<ns1__relatedDatafiles * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__relatedDatafiles(soap, -1)))
		return NULL;
	ns1__relatedDatafiles *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__relatedDatafiles, SOAP_TYPE_std__vectorTemplateOfPointerTons1__relatedDatafiles, sizeof(ns1__relatedDatafiles), 1))
				break;
			if (!soap_in_PointerTons1__relatedDatafiles(soap, tag, NULL, "ns1:relatedDatafiles"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__relatedDatafiles(soap, tag, &n, "ns1:relatedDatafiles"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__relatedDatafiles * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__relatedDatafiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__relatedDatafiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__relatedDatafiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__relatedDatafiles * >);
		if (size)
			*size = sizeof(std::vector<ns1__relatedDatafiles * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__relatedDatafiles * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__relatedDatafiles * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__relatedDatafiles * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__relatedDatafiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__relatedDatafiles * > %p -> %p\n", q, p));
	*(std::vector<ns1__relatedDatafiles * >*)p = *(std::vector<ns1__relatedDatafiles * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, std::vector<ns1__sampleParameter * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, const std::vector<ns1__sampleParameter * >*a)
{
	for (std::vector<ns1__sampleParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__sampleParameter(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, const char *tag, int id, const std::vector<ns1__sampleParameter * >*a, const char *type)
{
	for (std::vector<ns1__sampleParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__sampleParameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__sampleParameter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, const char *tag, std::vector<ns1__sampleParameter * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__sampleParameter(soap, -1)))
		return NULL;
	ns1__sampleParameter *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__sampleParameter, SOAP_TYPE_std__vectorTemplateOfPointerTons1__sampleParameter, sizeof(ns1__sampleParameter), 1))
				break;
			if (!soap_in_PointerTons1__sampleParameter(soap, tag, NULL, "ns1:sampleParameter"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__sampleParameter(soap, tag, &n, "ns1:sampleParameter"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__sampleParameter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__sampleParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__sampleParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__sampleParameter * >);
		if (size)
			*size = sizeof(std::vector<ns1__sampleParameter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__sampleParameter * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__sampleParameter * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__sampleParameter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__sampleParameter * > %p -> %p\n", q, p));
	*(std::vector<ns1__sampleParameter * >*)p = *(std::vector<ns1__sampleParameter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__parameter(struct soap *soap, std::vector<ns1__parameter * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__parameter(struct soap *soap, const std::vector<ns1__parameter * >*a)
{
	for (std::vector<ns1__parameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__parameter(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__parameter(struct soap *soap, const char *tag, int id, const std::vector<ns1__parameter * >*a, const char *type)
{
	for (std::vector<ns1__parameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__parameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__parameter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__parameter(struct soap *soap, const char *tag, std::vector<ns1__parameter * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__parameter(soap, -1)))
		return NULL;
	ns1__parameter *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__parameter, SOAP_TYPE_std__vectorTemplateOfPointerTons1__parameter, sizeof(ns1__parameter), 1))
				break;
			if (!soap_in_PointerTons1__parameter(soap, tag, NULL, "ns1:parameter"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__parameter(soap, tag, &n, "ns1:parameter"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__parameter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__parameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__parameter * >);
		if (size)
			*size = sizeof(std::vector<ns1__parameter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__parameter * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__parameter * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__parameter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__parameter * > %p -> %p\n", q, p));
	*(std::vector<ns1__parameter * >*)p = *(std::vector<ns1__parameter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__icatRole(struct soap *soap, std::vector<ns1__icatRole * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__icatRole(struct soap *soap, const std::vector<ns1__icatRole * >*a)
{
	for (std::vector<ns1__icatRole * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__icatRole(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__icatRole(struct soap *soap, const char *tag, int id, const std::vector<ns1__icatRole * >*a, const char *type)
{
	for (std::vector<ns1__icatRole * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__icatRole(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__icatRole * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__icatRole(struct soap *soap, const char *tag, std::vector<ns1__icatRole * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__icatRole(soap, -1)))
		return NULL;
	ns1__icatRole *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__icatRole, SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatRole, sizeof(ns1__icatRole), 1))
				break;
			if (!soap_in_PointerTons1__icatRole(soap, tag, NULL, "ns1:icatRole"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__icatRole(soap, tag, &n, "ns1:icatRole"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__icatRole * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__icatRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__icatRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__icatRole * >);
		if (size)
			*size = sizeof(std::vector<ns1__icatRole * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__icatRole * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__icatRole * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__icatRole * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__icatRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__icatRole * > %p -> %p\n", q, p));
	*(std::vector<ns1__icatRole * >*)p = *(std::vector<ns1__icatRole * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, std::vector<ns1__datafileFormat * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, const std::vector<ns1__datafileFormat * >*a)
{
	for (std::vector<ns1__datafileFormat * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__datafileFormat(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, const char *tag, int id, const std::vector<ns1__datafileFormat * >*a, const char *type)
{
	for (std::vector<ns1__datafileFormat * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__datafileFormat(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datafileFormat * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, const char *tag, std::vector<ns1__datafileFormat * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datafileFormat(soap, -1)))
		return NULL;
	ns1__datafileFormat *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__datafileFormat, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileFormat, sizeof(ns1__datafileFormat), 1))
				break;
			if (!soap_in_PointerTons1__datafileFormat(soap, tag, NULL, "ns1:datafileFormat"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__datafileFormat(soap, tag, &n, "ns1:datafileFormat"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__datafileFormat * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__datafileFormat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileFormat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datafileFormat * >);
		if (size)
			*size = sizeof(std::vector<ns1__datafileFormat * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datafileFormat * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__datafileFormat * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__datafileFormat * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datafileFormat * > %p -> %p\n", q, p));
	*(std::vector<ns1__datafileFormat * >*)p = *(std::vector<ns1__datafileFormat * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, std::vector<ns1__datasetParameter * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, const std::vector<ns1__datasetParameter * >*a)
{
	for (std::vector<ns1__datasetParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__datasetParameter(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, const char *tag, int id, const std::vector<ns1__datasetParameter * >*a, const char *type)
{
	for (std::vector<ns1__datasetParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__datasetParameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datasetParameter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, const char *tag, std::vector<ns1__datasetParameter * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datasetParameter(soap, -1)))
		return NULL;
	ns1__datasetParameter *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__datasetParameter, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datasetParameter, sizeof(ns1__datasetParameter), 1))
				break;
			if (!soap_in_PointerTons1__datasetParameter(soap, tag, NULL, "ns1:datasetParameter"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__datasetParameter(soap, tag, &n, "ns1:datasetParameter"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__datasetParameter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__datasetParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datasetParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datasetParameter * >);
		if (size)
			*size = sizeof(std::vector<ns1__datasetParameter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datasetParameter * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__datasetParameter * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__datasetParameter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datasetParameter * > %p -> %p\n", q, p));
	*(std::vector<ns1__datasetParameter * >*)p = *(std::vector<ns1__datasetParameter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__icatAuthorisation(struct soap *soap, std::vector<ns1__icatAuthorisation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__icatAuthorisation(struct soap *soap, const std::vector<ns1__icatAuthorisation * >*a)
{
	for (std::vector<ns1__icatAuthorisation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__icatAuthorisation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__icatAuthorisation(struct soap *soap, const char *tag, int id, const std::vector<ns1__icatAuthorisation * >*a, const char *type)
{
	for (std::vector<ns1__icatAuthorisation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__icatAuthorisation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__icatAuthorisation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__icatAuthorisation(struct soap *soap, const char *tag, std::vector<ns1__icatAuthorisation * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__icatAuthorisation(soap, -1)))
		return NULL;
	ns1__icatAuthorisation *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__icatAuthorisation, SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatAuthorisation, sizeof(ns1__icatAuthorisation), 1))
				break;
			if (!soap_in_PointerTons1__icatAuthorisation(soap, tag, NULL, "ns1:icatAuthorisation"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__icatAuthorisation(soap, tag, &n, "ns1:icatAuthorisation"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__icatAuthorisation * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__icatAuthorisation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__icatAuthorisation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__icatAuthorisation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__icatAuthorisation * >);
		if (size)
			*size = sizeof(std::vector<ns1__icatAuthorisation * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__icatAuthorisation * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__icatAuthorisation * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__icatAuthorisation * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__icatAuthorisation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__icatAuthorisation * > %p -> %p\n", q, p));
	*(std::vector<ns1__icatAuthorisation * >*)p = *(std::vector<ns1__icatAuthorisation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, std::vector<ns1__datafile * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, const std::vector<ns1__datafile * >*a)
{
	for (std::vector<ns1__datafile * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__datafile(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, const char *tag, int id, const std::vector<ns1__datafile * >*a, const char *type)
{
	for (std::vector<ns1__datafile * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__datafile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datafile * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, const char *tag, std::vector<ns1__datafile * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datafile(soap, -1)))
		return NULL;
	ns1__datafile *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__datafile, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafile, sizeof(ns1__datafile), 1))
				break;
			if (!soap_in_PointerTons1__datafile(soap, tag, NULL, "ns1:datafile"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__datafile(soap, tag, &n, "ns1:datafile"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__datafile * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__datafile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datafile * >);
		if (size)
			*size = sizeof(std::vector<ns1__datafile * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datafile * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__datafile * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__datafile * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datafile * > %p -> %p\n", q, p));
	*(std::vector<ns1__datafile * >*)p = *(std::vector<ns1__datafile * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, std::vector<ns1__investigation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, const std::vector<ns1__investigation * >*a)
{
	for (std::vector<ns1__investigation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__investigation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, const char *tag, int id, const std::vector<ns1__investigation * >*a, const char *type)
{
	for (std::vector<ns1__investigation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__investigation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__investigation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, const char *tag, std::vector<ns1__investigation * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__investigation(soap, -1)))
		return NULL;
	ns1__investigation *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__investigation, SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigation, sizeof(ns1__investigation), 1))
				break;
			if (!soap_in_PointerTons1__investigation(soap, tag, NULL, "ns1:investigation"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__investigation(soap, tag, &n, "ns1:investigation"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__investigation * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__investigation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__investigation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__investigation * >);
		if (size)
			*size = sizeof(std::vector<ns1__investigation * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__investigation * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__investigation * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__investigation * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__investigation * > %p -> %p\n", q, p));
	*(std::vector<ns1__investigation * >*)p = *(std::vector<ns1__investigation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, std::vector<xsd__anyType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const std::vector<xsd__anyType * >*a)
{
	for (std::vector<xsd__anyType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToxsd__anyType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const char *tag, int id, const std::vector<xsd__anyType * >*a, const char *type)
{
	for (std::vector<xsd__anyType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToxsd__anyType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xsd__anyType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const char *tag, std::vector<xsd__anyType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToxsd__anyType(soap, -1)))
		return NULL;
	xsd__anyType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__anyType, SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType, sizeof(xsd__anyType), 1))
				break;
			if (!soap_in_PointerToxsd__anyType(soap, tag, NULL, "xsd:anyType"))
				break;
		}
		else
		{
			if (!soap_in_PointerToxsd__anyType(soap, tag, &n, "xsd:anyType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xsd__anyType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__anyType * >);
		if (size)
			*size = sizeof(std::vector<xsd__anyType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__anyType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<xsd__anyType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<xsd__anyType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<xsd__anyType * > %p -> %p\n", q, p));
	*(std::vector<xsd__anyType * >*)p = *(std::vector<xsd__anyType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64 >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfLONG64(struct soap *soap, const std::vector<LONG64 >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, int id, const std::vector<LONG64 >*a, const char *type)
{
	for (std::vector<LONG64 >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_LONG64(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<LONG64 >* SOAP_FMAC4 soap_in_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, std::vector<LONG64 >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfLONG64(soap, -1)))
		return NULL;
	LONG64 n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_LONG64(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_LONG64, SOAP_TYPE_std__vectorTemplateOfLONG64, sizeof(LONG64), 0))
				break;
			if (!soap_in_LONG64(soap, tag, NULL, "xsd:long"))
				break;
		}
		else
		{
			if (!soap_in_LONG64(soap, tag, &n, "xsd:long"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<LONG64 > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfLONG64(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfLONG64(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfLONG64, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<LONG64 >);
		if (size)
			*size = sizeof(std::vector<LONG64 >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<LONG64 >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<LONG64 >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<LONG64 >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfLONG64(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<LONG64 > %p -> %p\n", q, p));
	*(std::vector<LONG64 >*)p = *(std::vector<LONG64 >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, std::vector<ns1__dataset * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, const std::vector<ns1__dataset * >*a)
{
	for (std::vector<ns1__dataset * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__dataset(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, const char *tag, int id, const std::vector<ns1__dataset * >*a, const char *type)
{
	for (std::vector<ns1__dataset * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__dataset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__dataset * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, const char *tag, std::vector<ns1__dataset * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__dataset(soap, -1)))
		return NULL;
	ns1__dataset *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__dataset, SOAP_TYPE_std__vectorTemplateOfPointerTons1__dataset, sizeof(ns1__dataset), 1))
				break;
			if (!soap_in_PointerTons1__dataset(soap, tag, NULL, "ns1:dataset"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__dataset(soap, tag, &n, "ns1:dataset"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__dataset * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__dataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__dataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__dataset * >);
		if (size)
			*size = sizeof(std::vector<ns1__dataset * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__dataset * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__dataset * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__dataset * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__dataset * > %p -> %p\n", q, p));
	*(std::vector<ns1__dataset * >*)p = *(std::vector<ns1__dataset * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, std::vector<ns1__facilityCycle * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, const std::vector<ns1__facilityCycle * >*a)
{
	for (std::vector<ns1__facilityCycle * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__facilityCycle(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, const char *tag, int id, const std::vector<ns1__facilityCycle * >*a, const char *type)
{
	for (std::vector<ns1__facilityCycle * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__facilityCycle(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__facilityCycle * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, const char *tag, std::vector<ns1__facilityCycle * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__facilityCycle(soap, -1)))
		return NULL;
	ns1__facilityCycle *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__facilityCycle, SOAP_TYPE_std__vectorTemplateOfPointerTons1__facilityCycle, sizeof(ns1__facilityCycle), 1))
				break;
			if (!soap_in_PointerTons1__facilityCycle(soap, tag, NULL, "ns1:facilityCycle"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__facilityCycle(soap, tag, &n, "ns1:facilityCycle"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__facilityCycle * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__facilityCycle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__facilityCycle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__facilityCycle * >);
		if (size)
			*size = sizeof(std::vector<ns1__facilityCycle * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__facilityCycle * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__facilityCycle * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__facilityCycle * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__facilityCycle * > %p -> %p\n", q, p));
	*(std::vector<ns1__facilityCycle * >*)p = *(std::vector<ns1__facilityCycle * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, std::vector<ns1__datafileParameter * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, const std::vector<ns1__datafileParameter * >*a)
{
	for (std::vector<ns1__datafileParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__datafileParameter(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, const char *tag, int id, const std::vector<ns1__datafileParameter * >*a, const char *type)
{
	for (std::vector<ns1__datafileParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__datafileParameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datafileParameter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, const char *tag, std::vector<ns1__datafileParameter * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datafileParameter(soap, -1)))
		return NULL;
	ns1__datafileParameter *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__datafileParameter, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileParameter, sizeof(ns1__datafileParameter), 1))
				break;
			if (!soap_in_PointerTons1__datafileParameter(soap, tag, NULL, "ns1:datafileParameter"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__datafileParameter(soap, tag, &n, "ns1:datafileParameter"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__datafileParameter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__datafileParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__datafileParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datafileParameter * >);
		if (size)
			*size = sizeof(std::vector<ns1__datafileParameter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__datafileParameter * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__datafileParameter * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__datafileParameter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datafileParameter * > %p -> %p\n", q, p));
	*(std::vector<ns1__datafileParameter * >*)p = *(std::vector<ns1__datafileParameter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, std::vector<ns1__sample * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, const std::vector<ns1__sample * >*a)
{
	for (std::vector<ns1__sample * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__sample(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, const char *tag, int id, const std::vector<ns1__sample * >*a, const char *type)
{
	for (std::vector<ns1__sample * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__sample(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__sample * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, const char *tag, std::vector<ns1__sample * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__sample(soap, -1)))
		return NULL;
	ns1__sample *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__sample, SOAP_TYPE_std__vectorTemplateOfPointerTons1__sample, sizeof(ns1__sample), 1))
				break;
			if (!soap_in_PointerTons1__sample(soap, tag, NULL, "ns1:sample"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__sample(soap, tag, &n, "ns1:sample"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__sample * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__sample(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__sample, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__sample * >);
		if (size)
			*size = sizeof(std::vector<ns1__sample * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__sample * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__sample * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__sample * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__sample * > %p -> %p\n", q, p));
	*(std::vector<ns1__sample * >*)p = *(std::vector<ns1__sample * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
