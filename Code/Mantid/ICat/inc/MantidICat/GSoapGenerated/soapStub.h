/* soapStub.h
   Generated by gSOAP 2.7.16 from ICATService.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	""
#define SOAP_NAMESPACE_OF_ns2	""
#define SOAP_NAMESPACE_OF_ns1	"client.icat3.uk"
#define SOAP_NAMESPACE_OF_ns3	"admin.client.icat3.uk"
#include "MantidICat/GSoap/stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__datafileInclude
#define SOAP_TYPE_ns1__datafileInclude (258)
/* ns1:datafileInclude */
enum ns1__datafileInclude {ns1__datafileInclude__DATAFILE_USCOREPARAMETERS = 0, ns1__datafileInclude__RELATED_USCOREDATAFILES = 1, ns1__datafileInclude__ALL = 2, ns1__datafileInclude__NONE = 3};
#endif

#ifndef SOAP_TYPE_ns1__keywordType
#define SOAP_TYPE_ns1__keywordType (260)
/* ns1:keywordType */
enum ns1__keywordType {ns1__keywordType__ALL = 0, ns1__keywordType__ALPHA_USCORENUMERIC = 1, ns1__keywordType__ALPHA = 2};
#endif

#ifndef SOAP_TYPE_ns1__investigationInclude
#define SOAP_TYPE_ns1__investigationInclude (262)
/* ns1:investigationInclude */
enum ns1__investigationInclude {ns1__investigationInclude__INVESTIGATORS_USCOREONLY = 0, ns1__investigationInclude__KEYWORDS_USCOREONLY = 1, ns1__investigationInclude__PUBLICATIONS_USCOREONLY = 2, ns1__investigationInclude__INVESTIGATORS_USCOREAND_USCOREKEYWORDS = 3, ns1__investigationInclude__INVESTIGATORS_USCOREAND_USCORESHIFTS = 4, ns1__investigationInclude__INVESTIGATORS_USCORESHIFTS_USCOREAND_USCORESAMPLES = 5, ns1__investigationInclude__INVESTIGATORS_USCORESHIFTS_USCORESAMPLES_USCOREAND_USCOREPUBLICATIONS = 6, ns1__investigationInclude__DATASETS_USCOREONLY = 7, ns1__investigationInclude__DATASETS_USCOREAND_USCOREDATASET_USCOREPARAMETERS_USCOREONLY = 8, ns1__investigationInclude__DATASETS_USCOREAND_USCOREDATAFILES = 9, ns1__investigationInclude__DATASETS_USCOREDATAFILES_USCOREAND_USCOREPARAMETERS = 10, ns1__investigationInclude__SAMPLES_USCOREONLY = 11, ns1__investigationInclude__ROLE_USCOREONLY = 12, ns1__investigationInclude__SHIFT_USCOREONLY = 13, ns1__investigationInclude__ALL = 14, ns1__investigationInclude__NONE = 15, ns1__investigationInclude__ALL_USCOREEXCEPT_USCOREDATASETS_USCOREAND_USCOREDATAFILES = 16, ns1__investigationInclude__ALL_USCOREEXCEPT_USCOREDATASETS_USCOREDATAFILES_USCOREAND_USCOREROLES = 17};
#endif

#ifndef SOAP_TYPE_ns1__elementType
#define SOAP_TYPE_ns1__elementType (264)
/* ns1:elementType */
enum ns1__elementType {ns1__elementType__STUDY = 0, ns1__elementType__INVESTIGATION = 1, ns1__elementType__INVESTIGATOR = 2, ns1__elementType__KEYWORD = 3, ns1__elementType__SAMPLE = 4, ns1__elementType__SAMPLE_USCOREPARAMETER = 5, ns1__elementType__PUBLICATION = 6, ns1__elementType__DATASET = 7, ns1__elementType__DATASET_USCOREPARAMETER = 8, ns1__elementType__DATAFILE = 9, ns1__elementType__DATAFILE_USCOREPARAMETER = 10};
#endif

#ifndef SOAP_TYPE_ns1__datasetInclude
#define SOAP_TYPE_ns1__datasetInclude (266)
/* ns1:datasetInclude */
enum ns1__datasetInclude {ns1__datasetInclude__DATASET_USCOREAND_USCOREDATAFILES_USCOREONLY = 0, ns1__datasetInclude__DATASET_USCOREPARAMETERS_USCOREONLY = 1, ns1__datasetInclude__DATASET_USCOREDATAFILES_USCOREAND_USCOREPARAMETERS = 2, ns1__datasetInclude__NONE = 3};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyType(): __item(NULL), soap(NULL) { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (10)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (12)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_xsd__dateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (14)
/* Primitive xsd:double schema type: */
class SOAP_CMAC xsd__double : public xsd__anyType
{
public:
	double __item;
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_xsd__double */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__double() { xsd__double::soap_default(NULL); }
	virtual ~xsd__double() { }
};
#endif

#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (16)
/* Primitive xsd:float schema type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
	float __item;
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_xsd__float */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__float() { xsd__float::soap_default(NULL); }
	virtual ~xsd__float() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (18)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (19)
/* Primitive xsd:long schema type: */
class SOAP_CMAC xsd__long : public xsd__anyType
{
public:
	LONG64 __item;
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_xsd__long */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__long() { xsd__long::soap_default(NULL); }
	virtual ~xsd__long() { }
};
#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (21)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datafileInclude_
#define SOAP_TYPE_ns1__datafileInclude_ (259)
/* Primitive ns1:datafileInclude schema type: */
class SOAP_CMAC ns1__datafileInclude_ : public xsd__anyType
{
public:
	enum ns1__datafileInclude __item;
public:
	virtual int soap_type() const { return 259; } /* = unique id SOAP_TYPE_ns1__datafileInclude_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafileInclude_() { ns1__datafileInclude_::soap_default(NULL); }
	virtual ~ns1__datafileInclude_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__keywordType_
#define SOAP_TYPE_ns1__keywordType_ (261)
/* Primitive ns1:keywordType schema type: */
class SOAP_CMAC ns1__keywordType_ : public xsd__anyType
{
public:
	enum ns1__keywordType __item;
public:
	virtual int soap_type() const { return 261; } /* = unique id SOAP_TYPE_ns1__keywordType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__keywordType_() { ns1__keywordType_::soap_default(NULL); }
	virtual ~ns1__keywordType_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__investigationInclude_
#define SOAP_TYPE_ns1__investigationInclude_ (263)
/* Primitive ns1:investigationInclude schema type: */
class SOAP_CMAC ns1__investigationInclude_ : public xsd__anyType
{
public:
	enum ns1__investigationInclude __item;
public:
	virtual int soap_type() const { return 263; } /* = unique id SOAP_TYPE_ns1__investigationInclude_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigationInclude_() { ns1__investigationInclude_::soap_default(NULL); }
	virtual ~ns1__investigationInclude_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__elementType_
#define SOAP_TYPE_ns1__elementType_ (265)
/* Primitive ns1:elementType schema type: */
class SOAP_CMAC ns1__elementType_ : public xsd__anyType
{
public:
	enum ns1__elementType __item;
public:
	virtual int soap_type() const { return 265; } /* = unique id SOAP_TYPE_ns1__elementType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__elementType_() { ns1__elementType_::soap_default(NULL); }
	virtual ~ns1__elementType_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datasetInclude_
#define SOAP_TYPE_ns1__datasetInclude_ (267)
/* Primitive ns1:datasetInclude schema type: */
class SOAP_CMAC ns1__datasetInclude_ : public xsd__anyType
{
public:
	enum ns1__datasetInclude __item;
public:
	virtual int soap_type() const { return 267; } /* = unique id SOAP_TYPE_ns1__datasetInclude_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datasetInclude_() { ns1__datasetInclude_::soap_default(NULL); }
	virtual ~ns1__datasetInclude_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listDatasetTypes
#define SOAP_TYPE_ns1__listDatasetTypes (23)
/* ns1:listDatasetTypes */
class SOAP_CMAC ns1__listDatasetTypes : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__listDatasetTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listDatasetTypes(): sessionId(NULL) { ns1__listDatasetTypes::soap_default(NULL); }
	virtual ~ns1__listDatasetTypes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listDatasetTypesResponse
#define SOAP_TYPE_ns1__listDatasetTypesResponse (24)
/* ns1:listDatasetTypesResponse */
class SOAP_CMAC ns1__listDatasetTypesResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__listDatasetTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listDatasetTypesResponse() { ns1__listDatasetTypesResponse::soap_default(NULL); }
	virtual ~ns1__listDatasetTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchSamplesBySampleName
#define SOAP_TYPE_ns1__searchSamplesBySampleName (25)
/* ns1:searchSamplesBySampleName */
class SOAP_CMAC ns1__searchSamplesBySampleName : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *sampleName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__searchSamplesBySampleName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchSamplesBySampleName(): sessionId(NULL), sampleName(NULL) { ns1__searchSamplesBySampleName::soap_default(NULL); }
	virtual ~ns1__searchSamplesBySampleName() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchSamplesBySampleNameResponse
#define SOAP_TYPE_ns1__searchSamplesBySampleNameResponse (26)
/* ns1:searchSamplesBySampleNameResponse */
class SOAP_CMAC ns1__searchSamplesBySampleNameResponse : public xsd__anyType
{
public:
	std::vector<class ns1__sample * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:sample */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__searchSamplesBySampleNameResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchSamplesBySampleNameResponse() { ns1__searchSamplesBySampleNameResponse::soap_default(NULL); }
	virtual ~ns1__searchSamplesBySampleNameResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__entityBaseBean
#define SOAP_TYPE_ns1__entityBaseBean (28)
/* ns1:entityBaseBean */
class SOAP_CMAC ns1__entityBaseBean : public xsd__anyType
{
public:
	bool facilityAcquiredData;	/* required element of type xsd:boolean */
	class ns1__icatRole *icatRole;	/* optional element of type ns1:icatRole */
	bool selected;	/* required element of type xsd:boolean */
	std::string *uniqueId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__entityBaseBean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__entityBaseBean(): icatRole(NULL), uniqueId(NULL) { ns1__entityBaseBean::soap_default(NULL); }
	virtual ~ns1__entityBaseBean() { }
};
#endif

#ifndef SOAP_TYPE_ns1__entityPrimaryKeyBaseBean
#define SOAP_TYPE_ns1__entityPrimaryKeyBaseBean (31)
/* Primitive ns1:entityPrimaryKeyBaseBean schema type: */
class SOAP_CMAC ns1__entityPrimaryKeyBaseBean : public xsd__anyType
{
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__entityPrimaryKeyBaseBean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__entityPrimaryKeyBaseBean() { ns1__entityPrimaryKeyBaseBean::soap_default(NULL); }
	virtual ~ns1__entityPrimaryKeyBaseBean() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeSample
#define SOAP_TYPE_ns1__removeSample (33)
/* ns1:removeSample */
class SOAP_CMAC ns1__removeSample : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *sampleId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__removeSample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeSample(): sessionId(NULL), sampleId(NULL) { ns1__removeSample::soap_default(NULL); }
	virtual ~ns1__removeSample() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeSampleResponse
#define SOAP_TYPE_ns1__removeSampleResponse (34)
/* Primitive ns1:removeSampleResponse schema type: */
class SOAP_CMAC ns1__removeSampleResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__removeSampleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeSampleResponse() { ns1__removeSampleResponse::soap_default(NULL); }
	virtual ~ns1__removeSampleResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InsufficientPrivilegesException
#define SOAP_TYPE_ns1__InsufficientPrivilegesException (35)
/* ns1:InsufficientPrivilegesException */
class SOAP_CMAC ns1__InsufficientPrivilegesException : public xsd__anyType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	std::string *stackTraceAsString;	/* optional element of type xsd:string */
	std::string *uniqueId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__InsufficientPrivilegesException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InsufficientPrivilegesException(): message(NULL), stackTraceAsString(NULL), uniqueId(NULL) { ns1__InsufficientPrivilegesException::soap_default(NULL); }
	virtual ~ns1__InsufficientPrivilegesException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NoSuchObjectFoundException
#define SOAP_TYPE_ns1__NoSuchObjectFoundException (36)
/* ns1:NoSuchObjectFoundException */
class SOAP_CMAC ns1__NoSuchObjectFoundException : public xsd__anyType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	std::string *stackTraceAsString;	/* optional element of type xsd:string */
	std::string *uniqueId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__NoSuchObjectFoundException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NoSuchObjectFoundException(): message(NULL), stackTraceAsString(NULL), uniqueId(NULL) { ns1__NoSuchObjectFoundException::soap_default(NULL); }
	virtual ~ns1__NoSuchObjectFoundException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listInstruments
#define SOAP_TYPE_ns1__listInstruments (37)
/* ns1:listInstruments */
class SOAP_CMAC ns1__listInstruments : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__listInstruments */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listInstruments(): sessionId(NULL) { ns1__listInstruments::soap_default(NULL); }
	virtual ~ns1__listInstruments() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listInstrumentsResponse
#define SOAP_TYPE_ns1__listInstrumentsResponse (38)
/* ns1:listInstrumentsResponse */
class SOAP_CMAC ns1__listInstrumentsResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__listInstrumentsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listInstrumentsResponse() { ns1__listInstrumentsResponse::soap_default(NULL); }
	virtual ~ns1__listInstrumentsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataFile
#define SOAP_TYPE_ns1__createDataFile (39)
/* ns1:createDataFile */
class SOAP_CMAC ns1__createDataFile : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__datafile *dataFile;	/* optional element of type ns1:datafile */
	LONG64 *datasetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__createDataFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataFile(): sessionId(NULL), dataFile(NULL), datasetId(NULL) { ns1__createDataFile::soap_default(NULL); }
	virtual ~ns1__createDataFile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataFileResponse
#define SOAP_TYPE_ns1__createDataFileResponse (47)
/* ns1:createDataFileResponse */
class SOAP_CMAC ns1__createDataFileResponse : public xsd__anyType
{
public:
	ns1__datafile *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__createDataFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataFileResponse(): return_(NULL) { ns1__createDataFileResponse::soap_default(NULL); }
	virtual ~ns1__createDataFileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ValidationException
#define SOAP_TYPE_ns1__ValidationException (48)
/* ns1:ValidationException */
class SOAP_CMAC ns1__ValidationException : public xsd__anyType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	std::string *stackTraceAsString;	/* optional element of type xsd:string */
	std::string *uniqueId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__ValidationException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ValidationException(): message(NULL), stackTraceAsString(NULL), uniqueId(NULL) { ns1__ValidationException::soap_default(NULL); }
	virtual ~ns1__ValidationException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifySample
#define SOAP_TYPE_ns1__modifySample (49)
/* ns1:modifySample */
class SOAP_CMAC ns1__modifySample : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__sample *sample;	/* optional element of type ns1:sample */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns1__modifySample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifySample(): sessionId(NULL), sample(NULL) { ns1__modifySample::soap_default(NULL); }
	virtual ~ns1__modifySample() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifySampleResponse
#define SOAP_TYPE_ns1__modifySampleResponse (50)
/* Primitive ns1:modifySampleResponse schema type: */
class SOAP_CMAC ns1__modifySampleResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__modifySampleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifySampleResponse() { ns1__modifySampleResponse::soap_default(NULL); }
	virtual ~ns1__modifySampleResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataFile
#define SOAP_TYPE_ns1__removeDataFile (51)
/* ns1:removeDataFile */
class SOAP_CMAC ns1__removeDataFile : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__removeDataFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataFile(): sessionId(NULL), datafileId(NULL) { ns1__removeDataFile::soap_default(NULL); }
	virtual ~ns1__removeDataFile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataFileResponse
#define SOAP_TYPE_ns1__removeDataFileResponse (52)
/* Primitive ns1:removeDataFileResponse schema type: */
class SOAP_CMAC ns1__removeDataFileResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__removeDataFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataFileResponse() { ns1__removeDataFileResponse::soap_default(NULL); }
	virtual ~ns1__removeDataFileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeAuthorisation
#define SOAP_TYPE_ns1__removeAuthorisation (53)
/* ns1:removeAuthorisation */
class SOAP_CMAC ns1__removeAuthorisation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *authorisationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__removeAuthorisation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeAuthorisation(): sessionId(NULL), authorisationId(NULL) { ns1__removeAuthorisation::soap_default(NULL); }
	virtual ~ns1__removeAuthorisation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeAuthorisationResponse
#define SOAP_TYPE_ns1__removeAuthorisationResponse (54)
/* Primitive ns1:removeAuthorisationResponse schema type: */
class SOAP_CMAC ns1__removeAuthorisationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns1__removeAuthorisationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeAuthorisationResponse() { ns1__removeAuthorisationResponse::soap_default(NULL); }
	virtual ~ns1__removeAuthorisationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataFileParameters
#define SOAP_TYPE_ns1__addDataFileParameters (55)
/* ns1:addDataFileParameters */
class SOAP_CMAC ns1__addDataFileParameters : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<class ns1__datafileParameter * >dataFileParameters;	/* optional element of type ns1:datafileParameter */
	LONG64 *datafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__addDataFileParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataFileParameters(): sessionId(NULL), datafileId(NULL) { ns1__addDataFileParameters::soap_default(NULL); }
	virtual ~ns1__addDataFileParameters() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataFileParametersResponse
#define SOAP_TYPE_ns1__addDataFileParametersResponse (56)
/* ns1:addDataFileParametersResponse */
class SOAP_CMAC ns1__addDataFileParametersResponse : public xsd__anyType
{
public:
	std::vector<ns1__datafileParameter * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafileParameter */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__addDataFileParametersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataFileParametersResponse() { ns1__addDataFileParametersResponse::soap_default(NULL); }
	virtual ~ns1__addDataFileParametersResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listFacilityCycles
#define SOAP_TYPE_ns1__listFacilityCycles (57)
/* ns1:listFacilityCycles */
class SOAP_CMAC ns1__listFacilityCycles : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns1__listFacilityCycles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listFacilityCycles(): sessionId(NULL) { ns1__listFacilityCycles::soap_default(NULL); }
	virtual ~ns1__listFacilityCycles() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listFacilityCyclesResponse
#define SOAP_TYPE_ns1__listFacilityCyclesResponse (58)
/* ns1:listFacilityCyclesResponse */
class SOAP_CMAC ns1__listFacilityCyclesResponse : public xsd__anyType
{
public:
	std::vector<class ns1__facilityCycle * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:facilityCycle */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__listFacilityCyclesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listFacilityCyclesResponse() { ns1__listFacilityCyclesResponse::soap_default(NULL); }
	virtual ~ns1__listFacilityCyclesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__logout
#define SOAP_TYPE_ns1__logout (60)
/* ns1:logout */
class SOAP_CMAC ns1__logout : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns1__logout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__logout(): sessionId(NULL) { ns1__logout::soap_default(NULL); }
	virtual ~ns1__logout() { }
};
#endif

#ifndef SOAP_TYPE_ns1__logoutResponse
#define SOAP_TYPE_ns1__logoutResponse (61)
/* ns1:logoutResponse */
class SOAP_CMAC ns1__logoutResponse : public xsd__anyType
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__logoutResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__logoutResponse() { ns1__logoutResponse::soap_default(NULL); }
	virtual ~ns1__logoutResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadDataset
#define SOAP_TYPE_ns1__downloadDataset (62)
/* ns1:downloadDataset */
class SOAP_CMAC ns1__downloadDataset : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datasetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns1__downloadDataset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadDataset(): sessionId(NULL), datasetId(NULL) { ns1__downloadDataset::soap_default(NULL); }
	virtual ~ns1__downloadDataset() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadDatasetResponse
#define SOAP_TYPE_ns1__downloadDatasetResponse (63)
/* ns1:downloadDatasetResponse */
class SOAP_CMAC ns1__downloadDatasetResponse : public xsd__anyType
{
public:
	std::string *URL;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns1__downloadDatasetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadDatasetResponse(): URL(NULL) { ns1__downloadDatasetResponse::soap_default(NULL); }
	virtual ~ns1__downloadDatasetResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getFacilityUserByFederalId
#define SOAP_TYPE_ns1__getFacilityUserByFederalId (64)
/* ns1:getFacilityUserByFederalId */
class SOAP_CMAC ns1__getFacilityUserByFederalId : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *federalId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__getFacilityUserByFederalId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getFacilityUserByFederalId(): sessionId(NULL), federalId(NULL) { ns1__getFacilityUserByFederalId::soap_default(NULL); }
	virtual ~ns1__getFacilityUserByFederalId() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse
#define SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse (65)
/* ns1:getFacilityUserByFederalIdResponse */
class SOAP_CMAC ns1__getFacilityUserByFederalIdResponse : public xsd__anyType
{
public:
	class ns1__facilityUser *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:facilityUser */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns1__getFacilityUserByFederalIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getFacilityUserByFederalIdResponse(): return_(NULL) { ns1__getFacilityUserByFederalIdResponse::soap_default(NULL); }
	virtual ~ns1__getFacilityUserByFederalIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeInvestigator
#define SOAP_TYPE_ns1__removeInvestigator (67)
/* ns1:removeInvestigator */
class SOAP_CMAC ns1__removeInvestigator : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__investigatorPK *investigatorPK;	/* optional element of type ns1:investigatorPK */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns1__removeInvestigator */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeInvestigator(): sessionId(NULL), investigatorPK(NULL) { ns1__removeInvestigator::soap_default(NULL); }
	virtual ~ns1__removeInvestigator() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeInvestigatorResponse
#define SOAP_TYPE_ns1__removeInvestigatorResponse (69)
/* Primitive ns1:removeInvestigatorResponse schema type: */
class SOAP_CMAC ns1__removeInvestigatorResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns1__removeInvestigatorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeInvestigatorResponse() { ns1__removeInvestigatorResponse::soap_default(NULL); }
	virtual ~ns1__removeInvestigatorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeInvestigation
#define SOAP_TYPE_ns1__removeInvestigation (70)
/* ns1:removeInvestigation */
class SOAP_CMAC ns1__removeInvestigation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns1__removeInvestigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeInvestigation(): sessionId(NULL), investigationId(NULL) { ns1__removeInvestigation::soap_default(NULL); }
	virtual ~ns1__removeInvestigation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeInvestigationResponse
#define SOAP_TYPE_ns1__removeInvestigationResponse (71)
/* Primitive ns1:removeInvestigationResponse schema type: */
class SOAP_CMAC ns1__removeInvestigationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__removeInvestigationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeInvestigationResponse() { ns1__removeInvestigationResponse::soap_default(NULL); }
	virtual ~ns1__removeInvestigationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeKeyword
#define SOAP_TYPE_ns1__removeKeyword (72)
/* ns1:removeKeyword */
class SOAP_CMAC ns1__removeKeyword : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__keywordPK *keywordPK;	/* optional element of type ns1:keywordPK */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns1__removeKeyword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeKeyword(): sessionId(NULL), keywordPK(NULL) { ns1__removeKeyword::soap_default(NULL); }
	virtual ~ns1__removeKeyword() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeKeywordResponse
#define SOAP_TYPE_ns1__removeKeywordResponse (74)
/* Primitive ns1:removeKeywordResponse schema type: */
class SOAP_CMAC ns1__removeKeywordResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns1__removeKeywordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeKeywordResponse() { ns1__removeKeywordResponse::soap_default(NULL); }
	virtual ~ns1__removeKeywordResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteInvestigation
#define SOAP_TYPE_ns1__deleteInvestigation (75)
/* ns1:deleteInvestigation */
class SOAP_CMAC ns1__deleteInvestigation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ns1__deleteInvestigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteInvestigation(): sessionId(NULL), investigationId(NULL) { ns1__deleteInvestigation::soap_default(NULL); }
	virtual ~ns1__deleteInvestigation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteInvestigationResponse
#define SOAP_TYPE_ns1__deleteInvestigationResponse (76)
/* Primitive ns1:deleteInvestigationResponse schema type: */
class SOAP_CMAC ns1__deleteInvestigationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns1__deleteInvestigationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteInvestigationResponse() { ns1__deleteInvestigationResponse::soap_default(NULL); }
	virtual ~ns1__deleteInvestigationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataSets
#define SOAP_TYPE_ns1__createDataSets (77)
/* ns1:createDataSets */
class SOAP_CMAC ns1__createDataSets : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<class ns1__dataset * >dataSets;	/* optional element of type ns1:dataset */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns1__createDataSets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataSets(): sessionId(NULL), investigationId(NULL) { ns1__createDataSets::soap_default(NULL); }
	virtual ~ns1__createDataSets() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataSetsResponse
#define SOAP_TYPE_ns1__createDataSetsResponse (83)
/* ns1:createDataSetsResponse */
class SOAP_CMAC ns1__createDataSetsResponse : public xsd__anyType
{
public:
	std::vector<ns1__dataset * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns1__createDataSetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataSetsResponse() { ns1__createDataSetsResponse::soap_default(NULL); }
	virtual ~ns1__createDataSetsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removePublication
#define SOAP_TYPE_ns1__removePublication (84)
/* ns1:removePublication */
class SOAP_CMAC ns1__removePublication : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *publicationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ns1__removePublication */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removePublication(): sessionId(NULL), publicationId(NULL) { ns1__removePublication::soap_default(NULL); }
	virtual ~ns1__removePublication() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removePublicationResponse
#define SOAP_TYPE_ns1__removePublicationResponse (85)
/* Primitive ns1:removePublicationResponse schema type: */
class SOAP_CMAC ns1__removePublicationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns1__removePublicationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removePublicationResponse() { ns1__removePublicationResponse::soap_default(NULL); }
	virtual ~ns1__removePublicationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAllKeywords
#define SOAP_TYPE_ns1__getAllKeywords (86)
/* ns1:getAllKeywords */
class SOAP_CMAC ns1__getAllKeywords : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	enum ns1__keywordType *type;	/* optional element of type ns1:keywordType */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ns1__getAllKeywords */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAllKeywords(): sessionId(NULL), type(NULL) { ns1__getAllKeywords::soap_default(NULL); }
	virtual ~ns1__getAllKeywords() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAllKeywordsResponse
#define SOAP_TYPE_ns1__getAllKeywordsResponse (87)
/* ns1:getAllKeywordsResponse */
class SOAP_CMAC ns1__getAllKeywordsResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ns1__getAllKeywordsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAllKeywordsResponse() { ns1__getAllKeywordsResponse::soap_default(NULL); }
	virtual ~ns1__getAllKeywordsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getUserDetails
#define SOAP_TYPE_ns1__getUserDetails (88)
/* ns1:getUserDetails */
class SOAP_CMAC ns1__getUserDetails : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *usersName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ns1__getUserDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getUserDetails(): sessionId(NULL), usersName(NULL) { ns1__getUserDetails::soap_default(NULL); }
	virtual ~ns1__getUserDetails() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getUserDetailsResponse
#define SOAP_TYPE_ns1__getUserDetailsResponse (89)
/* ns1:getUserDetailsResponse */
class SOAP_CMAC ns1__getUserDetailsResponse : public xsd__anyType
{
public:
	class ns1__userDetails *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:userDetails */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ns1__getUserDetailsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getUserDetailsResponse(): return_(NULL) { ns1__getUserDetailsResponse::soap_default(NULL); }
	virtual ~ns1__getUserDetailsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__userDetails
#define SOAP_TYPE_ns1__userDetails (90)
/* ns1:userDetails */
class SOAP_CMAC ns1__userDetails : public xsd__anyType
{
public:
	std::string *credential;	/* optional element of type xsd:string */
	std::string *department;	/* optional element of type xsd:string */
	std::string *email;	/* optional element of type xsd:string */
	std::string *federalId;	/* optional element of type xsd:string */
	std::string *firstName;	/* optional element of type xsd:string */
	std::string *initial;	/* optional element of type xsd:string */
	std::string *institution;	/* optional element of type xsd:string */
	std::string *lastName;	/* optional element of type xsd:string */
	std::string *title;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ns1__userDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__userDetails(): credential(NULL), department(NULL), email(NULL), federalId(NULL), firstName(NULL), initial(NULL), institution(NULL), lastName(NULL), title(NULL) { ns1__userDetails::soap_default(NULL); }
	virtual ~ns1__userDetails() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NoSuchUserException
#define SOAP_TYPE_ns1__NoSuchUserException (91)
/* ns1:NoSuchUserException */
class SOAP_CMAC ns1__NoSuchUserException : public xsd__anyType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	std::string *stackTraceAsString;	/* optional element of type xsd:string */
	std::string *uniqueId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ns1__NoSuchUserException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NoSuchUserException(): message(NULL), stackTraceAsString(NULL), uniqueId(NULL) { ns1__NoSuchUserException::soap_default(NULL); }
	virtual ~ns1__NoSuchUserException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadDatafiles
#define SOAP_TYPE_ns1__downloadDatafiles (92)
/* ns1:downloadDatafiles */
class SOAP_CMAC ns1__downloadDatafiles : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<LONG64 >datafileIds;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns1__downloadDatafiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadDatafiles(): sessionId(NULL) { ns1__downloadDatafiles::soap_default(NULL); }
	virtual ~ns1__downloadDatafiles() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadDatafilesResponse
#define SOAP_TYPE_ns1__downloadDatafilesResponse (93)
/* ns1:downloadDatafilesResponse */
class SOAP_CMAC ns1__downloadDatafilesResponse : public xsd__anyType
{
public:
	std::string *URL;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns1__downloadDatafilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadDatafilesResponse(): URL(NULL) { ns1__downloadDatafilesResponse::soap_default(NULL); }
	virtual ~ns1__downloadDatafilesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataSet
#define SOAP_TYPE_ns1__modifyDataSet (94)
/* ns1:modifyDataSet */
class SOAP_CMAC ns1__modifyDataSet : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__dataset *dataSet;	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns1__modifyDataSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataSet(): sessionId(NULL), dataSet(NULL) { ns1__modifyDataSet::soap_default(NULL); }
	virtual ~ns1__modifyDataSet() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataSetResponse
#define SOAP_TYPE_ns1__modifyDataSetResponse (95)
/* Primitive ns1:modifyDataSetResponse schema type: */
class SOAP_CMAC ns1__modifyDataSetResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns1__modifyDataSetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataSetResponse() { ns1__modifyDataSetResponse::soap_default(NULL); }
	virtual ~ns1__modifyDataSetResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addSampleParameter
#define SOAP_TYPE_ns1__addSampleParameter (96)
/* ns1:addSampleParameter */
class SOAP_CMAC ns1__addSampleParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__sampleParameter *sampleParameter;	/* optional element of type ns1:sampleParameter */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns1__addSampleParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addSampleParameter(): sessionId(NULL), sampleParameter(NULL), investigationId(NULL) { ns1__addSampleParameter::soap_default(NULL); }
	virtual ~ns1__addSampleParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addSampleParameterResponse
#define SOAP_TYPE_ns1__addSampleParameterResponse (97)
/* ns1:addSampleParameterResponse */
class SOAP_CMAC ns1__addSampleParameterResponse : public xsd__anyType
{
public:
	ns1__sampleParameter *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:sampleParameter */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns1__addSampleParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addSampleParameterResponse(): return_(NULL) { ns1__addSampleParameterResponse::soap_default(NULL); }
	virtual ~ns1__addSampleParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getFacilityUserByFacilityUserId
#define SOAP_TYPE_ns1__getFacilityUserByFacilityUserId (98)
/* ns1:getFacilityUserByFacilityUserId */
class SOAP_CMAC ns1__getFacilityUserByFacilityUserId : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *facilityUserId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns1__getFacilityUserByFacilityUserId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getFacilityUserByFacilityUserId(): sessionId(NULL), facilityUserId(NULL) { ns1__getFacilityUserByFacilityUserId::soap_default(NULL); }
	virtual ~ns1__getFacilityUserByFacilityUserId() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse
#define SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse (99)
/* ns1:getFacilityUserByFacilityUserIdResponse */
class SOAP_CMAC ns1__getFacilityUserByFacilityUserIdResponse : public xsd__anyType
{
public:
	ns1__facilityUser *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:facilityUser */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns1__getFacilityUserByFacilityUserIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getFacilityUserByFacilityUserIdResponse(): return_(NULL) { ns1__getFacilityUserByFacilityUserIdResponse::soap_default(NULL); }
	virtual ~ns1__getFacilityUserByFacilityUserIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkDatafileDownloadAccess
#define SOAP_TYPE_ns1__checkDatafileDownloadAccess (100)
/* ns1:checkDatafileDownloadAccess */
class SOAP_CMAC ns1__checkDatafileDownloadAccess : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<LONG64 >datafileIds;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns1__checkDatafileDownloadAccess */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkDatafileDownloadAccess(): sessionId(NULL) { ns1__checkDatafileDownloadAccess::soap_default(NULL); }
	virtual ~ns1__checkDatafileDownloadAccess() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse
#define SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse (101)
/* ns1:checkDatafileDownloadAccessResponse */
class SOAP_CMAC ns1__checkDatafileDownloadAccessResponse : public xsd__anyType
{
public:
	class ns1__downloadInfo *downloadInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:downloadInfo */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns1__checkDatafileDownloadAccessResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkDatafileDownloadAccessResponse(): downloadInfo(NULL) { ns1__checkDatafileDownloadAccessResponse::soap_default(NULL); }
	virtual ~ns1__checkDatafileDownloadAccessResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadInfo
#define SOAP_TYPE_ns1__downloadInfo (102)
/* ns1:downloadInfo */
class SOAP_CMAC ns1__downloadInfo : public xsd__anyType
{
public:
	std::string *credential;	/* optional element of type xsd:string */
	std::vector<std::string >datafileLocations;	/* optional element of type xsd:string */
	std::vector<xsd__anyType * >datafileNames;	/* optional element of type xsd:anyType */
	std::string *userId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns1__downloadInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadInfo(): credential(NULL), userId(NULL) { ns1__downloadInfo::soap_default(NULL); }
	virtual ~ns1__downloadInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataFile
#define SOAP_TYPE_ns1__deleteDataFile (103)
/* ns1:deleteDataFile */
class SOAP_CMAC ns1__deleteDataFile : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns1__deleteDataFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataFile(): sessionId(NULL), datafileId(NULL) { ns1__deleteDataFile::soap_default(NULL); }
	virtual ~ns1__deleteDataFile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataFileResponse
#define SOAP_TYPE_ns1__deleteDataFileResponse (104)
/* Primitive ns1:deleteDataFileResponse schema type: */
class SOAP_CMAC ns1__deleteDataFileResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns1__deleteDataFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataFileResponse() { ns1__deleteDataFileResponse::soap_default(NULL); }
	virtual ~ns1__deleteDataFileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserSurname
#define SOAP_TYPE_ns1__searchByUserSurname (105)
/* ns1:searchByUserSurname */
class SOAP_CMAC ns1__searchByUserSurname : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *surname;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns1__searchByUserSurname */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserSurname(): sessionId(NULL), surname(NULL) { ns1__searchByUserSurname::soap_default(NULL); }
	virtual ~ns1__searchByUserSurname() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserSurnameResponse
#define SOAP_TYPE_ns1__searchByUserSurnameResponse (106)
/* ns1:searchByUserSurnameResponse */
class SOAP_CMAC ns1__searchByUserSurnameResponse : public xsd__anyType
{
public:
	std::vector<class ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns1__searchByUserSurnameResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserSurnameResponse() { ns1__searchByUserSurnameResponse::soap_default(NULL); }
	virtual ~ns1__searchByUserSurnameResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserSurnamePagination
#define SOAP_TYPE_ns1__searchByUserSurnamePagination (113)
/* ns1:searchByUserSurnamePagination */
class SOAP_CMAC ns1__searchByUserSurnamePagination : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *surname;	/* optional element of type xsd:string */
	int startIndex;	/* required element of type xsd:int */
	int numberOfResults;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE_ns1__searchByUserSurnamePagination */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserSurnamePagination(): sessionId(NULL), surname(NULL) { ns1__searchByUserSurnamePagination::soap_default(NULL); }
	virtual ~ns1__searchByUserSurnamePagination() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse
#define SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse (114)
/* ns1:searchByUserSurnamePaginationResponse */
class SOAP_CMAC ns1__searchByUserSurnamePaginationResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_ns1__searchByUserSurnamePaginationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserSurnamePaginationResponse() { ns1__searchByUserSurnamePaginationResponse::soap_default(NULL); }
	virtual ~ns1__searchByUserSurnamePaginationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkDatasetDownloadAccess
#define SOAP_TYPE_ns1__checkDatasetDownloadAccess (115)
/* ns1:checkDatasetDownloadAccess */
class SOAP_CMAC ns1__checkDatasetDownloadAccess : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datasetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE_ns1__checkDatasetDownloadAccess */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkDatasetDownloadAccess(): sessionId(NULL), datasetId(NULL) { ns1__checkDatasetDownloadAccess::soap_default(NULL); }
	virtual ~ns1__checkDatasetDownloadAccess() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse
#define SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse (116)
/* ns1:checkDatasetDownloadAccessResponse */
class SOAP_CMAC ns1__checkDatasetDownloadAccessResponse : public xsd__anyType
{
public:
	ns1__downloadInfo *downloadInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:downloadInfo */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_ns1__checkDatasetDownloadAccessResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkDatasetDownloadAccessResponse(): downloadInfo(NULL) { ns1__checkDatasetDownloadAccessResponse::soap_default(NULL); }
	virtual ~ns1__checkDatasetDownloadAccessResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByKeywords
#define SOAP_TYPE_ns1__searchByKeywords (117)
/* ns1:searchByKeywords */
class SOAP_CMAC ns1__searchByKeywords : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<std::string >keywords;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE_ns1__searchByKeywords */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByKeywords(): sessionId(NULL) { ns1__searchByKeywords::soap_default(NULL); }
	virtual ~ns1__searchByKeywords() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByKeywordsResponse
#define SOAP_TYPE_ns1__searchByKeywordsResponse (118)
/* ns1:searchByKeywordsResponse */
class SOAP_CMAC ns1__searchByKeywordsResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE_ns1__searchByKeywordsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByKeywordsResponse() { ns1__searchByKeywordsResponse::soap_default(NULL); }
	virtual ~ns1__searchByKeywordsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByKeywordsAll
#define SOAP_TYPE_ns1__searchByKeywordsAll (119)
/* ns1:searchByKeywordsAll */
class SOAP_CMAC ns1__searchByKeywordsAll : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__keywordDetails *keywordDetails;	/* optional element of type ns1:keywordDetails */
	int startIndex;	/* required element of type xsd:int */
	int numberOfResults;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE_ns1__searchByKeywordsAll */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByKeywordsAll(): sessionId(NULL), keywordDetails(NULL) { ns1__searchByKeywordsAll::soap_default(NULL); }
	virtual ~ns1__searchByKeywordsAll() { }
};
#endif

#ifndef SOAP_TYPE_ns1__keywordDetails
#define SOAP_TYPE_ns1__keywordDetails (120)
/* ns1:keywordDetails */
class SOAP_CMAC ns1__keywordDetails : public xsd__anyType
{
public:
	bool caseSensitive;	/* required element of type xsd:boolean */
	enum ns1__investigationInclude *investigationInclude;	/* optional element of type ns1:investigationInclude */
	std::vector<std::string >keywords;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE_ns1__keywordDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__keywordDetails(): investigationInclude(NULL) { ns1__keywordDetails::soap_default(NULL); }
	virtual ~ns1__keywordDetails() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByKeywordsAllResponse
#define SOAP_TYPE_ns1__searchByKeywordsAllResponse (121)
/* ns1:searchByKeywordsAllResponse */
class SOAP_CMAC ns1__searchByKeywordsAllResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE_ns1__searchByKeywordsAllResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByKeywordsAllResponse() { ns1__searchByKeywordsAllResponse::soap_default(NULL); }
	virtual ~ns1__searchByKeywordsAllResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyInvestigations
#define SOAP_TYPE_ns1__getMyInvestigations (122)
/* ns1:getMyInvestigations */
class SOAP_CMAC ns1__getMyInvestigations : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE_ns1__getMyInvestigations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyInvestigations(): sessionId(NULL) { ns1__getMyInvestigations::soap_default(NULL); }
	virtual ~ns1__getMyInvestigations() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyInvestigationsResponse
#define SOAP_TYPE_ns1__getMyInvestigationsResponse (123)
/* ns1:getMyInvestigationsResponse */
class SOAP_CMAC ns1__getMyInvestigationsResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_ns1__getMyInvestigationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyInvestigationsResponse() { ns1__getMyInvestigationsResponse::soap_default(NULL); }
	virtual ~ns1__getMyInvestigationsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyInvestigationsIncludes
#define SOAP_TYPE_ns1__getMyInvestigationsIncludes (124)
/* ns1:getMyInvestigationsIncludes */
class SOAP_CMAC ns1__getMyInvestigationsIncludes : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	enum ns1__investigationInclude *investigationInclude;	/* optional element of type ns1:investigationInclude */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE_ns1__getMyInvestigationsIncludes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyInvestigationsIncludes(): sessionId(NULL), investigationInclude(NULL) { ns1__getMyInvestigationsIncludes::soap_default(NULL); }
	virtual ~ns1__getMyInvestigationsIncludes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse
#define SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse (125)
/* ns1:getMyInvestigationsIncludesResponse */
class SOAP_CMAC ns1__getMyInvestigationsIncludesResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 125; } /* = unique id SOAP_TYPE_ns1__getMyInvestigationsIncludesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyInvestigationsIncludesResponse() { ns1__getMyInvestigationsIncludesResponse::soap_default(NULL); }
	virtual ~ns1__getMyInvestigationsIncludesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination
#define SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination (126)
/* ns1:getMyInvestigationsIncludesPagination */
class SOAP_CMAC ns1__getMyInvestigationsIncludesPagination : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	enum ns1__investigationInclude *investigationInclude;	/* optional element of type ns1:investigationInclude */
	int startIndex;	/* required element of type xsd:int */
	int numberOfResults;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE_ns1__getMyInvestigationsIncludesPagination */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyInvestigationsIncludesPagination(): sessionId(NULL), investigationInclude(NULL) { ns1__getMyInvestigationsIncludesPagination::soap_default(NULL); }
	virtual ~ns1__getMyInvestigationsIncludesPagination() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse
#define SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse (127)
/* ns1:getMyInvestigationsIncludesPaginationResponse */
class SOAP_CMAC ns1__getMyInvestigationsIncludesPaginationResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE_ns1__getMyInvestigationsIncludesPaginationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyInvestigationsIncludesPaginationResponse() { ns1__getMyInvestigationsIncludesPaginationResponse::soap_default(NULL); }
	virtual ~ns1__getMyInvestigationsIncludesPaginationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataSetParameter
#define SOAP_TYPE_ns1__removeDataSetParameter (128)
/* ns1:removeDataSetParameter */
class SOAP_CMAC ns1__removeDataSetParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__datasetParameterPK *datasetParameterPK;	/* optional element of type ns1:datasetParameterPK */
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE_ns1__removeDataSetParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataSetParameter(): sessionId(NULL), datasetParameterPK(NULL) { ns1__removeDataSetParameter::soap_default(NULL); }
	virtual ~ns1__removeDataSetParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataSetParameterResponse
#define SOAP_TYPE_ns1__removeDataSetParameterResponse (129)
/* Primitive ns1:removeDataSetParameterResponse schema type: */
class SOAP_CMAC ns1__removeDataSetParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE_ns1__removeDataSetParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataSetParameterResponse() { ns1__removeDataSetParameterResponse::soap_default(NULL); }
	virtual ~ns1__removeDataSetParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyPublication
#define SOAP_TYPE_ns1__modifyPublication (130)
/* ns1:modifyPublication */
class SOAP_CMAC ns1__modifyPublication : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__publication *publication;	/* optional element of type ns1:publication */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE_ns1__modifyPublication */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyPublication(): sessionId(NULL), publication(NULL) { ns1__modifyPublication::soap_default(NULL); }
	virtual ~ns1__modifyPublication() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyPublicationResponse
#define SOAP_TYPE_ns1__modifyPublicationResponse (131)
/* Primitive ns1:modifyPublicationResponse schema type: */
class SOAP_CMAC ns1__modifyPublicationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE_ns1__modifyPublicationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyPublicationResponse() { ns1__modifyPublicationResponse::soap_default(NULL); }
	virtual ~ns1__modifyPublicationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserID
#define SOAP_TYPE_ns1__searchByUserID (132)
/* ns1:searchByUserID */
class SOAP_CMAC ns1__searchByUserID : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *userSearch;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE_ns1__searchByUserID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserID(): sessionId(NULL), userSearch(NULL) { ns1__searchByUserID::soap_default(NULL); }
	virtual ~ns1__searchByUserID() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserIDResponse
#define SOAP_TYPE_ns1__searchByUserIDResponse (133)
/* ns1:searchByUserIDResponse */
class SOAP_CMAC ns1__searchByUserIDResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE_ns1__searchByUserIDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserIDResponse() { ns1__searchByUserIDResponse::soap_default(NULL); }
	virtual ~ns1__searchByUserIDResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserIDPagination
#define SOAP_TYPE_ns1__searchByUserIDPagination (134)
/* ns1:searchByUserIDPagination */
class SOAP_CMAC ns1__searchByUserIDPagination : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *userSearch;	/* optional element of type xsd:string */
	int startIndex;	/* required element of type xsd:int */
	int numberOfResults;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE_ns1__searchByUserIDPagination */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserIDPagination(): sessionId(NULL), userSearch(NULL) { ns1__searchByUserIDPagination::soap_default(NULL); }
	virtual ~ns1__searchByUserIDPagination() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByUserIDPaginationResponse
#define SOAP_TYPE_ns1__searchByUserIDPaginationResponse (135)
/* ns1:searchByUserIDPaginationResponse */
class SOAP_CMAC ns1__searchByUserIDPaginationResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE_ns1__searchByUserIDPaginationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByUserIDPaginationResponse() { ns1__searchByUserIDPaginationResponse::soap_default(NULL); }
	virtual ~ns1__searchByUserIDPaginationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataFileParameter
#define SOAP_TYPE_ns1__removeDataFileParameter (136)
/* ns1:removeDataFileParameter */
class SOAP_CMAC ns1__removeDataFileParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__datafileParameterPK *datafileParameterPK;	/* optional element of type ns1:datafileParameterPK */
public:
	virtual int soap_type() const { return 136; } /* = unique id SOAP_TYPE_ns1__removeDataFileParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataFileParameter(): sessionId(NULL), datafileParameterPK(NULL) { ns1__removeDataFileParameter::soap_default(NULL); }
	virtual ~ns1__removeDataFileParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataFileParameterResponse
#define SOAP_TYPE_ns1__removeDataFileParameterResponse (137)
/* Primitive ns1:removeDataFileParameterResponse schema type: */
class SOAP_CMAC ns1__removeDataFileParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE_ns1__removeDataFileParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataFileParameterResponse() { ns1__removeDataFileParameterResponse::soap_default(NULL); }
	virtual ~ns1__removeDataFileParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getInvestigationsIncludes
#define SOAP_TYPE_ns1__getInvestigationsIncludes (138)
/* ns1:getInvestigationsIncludes */
class SOAP_CMAC ns1__getInvestigationsIncludes : public xsd__anyType
{
public:
	std::string *userId;	/* optional element of type xsd:string */
	std::vector<LONG64 >investigationIds;	/* optional element of type xsd:long */
	enum ns1__investigationInclude *investigationInclude;	/* optional element of type ns1:investigationInclude */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE_ns1__getInvestigationsIncludes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getInvestigationsIncludes(): userId(NULL), investigationInclude(NULL) { ns1__getInvestigationsIncludes::soap_default(NULL); }
	virtual ~ns1__getInvestigationsIncludes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getInvestigationsIncludesResponse
#define SOAP_TYPE_ns1__getInvestigationsIncludesResponse (139)
/* ns1:getInvestigationsIncludesResponse */
class SOAP_CMAC ns1__getInvestigationsIncludesResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE_ns1__getInvestigationsIncludesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getInvestigationsIncludesResponse() { ns1__getInvestigationsIncludesResponse::soap_default(NULL); }
	virtual ~ns1__getInvestigationsIncludesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataSet
#define SOAP_TYPE_ns1__deleteDataSet (140)
/* ns1:deleteDataSet */
class SOAP_CMAC ns1__deleteDataSet : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *dataSetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE_ns1__deleteDataSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataSet(): sessionId(NULL), dataSetId(NULL) { ns1__deleteDataSet::soap_default(NULL); }
	virtual ~ns1__deleteDataSet() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataSetResponse
#define SOAP_TYPE_ns1__deleteDataSetResponse (141)
/* Primitive ns1:deleteDataSetResponse schema type: */
class SOAP_CMAC ns1__deleteDataSetResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 141; } /* = unique id SOAP_TYPE_ns1__deleteDataSetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataSetResponse() { ns1__deleteDataSetResponse::soap_default(NULL); }
	virtual ~ns1__deleteDataSetResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatafiles
#define SOAP_TYPE_ns1__getDatafiles (142)
/* ns1:getDatafiles */
class SOAP_CMAC ns1__getDatafiles : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<LONG64 >datafileIds;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE_ns1__getDatafiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatafiles(): sessionId(NULL) { ns1__getDatafiles::soap_default(NULL); }
	virtual ~ns1__getDatafiles() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatafilesResponse
#define SOAP_TYPE_ns1__getDatafilesResponse (143)
/* ns1:getDatafilesResponse */
class SOAP_CMAC ns1__getDatafilesResponse : public xsd__anyType
{
public:
	std::vector<ns1__datafile * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE_ns1__getDatafilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatafilesResponse() { ns1__getDatafilesResponse::soap_default(NULL); }
	virtual ~ns1__getDatafilesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getICATAPIVersion
#define SOAP_TYPE_ns1__getICATAPIVersion (144)
/* ns1:getICATAPIVersion */
class SOAP_CMAC ns1__getICATAPIVersion : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE_ns1__getICATAPIVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getICATAPIVersion(): sessionId(NULL) { ns1__getICATAPIVersion::soap_default(NULL); }
	virtual ~ns1__getICATAPIVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getICATAPIVersionResponse
#define SOAP_TYPE_ns1__getICATAPIVersionResponse (145)
/* ns1:getICATAPIVersionResponse */
class SOAP_CMAC ns1__getICATAPIVersionResponse : public xsd__anyType
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 145; } /* = unique id SOAP_TYPE_ns1__getICATAPIVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getICATAPIVersionResponse(): return_(NULL) { ns1__getICATAPIVersionResponse::soap_default(NULL); }
	virtual ~ns1__getICATAPIVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteInvestigator
#define SOAP_TYPE_ns1__deleteInvestigator (146)
/* ns1:deleteInvestigator */
class SOAP_CMAC ns1__deleteInvestigator : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__investigatorPK *investigatorPK;	/* optional element of type ns1:investigatorPK */
public:
	virtual int soap_type() const { return 146; } /* = unique id SOAP_TYPE_ns1__deleteInvestigator */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteInvestigator(): sessionId(NULL), investigatorPK(NULL) { ns1__deleteInvestigator::soap_default(NULL); }
	virtual ~ns1__deleteInvestigator() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteInvestigatorResponse
#define SOAP_TYPE_ns1__deleteInvestigatorResponse (147)
/* Primitive ns1:deleteInvestigatorResponse schema type: */
class SOAP_CMAC ns1__deleteInvestigatorResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE_ns1__deleteInvestigatorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteInvestigatorResponse() { ns1__deleteInvestigatorResponse::soap_default(NULL); }
	virtual ~ns1__deleteInvestigatorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addInvestigator
#define SOAP_TYPE_ns1__addInvestigator (148)
/* ns1:addInvestigator */
class SOAP_CMAC ns1__addInvestigator : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__investigator *investigator;	/* optional element of type ns1:investigator */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE_ns1__addInvestigator */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addInvestigator(): sessionId(NULL), investigator(NULL), investigationId(NULL) { ns1__addInvestigator::soap_default(NULL); }
	virtual ~ns1__addInvestigator() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addInvestigatorResponse
#define SOAP_TYPE_ns1__addInvestigatorResponse (149)
/* ns1:addInvestigatorResponse */
class SOAP_CMAC ns1__addInvestigatorResponse : public xsd__anyType
{
public:
	ns1__investigator *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigator */
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE_ns1__addInvestigatorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addInvestigatorResponse(): return_(NULL) { ns1__addInvestigatorResponse::soap_default(NULL); }
	virtual ~ns1__addInvestigatorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataSet
#define SOAP_TYPE_ns1__createDataSet (150)
/* ns1:createDataSet */
class SOAP_CMAC ns1__createDataSet : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__dataset *dataSet;	/* optional element of type ns1:dataset */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 150; } /* = unique id SOAP_TYPE_ns1__createDataSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataSet(): sessionId(NULL), dataSet(NULL), investigationId(NULL) { ns1__createDataSet::soap_default(NULL); }
	virtual ~ns1__createDataSet() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataSetResponse
#define SOAP_TYPE_ns1__createDataSetResponse (151)
/* ns1:createDataSetResponse */
class SOAP_CMAC ns1__createDataSetResponse : public xsd__anyType
{
public:
	ns1__dataset *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE_ns1__createDataSetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataSetResponse(): return_(NULL) { ns1__createDataSetResponse::soap_default(NULL); }
	virtual ~ns1__createDataSetResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeSampleParameter
#define SOAP_TYPE_ns1__removeSampleParameter (152)
/* ns1:removeSampleParameter */
class SOAP_CMAC ns1__removeSampleParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__sampleParameterPK *sampleParameterPK;	/* optional element of type ns1:sampleParameterPK */
public:
	virtual int soap_type() const { return 152; } /* = unique id SOAP_TYPE_ns1__removeSampleParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeSampleParameter(): sessionId(NULL), sampleParameterPK(NULL) { ns1__removeSampleParameter::soap_default(NULL); }
	virtual ~ns1__removeSampleParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeSampleParameterResponse
#define SOAP_TYPE_ns1__removeSampleParameterResponse (153)
/* Primitive ns1:removeSampleParameterResponse schema type: */
class SOAP_CMAC ns1__removeSampleParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 153; } /* = unique id SOAP_TYPE_ns1__removeSampleParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeSampleParameterResponse() { ns1__removeSampleParameterResponse::soap_default(NULL); }
	virtual ~ns1__removeSampleParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataSetParameter
#define SOAP_TYPE_ns1__deleteDataSetParameter (154)
/* ns1:deleteDataSetParameter */
class SOAP_CMAC ns1__deleteDataSetParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__datasetParameterPK *datasetParameterPK;	/* optional element of type ns1:datasetParameterPK */
public:
	virtual int soap_type() const { return 154; } /* = unique id SOAP_TYPE_ns1__deleteDataSetParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataSetParameter(): sessionId(NULL), datasetParameterPK(NULL) { ns1__deleteDataSetParameter::soap_default(NULL); }
	virtual ~ns1__deleteDataSetParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataSetParameterResponse
#define SOAP_TYPE_ns1__deleteDataSetParameterResponse (155)
/* Primitive ns1:deleteDataSetParameterResponse schema type: */
class SOAP_CMAC ns1__deleteDataSetParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE_ns1__deleteDataSetParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataSetParameterResponse() { ns1__deleteDataSetParameterResponse::soap_default(NULL); }
	virtual ~ns1__deleteDataSetParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setDataSetSample
#define SOAP_TYPE_ns1__setDataSetSample (156)
/* ns1:setDataSetSample */
class SOAP_CMAC ns1__setDataSetSample : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *sampleId;	/* optional element of type xsd:long */
	LONG64 *datafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 156; } /* = unique id SOAP_TYPE_ns1__setDataSetSample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setDataSetSample(): sessionId(NULL), sampleId(NULL), datafileId(NULL) { ns1__setDataSetSample::soap_default(NULL); }
	virtual ~ns1__setDataSetSample() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setDataSetSampleResponse
#define SOAP_TYPE_ns1__setDataSetSampleResponse (157)
/* Primitive ns1:setDataSetSampleResponse schema type: */
class SOAP_CMAC ns1__setDataSetSampleResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 157; } /* = unique id SOAP_TYPE_ns1__setDataSetSampleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setDataSetSampleResponse() { ns1__setDataSetSampleResponse::soap_default(NULL); }
	virtual ~ns1__setDataSetSampleResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadDatafile
#define SOAP_TYPE_ns1__downloadDatafile (158)
/* ns1:downloadDatafile */
class SOAP_CMAC ns1__downloadDatafile : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE_ns1__downloadDatafile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadDatafile(): sessionId(NULL), datafileId(NULL) { ns1__downloadDatafile::soap_default(NULL); }
	virtual ~ns1__downloadDatafile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadDatafileResponse
#define SOAP_TYPE_ns1__downloadDatafileResponse (159)
/* ns1:downloadDatafileResponse */
class SOAP_CMAC ns1__downloadDatafileResponse : public xsd__anyType
{
public:
	std::string *URL;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE_ns1__downloadDatafileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadDatafileResponse(): URL(NULL) { ns1__downloadDatafileResponse::soap_default(NULL); }
	virtual ~ns1__downloadDatafileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUser
#define SOAP_TYPE_ns1__getKeywordsForUser (160)
/* ns1:getKeywordsForUser */
class SOAP_CMAC ns1__getKeywordsForUser : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 160; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUser(): sessionId(NULL) { ns1__getKeywordsForUser::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUser() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUserResponse
#define SOAP_TYPE_ns1__getKeywordsForUserResponse (161)
/* ns1:getKeywordsForUserResponse */
class SOAP_CMAC ns1__getKeywordsForUserResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUserResponse() { ns1__getKeywordsForUserResponse::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUserResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUserStartWithMax
#define SOAP_TYPE_ns1__getKeywordsForUserStartWithMax (162)
/* ns1:getKeywordsForUserStartWithMax */
class SOAP_CMAC ns1__getKeywordsForUserStartWithMax : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *startKeyword;	/* optional element of type xsd:string */
	int numberReturned;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 162; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUserStartWithMax */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUserStartWithMax(): sessionId(NULL), startKeyword(NULL) { ns1__getKeywordsForUserStartWithMax::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUserStartWithMax() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse
#define SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse (163)
/* ns1:getKeywordsForUserStartWithMaxResponse */
class SOAP_CMAC ns1__getKeywordsForUserStartWithMaxResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUserStartWithMaxResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUserStartWithMaxResponse() { ns1__getKeywordsForUserStartWithMaxResponse::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUserStartWithMaxResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUserMax
#define SOAP_TYPE_ns1__getKeywordsForUserMax (164)
/* ns1:getKeywordsForUserMax */
class SOAP_CMAC ns1__getKeywordsForUserMax : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	int numberReturned;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUserMax */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUserMax(): sessionId(NULL) { ns1__getKeywordsForUserMax::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUserMax() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUserMaxResponse
#define SOAP_TYPE_ns1__getKeywordsForUserMaxResponse (165)
/* ns1:getKeywordsForUserMaxResponse */
class SOAP_CMAC ns1__getKeywordsForUserMaxResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 165; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUserMaxResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUserMaxResponse() { ns1__getKeywordsForUserMaxResponse::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUserMaxResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUserType
#define SOAP_TYPE_ns1__getKeywordsForUserType (166)
/* ns1:getKeywordsForUserType */
class SOAP_CMAC ns1__getKeywordsForUserType : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	enum ns1__keywordType *keywordType;	/* optional element of type ns1:keywordType */
public:
	virtual int soap_type() const { return 166; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUserType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUserType(): sessionId(NULL), keywordType(NULL) { ns1__getKeywordsForUserType::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUserType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getKeywordsForUserTypeResponse
#define SOAP_TYPE_ns1__getKeywordsForUserTypeResponse (167)
/* ns1:getKeywordsForUserTypeResponse */
class SOAP_CMAC ns1__getKeywordsForUserTypeResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE_ns1__getKeywordsForUserTypeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getKeywordsForUserTypeResponse() { ns1__getKeywordsForUserTypeResponse::soap_default(NULL); }
	virtual ~ns1__getKeywordsForUserTypeResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listInvestigationTypes
#define SOAP_TYPE_ns1__listInvestigationTypes (168)
/* ns1:listInvestigationTypes */
class SOAP_CMAC ns1__listInvestigationTypes : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE_ns1__listInvestigationTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listInvestigationTypes(): sessionId(NULL) { ns1__listInvestigationTypes::soap_default(NULL); }
	virtual ~ns1__listInvestigationTypes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listInvestigationTypesResponse
#define SOAP_TYPE_ns1__listInvestigationTypesResponse (169)
/* ns1:listInvestigationTypesResponse */
class SOAP_CMAC ns1__listInvestigationTypesResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE_ns1__listInvestigationTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listInvestigationTypesResponse() { ns1__listInvestigationTypesResponse::soap_default(NULL); }
	virtual ~ns1__listInvestigationTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataSetParameter
#define SOAP_TYPE_ns1__modifyDataSetParameter (170)
/* ns1:modifyDataSetParameter */
class SOAP_CMAC ns1__modifyDataSetParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__datasetParameter *dataSetParameter;	/* optional element of type ns1:datasetParameter */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE_ns1__modifyDataSetParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataSetParameter(): sessionId(NULL), dataSetParameter(NULL) { ns1__modifyDataSetParameter::soap_default(NULL); }
	virtual ~ns1__modifyDataSetParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataSetParameterResponse
#define SOAP_TYPE_ns1__modifyDataSetParameterResponse (171)
/* Primitive ns1:modifyDataSetParameterResponse schema type: */
class SOAP_CMAC ns1__modifyDataSetParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 171; } /* = unique id SOAP_TYPE_ns1__modifyDataSetParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataSetParameterResponse() { ns1__modifyDataSetParameterResponse::soap_default(NULL); }
	virtual ~ns1__modifyDataSetParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataSet
#define SOAP_TYPE_ns1__removeDataSet (172)
/* ns1:removeDataSet */
class SOAP_CMAC ns1__removeDataSet : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *dataSetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE_ns1__removeDataSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataSet(): sessionId(NULL), dataSetId(NULL) { ns1__removeDataSet::soap_default(NULL); }
	virtual ~ns1__removeDataSet() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeDataSetResponse
#define SOAP_TYPE_ns1__removeDataSetResponse (173)
/* Primitive ns1:removeDataSetResponse schema type: */
class SOAP_CMAC ns1__removeDataSetResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 173; } /* = unique id SOAP_TYPE_ns1__removeDataSetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeDataSetResponse() { ns1__removeDataSetResponse::soap_default(NULL); }
	virtual ~ns1__removeDataSetResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAuthorisations
#define SOAP_TYPE_ns1__getAuthorisations (174)
/* ns1:getAuthorisations */
class SOAP_CMAC ns1__getAuthorisations : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *elementId;	/* optional element of type xsd:long */
	enum ns1__elementType *elementType;	/* optional element of type ns1:elementType */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE_ns1__getAuthorisations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAuthorisations(): sessionId(NULL), elementId(NULL), elementType(NULL) { ns1__getAuthorisations::soap_default(NULL); }
	virtual ~ns1__getAuthorisations() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAuthorisationsResponse
#define SOAP_TYPE_ns1__getAuthorisationsResponse (175)
/* ns1:getAuthorisationsResponse */
class SOAP_CMAC ns1__getAuthorisationsResponse : public xsd__anyType
{
public:
	std::vector<class ns1__icatAuthorisation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:icatAuthorisation */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE_ns1__getAuthorisationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAuthorisationsResponse() { ns1__getAuthorisationsResponse::soap_default(NULL); }
	virtual ~ns1__getAuthorisationsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addKeyword
#define SOAP_TYPE_ns1__addKeyword (177)
/* ns1:addKeyword */
class SOAP_CMAC ns1__addKeyword : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__keyword *keyword;	/* optional element of type ns1:keyword */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 177; } /* = unique id SOAP_TYPE_ns1__addKeyword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addKeyword(): sessionId(NULL), keyword(NULL), investigationId(NULL) { ns1__addKeyword::soap_default(NULL); }
	virtual ~ns1__addKeyword() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addKeywordResponse
#define SOAP_TYPE_ns1__addKeywordResponse (178)
/* ns1:addKeywordResponse */
class SOAP_CMAC ns1__addKeywordResponse : public xsd__anyType
{
public:
	ns1__keyword *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:keyword */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE_ns1__addKeywordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addKeywordResponse(): return_(NULL) { ns1__addKeywordResponse::soap_default(NULL); }
	virtual ~ns1__addKeywordResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyInvestigation
#define SOAP_TYPE_ns1__modifyInvestigation (179)
/* ns1:modifyInvestigation */
class SOAP_CMAC ns1__modifyInvestigation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__investigation *investigaion;	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE_ns1__modifyInvestigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyInvestigation(): sessionId(NULL), investigaion(NULL) { ns1__modifyInvestigation::soap_default(NULL); }
	virtual ~ns1__modifyInvestigation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyInvestigationResponse
#define SOAP_TYPE_ns1__modifyInvestigationResponse (180)
/* Primitive ns1:modifyInvestigationResponse schema type: */
class SOAP_CMAC ns1__modifyInvestigationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 180; } /* = unique id SOAP_TYPE_ns1__modifyInvestigationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyInvestigationResponse() { ns1__modifyInvestigationResponse::soap_default(NULL); }
	virtual ~ns1__modifyInvestigationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listDatasetStatus
#define SOAP_TYPE_ns1__listDatasetStatus (181)
/* ns1:listDatasetStatus */
class SOAP_CMAC ns1__listDatasetStatus : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 181; } /* = unique id SOAP_TYPE_ns1__listDatasetStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listDatasetStatus(): sessionId(NULL) { ns1__listDatasetStatus::soap_default(NULL); }
	virtual ~ns1__listDatasetStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listDatasetStatusResponse
#define SOAP_TYPE_ns1__listDatasetStatusResponse (182)
/* ns1:listDatasetStatusResponse */
class SOAP_CMAC ns1__listDatasetStatusResponse : public xsd__anyType
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE_ns1__listDatasetStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listDatasetStatusResponse() { ns1__listDatasetStatusResponse::soap_default(NULL); }
	virtual ~ns1__listDatasetStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteSample
#define SOAP_TYPE_ns1__deleteSample (183)
/* ns1:deleteSample */
class SOAP_CMAC ns1__deleteSample : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *sampleId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 183; } /* = unique id SOAP_TYPE_ns1__deleteSample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteSample(): sessionId(NULL), sampleId(NULL) { ns1__deleteSample::soap_default(NULL); }
	virtual ~ns1__deleteSample() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteSampleResponse
#define SOAP_TYPE_ns1__deleteSampleResponse (184)
/* Primitive ns1:deleteSampleResponse schema type: */
class SOAP_CMAC ns1__deleteSampleResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 184; } /* = unique id SOAP_TYPE_ns1__deleteSampleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteSampleResponse() { ns1__deleteSampleResponse::soap_default(NULL); }
	virtual ~ns1__deleteSampleResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteKeyword
#define SOAP_TYPE_ns1__deleteKeyword (185)
/* ns1:deleteKeyword */
class SOAP_CMAC ns1__deleteKeyword : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__keywordPK *keywordPK;	/* optional element of type ns1:keywordPK */
public:
	virtual int soap_type() const { return 185; } /* = unique id SOAP_TYPE_ns1__deleteKeyword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteKeyword(): sessionId(NULL), keywordPK(NULL) { ns1__deleteKeyword::soap_default(NULL); }
	virtual ~ns1__deleteKeyword() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteKeywordResponse
#define SOAP_TYPE_ns1__deleteKeywordResponse (186)
/* Primitive ns1:deleteKeywordResponse schema type: */
class SOAP_CMAC ns1__deleteKeywordResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 186; } /* = unique id SOAP_TYPE_ns1__deleteKeywordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteKeywordResponse() { ns1__deleteKeywordResponse::soap_default(NULL); }
	virtual ~ns1__deleteKeywordResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataSetParameters
#define SOAP_TYPE_ns1__addDataSetParameters (187)
/* ns1:addDataSetParameters */
class SOAP_CMAC ns1__addDataSetParameters : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<ns1__datasetParameter * >dataSetParameters;	/* optional element of type ns1:datasetParameter */
	LONG64 *datasetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 187; } /* = unique id SOAP_TYPE_ns1__addDataSetParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataSetParameters(): sessionId(NULL), datasetId(NULL) { ns1__addDataSetParameters::soap_default(NULL); }
	virtual ~ns1__addDataSetParameters() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataSetParametersResponse
#define SOAP_TYPE_ns1__addDataSetParametersResponse (188)
/* ns1:addDataSetParametersResponse */
class SOAP_CMAC ns1__addDataSetParametersResponse : public xsd__anyType
{
public:
	std::vector<ns1__datasetParameter * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datasetParameter */
public:
	virtual int soap_type() const { return 188; } /* = unique id SOAP_TYPE_ns1__addDataSetParametersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataSetParametersResponse() { ns1__addDataSetParametersResponse::soap_default(NULL); }
	virtual ~ns1__addDataSetParametersResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByRunNumber
#define SOAP_TYPE_ns1__searchByRunNumber (189)
/* ns1:searchByRunNumber */
class SOAP_CMAC ns1__searchByRunNumber : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<std::string >instruments;	/* optional element of type xsd:string */
	float startRun;	/* required element of type xsd:float */
	float endRun;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 189; } /* = unique id SOAP_TYPE_ns1__searchByRunNumber */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByRunNumber(): sessionId(NULL) { ns1__searchByRunNumber::soap_default(NULL); }
	virtual ~ns1__searchByRunNumber() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByRunNumberResponse
#define SOAP_TYPE_ns1__searchByRunNumberResponse (190)
/* ns1:searchByRunNumberResponse */
class SOAP_CMAC ns1__searchByRunNumberResponse : public xsd__anyType
{
public:
	std::vector<ns1__datafile * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 190; } /* = unique id SOAP_TYPE_ns1__searchByRunNumberResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByRunNumberResponse() { ns1__searchByRunNumberResponse::soap_default(NULL); }
	virtual ~ns1__searchByRunNumberResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByRunNumberPagination
#define SOAP_TYPE_ns1__searchByRunNumberPagination (191)
/* ns1:searchByRunNumberPagination */
class SOAP_CMAC ns1__searchByRunNumberPagination : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<std::string >instruments;	/* optional element of type xsd:string */
	float startRun;	/* required element of type xsd:float */
	float endRun;	/* required element of type xsd:float */
	int startIndex;	/* required element of type xsd:int */
	int numberOfResults;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 191; } /* = unique id SOAP_TYPE_ns1__searchByRunNumberPagination */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByRunNumberPagination(): sessionId(NULL) { ns1__searchByRunNumberPagination::soap_default(NULL); }
	virtual ~ns1__searchByRunNumberPagination() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByRunNumberPaginationResponse
#define SOAP_TYPE_ns1__searchByRunNumberPaginationResponse (192)
/* ns1:searchByRunNumberPaginationResponse */
class SOAP_CMAC ns1__searchByRunNumberPaginationResponse : public xsd__anyType
{
public:
	std::vector<ns1__datafile * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 192; } /* = unique id SOAP_TYPE_ns1__searchByRunNumberPaginationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByRunNumberPaginationResponse() { ns1__searchByRunNumberPaginationResponse::soap_default(NULL); }
	virtual ~ns1__searchByRunNumberPaginationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByAdvanced
#define SOAP_TYPE_ns1__searchByAdvanced (193)
/* ns1:searchByAdvanced */
class SOAP_CMAC ns1__searchByAdvanced : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	class ns1__advancedSearchDetails *advancedSearchDetails;	/* optional element of type ns1:advancedSearchDetails */
public:
	virtual int soap_type() const { return 193; } /* = unique id SOAP_TYPE_ns1__searchByAdvanced */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByAdvanced(): sessionId(NULL), advancedSearchDetails(NULL) { ns1__searchByAdvanced::soap_default(NULL); }
	virtual ~ns1__searchByAdvanced() { }
};
#endif

#ifndef SOAP_TYPE_ns1__advancedSearchDetails
#define SOAP_TYPE_ns1__advancedSearchDetails (194)
/* ns1:advancedSearchDetails */
class SOAP_CMAC ns1__advancedSearchDetails : public xsd__anyType
{
public:
	std::string *backCatalogueInvestigatorString;	/* optional element of type xsd:string */
	bool caseSensitive;	/* required element of type xsd:boolean */
	std::string *datafileName;	/* optional element of type xsd:string */
	time_t *dateRangeEnd;	/* optional element of type xsd:dateTime */
	time_t *dateRangeStart;	/* optional element of type xsd:dateTime */
	std::string *experimentNumber;	/* optional element of type xsd:string */
	LONG64 *grantId;	/* optional element of type xsd:long */
	std::vector<std::string >instruments;	/* optional element of type xsd:string */
	std::string *investigationAbstract;	/* optional element of type xsd:string */
	enum ns1__investigationInclude *investigationInclude;	/* optional element of type ns1:investigationInclude */
	std::string *investigationName;	/* optional element of type xsd:string */
	std::string *investigationType;	/* optional element of type xsd:string */
	std::vector<std::string >investigators;	/* optional element of type xsd:string */
	std::vector<std::string >keywords;	/* optional element of type xsd:string */
	double *runEnd;	/* optional element of type xsd:double */
	double *runStart;	/* optional element of type xsd:double */
	std::string *sampleName;	/* optional element of type xsd:string */
	std::string *visitId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 194; } /* = unique id SOAP_TYPE_ns1__advancedSearchDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__advancedSearchDetails(): backCatalogueInvestigatorString(NULL), datafileName(NULL), dateRangeEnd(NULL), dateRangeStart(NULL), experimentNumber(NULL), grantId(NULL), investigationAbstract(NULL), investigationInclude(NULL), investigationName(NULL), investigationType(NULL), runEnd(NULL), runStart(NULL), sampleName(NULL), visitId(NULL) { ns1__advancedSearchDetails::soap_default(NULL); }
	virtual ~ns1__advancedSearchDetails() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByAdvancedResponse
#define SOAP_TYPE_ns1__searchByAdvancedResponse (195)
/* ns1:searchByAdvancedResponse */
class SOAP_CMAC ns1__searchByAdvancedResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE_ns1__searchByAdvancedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByAdvancedResponse() { ns1__searchByAdvancedResponse::soap_default(NULL); }
	virtual ~ns1__searchByAdvancedResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByAdvancedPagination
#define SOAP_TYPE_ns1__searchByAdvancedPagination (196)
/* ns1:searchByAdvancedPagination */
class SOAP_CMAC ns1__searchByAdvancedPagination : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__advancedSearchDetails *advancedSearchDetails;	/* optional element of type ns1:advancedSearchDetails */
	int startIndex;	/* required element of type xsd:int */
	int numberOfResults;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 196; } /* = unique id SOAP_TYPE_ns1__searchByAdvancedPagination */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByAdvancedPagination(): sessionId(NULL), advancedSearchDetails(NULL) { ns1__searchByAdvancedPagination::soap_default(NULL); }
	virtual ~ns1__searchByAdvancedPagination() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchByAdvancedPaginationResponse
#define SOAP_TYPE_ns1__searchByAdvancedPaginationResponse (197)
/* ns1:searchByAdvancedPaginationResponse */
class SOAP_CMAC ns1__searchByAdvancedPaginationResponse : public xsd__anyType
{
public:
	std::vector<ns1__investigation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 197; } /* = unique id SOAP_TYPE_ns1__searchByAdvancedPaginationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchByAdvancedPaginationResponse() { ns1__searchByAdvancedPaginationResponse::soap_default(NULL); }
	virtual ~ns1__searchByAdvancedPaginationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listDatafileFormats
#define SOAP_TYPE_ns1__listDatafileFormats (198)
/* ns1:listDatafileFormats */
class SOAP_CMAC ns1__listDatafileFormats : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 198; } /* = unique id SOAP_TYPE_ns1__listDatafileFormats */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listDatafileFormats(): sessionId(NULL) { ns1__listDatafileFormats::soap_default(NULL); }
	virtual ~ns1__listDatafileFormats() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listDatafileFormatsResponse
#define SOAP_TYPE_ns1__listDatafileFormatsResponse (199)
/* ns1:listDatafileFormatsResponse */
class SOAP_CMAC ns1__listDatafileFormatsResponse : public xsd__anyType
{
public:
	std::vector<class ns1__datafileFormat * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafileFormat */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE_ns1__listDatafileFormatsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listDatafileFormatsResponse() { ns1__listDatafileFormatsResponse::soap_default(NULL); }
	virtual ~ns1__listDatafileFormatsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifySampleParameter
#define SOAP_TYPE_ns1__modifySampleParameter (200)
/* ns1:modifySampleParameter */
class SOAP_CMAC ns1__modifySampleParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__sampleParameter *sampleParameter;	/* optional element of type ns1:sampleParameter */
public:
	virtual int soap_type() const { return 200; } /* = unique id SOAP_TYPE_ns1__modifySampleParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifySampleParameter(): sessionId(NULL), sampleParameter(NULL) { ns1__modifySampleParameter::soap_default(NULL); }
	virtual ~ns1__modifySampleParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifySampleParameterResponse
#define SOAP_TYPE_ns1__modifySampleParameterResponse (201)
/* Primitive ns1:modifySampleParameterResponse schema type: */
class SOAP_CMAC ns1__modifySampleParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 201; } /* = unique id SOAP_TYPE_ns1__modifySampleParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifySampleParameterResponse() { ns1__modifySampleParameterResponse::soap_default(NULL); }
	virtual ~ns1__modifySampleParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyInvestigator
#define SOAP_TYPE_ns1__modifyInvestigator (202)
/* ns1:modifyInvestigator */
class SOAP_CMAC ns1__modifyInvestigator : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__investigator *investigator;	/* optional element of type ns1:investigator */
public:
	virtual int soap_type() const { return 202; } /* = unique id SOAP_TYPE_ns1__modifyInvestigator */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyInvestigator(): sessionId(NULL), investigator(NULL) { ns1__modifyInvestigator::soap_default(NULL); }
	virtual ~ns1__modifyInvestigator() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyInvestigatorResponse
#define SOAP_TYPE_ns1__modifyInvestigatorResponse (203)
/* Primitive ns1:modifyInvestigatorResponse schema type: */
class SOAP_CMAC ns1__modifyInvestigatorResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 203; } /* = unique id SOAP_TYPE_ns1__modifyInvestigatorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyInvestigatorResponse() { ns1__modifyInvestigatorResponse::soap_default(NULL); }
	virtual ~ns1__modifyInvestigatorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataFiles
#define SOAP_TYPE_ns1__createDataFiles (204)
/* ns1:createDataFiles */
class SOAP_CMAC ns1__createDataFiles : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<ns1__datafile * >dataFiles;	/* optional element of type ns1:datafile */
	LONG64 *datasetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 204; } /* = unique id SOAP_TYPE_ns1__createDataFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataFiles(): sessionId(NULL), datasetId(NULL) { ns1__createDataFiles::soap_default(NULL); }
	virtual ~ns1__createDataFiles() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDataFilesResponse
#define SOAP_TYPE_ns1__createDataFilesResponse (205)
/* ns1:createDataFilesResponse */
class SOAP_CMAC ns1__createDataFilesResponse : public xsd__anyType
{
public:
	std::vector<ns1__datafile * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 205; } /* = unique id SOAP_TYPE_ns1__createDataFilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDataFilesResponse() { ns1__createDataFilesResponse::soap_default(NULL); }
	virtual ~ns1__createDataFilesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataSetParameter
#define SOAP_TYPE_ns1__addDataSetParameter (206)
/* ns1:addDataSetParameter */
class SOAP_CMAC ns1__addDataSetParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__datasetParameter *dataSetParameter;	/* optional element of type ns1:datasetParameter */
	LONG64 *datasetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 206; } /* = unique id SOAP_TYPE_ns1__addDataSetParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataSetParameter(): sessionId(NULL), dataSetParameter(NULL), datasetId(NULL) { ns1__addDataSetParameter::soap_default(NULL); }
	virtual ~ns1__addDataSetParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataSetParameterResponse
#define SOAP_TYPE_ns1__addDataSetParameterResponse (207)
/* ns1:addDataSetParameterResponse */
class SOAP_CMAC ns1__addDataSetParameterResponse : public xsd__anyType
{
public:
	ns1__datasetParameter *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datasetParameter */
public:
	virtual int soap_type() const { return 207; } /* = unique id SOAP_TYPE_ns1__addDataSetParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataSetParameterResponse(): return_(NULL) { ns1__addDataSetParameterResponse::soap_default(NULL); }
	virtual ~ns1__addDataSetParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addAuthorisation
#define SOAP_TYPE_ns1__addAuthorisation (208)
/* ns1:addAuthorisation */
class SOAP_CMAC ns1__addAuthorisation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *toAddFedId;	/* optional element of type xsd:string */
	std::string *toAddRole;	/* optional element of type xsd:string */
	LONG64 *elementId;	/* optional element of type xsd:long */
	enum ns1__elementType *elementType;	/* optional element of type ns1:elementType */
public:
	virtual int soap_type() const { return 208; } /* = unique id SOAP_TYPE_ns1__addAuthorisation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addAuthorisation(): sessionId(NULL), toAddFedId(NULL), toAddRole(NULL), elementId(NULL), elementType(NULL) { ns1__addAuthorisation::soap_default(NULL); }
	virtual ~ns1__addAuthorisation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addAuthorisationResponse
#define SOAP_TYPE_ns1__addAuthorisationResponse (209)
/* ns1:addAuthorisationResponse */
class SOAP_CMAC ns1__addAuthorisationResponse : public xsd__anyType
{
public:
	ns1__icatAuthorisation *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:icatAuthorisation */
public:
	virtual int soap_type() const { return 209; } /* = unique id SOAP_TYPE_ns1__addAuthorisationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addAuthorisationResponse(): return_(NULL) { ns1__addAuthorisationResponse::soap_default(NULL); }
	virtual ~ns1__addAuthorisationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addSample
#define SOAP_TYPE_ns1__addSample (210)
/* ns1:addSample */
class SOAP_CMAC ns1__addSample : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__sample *sample;	/* optional element of type ns1:sample */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 210; } /* = unique id SOAP_TYPE_ns1__addSample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addSample(): sessionId(NULL), sample(NULL), investigationId(NULL) { ns1__addSample::soap_default(NULL); }
	virtual ~ns1__addSample() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addSampleResponse
#define SOAP_TYPE_ns1__addSampleResponse (211)
/* ns1:addSampleResponse */
class SOAP_CMAC ns1__addSampleResponse : public xsd__anyType
{
public:
	ns1__sample *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:sample */
public:
	virtual int soap_type() const { return 211; } /* = unique id SOAP_TYPE_ns1__addSampleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addSampleResponse(): return_(NULL) { ns1__addSampleResponse::soap_default(NULL); }
	virtual ~ns1__addSampleResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deletePublication
#define SOAP_TYPE_ns1__deletePublication (212)
/* ns1:deletePublication */
class SOAP_CMAC ns1__deletePublication : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *publicationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 212; } /* = unique id SOAP_TYPE_ns1__deletePublication */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deletePublication(): sessionId(NULL), publicationId(NULL) { ns1__deletePublication::soap_default(NULL); }
	virtual ~ns1__deletePublication() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deletePublicationResponse
#define SOAP_TYPE_ns1__deletePublicationResponse (213)
/* Primitive ns1:deletePublicationResponse schema type: */
class SOAP_CMAC ns1__deletePublicationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 213; } /* = unique id SOAP_TYPE_ns1__deletePublicationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deletePublicationResponse() { ns1__deletePublicationResponse::soap_default(NULL); }
	virtual ~ns1__deletePublicationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__loginLifetime
#define SOAP_TYPE_ns1__loginLifetime (214)
/* ns1:loginLifetime */
class SOAP_CMAC ns1__loginLifetime : public xsd__anyType
{
public:
	std::string *username;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	int lifetime;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 214; } /* = unique id SOAP_TYPE_ns1__loginLifetime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loginLifetime(): username(NULL), password(NULL) { ns1__loginLifetime::soap_default(NULL); }
	virtual ~ns1__loginLifetime() { }
};
#endif

#ifndef SOAP_TYPE_ns1__loginLifetimeResponse
#define SOAP_TYPE_ns1__loginLifetimeResponse (215)
/* ns1:loginLifetimeResponse */
class SOAP_CMAC ns1__loginLifetimeResponse : public xsd__anyType
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 215; } /* = unique id SOAP_TYPE_ns1__loginLifetimeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loginLifetimeResponse(): return_(NULL) { ns1__loginLifetimeResponse::soap_default(NULL); }
	virtual ~ns1__loginLifetimeResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__login
#define SOAP_TYPE_ns1__login (216)
/* ns1:login */
class SOAP_CMAC ns1__login : public xsd__anyType
{
public:
	std::string *username;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 216; } /* = unique id SOAP_TYPE_ns1__login */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__login(): username(NULL), password(NULL) { ns1__login::soap_default(NULL); }
	virtual ~ns1__login() { }
};
#endif

#ifndef SOAP_TYPE_ns1__loginResponse
#define SOAP_TYPE_ns1__loginResponse (217)
/* ns1:loginResponse */
class SOAP_CMAC ns1__loginResponse : public xsd__anyType
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 217; } /* = unique id SOAP_TYPE_ns1__loginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loginResponse(): return_(NULL) { ns1__loginResponse::soap_default(NULL); }
	virtual ~ns1__loginResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteAuthorisation
#define SOAP_TYPE_ns1__deleteAuthorisation (218)
/* ns1:deleteAuthorisation */
class SOAP_CMAC ns1__deleteAuthorisation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *authorisationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 218; } /* = unique id SOAP_TYPE_ns1__deleteAuthorisation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteAuthorisation(): sessionId(NULL), authorisationId(NULL) { ns1__deleteAuthorisation::soap_default(NULL); }
	virtual ~ns1__deleteAuthorisation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteAuthorisationResponse
#define SOAP_TYPE_ns1__deleteAuthorisationResponse (219)
/* Primitive ns1:deleteAuthorisationResponse schema type: */
class SOAP_CMAC ns1__deleteAuthorisationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 219; } /* = unique id SOAP_TYPE_ns1__deleteAuthorisationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteAuthorisationResponse() { ns1__deleteAuthorisationResponse::soap_default(NULL); }
	virtual ~ns1__deleteAuthorisationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateAuthorisation
#define SOAP_TYPE_ns1__updateAuthorisation (220)
/* ns1:updateAuthorisation */
class SOAP_CMAC ns1__updateAuthorisation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *toChangetoRole;	/* optional element of type xsd:string */
	LONG64 *authorisationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 220; } /* = unique id SOAP_TYPE_ns1__updateAuthorisation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateAuthorisation(): sessionId(NULL), toChangetoRole(NULL), authorisationId(NULL) { ns1__updateAuthorisation::soap_default(NULL); }
	virtual ~ns1__updateAuthorisation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateAuthorisationResponse
#define SOAP_TYPE_ns1__updateAuthorisationResponse (221)
/* Primitive ns1:updateAuthorisationResponse schema type: */
class SOAP_CMAC ns1__updateAuthorisationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 221; } /* = unique id SOAP_TYPE_ns1__updateAuthorisationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateAuthorisationResponse() { ns1__updateAuthorisationResponse::soap_default(NULL); }
	virtual ~ns1__updateAuthorisationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatasetIncludes
#define SOAP_TYPE_ns1__getDatasetIncludes (222)
/* ns1:getDatasetIncludes */
class SOAP_CMAC ns1__getDatasetIncludes : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datasetId;	/* optional element of type xsd:long */
	enum ns1__datasetInclude *datasetInclude;	/* optional element of type ns1:datasetInclude */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE_ns1__getDatasetIncludes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatasetIncludes(): sessionId(NULL), datasetId(NULL), datasetInclude(NULL) { ns1__getDatasetIncludes::soap_default(NULL); }
	virtual ~ns1__getDatasetIncludes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatasetIncludesResponse
#define SOAP_TYPE_ns1__getDatasetIncludesResponse (223)
/* ns1:getDatasetIncludesResponse */
class SOAP_CMAC ns1__getDatasetIncludesResponse : public xsd__anyType
{
public:
	ns1__dataset *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 223; } /* = unique id SOAP_TYPE_ns1__getDatasetIncludesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatasetIncludesResponse(): return_(NULL) { ns1__getDatasetIncludesResponse::soap_default(NULL); }
	virtual ~ns1__getDatasetIncludesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDataset
#define SOAP_TYPE_ns1__getDataset (224)
/* ns1:getDataset */
class SOAP_CMAC ns1__getDataset : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datasetId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 224; } /* = unique id SOAP_TYPE_ns1__getDataset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDataset(): sessionId(NULL), datasetId(NULL) { ns1__getDataset::soap_default(NULL); }
	virtual ~ns1__getDataset() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatasetResponse
#define SOAP_TYPE_ns1__getDatasetResponse (225)
/* ns1:getDatasetResponse */
class SOAP_CMAC ns1__getDatasetResponse : public xsd__anyType
{
public:
	ns1__dataset *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 225; } /* = unique id SOAP_TYPE_ns1__getDatasetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatasetResponse(): return_(NULL) { ns1__getDatasetResponse::soap_default(NULL); }
	virtual ~ns1__getDatasetResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listRoles
#define SOAP_TYPE_ns1__listRoles (226)
/* ns1:listRoles */
class SOAP_CMAC ns1__listRoles : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 226; } /* = unique id SOAP_TYPE_ns1__listRoles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listRoles(): sessionId(NULL) { ns1__listRoles::soap_default(NULL); }
	virtual ~ns1__listRoles() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listRolesResponse
#define SOAP_TYPE_ns1__listRolesResponse (227)
/* ns1:listRolesResponse */
class SOAP_CMAC ns1__listRolesResponse : public xsd__anyType
{
public:
	std::vector<ns1__icatRole * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:icatRole */
public:
	virtual int soap_type() const { return 227; } /* = unique id SOAP_TYPE_ns1__listRolesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listRolesResponse() { ns1__listRolesResponse::soap_default(NULL); }
	virtual ~ns1__listRolesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ingestMetadata
#define SOAP_TYPE_ns1__ingestMetadata (228)
/* ns1:ingestMetadata */
class SOAP_CMAC ns1__ingestMetadata : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *xml;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 228; } /* = unique id SOAP_TYPE_ns1__ingestMetadata */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ingestMetadata(): sessionId(NULL), xml(NULL) { ns1__ingestMetadata::soap_default(NULL); }
	virtual ~ns1__ingestMetadata() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ingestMetadataResponse
#define SOAP_TYPE_ns1__ingestMetadataResponse (229)
/* ns1:ingestMetadataResponse */
class SOAP_CMAC ns1__ingestMetadataResponse : public xsd__anyType
{
public:
	std::vector<LONG64 >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 229; } /* = unique id SOAP_TYPE_ns1__ingestMetadataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ingestMetadataResponse() { ns1__ingestMetadataResponse::soap_default(NULL); }
	virtual ~ns1__ingestMetadataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ICATAPIException
#define SOAP_TYPE_ns1__ICATAPIException (230)
/* ns1:ICATAPIException */
class SOAP_CMAC ns1__ICATAPIException : public xsd__anyType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	std::string *stackTraceAsString;	/* optional element of type xsd:string */
	std::string *uniqueId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 230; } /* = unique id SOAP_TYPE_ns1__ICATAPIException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ICATAPIException(): message(NULL), stackTraceAsString(NULL), uniqueId(NULL) { ns1__ICATAPIException::soap_default(NULL); }
	virtual ~ns1__ICATAPIException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatafile
#define SOAP_TYPE_ns1__getDatafile (231)
/* ns1:getDatafile */
class SOAP_CMAC ns1__getDatafile : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *datafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 231; } /* = unique id SOAP_TYPE_ns1__getDatafile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatafile(): sessionId(NULL), datafileId(NULL) { ns1__getDatafile::soap_default(NULL); }
	virtual ~ns1__getDatafile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatafileResponse
#define SOAP_TYPE_ns1__getDatafileResponse (232)
/* ns1:getDatafileResponse */
class SOAP_CMAC ns1__getDatafileResponse : public xsd__anyType
{
public:
	ns1__datafile *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 232; } /* = unique id SOAP_TYPE_ns1__getDatafileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatafileResponse(): return_(NULL) { ns1__getDatafileResponse::soap_default(NULL); }
	virtual ~ns1__getDatafileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataFile
#define SOAP_TYPE_ns1__modifyDataFile (233)
/* ns1:modifyDataFile */
class SOAP_CMAC ns1__modifyDataFile : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__datafile *dataFile;	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 233; } /* = unique id SOAP_TYPE_ns1__modifyDataFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataFile(): sessionId(NULL), dataFile(NULL) { ns1__modifyDataFile::soap_default(NULL); }
	virtual ~ns1__modifyDataFile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataFileResponse
#define SOAP_TYPE_ns1__modifyDataFileResponse (234)
/* Primitive ns1:modifyDataFileResponse schema type: */
class SOAP_CMAC ns1__modifyDataFileResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 234; } /* = unique id SOAP_TYPE_ns1__modifyDataFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataFileResponse() { ns1__modifyDataFileResponse::soap_default(NULL); }
	virtual ~ns1__modifyDataFileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getInvestigationIncludes
#define SOAP_TYPE_ns1__getInvestigationIncludes (235)
/* ns1:getInvestigationIncludes */
class SOAP_CMAC ns1__getInvestigationIncludes : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *investigationId;	/* optional element of type xsd:long */
	enum ns1__investigationInclude *investigationInclude;	/* optional element of type ns1:investigationInclude */
public:
	virtual int soap_type() const { return 235; } /* = unique id SOAP_TYPE_ns1__getInvestigationIncludes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getInvestigationIncludes(): sessionId(NULL), investigationId(NULL), investigationInclude(NULL) { ns1__getInvestigationIncludes::soap_default(NULL); }
	virtual ~ns1__getInvestigationIncludes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getInvestigationIncludesResponse
#define SOAP_TYPE_ns1__getInvestigationIncludesResponse (236)
/* ns1:getInvestigationIncludesResponse */
class SOAP_CMAC ns1__getInvestigationIncludesResponse : public xsd__anyType
{
public:
	ns1__investigation *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 236; } /* = unique id SOAP_TYPE_ns1__getInvestigationIncludesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getInvestigationIncludesResponse(): return_(NULL) { ns1__getInvestigationIncludesResponse::soap_default(NULL); }
	virtual ~ns1__getInvestigationIncludesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getInvestigation
#define SOAP_TYPE_ns1__getInvestigation (237)
/* ns1:getInvestigation */
class SOAP_CMAC ns1__getInvestigation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 237; } /* = unique id SOAP_TYPE_ns1__getInvestigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getInvestigation(): sessionId(NULL), investigationId(NULL) { ns1__getInvestigation::soap_default(NULL); }
	virtual ~ns1__getInvestigation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getInvestigationResponse
#define SOAP_TYPE_ns1__getInvestigationResponse (238)
/* ns1:getInvestigationResponse */
class SOAP_CMAC ns1__getInvestigationResponse : public xsd__anyType
{
public:
	ns1__investigation *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 238; } /* = unique id SOAP_TYPE_ns1__getInvestigationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getInvestigationResponse(): return_(NULL) { ns1__getInvestigationResponse::soap_default(NULL); }
	virtual ~ns1__getInvestigationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataFileParameter
#define SOAP_TYPE_ns1__deleteDataFileParameter (239)
/* ns1:deleteDataFileParameter */
class SOAP_CMAC ns1__deleteDataFileParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__datafileParameterPK *datafileParameterPK;	/* optional element of type ns1:datafileParameterPK */
public:
	virtual int soap_type() const { return 239; } /* = unique id SOAP_TYPE_ns1__deleteDataFileParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataFileParameter(): sessionId(NULL), datafileParameterPK(NULL) { ns1__deleteDataFileParameter::soap_default(NULL); }
	virtual ~ns1__deleteDataFileParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDataFileParameterResponse
#define SOAP_TYPE_ns1__deleteDataFileParameterResponse (240)
/* Primitive ns1:deleteDataFileParameterResponse schema type: */
class SOAP_CMAC ns1__deleteDataFileParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 240; } /* = unique id SOAP_TYPE_ns1__deleteDataFileParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDataFileParameterResponse() { ns1__deleteDataFileParameterResponse::soap_default(NULL); }
	virtual ~ns1__deleteDataFileParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createInvestigation
#define SOAP_TYPE_ns1__createInvestigation (241)
/* ns1:createInvestigation */
class SOAP_CMAC ns1__createInvestigation : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 241; } /* = unique id SOAP_TYPE_ns1__createInvestigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createInvestigation(): sessionId(NULL), investigation(NULL) { ns1__createInvestigation::soap_default(NULL); }
	virtual ~ns1__createInvestigation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createInvestigationResponse
#define SOAP_TYPE_ns1__createInvestigationResponse (242)
/* ns1:createInvestigationResponse */
class SOAP_CMAC ns1__createInvestigationResponse : public xsd__anyType
{
public:
	ns1__investigation *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 242; } /* = unique id SOAP_TYPE_ns1__createInvestigationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createInvestigationResponse(): return_(NULL) { ns1__createInvestigationResponse::soap_default(NULL); }
	virtual ~ns1__createInvestigationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addPublication
#define SOAP_TYPE_ns1__addPublication (243)
/* ns1:addPublication */
class SOAP_CMAC ns1__addPublication : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__publication *publication;	/* optional element of type ns1:publication */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 243; } /* = unique id SOAP_TYPE_ns1__addPublication */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addPublication(): sessionId(NULL), publication(NULL), investigationId(NULL) { ns1__addPublication::soap_default(NULL); }
	virtual ~ns1__addPublication() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addPublicationResponse
#define SOAP_TYPE_ns1__addPublicationResponse (244)
/* ns1:addPublicationResponse */
class SOAP_CMAC ns1__addPublicationResponse : public xsd__anyType
{
public:
	ns1__publication *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:publication */
public:
	virtual int soap_type() const { return 244; } /* = unique id SOAP_TYPE_ns1__addPublicationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addPublicationResponse(): return_(NULL) { ns1__addPublicationResponse::soap_default(NULL); }
	virtual ~ns1__addPublicationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchDatasetsBySample
#define SOAP_TYPE_ns1__searchDatasetsBySample (245)
/* ns1:searchDatasetsBySample */
class SOAP_CMAC ns1__searchDatasetsBySample : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__sample *sample;	/* optional element of type ns1:sample */
public:
	virtual int soap_type() const { return 245; } /* = unique id SOAP_TYPE_ns1__searchDatasetsBySample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchDatasetsBySample(): sessionId(NULL), sample(NULL) { ns1__searchDatasetsBySample::soap_default(NULL); }
	virtual ~ns1__searchDatasetsBySample() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchDatasetsBySampleResponse
#define SOAP_TYPE_ns1__searchDatasetsBySampleResponse (246)
/* ns1:searchDatasetsBySampleResponse */
class SOAP_CMAC ns1__searchDatasetsBySampleResponse : public xsd__anyType
{
public:
	std::vector<ns1__dataset * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 246; } /* = unique id SOAP_TYPE_ns1__searchDatasetsBySampleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchDatasetsBySampleResponse() { ns1__searchDatasetsBySampleResponse::soap_default(NULL); }
	virtual ~ns1__searchDatasetsBySampleResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataFileParameter
#define SOAP_TYPE_ns1__addDataFileParameter (247)
/* ns1:addDataFileParameter */
class SOAP_CMAC ns1__addDataFileParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__datafileParameter *dataFileParameter;	/* optional element of type ns1:datafileParameter */
	LONG64 *datafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 247; } /* = unique id SOAP_TYPE_ns1__addDataFileParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataFileParameter(): sessionId(NULL), dataFileParameter(NULL), datafileId(NULL) { ns1__addDataFileParameter::soap_default(NULL); }
	virtual ~ns1__addDataFileParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addDataFileParameterResponse
#define SOAP_TYPE_ns1__addDataFileParameterResponse (248)
/* ns1:addDataFileParameterResponse */
class SOAP_CMAC ns1__addDataFileParameterResponse : public xsd__anyType
{
public:
	ns1__datafileParameter *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:datafileParameter */
public:
	virtual int soap_type() const { return 248; } /* = unique id SOAP_TYPE_ns1__addDataFileParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addDataFileParameterResponse(): return_(NULL) { ns1__addDataFileParameterResponse::soap_default(NULL); }
	virtual ~ns1__addDataFileParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteSampleParameter
#define SOAP_TYPE_ns1__deleteSampleParameter (249)
/* ns1:deleteSampleParameter */
class SOAP_CMAC ns1__deleteSampleParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__sampleParameterPK *sampleParameterPK;	/* optional element of type ns1:sampleParameterPK */
public:
	virtual int soap_type() const { return 249; } /* = unique id SOAP_TYPE_ns1__deleteSampleParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteSampleParameter(): sessionId(NULL), sampleParameterPK(NULL) { ns1__deleteSampleParameter::soap_default(NULL); }
	virtual ~ns1__deleteSampleParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteSampleParameterResponse
#define SOAP_TYPE_ns1__deleteSampleParameterResponse (250)
/* Primitive ns1:deleteSampleParameterResponse schema type: */
class SOAP_CMAC ns1__deleteSampleParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 250; } /* = unique id SOAP_TYPE_ns1__deleteSampleParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteSampleParameterResponse() { ns1__deleteSampleParameterResponse::soap_default(NULL); }
	virtual ~ns1__deleteSampleParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataFileParameter
#define SOAP_TYPE_ns1__modifyDataFileParameter (251)
/* ns1:modifyDataFileParameter */
class SOAP_CMAC ns1__modifyDataFileParameter : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__datafileParameter *dataFileParameter;	/* optional element of type ns1:datafileParameter */
public:
	virtual int soap_type() const { return 251; } /* = unique id SOAP_TYPE_ns1__modifyDataFileParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataFileParameter(): sessionId(NULL), dataFileParameter(NULL) { ns1__modifyDataFileParameter::soap_default(NULL); }
	virtual ~ns1__modifyDataFileParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__modifyDataFileParameterResponse
#define SOAP_TYPE_ns1__modifyDataFileParameterResponse (252)
/* Primitive ns1:modifyDataFileParameterResponse schema type: */
class SOAP_CMAC ns1__modifyDataFileParameterResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE_ns1__modifyDataFileParameterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__modifyDataFileParameterResponse() { ns1__modifyDataFileParameterResponse::soap_default(NULL); }
	virtual ~ns1__modifyDataFileParameterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listParameters
#define SOAP_TYPE_ns1__listParameters (253)
/* ns1:listParameters */
class SOAP_CMAC ns1__listParameters : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 253; } /* = unique id SOAP_TYPE_ns1__listParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listParameters(): sessionId(NULL) { ns1__listParameters::soap_default(NULL); }
	virtual ~ns1__listParameters() { }
};
#endif

#ifndef SOAP_TYPE_ns1__listParametersResponse
#define SOAP_TYPE_ns1__listParametersResponse (254)
/* ns1:listParametersResponse */
class SOAP_CMAC ns1__listParametersResponse : public xsd__anyType
{
public:
	std::vector<class ns1__parameter * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:parameter */
public:
	virtual int soap_type() const { return 254; } /* = unique id SOAP_TYPE_ns1__listParametersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__listParametersResponse() { ns1__listParametersResponse::soap_default(NULL); }
	virtual ~ns1__listParametersResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatasets
#define SOAP_TYPE_ns1__getDatasets (255)
/* ns1:getDatasets */
class SOAP_CMAC ns1__getDatasets : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<LONG64 >datasetIds;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 255; } /* = unique id SOAP_TYPE_ns1__getDatasets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatasets(): sessionId(NULL) { ns1__getDatasets::soap_default(NULL); }
	virtual ~ns1__getDatasets() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDatasetsResponse
#define SOAP_TYPE_ns1__getDatasetsResponse (256)
/* ns1:getDatasetsResponse */
class SOAP_CMAC ns1__getDatasetsResponse : public xsd__anyType
{
public:
	std::vector<ns1__dataset * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 256; } /* = unique id SOAP_TYPE_ns1__getDatasetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDatasetsResponse() { ns1__getDatasetsResponse::soap_default(NULL); }
	virtual ~ns1__getDatasetsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SessionException
#define SOAP_TYPE_ns3__SessionException (257)
/* ns3:SessionException */
class SOAP_CMAC ns3__SessionException : public xsd__anyType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	std::string *stackTraceAsString;	/* optional element of type xsd:string */
	std::string *uniqueId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 257; } /* = unique id SOAP_TYPE_ns3__SessionException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SessionException(): message(NULL), stackTraceAsString(NULL), uniqueId(NULL) { ns3__SessionException::soap_default(NULL); }
	virtual ~ns3__SessionException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sample
#define SOAP_TYPE_ns1__sample (27)
/* ns1:sample */
class SOAP_CMAC ns1__sample : public ns1__entityBaseBean
{
public:
	std::string *chemicalFormula;	/* optional element of type xsd:string */
	LONG64 *id;	/* optional element of type xsd:long */
	std::string *instance;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	int *proposalSampleId;	/* optional element of type xsd:int */
	std::string *safetyInformation;	/* optional element of type xsd:string */
	std::vector<ns1__sampleParameter * >sampleParameterCollection;	/* optional element of type ns1:sampleParameter */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__sample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sample(): chemicalFormula(NULL), id(NULL), instance(NULL), name(NULL), proposalSampleId(NULL), safetyInformation(NULL) { ns1__sample::soap_default(NULL); }
	virtual ~ns1__sample() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sampleParameter
#define SOAP_TYPE_ns1__sampleParameter (29)
/* ns1:sampleParameter */
class SOAP_CMAC ns1__sampleParameter : public ns1__entityBaseBean
{
public:
	std::string *description;	/* optional element of type xsd:string */
	std::string *error;	/* optional element of type xsd:string */
	bool numeric;	/* required element of type xsd:boolean */
	double *numericValue;	/* optional element of type xsd:double */
	std::string *rangeBottom;	/* optional element of type xsd:string */
	std::string *rangeTop;	/* optional element of type xsd:string */
	ns1__sampleParameterPK *sampleParameterPK;	/* optional element of type ns1:sampleParameterPK */
	std::string *stringValue;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__sampleParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sampleParameter(): description(NULL), error(NULL), numericValue(NULL), rangeBottom(NULL), rangeTop(NULL), sampleParameterPK(NULL), stringValue(NULL) { ns1__sampleParameter::soap_default(NULL); }
	virtual ~ns1__sampleParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sampleParameterPK
#define SOAP_TYPE_ns1__sampleParameterPK (30)
/* ns1:sampleParameterPK */
class SOAP_CMAC ns1__sampleParameterPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	std::string *name;	/* optional element of type xsd:string */
	LONG64 *sampleId;	/* optional element of type xsd:long */
	std::string *units;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__sampleParameterPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sampleParameterPK(): name(NULL), sampleId(NULL), units(NULL) { ns1__sampleParameterPK::soap_default(NULL); }
	virtual ~ns1__sampleParameterPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__icatRole
#define SOAP_TYPE_ns1__icatRole (32)
/* ns1:icatRole */
class SOAP_CMAC ns1__icatRole : public ns1__entityBaseBean
{
public:
	bool actionDelete;	/* required element of type xsd:boolean */
	bool actionDownload;	/* required element of type xsd:boolean */
	bool actionFacilityAcquired;	/* required element of type xsd:boolean */
	bool actionInsert;	/* required element of type xsd:boolean */
	bool actionManageUsers;	/* required element of type xsd:boolean */
	bool actionRemove;	/* required element of type xsd:boolean */
	bool actionRootInsert;	/* required element of type xsd:boolean */
	bool actionRootRemove;	/* required element of type xsd:boolean */
	bool actionSelect;	/* required element of type xsd:boolean */
	bool actionUpdate;	/* required element of type xsd:boolean */
	std::string *role;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__icatRole */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__icatRole(): role(NULL) { ns1__icatRole::soap_default(NULL); }
	virtual ~ns1__icatRole() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datafile
#define SOAP_TYPE_ns1__datafile (40)
/* ns1:datafile */
class SOAP_CMAC ns1__datafile : public ns1__entityBaseBean
{
public:
	std::string *checksum;	/* optional element of type xsd:string */
	std::string *command;	/* optional element of type xsd:string */
	time_t *datafileCreateTime;	/* optional element of type xsd:dateTime */
	ns1__datafileFormat *datafileFormat;	/* optional element of type ns1:datafileFormat */
	enum ns1__datafileInclude *datafileInclude;	/* optional element of type ns1:datafileInclude */
	time_t *datafileModifyTime;	/* optional element of type xsd:dateTime */
	std::vector<ns1__datafileParameter * >datafileParameterCollection;	/* optional element of type ns1:datafileParameter */
	std::string *datafileVersion;	/* optional element of type xsd:string */
	std::string *datafileVersionComment;	/* optional element of type xsd:string */
	LONG64 *datasetId;	/* optional element of type xsd:long */
	std::string *description;	/* optional element of type xsd:string */
	int *fileSize;	/* optional element of type xsd:int */
	LONG64 *id;	/* optional element of type xsd:long */
	std::string *location;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<class ns1__relatedDatafiles * >relatedDatafilesCollection1;	/* optional element of type ns1:relatedDatafiles */
	std::vector<ns1__relatedDatafiles * >relatedDatafilesCollection;	/* optional element of type ns1:relatedDatafiles */
	std::string *signature;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__datafile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafile(): checksum(NULL), command(NULL), datafileCreateTime(NULL), datafileFormat(NULL), datafileInclude(NULL), datafileModifyTime(NULL), datafileVersion(NULL), datafileVersionComment(NULL), datasetId(NULL), description(NULL), fileSize(NULL), id(NULL), location(NULL), name(NULL), signature(NULL) { ns1__datafile::soap_default(NULL); }
	virtual ~ns1__datafile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datafileFormat
#define SOAP_TYPE_ns1__datafileFormat (41)
/* ns1:datafileFormat */
class SOAP_CMAC ns1__datafileFormat : public ns1__entityBaseBean
{
public:
	class ns1__datafileFormatPK *datafileFormatPK;	/* optional element of type ns1:datafileFormatPK */
	std::string *description;	/* optional element of type xsd:string */
	std::string *formatType;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__datafileFormat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafileFormat(): datafileFormatPK(NULL), description(NULL), formatType(NULL) { ns1__datafileFormat::soap_default(NULL); }
	virtual ~ns1__datafileFormat() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datafileFormatPK
#define SOAP_TYPE_ns1__datafileFormatPK (42)
/* ns1:datafileFormatPK */
class SOAP_CMAC ns1__datafileFormatPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	std::string *name;	/* optional element of type xsd:string */
	std::string *version;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__datafileFormatPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafileFormatPK(): name(NULL), version(NULL) { ns1__datafileFormatPK::soap_default(NULL); }
	virtual ~ns1__datafileFormatPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datafileParameter
#define SOAP_TYPE_ns1__datafileParameter (43)
/* ns1:datafileParameter */
class SOAP_CMAC ns1__datafileParameter : public ns1__entityBaseBean
{
public:
	ns1__datafileParameterPK *datafileParameterPK;	/* optional element of type ns1:datafileParameterPK */
	std::string *description;	/* optional element of type xsd:string */
	std::string *error;	/* optional element of type xsd:string */
	bool numeric;	/* required element of type xsd:boolean */
	double *numericValue;	/* optional element of type xsd:double */
	std::string *rangeBottom;	/* optional element of type xsd:string */
	std::string *rangeTop;	/* optional element of type xsd:string */
	std::string *stringValue;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__datafileParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafileParameter(): datafileParameterPK(NULL), description(NULL), error(NULL), numericValue(NULL), rangeBottom(NULL), rangeTop(NULL), stringValue(NULL) { ns1__datafileParameter::soap_default(NULL); }
	virtual ~ns1__datafileParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datafileParameterPK
#define SOAP_TYPE_ns1__datafileParameterPK (44)
/* ns1:datafileParameterPK */
class SOAP_CMAC ns1__datafileParameterPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	LONG64 *datafileId;	/* optional element of type xsd:long */
	std::string *name;	/* optional element of type xsd:string */
	std::string *units;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__datafileParameterPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafileParameterPK(): datafileId(NULL), name(NULL), units(NULL) { ns1__datafileParameterPK::soap_default(NULL); }
	virtual ~ns1__datafileParameterPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__relatedDatafiles
#define SOAP_TYPE_ns1__relatedDatafiles (45)
/* ns1:relatedDatafiles */
class SOAP_CMAC ns1__relatedDatafiles : public ns1__entityBaseBean
{
public:
	class ns1__relatedDatafilesPK *relatedDatafilesPK;	/* optional element of type ns1:relatedDatafilesPK */
	std::string *relation;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__relatedDatafiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__relatedDatafiles(): relatedDatafilesPK(NULL), relation(NULL) { ns1__relatedDatafiles::soap_default(NULL); }
	virtual ~ns1__relatedDatafiles() { }
};
#endif

#ifndef SOAP_TYPE_ns1__relatedDatafilesPK
#define SOAP_TYPE_ns1__relatedDatafilesPK (46)
/* ns1:relatedDatafilesPK */
class SOAP_CMAC ns1__relatedDatafilesPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	LONG64 *destDatafileId;	/* optional element of type xsd:long */
	LONG64 *sourceDatafileId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__relatedDatafilesPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__relatedDatafilesPK(): destDatafileId(NULL), sourceDatafileId(NULL) { ns1__relatedDatafilesPK::soap_default(NULL); }
	virtual ~ns1__relatedDatafilesPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__facilityCycle
#define SOAP_TYPE_ns1__facilityCycle (59)
/* ns1:facilityCycle */
class SOAP_CMAC ns1__facilityCycle : public ns1__entityBaseBean
{
public:
	std::string *description;	/* optional element of type xsd:string */
	time_t *finishDate;	/* optional element of type xsd:dateTime */
	std::string *name;	/* optional element of type xsd:string */
	time_t *startDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__facilityCycle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__facilityCycle(): description(NULL), finishDate(NULL), name(NULL), startDate(NULL) { ns1__facilityCycle::soap_default(NULL); }
	virtual ~ns1__facilityCycle() { }
};
#endif

#ifndef SOAP_TYPE_ns1__facilityUser
#define SOAP_TYPE_ns1__facilityUser (66)
/* ns1:facilityUser */
class SOAP_CMAC ns1__facilityUser : public ns1__entityBaseBean
{
public:
	std::string *facilityUserId;	/* optional element of type xsd:string */
	std::string *federalId;	/* optional element of type xsd:string */
	std::string *firstName;	/* optional element of type xsd:string */
	std::string *initials;	/* optional element of type xsd:string */
	std::string *lastName;	/* optional element of type xsd:string */
	std::string *middleName;	/* optional element of type xsd:string */
	std::string *title;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns1__facilityUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__facilityUser(): facilityUserId(NULL), federalId(NULL), firstName(NULL), initials(NULL), lastName(NULL), middleName(NULL), title(NULL) { ns1__facilityUser::soap_default(NULL); }
	virtual ~ns1__facilityUser() { }
};
#endif

#ifndef SOAP_TYPE_ns1__investigatorPK
#define SOAP_TYPE_ns1__investigatorPK (68)
/* ns1:investigatorPK */
class SOAP_CMAC ns1__investigatorPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	std::string *facilityUserId;	/* optional element of type xsd:string */
	LONG64 *investigationId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__investigatorPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigatorPK(): facilityUserId(NULL), investigationId(NULL) { ns1__investigatorPK::soap_default(NULL); }
	virtual ~ns1__investigatorPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__keywordPK
#define SOAP_TYPE_ns1__keywordPK (73)
/* ns1:keywordPK */
class SOAP_CMAC ns1__keywordPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	LONG64 *investigationId;	/* optional element of type xsd:long */
	std::string *name;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns1__keywordPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__keywordPK(): investigationId(NULL), name(NULL) { ns1__keywordPK::soap_default(NULL); }
	virtual ~ns1__keywordPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__dataset
#define SOAP_TYPE_ns1__dataset (78)
/* ns1:dataset */
class SOAP_CMAC ns1__dataset : public ns1__entityBaseBean
{
public:
	std::vector<ns1__datafile * >datafileCollection;	/* optional element of type ns1:datafile */
	std::vector<ns1__datasetParameter * >datasetParameterCollection;	/* optional element of type ns1:datasetParameter */
	std::string *datasetStatus;	/* optional element of type xsd:string */
	std::string *datasetType;	/* optional element of type xsd:string */
	std::string *description;	/* optional element of type xsd:string */
	LONG64 *id;	/* optional element of type xsd:long */
	LONG64 *investigationId;	/* optional element of type xsd:long */
	std::string *location;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	LONG64 *sampleId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns1__dataset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dataset(): datasetStatus(NULL), datasetType(NULL), description(NULL), id(NULL), investigationId(NULL), location(NULL), name(NULL), sampleId(NULL) { ns1__dataset::soap_default(NULL); }
	virtual ~ns1__dataset() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datasetParameter
#define SOAP_TYPE_ns1__datasetParameter (79)
/* ns1:datasetParameter */
class SOAP_CMAC ns1__datasetParameter : public ns1__entityBaseBean
{
public:
	ns1__datasetParameterPK *datasetParameterPK;	/* optional element of type ns1:datasetParameterPK */
	std::string *description;	/* optional element of type xsd:string */
	std::string *error;	/* optional element of type xsd:string */
	bool numeric;	/* required element of type xsd:boolean */
	double *numericValue;	/* optional element of type xsd:double */
	ns1__parameter *parameter;	/* optional element of type ns1:parameter */
	std::string *rangeBottom;	/* optional element of type xsd:string */
	std::string *rangeTop;	/* optional element of type xsd:string */
	std::string *stringValue;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns1__datasetParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datasetParameter(): datasetParameterPK(NULL), description(NULL), error(NULL), numericValue(NULL), parameter(NULL), rangeBottom(NULL), rangeTop(NULL), stringValue(NULL) { ns1__datasetParameter::soap_default(NULL); }
	virtual ~ns1__datasetParameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__datasetParameterPK
#define SOAP_TYPE_ns1__datasetParameterPK (80)
/* ns1:datasetParameterPK */
class SOAP_CMAC ns1__datasetParameterPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	LONG64 *datasetId;	/* optional element of type xsd:long */
	std::string *name;	/* optional element of type xsd:string */
	std::string *units;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns1__datasetParameterPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datasetParameterPK(): datasetId(NULL), name(NULL), units(NULL) { ns1__datasetParameterPK::soap_default(NULL); }
	virtual ~ns1__datasetParameterPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__parameter
#define SOAP_TYPE_ns1__parameter (81)
/* ns1:parameter */
class SOAP_CMAC ns1__parameter : public ns1__entityBaseBean
{
public:
	bool datafileParameter;	/* required element of type xsd:boolean */
	std::string *description;	/* optional element of type xsd:string */
	std::string *nonNumericValueFormat;	/* optional element of type xsd:string */
	bool numeric;	/* required element of type xsd:boolean */
	std::string *numericValue;	/* optional element of type xsd:string */
	class ns1__parameterPK *parameterPK;	/* optional element of type ns1:parameterPK */
	bool sampleParameter;	/* required element of type xsd:boolean */
	std::string *searchable;	/* optional element of type xsd:string */
	std::string *unitsLongVersion;	/* optional element of type xsd:string */
	bool verified;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns1__parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__parameter(): description(NULL), nonNumericValueFormat(NULL), numericValue(NULL), parameterPK(NULL), searchable(NULL), unitsLongVersion(NULL) { ns1__parameter::soap_default(NULL); }
	virtual ~ns1__parameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__parameterPK
#define SOAP_TYPE_ns1__parameterPK (82)
/* ns1:parameterPK */
class SOAP_CMAC ns1__parameterPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	std::string *name;	/* optional element of type xsd:string */
	std::string *units;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ns1__parameterPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__parameterPK(): name(NULL), units(NULL) { ns1__parameterPK::soap_default(NULL); }
	virtual ~ns1__parameterPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__investigation
#define SOAP_TYPE_ns1__investigation (107)
/* ns1:investigation */
class SOAP_CMAC ns1__investigation : public ns1__entityBaseBean
{
public:
	std::string *bcatInvStr;	/* optional element of type xsd:string */
	std::vector<ns1__dataset * >datasetCollection;	/* optional element of type ns1:dataset */
	std::string *facility;	/* optional element of type xsd:string */
	ns1__facilityCycle *facilityCycle;	/* optional element of type ns1:facilityCycle */
	LONG64 *grantId;	/* optional element of type xsd:long */
	LONG64 *id;	/* optional element of type xsd:long */
	std::string *instrument;	/* optional element of type xsd:string */
	std::string *invAbstract;	/* optional element of type xsd:string */
	time_t *invEndDate;	/* optional element of type xsd:dateTime */
	std::string *invNumber;	/* optional element of type xsd:string */
	std::string *invParamName;	/* optional element of type xsd:string */
	std::string *invParamValue;	/* optional element of type xsd:string */
	time_t *invStartDate;	/* optional element of type xsd:dateTime */
	std::string *invType;	/* optional element of type xsd:string */
	std::vector<ns1__investigator * >investigatorCollection;	/* optional element of type ns1:investigator */
	std::vector<ns1__keyword * >keywordCollection;	/* optional element of type ns1:keyword */
	std::string *prevInvNumber;	/* optional element of type xsd:string */
	std::vector<ns1__publication * >publicationCollection;	/* optional element of type ns1:publication */
	time_t *releaseDate;	/* optional element of type xsd:dateTime */
	std::vector<ns1__sample * >sampleCollection;	/* optional element of type ns1:sample */
	std::vector<class ns1__shift * >shiftCollection;	/* optional element of type ns1:shift */
	std::string *title;	/* optional element of type xsd:string */
	std::string *visitId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns1__investigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigation(): bcatInvStr(NULL), facility(NULL), facilityCycle(NULL), grantId(NULL), id(NULL), instrument(NULL), invAbstract(NULL), invEndDate(NULL), invNumber(NULL), invParamName(NULL), invParamValue(NULL), invStartDate(NULL), invType(NULL), prevInvNumber(NULL), releaseDate(NULL), title(NULL), visitId(NULL) { ns1__investigation::soap_default(NULL); }
	virtual ~ns1__investigation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__investigator
#define SOAP_TYPE_ns1__investigator (108)
/* ns1:investigator */
class SOAP_CMAC ns1__investigator : public ns1__entityBaseBean
{
public:
	ns1__facilityUser *facilityUser;	/* optional element of type ns1:facilityUser */
	ns1__investigatorPK *investigatorPK;	/* optional element of type ns1:investigatorPK */
	std::string *role;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns1__investigator */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigator(): facilityUser(NULL), investigatorPK(NULL), role(NULL) { ns1__investigator::soap_default(NULL); }
	virtual ~ns1__investigator() { }
};
#endif

#ifndef SOAP_TYPE_ns1__keyword
#define SOAP_TYPE_ns1__keyword (109)
/* ns1:keyword */
class SOAP_CMAC ns1__keyword : public ns1__entityBaseBean
{
public:
	ns1__keywordPK *keywordPK;	/* optional element of type ns1:keywordPK */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns1__keyword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__keyword(): keywordPK(NULL) { ns1__keyword::soap_default(NULL); }
	virtual ~ns1__keyword() { }
};
#endif

#ifndef SOAP_TYPE_ns1__publication
#define SOAP_TYPE_ns1__publication (110)
/* ns1:publication */
class SOAP_CMAC ns1__publication : public ns1__entityBaseBean
{
public:
	std::string *fullReference;	/* optional element of type xsd:string */
	LONG64 *id;	/* optional element of type xsd:long */
	std::string *repository;	/* optional element of type xsd:string */
	std::string *repositoryId;	/* optional element of type xsd:string */
	std::string *url;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns1__publication */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__publication(): fullReference(NULL), id(NULL), repository(NULL), repositoryId(NULL), url(NULL) { ns1__publication::soap_default(NULL); }
	virtual ~ns1__publication() { }
};
#endif

#ifndef SOAP_TYPE_ns1__shift
#define SOAP_TYPE_ns1__shift (111)
/* ns1:shift */
class SOAP_CMAC ns1__shift : public ns1__entityBaseBean
{
public:
	std::string *shiftComment;	/* optional element of type xsd:string */
	class ns1__shiftPK *shiftPK;	/* optional element of type ns1:shiftPK */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns1__shift */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__shift(): shiftComment(NULL), shiftPK(NULL) { ns1__shift::soap_default(NULL); }
	virtual ~ns1__shift() { }
};
#endif

#ifndef SOAP_TYPE_ns1__shiftPK
#define SOAP_TYPE_ns1__shiftPK (112)
/* ns1:shiftPK */
class SOAP_CMAC ns1__shiftPK : public ns1__entityPrimaryKeyBaseBean
{
public:
	time_t *endDate;	/* optional element of type xsd:dateTime */
	LONG64 *investigationId;	/* optional element of type xsd:long */
	time_t *startDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_ns1__shiftPK */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__shiftPK(): endDate(NULL), investigationId(NULL), startDate(NULL) { ns1__shiftPK::soap_default(NULL); }
	virtual ~ns1__shiftPK() { }
};
#endif

#ifndef SOAP_TYPE_ns1__icatAuthorisation
#define SOAP_TYPE_ns1__icatAuthorisation (176)
/* ns1:icatAuthorisation */
class SOAP_CMAC ns1__icatAuthorisation : public ns1__entityBaseBean
{
public:
	LONG64 *elementId;	/* optional element of type xsd:long */
	enum ns1__elementType *elementType;	/* optional element of type ns1:elementType */
	ns1__icatRole *role;	/* optional element of type ns1:icatRole */
	LONG64 *userChildRecord;	/* optional element of type xsd:long */
	std::string *userId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE_ns1__icatAuthorisation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__icatAuthorisation(): elementId(NULL), elementType(NULL), role(NULL), userChildRecord(NULL), userId(NULL) { ns1__icatAuthorisation::soap_default(NULL); }
	virtual ~ns1__icatAuthorisation() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (330)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns1__ICATAPIException *ns1__ICATAPIException_;	/* optional element of type ns1:ICATAPIException */
	ns1__InsufficientPrivilegesException *ns1__InsufficientPrivilegesException_;	/* optional element of type ns1:InsufficientPrivilegesException */
	ns1__NoSuchObjectFoundException *ns1__NoSuchObjectFoundException_;	/* optional element of type ns1:NoSuchObjectFoundException */
	ns1__NoSuchUserException *ns1__NoSuchUserException_;	/* optional element of type ns1:NoSuchUserException */
	ns3__SessionException *ns1__SessionException;	/* optional element of type ns3:SessionException */
	ns1__ValidationException *ns1__ValidationException_;	/* optional element of type ns1:ValidationException */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns1__login
#define SOAP_TYPE___ns1__login (342)
/* Operation wrapper: */
struct __ns1__login
{
public:
	ns1__login *ns1__login_;	/* optional element of type ns1:login */
};
#endif

#ifndef SOAP_TYPE___ns1__loginLifetime
#define SOAP_TYPE___ns1__loginLifetime (346)
/* Operation wrapper: */
struct __ns1__loginLifetime
{
public:
	ns1__loginLifetime *ns1__loginLifetime_;	/* optional element of type ns1:loginLifetime */
};
#endif

#ifndef SOAP_TYPE___ns1__addSample
#define SOAP_TYPE___ns1__addSample (350)
/* Operation wrapper: */
struct __ns1__addSample
{
public:
	ns1__addSample *ns1__addSample_;	/* optional element of type ns1:addSample */
};
#endif

#ifndef SOAP_TYPE___ns1__logout
#define SOAP_TYPE___ns1__logout (354)
/* Operation wrapper: */
struct __ns1__logout
{
public:
	ns1__logout *ns1__logout_;	/* optional element of type ns1:logout */
};
#endif

#ifndef SOAP_TYPE___ns1__addSampleParameter
#define SOAP_TYPE___ns1__addSampleParameter (358)
/* Operation wrapper: */
struct __ns1__addSampleParameter
{
public:
	ns1__addSampleParameter *ns1__addSampleParameter_;	/* optional element of type ns1:addSampleParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__addPublication
#define SOAP_TYPE___ns1__addPublication (362)
/* Operation wrapper: */
struct __ns1__addPublication
{
public:
	ns1__addPublication *ns1__addPublication_;	/* optional element of type ns1:addPublication */
};
#endif

#ifndef SOAP_TYPE___ns1__addKeyword
#define SOAP_TYPE___ns1__addKeyword (366)
/* Operation wrapper: */
struct __ns1__addKeyword
{
public:
	ns1__addKeyword *ns1__addKeyword_;	/* optional element of type ns1:addKeyword */
};
#endif

#ifndef SOAP_TYPE___ns1__addInvestigator
#define SOAP_TYPE___ns1__addInvestigator (370)
/* Operation wrapper: */
struct __ns1__addInvestigator
{
public:
	ns1__addInvestigator *ns1__addInvestigator_;	/* optional element of type ns1:addInvestigator */
};
#endif

#ifndef SOAP_TYPE___ns1__getInvestigation
#define SOAP_TYPE___ns1__getInvestigation (374)
/* Operation wrapper: */
struct __ns1__getInvestigation
{
public:
	ns1__getInvestigation *ns1__getInvestigation_;	/* optional element of type ns1:getInvestigation */
};
#endif

#ifndef SOAP_TYPE___ns1__getInvestigationIncludes
#define SOAP_TYPE___ns1__getInvestigationIncludes (378)
/* Operation wrapper: */
struct __ns1__getInvestigationIncludes
{
public:
	ns1__getInvestigationIncludes *ns1__getInvestigationIncludes_;	/* optional element of type ns1:getInvestigationIncludes */
};
#endif

#ifndef SOAP_TYPE___ns1__getDataset
#define SOAP_TYPE___ns1__getDataset (382)
/* Operation wrapper: */
struct __ns1__getDataset
{
public:
	ns1__getDataset *ns1__getDataset_;	/* optional element of type ns1:getDataset */
};
#endif

#ifndef SOAP_TYPE___ns1__getDatasetIncludes
#define SOAP_TYPE___ns1__getDatasetIncludes (386)
/* Operation wrapper: */
struct __ns1__getDatasetIncludes
{
public:
	ns1__getDatasetIncludes *ns1__getDatasetIncludes_;	/* optional element of type ns1:getDatasetIncludes */
};
#endif

#ifndef SOAP_TYPE___ns1__getDatafile
#define SOAP_TYPE___ns1__getDatafile (390)
/* Operation wrapper: */
struct __ns1__getDatafile
{
public:
	ns1__getDatafile *ns1__getDatafile_;	/* optional element of type ns1:getDatafile */
};
#endif

#ifndef SOAP_TYPE___ns1__addDataFileParameter
#define SOAP_TYPE___ns1__addDataFileParameter (394)
/* Operation wrapper: */
struct __ns1__addDataFileParameter
{
public:
	ns1__addDataFileParameter *ns1__addDataFileParameter_;	/* optional element of type ns1:addDataFileParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__getUserDetails
#define SOAP_TYPE___ns1__getUserDetails (398)
/* Operation wrapper: */
struct __ns1__getUserDetails
{
public:
	ns1__getUserDetails *ns1__getUserDetails_;	/* optional element of type ns1:getUserDetails */
};
#endif

#ifndef SOAP_TYPE___ns1__ingestMetadata
#define SOAP_TYPE___ns1__ingestMetadata (402)
/* Operation wrapper: */
struct __ns1__ingestMetadata
{
public:
	ns1__ingestMetadata *ns1__ingestMetadata_;	/* optional element of type ns1:ingestMetadata */
};
#endif

#ifndef SOAP_TYPE___ns1__getDatafiles
#define SOAP_TYPE___ns1__getDatafiles (406)
/* Operation wrapper: */
struct __ns1__getDatafiles
{
public:
	ns1__getDatafiles *ns1__getDatafiles_;	/* optional element of type ns1:getDatafiles */
};
#endif

#ifndef SOAP_TYPE___ns1__createDataFile
#define SOAP_TYPE___ns1__createDataFile (410)
/* Operation wrapper: */
struct __ns1__createDataFile
{
public:
	ns1__createDataFile *ns1__createDataFile_;	/* optional element of type ns1:createDataFile */
};
#endif

#ifndef SOAP_TYPE___ns1__createDataFiles
#define SOAP_TYPE___ns1__createDataFiles (414)
/* Operation wrapper: */
struct __ns1__createDataFiles
{
public:
	ns1__createDataFiles *ns1__createDataFiles_;	/* optional element of type ns1:createDataFiles */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataFileResponse
#define SOAP_TYPE___ns1__deleteDataFileResponse (418)
/* Operation wrapper: */
struct __ns1__deleteDataFileResponse
{
public:
	ns1__deleteDataFileResponse *ns1__deleteDataFileResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteDataFileResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataFile
#define SOAP_TYPE___ns1__deleteDataFile (419)
/* Operation wrapper: */
struct __ns1__deleteDataFile
{
public:
	ns1__deleteDataFile *ns1__deleteDataFile_;	/* optional element of type ns1:deleteDataFile */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataFileResponse
#define SOAP_TYPE___ns1__removeDataFileResponse (423)
/* Operation wrapper: */
struct __ns1__removeDataFileResponse
{
public:
	ns1__removeDataFileResponse *ns1__removeDataFileResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeDataFileResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataFile
#define SOAP_TYPE___ns1__removeDataFile (424)
/* Operation wrapper: */
struct __ns1__removeDataFile
{
public:
	ns1__removeDataFile *ns1__removeDataFile_;	/* optional element of type ns1:removeDataFile */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataFileResponse
#define SOAP_TYPE___ns1__modifyDataFileResponse (428)
/* Operation wrapper: */
struct __ns1__modifyDataFileResponse
{
public:
	ns1__modifyDataFileResponse *ns1__modifyDataFileResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifyDataFileResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataFile
#define SOAP_TYPE___ns1__modifyDataFile (429)
/* Operation wrapper: */
struct __ns1__modifyDataFile
{
public:
	ns1__modifyDataFile *ns1__modifyDataFile_;	/* optional element of type ns1:modifyDataFile */
};
#endif

#ifndef SOAP_TYPE___ns1__addDataFileParameters
#define SOAP_TYPE___ns1__addDataFileParameters (433)
/* Operation wrapper: */
struct __ns1__addDataFileParameters
{
public:
	ns1__addDataFileParameters *ns1__addDataFileParameters_;	/* optional element of type ns1:addDataFileParameters */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataFileParameterResponse
#define SOAP_TYPE___ns1__modifyDataFileParameterResponse (437)
/* Operation wrapper: */
struct __ns1__modifyDataFileParameterResponse
{
public:
	ns1__modifyDataFileParameterResponse *ns1__modifyDataFileParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifyDataFileParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataFileParameter
#define SOAP_TYPE___ns1__modifyDataFileParameter (438)
/* Operation wrapper: */
struct __ns1__modifyDataFileParameter
{
public:
	ns1__modifyDataFileParameter *ns1__modifyDataFileParameter_;	/* optional element of type ns1:modifyDataFileParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataFileParameterResponse
#define SOAP_TYPE___ns1__removeDataFileParameterResponse (442)
/* Operation wrapper: */
struct __ns1__removeDataFileParameterResponse
{
public:
	ns1__removeDataFileParameterResponse *ns1__removeDataFileParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeDataFileParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataFileParameter
#define SOAP_TYPE___ns1__removeDataFileParameter (443)
/* Operation wrapper: */
struct __ns1__removeDataFileParameter
{
public:
	ns1__removeDataFileParameter *ns1__removeDataFileParameter_;	/* optional element of type ns1:removeDataFileParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataFileParameterResponse
#define SOAP_TYPE___ns1__deleteDataFileParameterResponse (447)
/* Operation wrapper: */
struct __ns1__deleteDataFileParameterResponse
{
public:
	ns1__deleteDataFileParameterResponse *ns1__deleteDataFileParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteDataFileParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataFileParameter
#define SOAP_TYPE___ns1__deleteDataFileParameter (448)
/* Operation wrapper: */
struct __ns1__deleteDataFileParameter
{
public:
	ns1__deleteDataFileParameter *ns1__deleteDataFileParameter_;	/* optional element of type ns1:deleteDataFileParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__getAuthorisations
#define SOAP_TYPE___ns1__getAuthorisations (452)
/* Operation wrapper: */
struct __ns1__getAuthorisations
{
public:
	ns1__getAuthorisations *ns1__getAuthorisations_;	/* optional element of type ns1:getAuthorisations */
};
#endif

#ifndef SOAP_TYPE___ns1__addAuthorisation
#define SOAP_TYPE___ns1__addAuthorisation (456)
/* Operation wrapper: */
struct __ns1__addAuthorisation
{
public:
	ns1__addAuthorisation *ns1__addAuthorisation_;	/* optional element of type ns1:addAuthorisation */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteAuthorisationResponse
#define SOAP_TYPE___ns1__deleteAuthorisationResponse (460)
/* Operation wrapper: */
struct __ns1__deleteAuthorisationResponse
{
public:
	ns1__deleteAuthorisationResponse *ns1__deleteAuthorisationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteAuthorisationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteAuthorisation
#define SOAP_TYPE___ns1__deleteAuthorisation (461)
/* Operation wrapper: */
struct __ns1__deleteAuthorisation
{
public:
	ns1__deleteAuthorisation *ns1__deleteAuthorisation_;	/* optional element of type ns1:deleteAuthorisation */
};
#endif

#ifndef SOAP_TYPE___ns1__removeAuthorisationResponse
#define SOAP_TYPE___ns1__removeAuthorisationResponse (465)
/* Operation wrapper: */
struct __ns1__removeAuthorisationResponse
{
public:
	ns1__removeAuthorisationResponse *ns1__removeAuthorisationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeAuthorisationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeAuthorisation
#define SOAP_TYPE___ns1__removeAuthorisation (466)
/* Operation wrapper: */
struct __ns1__removeAuthorisation
{
public:
	ns1__removeAuthorisation *ns1__removeAuthorisation_;	/* optional element of type ns1:removeAuthorisation */
};
#endif

#ifndef SOAP_TYPE___ns1__updateAuthorisationResponse
#define SOAP_TYPE___ns1__updateAuthorisationResponse (470)
/* Operation wrapper: */
struct __ns1__updateAuthorisationResponse
{
public:
	ns1__updateAuthorisationResponse *ns1__updateAuthorisationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:updateAuthorisationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__updateAuthorisation
#define SOAP_TYPE___ns1__updateAuthorisation (471)
/* Operation wrapper: */
struct __ns1__updateAuthorisation
{
public:
	ns1__updateAuthorisation *ns1__updateAuthorisation_;	/* optional element of type ns1:updateAuthorisation */
};
#endif

#ifndef SOAP_TYPE___ns1__getInvestigationsIncludes
#define SOAP_TYPE___ns1__getInvestigationsIncludes (475)
/* Operation wrapper: */
struct __ns1__getInvestigationsIncludes
{
public:
	ns1__getInvestigationsIncludes *ns1__getInvestigationsIncludes_;	/* optional element of type ns1:getInvestigationsIncludes */
};
#endif

#ifndef SOAP_TYPE___ns1__createInvestigation
#define SOAP_TYPE___ns1__createInvestigation (479)
/* Operation wrapper: */
struct __ns1__createInvestigation
{
public:
	ns1__createInvestigation *ns1__createInvestigation_;	/* optional element of type ns1:createInvestigation */
};
#endif

#ifndef SOAP_TYPE___ns1__removeInvestigationResponse
#define SOAP_TYPE___ns1__removeInvestigationResponse (483)
/* Operation wrapper: */
struct __ns1__removeInvestigationResponse
{
public:
	ns1__removeInvestigationResponse *ns1__removeInvestigationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeInvestigationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeInvestigation
#define SOAP_TYPE___ns1__removeInvestigation (484)
/* Operation wrapper: */
struct __ns1__removeInvestigation
{
public:
	ns1__removeInvestigation *ns1__removeInvestigation_;	/* optional element of type ns1:removeInvestigation */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteInvestigationResponse
#define SOAP_TYPE___ns1__deleteInvestigationResponse (488)
/* Operation wrapper: */
struct __ns1__deleteInvestigationResponse
{
public:
	ns1__deleteInvestigationResponse *ns1__deleteInvestigationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteInvestigationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteInvestigation
#define SOAP_TYPE___ns1__deleteInvestigation (489)
/* Operation wrapper: */
struct __ns1__deleteInvestigation
{
public:
	ns1__deleteInvestigation *ns1__deleteInvestigation_;	/* optional element of type ns1:deleteInvestigation */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyInvestigationResponse
#define SOAP_TYPE___ns1__modifyInvestigationResponse (493)
/* Operation wrapper: */
struct __ns1__modifyInvestigationResponse
{
public:
	ns1__modifyInvestigationResponse *ns1__modifyInvestigationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifyInvestigationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyInvestigation
#define SOAP_TYPE___ns1__modifyInvestigation (494)
/* Operation wrapper: */
struct __ns1__modifyInvestigation
{
public:
	ns1__modifyInvestigation *ns1__modifyInvestigation_;	/* optional element of type ns1:modifyInvestigation */
};
#endif

#ifndef SOAP_TYPE___ns1__removeKeywordResponse
#define SOAP_TYPE___ns1__removeKeywordResponse (498)
/* Operation wrapper: */
struct __ns1__removeKeywordResponse
{
public:
	ns1__removeKeywordResponse *ns1__removeKeywordResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeKeywordResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeKeyword
#define SOAP_TYPE___ns1__removeKeyword (499)
/* Operation wrapper: */
struct __ns1__removeKeyword
{
public:
	ns1__removeKeyword *ns1__removeKeyword_;	/* optional element of type ns1:removeKeyword */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteKeywordResponse
#define SOAP_TYPE___ns1__deleteKeywordResponse (503)
/* Operation wrapper: */
struct __ns1__deleteKeywordResponse
{
public:
	ns1__deleteKeywordResponse *ns1__deleteKeywordResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteKeywordResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteKeyword
#define SOAP_TYPE___ns1__deleteKeyword (504)
/* Operation wrapper: */
struct __ns1__deleteKeyword
{
public:
	ns1__deleteKeyword *ns1__deleteKeyword_;	/* optional element of type ns1:deleteKeyword */
};
#endif

#ifndef SOAP_TYPE___ns1__removePublicationResponse
#define SOAP_TYPE___ns1__removePublicationResponse (508)
/* Operation wrapper: */
struct __ns1__removePublicationResponse
{
public:
	ns1__removePublicationResponse *ns1__removePublicationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removePublicationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removePublication
#define SOAP_TYPE___ns1__removePublication (509)
/* Operation wrapper: */
struct __ns1__removePublication
{
public:
	ns1__removePublication *ns1__removePublication_;	/* optional element of type ns1:removePublication */
};
#endif

#ifndef SOAP_TYPE___ns1__deletePublicationResponse
#define SOAP_TYPE___ns1__deletePublicationResponse (513)
/* Operation wrapper: */
struct __ns1__deletePublicationResponse
{
public:
	ns1__deletePublicationResponse *ns1__deletePublicationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deletePublicationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deletePublication
#define SOAP_TYPE___ns1__deletePublication (514)
/* Operation wrapper: */
struct __ns1__deletePublication
{
public:
	ns1__deletePublication *ns1__deletePublication_;	/* optional element of type ns1:deletePublication */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyPublicationResponse
#define SOAP_TYPE___ns1__modifyPublicationResponse (518)
/* Operation wrapper: */
struct __ns1__modifyPublicationResponse
{
public:
	ns1__modifyPublicationResponse *ns1__modifyPublicationResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifyPublicationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyPublication
#define SOAP_TYPE___ns1__modifyPublication (519)
/* Operation wrapper: */
struct __ns1__modifyPublication
{
public:
	ns1__modifyPublication *ns1__modifyPublication_;	/* optional element of type ns1:modifyPublication */
};
#endif

#ifndef SOAP_TYPE___ns1__removeInvestigatorResponse
#define SOAP_TYPE___ns1__removeInvestigatorResponse (523)
/* Operation wrapper: */
struct __ns1__removeInvestigatorResponse
{
public:
	ns1__removeInvestigatorResponse *ns1__removeInvestigatorResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeInvestigatorResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeInvestigator
#define SOAP_TYPE___ns1__removeInvestigator (524)
/* Operation wrapper: */
struct __ns1__removeInvestigator
{
public:
	ns1__removeInvestigator *ns1__removeInvestigator_;	/* optional element of type ns1:removeInvestigator */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyInvestigatorResponse
#define SOAP_TYPE___ns1__modifyInvestigatorResponse (528)
/* Operation wrapper: */
struct __ns1__modifyInvestigatorResponse
{
public:
	ns1__modifyInvestigatorResponse *ns1__modifyInvestigatorResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifyInvestigatorResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyInvestigator
#define SOAP_TYPE___ns1__modifyInvestigator (529)
/* Operation wrapper: */
struct __ns1__modifyInvestigator
{
public:
	ns1__modifyInvestigator *ns1__modifyInvestigator_;	/* optional element of type ns1:modifyInvestigator */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteInvestigatorResponse
#define SOAP_TYPE___ns1__deleteInvestigatorResponse (533)
/* Operation wrapper: */
struct __ns1__deleteInvestigatorResponse
{
public:
	ns1__deleteInvestigatorResponse *ns1__deleteInvestigatorResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteInvestigatorResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteInvestigator
#define SOAP_TYPE___ns1__deleteInvestigator (534)
/* Operation wrapper: */
struct __ns1__deleteInvestigator
{
public:
	ns1__deleteInvestigator *ns1__deleteInvestigator_;	/* optional element of type ns1:deleteInvestigator */
};
#endif

#ifndef SOAP_TYPE___ns1__removeSampleResponse
#define SOAP_TYPE___ns1__removeSampleResponse (538)
/* Operation wrapper: */
struct __ns1__removeSampleResponse
{
public:
	ns1__removeSampleResponse *ns1__removeSampleResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeSampleResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeSample
#define SOAP_TYPE___ns1__removeSample (539)
/* Operation wrapper: */
struct __ns1__removeSample
{
public:
	ns1__removeSample *ns1__removeSample_;	/* optional element of type ns1:removeSample */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteSampleResponse
#define SOAP_TYPE___ns1__deleteSampleResponse (543)
/* Operation wrapper: */
struct __ns1__deleteSampleResponse
{
public:
	ns1__deleteSampleResponse *ns1__deleteSampleResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteSampleResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteSample
#define SOAP_TYPE___ns1__deleteSample (544)
/* Operation wrapper: */
struct __ns1__deleteSample
{
public:
	ns1__deleteSample *ns1__deleteSample_;	/* optional element of type ns1:deleteSample */
};
#endif

#ifndef SOAP_TYPE___ns1__modifySampleResponse
#define SOAP_TYPE___ns1__modifySampleResponse (548)
/* Operation wrapper: */
struct __ns1__modifySampleResponse
{
public:
	ns1__modifySampleResponse *ns1__modifySampleResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifySampleResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifySample
#define SOAP_TYPE___ns1__modifySample (549)
/* Operation wrapper: */
struct __ns1__modifySample
{
public:
	ns1__modifySample *ns1__modifySample_;	/* optional element of type ns1:modifySample */
};
#endif

#ifndef SOAP_TYPE___ns1__removeSampleParameterResponse
#define SOAP_TYPE___ns1__removeSampleParameterResponse (553)
/* Operation wrapper: */
struct __ns1__removeSampleParameterResponse
{
public:
	ns1__removeSampleParameterResponse *ns1__removeSampleParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeSampleParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeSampleParameter
#define SOAP_TYPE___ns1__removeSampleParameter (554)
/* Operation wrapper: */
struct __ns1__removeSampleParameter
{
public:
	ns1__removeSampleParameter *ns1__removeSampleParameter_;	/* optional element of type ns1:removeSampleParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteSampleParameterResponse
#define SOAP_TYPE___ns1__deleteSampleParameterResponse (558)
/* Operation wrapper: */
struct __ns1__deleteSampleParameterResponse
{
public:
	ns1__deleteSampleParameterResponse *ns1__deleteSampleParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteSampleParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteSampleParameter
#define SOAP_TYPE___ns1__deleteSampleParameter (559)
/* Operation wrapper: */
struct __ns1__deleteSampleParameter
{
public:
	ns1__deleteSampleParameter *ns1__deleteSampleParameter_;	/* optional element of type ns1:deleteSampleParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__modifySampleParameterResponse
#define SOAP_TYPE___ns1__modifySampleParameterResponse (563)
/* Operation wrapper: */
struct __ns1__modifySampleParameterResponse
{
public:
	ns1__modifySampleParameterResponse *ns1__modifySampleParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifySampleParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifySampleParameter
#define SOAP_TYPE___ns1__modifySampleParameter (564)
/* Operation wrapper: */
struct __ns1__modifySampleParameter
{
public:
	ns1__modifySampleParameter *ns1__modifySampleParameter_;	/* optional element of type ns1:modifySampleParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__getKeywordsForUser
#define SOAP_TYPE___ns1__getKeywordsForUser (568)
/* Operation wrapper: */
struct __ns1__getKeywordsForUser
{
public:
	ns1__getKeywordsForUser *ns1__getKeywordsForUser_;	/* optional element of type ns1:getKeywordsForUser */
};
#endif

#ifndef SOAP_TYPE___ns1__getKeywordsForUserStartWithMax
#define SOAP_TYPE___ns1__getKeywordsForUserStartWithMax (572)
/* Operation wrapper: */
struct __ns1__getKeywordsForUserStartWithMax
{
public:
	ns1__getKeywordsForUserStartWithMax *ns1__getKeywordsForUserStartWithMax_;	/* optional element of type ns1:getKeywordsForUserStartWithMax */
};
#endif

#ifndef SOAP_TYPE___ns1__getKeywordsForUserMax
#define SOAP_TYPE___ns1__getKeywordsForUserMax (576)
/* Operation wrapper: */
struct __ns1__getKeywordsForUserMax
{
public:
	ns1__getKeywordsForUserMax *ns1__getKeywordsForUserMax_;	/* optional element of type ns1:getKeywordsForUserMax */
};
#endif

#ifndef SOAP_TYPE___ns1__getKeywordsForUserType
#define SOAP_TYPE___ns1__getKeywordsForUserType (580)
/* Operation wrapper: */
struct __ns1__getKeywordsForUserType
{
public:
	ns1__getKeywordsForUserType *ns1__getKeywordsForUserType_;	/* optional element of type ns1:getKeywordsForUserType */
};
#endif

#ifndef SOAP_TYPE___ns1__getAllKeywords
#define SOAP_TYPE___ns1__getAllKeywords (584)
/* Operation wrapper: */
struct __ns1__getAllKeywords
{
public:
	ns1__getAllKeywords *ns1__getAllKeywords_;	/* optional element of type ns1:getAllKeywords */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByRunNumber
#define SOAP_TYPE___ns1__searchByRunNumber (588)
/* Operation wrapper: */
struct __ns1__searchByRunNumber
{
public:
	ns1__searchByRunNumber *ns1__searchByRunNumber_;	/* optional element of type ns1:searchByRunNumber */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByRunNumberPagination
#define SOAP_TYPE___ns1__searchByRunNumberPagination (592)
/* Operation wrapper: */
struct __ns1__searchByRunNumberPagination
{
public:
	ns1__searchByRunNumberPagination *ns1__searchByRunNumberPagination_;	/* optional element of type ns1:searchByRunNumberPagination */
};
#endif

#ifndef SOAP_TYPE___ns1__listDatafileFormats
#define SOAP_TYPE___ns1__listDatafileFormats (596)
/* Operation wrapper: */
struct __ns1__listDatafileFormats
{
public:
	ns1__listDatafileFormats *ns1__listDatafileFormats_;	/* optional element of type ns1:listDatafileFormats */
};
#endif

#ifndef SOAP_TYPE___ns1__searchSamplesBySampleName
#define SOAP_TYPE___ns1__searchSamplesBySampleName (600)
/* Operation wrapper: */
struct __ns1__searchSamplesBySampleName
{
public:
	ns1__searchSamplesBySampleName *ns1__searchSamplesBySampleName_;	/* optional element of type ns1:searchSamplesBySampleName */
};
#endif

#ifndef SOAP_TYPE___ns1__listDatasetTypes
#define SOAP_TYPE___ns1__listDatasetTypes (604)
/* Operation wrapper: */
struct __ns1__listDatasetTypes
{
public:
	ns1__listDatasetTypes *ns1__listDatasetTypes_;	/* optional element of type ns1:listDatasetTypes */
};
#endif

#ifndef SOAP_TYPE___ns1__listDatasetStatus
#define SOAP_TYPE___ns1__listDatasetStatus (608)
/* Operation wrapper: */
struct __ns1__listDatasetStatus
{
public:
	ns1__listDatasetStatus *ns1__listDatasetStatus_;	/* optional element of type ns1:listDatasetStatus */
};
#endif

#ifndef SOAP_TYPE___ns1__getDatasets
#define SOAP_TYPE___ns1__getDatasets (612)
/* Operation wrapper: */
struct __ns1__getDatasets
{
public:
	ns1__getDatasets *ns1__getDatasets_;	/* optional element of type ns1:getDatasets */
};
#endif

#ifndef SOAP_TYPE___ns1__createDataSet
#define SOAP_TYPE___ns1__createDataSet (616)
/* Operation wrapper: */
struct __ns1__createDataSet
{
public:
	ns1__createDataSet *ns1__createDataSet_;	/* optional element of type ns1:createDataSet */
};
#endif

#ifndef SOAP_TYPE___ns1__createDataSets
#define SOAP_TYPE___ns1__createDataSets (620)
/* Operation wrapper: */
struct __ns1__createDataSets
{
public:
	ns1__createDataSets *ns1__createDataSets_;	/* optional element of type ns1:createDataSets */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataSetResponse
#define SOAP_TYPE___ns1__removeDataSetResponse (624)
/* Operation wrapper: */
struct __ns1__removeDataSetResponse
{
public:
	ns1__removeDataSetResponse *ns1__removeDataSetResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeDataSetResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataSet
#define SOAP_TYPE___ns1__removeDataSet (625)
/* Operation wrapper: */
struct __ns1__removeDataSet
{
public:
	ns1__removeDataSet *ns1__removeDataSet_;	/* optional element of type ns1:removeDataSet */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataSetResponse
#define SOAP_TYPE___ns1__deleteDataSetResponse (629)
/* Operation wrapper: */
struct __ns1__deleteDataSetResponse
{
public:
	ns1__deleteDataSetResponse *ns1__deleteDataSetResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteDataSetResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataSet
#define SOAP_TYPE___ns1__deleteDataSet (630)
/* Operation wrapper: */
struct __ns1__deleteDataSet
{
public:
	ns1__deleteDataSet *ns1__deleteDataSet_;	/* optional element of type ns1:deleteDataSet */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataSetResponse
#define SOAP_TYPE___ns1__modifyDataSetResponse (634)
/* Operation wrapper: */
struct __ns1__modifyDataSetResponse
{
public:
	ns1__modifyDataSetResponse *ns1__modifyDataSetResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifyDataSetResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataSet
#define SOAP_TYPE___ns1__modifyDataSet (635)
/* Operation wrapper: */
struct __ns1__modifyDataSet
{
public:
	ns1__modifyDataSet *ns1__modifyDataSet_;	/* optional element of type ns1:modifyDataSet */
};
#endif

#ifndef SOAP_TYPE___ns1__addDataSetParameter
#define SOAP_TYPE___ns1__addDataSetParameter (639)
/* Operation wrapper: */
struct __ns1__addDataSetParameter
{
public:
	ns1__addDataSetParameter *ns1__addDataSetParameter_;	/* optional element of type ns1:addDataSetParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__addDataSetParameters
#define SOAP_TYPE___ns1__addDataSetParameters (643)
/* Operation wrapper: */
struct __ns1__addDataSetParameters
{
public:
	ns1__addDataSetParameters *ns1__addDataSetParameters_;	/* optional element of type ns1:addDataSetParameters */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataSetParameterResponse
#define SOAP_TYPE___ns1__modifyDataSetParameterResponse (647)
/* Operation wrapper: */
struct __ns1__modifyDataSetParameterResponse
{
public:
	ns1__modifyDataSetParameterResponse *ns1__modifyDataSetParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:modifyDataSetParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__modifyDataSetParameter
#define SOAP_TYPE___ns1__modifyDataSetParameter (648)
/* Operation wrapper: */
struct __ns1__modifyDataSetParameter
{
public:
	ns1__modifyDataSetParameter *ns1__modifyDataSetParameter_;	/* optional element of type ns1:modifyDataSetParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataSetParameterResponse
#define SOAP_TYPE___ns1__removeDataSetParameterResponse (652)
/* Operation wrapper: */
struct __ns1__removeDataSetParameterResponse
{
public:
	ns1__removeDataSetParameterResponse *ns1__removeDataSetParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeDataSetParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeDataSetParameter
#define SOAP_TYPE___ns1__removeDataSetParameter (653)
/* Operation wrapper: */
struct __ns1__removeDataSetParameter
{
public:
	ns1__removeDataSetParameter *ns1__removeDataSetParameter_;	/* optional element of type ns1:removeDataSetParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataSetParameterResponse
#define SOAP_TYPE___ns1__deleteDataSetParameterResponse (657)
/* Operation wrapper: */
struct __ns1__deleteDataSetParameterResponse
{
public:
	ns1__deleteDataSetParameterResponse *ns1__deleteDataSetParameterResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteDataSetParameterResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDataSetParameter
#define SOAP_TYPE___ns1__deleteDataSetParameter (658)
/* Operation wrapper: */
struct __ns1__deleteDataSetParameter
{
public:
	ns1__deleteDataSetParameter *ns1__deleteDataSetParameter_;	/* optional element of type ns1:deleteDataSetParameter */
};
#endif

#ifndef SOAP_TYPE___ns1__setDataSetSampleResponse
#define SOAP_TYPE___ns1__setDataSetSampleResponse (662)
/* Operation wrapper: */
struct __ns1__setDataSetSampleResponse
{
public:
	ns1__setDataSetSampleResponse *ns1__setDataSetSampleResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:setDataSetSampleResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__setDataSetSample
#define SOAP_TYPE___ns1__setDataSetSample (663)
/* Operation wrapper: */
struct __ns1__setDataSetSample
{
public:
	ns1__setDataSetSample *ns1__setDataSetSample_;	/* optional element of type ns1:setDataSetSample */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByAdvanced
#define SOAP_TYPE___ns1__searchByAdvanced (667)
/* Operation wrapper: */
struct __ns1__searchByAdvanced
{
public:
	ns1__searchByAdvanced *ns1__searchByAdvanced_;	/* optional element of type ns1:searchByAdvanced */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByAdvancedPagination
#define SOAP_TYPE___ns1__searchByAdvancedPagination (671)
/* Operation wrapper: */
struct __ns1__searchByAdvancedPagination
{
public:
	ns1__searchByAdvancedPagination *ns1__searchByAdvancedPagination_;	/* optional element of type ns1:searchByAdvancedPagination */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByKeywords
#define SOAP_TYPE___ns1__searchByKeywords (675)
/* Operation wrapper: */
struct __ns1__searchByKeywords
{
public:
	ns1__searchByKeywords *ns1__searchByKeywords_;	/* optional element of type ns1:searchByKeywords */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByKeywordsAll
#define SOAP_TYPE___ns1__searchByKeywordsAll (679)
/* Operation wrapper: */
struct __ns1__searchByKeywordsAll
{
public:
	ns1__searchByKeywordsAll *ns1__searchByKeywordsAll_;	/* optional element of type ns1:searchByKeywordsAll */
};
#endif

#ifndef SOAP_TYPE___ns1__getMyInvestigations
#define SOAP_TYPE___ns1__getMyInvestigations (683)
/* Operation wrapper: */
struct __ns1__getMyInvestigations
{
public:
	ns1__getMyInvestigations *ns1__getMyInvestigations_;	/* optional element of type ns1:getMyInvestigations */
};
#endif

#ifndef SOAP_TYPE___ns1__getMyInvestigationsIncludes
#define SOAP_TYPE___ns1__getMyInvestigationsIncludes (687)
/* Operation wrapper: */
struct __ns1__getMyInvestigationsIncludes
{
public:
	ns1__getMyInvestigationsIncludes *ns1__getMyInvestigationsIncludes_;	/* optional element of type ns1:getMyInvestigationsIncludes */
};
#endif

#ifndef SOAP_TYPE___ns1__getMyInvestigationsIncludesPagination
#define SOAP_TYPE___ns1__getMyInvestigationsIncludesPagination (691)
/* Operation wrapper: */
struct __ns1__getMyInvestigationsIncludesPagination
{
public:
	ns1__getMyInvestigationsIncludesPagination *ns1__getMyInvestigationsIncludesPagination_;	/* optional element of type ns1:getMyInvestigationsIncludesPagination */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByUserID
#define SOAP_TYPE___ns1__searchByUserID (695)
/* Operation wrapper: */
struct __ns1__searchByUserID
{
public:
	ns1__searchByUserID *ns1__searchByUserID_;	/* optional element of type ns1:searchByUserID */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByUserIDPagination
#define SOAP_TYPE___ns1__searchByUserIDPagination (699)
/* Operation wrapper: */
struct __ns1__searchByUserIDPagination
{
public:
	ns1__searchByUserIDPagination *ns1__searchByUserIDPagination_;	/* optional element of type ns1:searchByUserIDPagination */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByUserSurname
#define SOAP_TYPE___ns1__searchByUserSurname (703)
/* Operation wrapper: */
struct __ns1__searchByUserSurname
{
public:
	ns1__searchByUserSurname *ns1__searchByUserSurname_;	/* optional element of type ns1:searchByUserSurname */
};
#endif

#ifndef SOAP_TYPE___ns1__searchByUserSurnamePagination
#define SOAP_TYPE___ns1__searchByUserSurnamePagination (707)
/* Operation wrapper: */
struct __ns1__searchByUserSurnamePagination
{
public:
	ns1__searchByUserSurnamePagination *ns1__searchByUserSurnamePagination_;	/* optional element of type ns1:searchByUserSurnamePagination */
};
#endif

#ifndef SOAP_TYPE___ns1__listInstruments
#define SOAP_TYPE___ns1__listInstruments (711)
/* Operation wrapper: */
struct __ns1__listInstruments
{
public:
	ns1__listInstruments *ns1__listInstruments_;	/* optional element of type ns1:listInstruments */
};
#endif

#ifndef SOAP_TYPE___ns1__listRoles
#define SOAP_TYPE___ns1__listRoles (715)
/* Operation wrapper: */
struct __ns1__listRoles
{
public:
	ns1__listRoles *ns1__listRoles_;	/* optional element of type ns1:listRoles */
};
#endif

#ifndef SOAP_TYPE___ns1__listInvestigationTypes
#define SOAP_TYPE___ns1__listInvestigationTypes (719)
/* Operation wrapper: */
struct __ns1__listInvestigationTypes
{
public:
	ns1__listInvestigationTypes *ns1__listInvestigationTypes_;	/* optional element of type ns1:listInvestigationTypes */
};
#endif

#ifndef SOAP_TYPE___ns1__listParameters
#define SOAP_TYPE___ns1__listParameters (723)
/* Operation wrapper: */
struct __ns1__listParameters
{
public:
	ns1__listParameters *ns1__listParameters_;	/* optional element of type ns1:listParameters */
};
#endif

#ifndef SOAP_TYPE___ns1__downloadDatafile
#define SOAP_TYPE___ns1__downloadDatafile (727)
/* Operation wrapper: */
struct __ns1__downloadDatafile
{
public:
	ns1__downloadDatafile *ns1__downloadDatafile_;	/* optional element of type ns1:downloadDatafile */
};
#endif

#ifndef SOAP_TYPE___ns1__downloadDatafiles
#define SOAP_TYPE___ns1__downloadDatafiles (731)
/* Operation wrapper: */
struct __ns1__downloadDatafiles
{
public:
	ns1__downloadDatafiles *ns1__downloadDatafiles_;	/* optional element of type ns1:downloadDatafiles */
};
#endif

#ifndef SOAP_TYPE___ns1__downloadDataset
#define SOAP_TYPE___ns1__downloadDataset (735)
/* Operation wrapper: */
struct __ns1__downloadDataset
{
public:
	ns1__downloadDataset *ns1__downloadDataset_;	/* optional element of type ns1:downloadDataset */
};
#endif

#ifndef SOAP_TYPE___ns1__checkDatafileDownloadAccess
#define SOAP_TYPE___ns1__checkDatafileDownloadAccess (739)
/* Operation wrapper: */
struct __ns1__checkDatafileDownloadAccess
{
public:
	ns1__checkDatafileDownloadAccess *ns1__checkDatafileDownloadAccess_;	/* optional element of type ns1:checkDatafileDownloadAccess */
};
#endif

#ifndef SOAP_TYPE___ns1__checkDatasetDownloadAccess
#define SOAP_TYPE___ns1__checkDatasetDownloadAccess (743)
/* Operation wrapper: */
struct __ns1__checkDatasetDownloadAccess
{
public:
	ns1__checkDatasetDownloadAccess *ns1__checkDatasetDownloadAccess_;	/* optional element of type ns1:checkDatasetDownloadAccess */
};
#endif

#ifndef SOAP_TYPE___ns1__searchDatasetsBySample
#define SOAP_TYPE___ns1__searchDatasetsBySample (747)
/* Operation wrapper: */
struct __ns1__searchDatasetsBySample
{
public:
	ns1__searchDatasetsBySample *ns1__searchDatasetsBySample_;	/* optional element of type ns1:searchDatasetsBySample */
};
#endif

#ifndef SOAP_TYPE___ns1__getFacilityUserByFacilityUserId
#define SOAP_TYPE___ns1__getFacilityUserByFacilityUserId (751)
/* Operation wrapper: */
struct __ns1__getFacilityUserByFacilityUserId
{
public:
	ns1__getFacilityUserByFacilityUserId *ns1__getFacilityUserByFacilityUserId_;	/* optional element of type ns1:getFacilityUserByFacilityUserId */
};
#endif

#ifndef SOAP_TYPE___ns1__getFacilityUserByFederalId
#define SOAP_TYPE___ns1__getFacilityUserByFederalId (755)
/* Operation wrapper: */
struct __ns1__getFacilityUserByFederalId
{
public:
	ns1__getFacilityUserByFederalId *ns1__getFacilityUserByFederalId_;	/* optional element of type ns1:getFacilityUserByFederalId */
};
#endif

#ifndef SOAP_TYPE___ns1__listFacilityCycles
#define SOAP_TYPE___ns1__listFacilityCycles (759)
/* Operation wrapper: */
struct __ns1__listFacilityCycles
{
public:
	ns1__listFacilityCycles *ns1__listFacilityCycles_;	/* optional element of type ns1:listFacilityCycles */
};
#endif

#ifndef SOAP_TYPE___ns1__getICATAPIVersion
#define SOAP_TYPE___ns1__getICATAPIVersion (763)
/* Operation wrapper: */
struct __ns1__getICATAPIVersion
{
public:
	ns1__getICATAPIVersion *ns1__getICATAPIVersion_;	/* optional element of type ns1:getICATAPIVersion */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (764)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (765)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (767)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (768)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
