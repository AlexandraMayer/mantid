#include "MantidDataHandling/LoadDetectorInfo.h"
#include "MantidDataObjects/Workspace2D.h"
#include "MantidKernel/ArrayProperty.h"
#include "MantidKernel/FileProperty.h"
#include "MantidAPI/WorkspaceValidators.h"
#include <fstream>
#include "LoadRaw/isisraw2.h"

namespace Mantid
{
namespace DataHandling
{

// Register the algorithm into the algorithm factory
DECLARE_ALGORITHM(LoadDetectorInfo)

using namespace Kernel;
using namespace API;
using namespace Geometry;
using namespace DataObjects;

/// Empty default constructor
LoadDetectorInfo::LoadDetectorInfo() :
    Algorithm()
{
}

void LoadDetectorInfo::init()
{
  // Declare required input parameters for algorithm
  declareProperty(new WorkspaceProperty<>("Workspace","",Direction::InOut),
    "The name of the workspace to that the detector information will be loaded into" );
  std::vector<std::string> exts;
  exts.push_back("dat");
  exts.push_back("raw");
  exts.push_back("sca");
  declareProperty(new FileProperty("DataFilename","", FileProperty::Load, exts),
    "A .DAT or .raw file that contains informtion about the detectors in the workspace");
}

void LoadDetectorInfo::exec()
{
  // Retrieve the filename and output workspace name from the properties
  std::string filename = getPropertyValue("DataFilename");

  if ( filename.find(".dat") == filename.size()-4 ||
    filename.find(".DAT") == filename.size()-4 )
  {
    readDAT(filename);
  }
  if ( filename.find(".sca") == filename.size()-4 ||
    filename.find(".SCA") == filename.size()-4 )
  {
    readDAT(filename);
  }
  
  if ( filename.find(".raw") == filename.size()-4 ||
    filename.find(".RAW") == filename.size()-4)
  {
    readRAW(filename);
  }
}

/** Reads detector information from a .dat file, the file contains one line per detector
*  and its format is documented in "DETECTOR.DAT format" (more details in LoadDetectorInfo.h)
*  @param fName name and path of the data file to read
*  @throws FileError if there is a problem with the file format
*/
void LoadDetectorInfo::readDAT(const std::string& fName)
{
  g_log.information() << "Reading DAT file " << fName << std::endl;
  std::ifstream sFile(fName.c_str());
  if (!sFile)
  {
    throw Exception::FileError("Can't open file", fName);
  }
  
  std::string str;
  // skip header line which contains something like <filename> generated by <prog>
  getline(sFile,str);
  
  int detectorCount;
  getline(sFile,str);
  std::istringstream header2(str);
  // there are two numbers on this detector count line, we want the first
  header2 >> detectorCount;
  if(detectorCount<1)
  {
    g_log.error("Bad detector count in data file");
    throw Exception::FileError("Problem reading the detector count on the second line of the data file", fName);
  }
 
  // skip title line
  getline(sFile,str);

  MatrixWorkspace_sptr workspace = getProperty("Workspace");
  IInstrument_const_sptr instrument = workspace->getInstrument();
  Geometry::ParameterMap& pmap = workspace->instrumentParameters();
  
  // used only for progress and error reporting
  int count = 0, detectorProblemCount = 0;
  // Now loop through lines, one for each detector or monitor. The latter are ignored.
  while( getline(sFile, str) )
  {
    if (str.empty() || str[0] == '#') continue;
    std::istringstream istr(str);
    
    // columns in the file, the detector ID and a code for the type of detector CODE = 3 (psd gas tube)
    int det_no, code;
    double delta;
    // column names det_2   ,   det_3  , assumes that code=3
    double         pressure, wallThick;
    // data for each detector in the file that we don't need
    float dump;
    // parse the line
    istr >> det_no >> delta >> dump >> code;

    if ( code != PSD_GAS_TUBE )
    {// the type of detector is wrong, we can't use the information
      if ( code != MONITOR_DEVICE && code != DUMMY_DECT )
      {//we can't use data for detectors with other codes because it could be in the wrong format, ignore the data and write to g_log.warning() once at the end
        detectorProblemCount ++;
        g_log.debug() << "Ignoring data for a detector with code " << code << std::endl;
      }
      continue;
    }

    //11 uninteresting columns
    istr >> dump >> dump >> dump >> dump >> dump >> dump >> dump >> dump >> dump >> dump >> dump;
    // more data, leaving the last number at the end of the line
    istr >> dump >> pressure >> wallThick;
    
    Geometry::IDetector_sptr det = instrument->getDetector(det_no);
    boost::shared_ptr<IComponent> comp = boost::dynamic_pointer_cast<IComponent>(det);
    
    //Need to get the address to the base instrument component
    ParametrizedComponent* pcomp = dynamic_cast<ParametrizedComponent*>(comp.get());
    
    const IComponent* baseComp;
    if (pcomp)
    {
      baseComp = pcomp->base();
    }
    else
    {
      baseComp = comp.get();
    }

    // write to the parameter tables, simliar code exists below for RAW files it is copied out inline to save the computional time required to copy values
    // set the detectors dead time, first check if it already has a setting, if not add it
    Parameter_sptr setting = pmap.get(baseComp, "time offset (microseconds)");
    if (setting) setting->set(delta);
    else
      pmap.add("double",baseComp,"time offset (microseconds)", delta);

    setting = pmap.get(baseComp, "gas pressure (atm)");
    if (setting) setting->set(pressure);
    else
      pmap.add("double", baseComp, "gas pressure (atm)", pressure);

    setting = pmap.get(baseComp, "wall thickness (m)");
    if (setting) setting->set(wallThick);
    else
      pmap.add("double", baseComp, "wall thickness (m)", wallThick);

    // report progress and check for a user cancel message at regualr intervals
    count ++;
    if ( count % INTERVAL == 0 )
    {
      progress(static_cast<float>(count)/detectorCount);
      interruption_point();
    }
  }
  if ( detectorProblemCount > 0 )
  {
    g_log.warning() << "Data for " << detectorProblemCount << " detectors that are neither monitors or psd gas tubes, the data has been ignored" << std::endl;
  }
  g_log.information() << "Successfully read DAT file " << fName << std::endl;
}

void LoadDetectorInfo::readRAW(const std::string& fName)
{
  // open raw file
  ISISRAW2 iraw;
  if (iraw.readFromFile(fName.c_str(),false) != 0)
  {
    g_log.error("Unable to open file " + fName);
    throw Exception::FileError("Unable to open File:" , fName);
  }
  // the number of detectors according to what was read in from the raw file header
  const int numDetectors = iraw.i_det;
  // number of user tables in the raw file, where a table is a lsit of dead times, pressures, etc. for each detector
  if ( iraw.i_use < 10 )
  {
    g_log.warning() << "There is no detector gas pressure or wall thickness information in the file" << std::endl;
  }

  MatrixWorkspace_sptr workspace = getProperty("Workspace");
  IInstrument_const_sptr instrument = workspace->getInstrument();
  Geometry::ParameterMap& pmap = workspace->instrumentParameters();

  int detectorProblemCount = 0;
  for (int i = 0; i < numDetectors; ++i)
  {
    // this code tells us what the numbers in the user table (iraw.ut), which we are about to use, mean
    const int format = iraw.code[i];
    if ( format != OUR_USER_TABLE_FORM )
    {// the type of detector is wrong, we can't use the information
      if ( format != USER_TABLE_MONITOR )
      {// the format of the data for this detector may be wrong, ignore the data and write to g_log.warning() once at the end
        detectorProblemCount ++;
        g_log.debug() << "Ignoring RAW file header user table information that has code " << format << std::endl;
      }
      continue;
    }

    // iraw.udet contains the detector IDs
    Geometry::IDetector_sptr det = instrument->getDetector(iraw.udet[i]);
    boost::shared_ptr<IComponent> comp =
      boost::dynamic_pointer_cast<IComponent>(det);
    
    //Need to get the address to the base instrument component
    ParametrizedComponent* pcomp = dynamic_cast<ParametrizedComponent*>(comp.get());
    const IComponent* baseComp;
    if (pcomp)
    {
      baseComp = pcomp->base();
    }
    else
    {
      baseComp = comp.get();
    }

    // write to the parameter tables, simliar code exists above for DAT files it is copied out inline to save the computional time required to copy values
    const double deadTime = iraw.delt[i];
    Parameter_sptr setting = pmap.get(baseComp, "time offset (microseconds)");
    if (setting) setting->set(deadTime);
    else
      pmap.add("double", baseComp, "time offset (microseconds)", deadTime);

    // copy out the data from user table from the header of the RAW file
    const double pressure = iraw.ut[i+PRESSURE_TAB_NUM*numDetectors];
    // set the detectors pressure, first check if it already has a setting, if not add it
    setting = pmap.get(baseComp, "gas pressure (atm)");
    if (setting) setting->set(pressure);
    else
      pmap.add("double", baseComp, "gas pressure (atm)", pressure);

    const double wallThick = iraw.ut[i+WALL_THICK_TAB_NUM*numDetectors];
    setting = pmap.get(baseComp, "wall thickness (m)");
    if (setting) setting->set(wallThick);
    else
      pmap.add("double", baseComp, "wall thickness (m)", wallThick);

    // report progress and check for a user cancel message,  ut only sometimes
    if ( i % INTERVAL == 0 )
    {
      progress(static_cast<float>(i)/numDetectors);
      interruption_point();
    }
  }

  if ( detectorProblemCount > 0 )
  {
    g_log.warning() << detectorProblemCount << " entries in the user table had the wrong format, this data has been ignored and some detectors parameters were not updated" << std::endl;
  }
  g_log.information() << "Successfully read RAW file " << fName << std::endl;

}

} // namespace DataHandling
} // namespace Mantid
