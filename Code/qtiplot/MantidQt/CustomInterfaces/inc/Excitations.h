#ifndef MANTIDQTCUSTOMINTERFACES_EXCITATIONS_H_
#define MANTIDQTCUSTOMINTERFACES_EXCITATIONS_H_

#include "MantidQtCustomInterfaces/ui_Excitations.h"
#include "MantidQtCustomInterfaces/pythonCalc.h"
#include "MantidKernel/PropertyWithValue.h"
#include "MantidQtAPI/UserSubWindow.h"
#include "MantidAPI/IAlgorithm.h"
#include <QString>
#include <QHash>

namespace MantidQt
{
namespace CustomInterfaces
{
class Excitations : public MantidQt::API::UserSubWindow
{
  Q_OBJECT

public:
  /// there has to be a default constructor but you can call it with a pointer to the thing that will take ownership of it
  Excitations(QWidget *parent = 0);

private:
  /// The form generated by Qt Designer
  Ui::Excitations m_uiForm;
  // structures to hold the values entered by the use
  /// Pointers to instances of all the algorithms used. From these the properties are taken and used for validation
  std::vector<Mantid::API::IAlgorithm_sptr> m_algorDummies;

    /// Initialize the layout
  virtual void initLayout();
  bool parseInput();
  void loadAlgorDummies();
  void clearData();
  void readTheDialog();
  void readFile(const QString &pythonFile, QString &scriptText) const;
  pythonCalc::TestSummary readRes(QString pyhtonOut);
  void storeUserSetting(const std::string &varibleName, const QString &value);
  /// enable the run button if the results dialog has been closed and the python has stopped
  void pythonIsRunning(bool running);

  void setUpPage1();
  void setUpPage2();
  void setUpPage3();

private slots:
  ///run the algorithms that can be run with the data that users supplied
  void run();
  //get rid of this one, no?
  void browseClicked(const QString &buttonDis);
  /// open the wiki page for this interface in their browser
  void helpClicked();
  void disenableAbsolute();
  void disenableDiag();

protected:
  /// The properties associated with this algorithm
  QHash<QString, Mantid::Kernel::Property*> m_algProperties;

  /// A list of labels to use as validation markers
  QHash<QString, QLabel*> m_validators;
  /// This sets up the labels that are to be used to mark whether a property is valid.
  void createValidatorLabels();
  /// A map of property <name, value> pairs that have been taken from the dialog
  QHash<QString, QString> m_propertyValueMap;
  /// Data stored in this map may or may not be validated, it is taken from the dialog and passed to the python script generation
  std::map<std::string, QString> m_userSettingsMap;

  std::map<std::string, std::string> m_algorPropList;
  /// Set the properties that have been parsed from the dialog
  bool setPropertyValues();
  void saveInput();
  QLabel* getValidatorMarker(const QString & propname) const;
  void placeValidatorLabels();
  void getAlgProperties();
  void storePropertyValue(const QString & name, const QString & value);
};
}
}

#endif //MANTIDQTCUSTOMINTERFACES_EXCITATIONS_H_