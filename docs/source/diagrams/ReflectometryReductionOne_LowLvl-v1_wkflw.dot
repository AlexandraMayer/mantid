digraph ReflectometryReductionOne {
label = "ReflectometryReductionOne Low Level Flowchart"
 $global_style

subgraph params {
 $param_style
  inputWorkspace    [label="InputWorkspace"]
  firstTransRun     [label="FirstTransmissionRun"]
  secondTransRun    [label="SecondTransmissionRun"]
  outputWorkspaceWL [label="OutputWorkspaceWavelength"]
  outputWorkspaceMT [label="OutputWorkspace"]
  outputWorksapceMTScale [label="OutputWorkspace"]
  thetaIn           [label="ThetaIn"]
  sourceRotationAngle  [label = "Rotation Angle"]
  sourceRotationAngleBack [label = "-Rotation Angle"]
  thetaOut          [label="ThetaOut"]
  corrAlg           [label="CorrectionAlgorithm"]
  momentumTransferMin  [label="MomentumTransferMinimum"]
  momentumTransferStep [label="MomentumTransferStep"]
  momentumTransferMax  [label="MomentumTransferMaximum"]
  procCommands      [label="ProcessingCommands"]
  wavMax            [label="WavelengthMax"]
  wavMin            [label="WavelengthMin"]
  wavStep           [label="WavelengthStep"]
  monStartWSIndex   [label="StartWorkspaceIndex"]
  monEndWSIndex     [label="EndWorkspaceIndex"]
  detWS             [label="DetectorWorkspace"]
  regionOfDirectBeam [label="RegionOf-\nDirectBeam"]
  scaleFactor       [label="ScaleFactor"]
}

subgraph decisions {
 $decision_style
  checkXUnit      [label="X axis in &lambda;?"]
  checkMultDet    [label="Multidetector?"]
  checkTransRun   [label="FirstTransmissionRun\ngiven?"]
  checkTransUnits [label="X axis in &lambda;?"]
  checkThetaIn    [label="ThetaIn given?"]
  checkCorDetPos  [label="Correct Detector Positions?"]
  checkNormDetMon [label="Normalize by\nIntegrated Monitors?"]
  checkCorrAlg    [label="CorrectionAlgorithm?"]
  checkSourceRotation [label="Is Source in Correct Position?"]
  checkSourceRotationBack [label = "Was Source Rotated?"]
  checkRebinMin   [label="MomentumTransferMinimum given?"]
  checkRebinMax   [label="MomentumTransferMaximum given?"]
  checkRebinStep  [label="MomentumTransferStep given?"]
  checkScale      [label="ScaleFactor given?"]
  checkMonUnity   [label="Monitors?"]
  checkBgMinMax   [label="Min or Max\nnon-zero?"]
  monIntWavInterval [label="Monitor Integration\nWavelength Interval"]
}

subgraph algorithms {
 $algorithm_style
  calcTheta       [label="SpecularReflectionCalculateTheta"]
  convertToMT     [label="ConvertUnits\n(Momentum-transfer)"]
  createTransWS   [label="CreateTransmissionWorkspace"]
  divideDetMon    [label="Divide\n(Detectors / Monitors / Unity)"]
  divideTrans     [label="Divide\n(InputWorkspace / TransmissionWorkspace)"]
  intMon          [label="Integrate"]
  specRefPosCor   [label="SpecularReflectionPositionCorrect"]
  polyCorr        [label="PolynomialCorrection"]
  expCorr         [label="ExponentialCorrection"]
  rotateSource    [label="RotateSource"]
  rotateSourceBack [label="RotateSource"]
  rebin           [label="Rebin"]
  scale           [label="Scale"]
  calcResolution  [label="CalculateResolution"]
  convertDet      [label="Convert Units\n(AlignBins = True)"]
  convertMon      [label="Convert Units"]
  groupDet        [label="Group Detectors"]
  cropDetWS       [label="Crop Detector\nWorkspace"]
  rebinDet        [label="Rebin Detectors"]
  cropMonWS       [label="Crop Monitor\nWorkspace"]
  calcFlatBg      [label="Calculate Flat\nBackground"]
  rebinToWS       [label="Rebin To\nWorkspace"]
  sumDirectBeam   [label="Sum Direct\nBeam"]
  rebinByDirectBeam [label="Rebin By\nDirect Beam"]
  normalizeByDirectBeam [label="Normalize By\nDirect Beam"]
  rebinByTransWS  [label="Rebin By Transmission\nWorkspace"]
}

subgraph processes {
 $process_style
  getSourceRotationAngle [label="Get Angle for Source Rotation"]
  calculateMomentumFromLambda [label="4&pi;sin(&theta;)/&lambda;"]
}

subgraph values {
 $value_style
  valMon          [label="I&#8320;(&lambda;)"]
  valDet          [label="I(&lambda;)"]
  valIntegrated   [label="&Sigma; I&#8320;(&lambda;)"]
  valTrans        [label="It(&lambda;) / &Sigma;I&#8320;t(&lambda;)"]
  valUnity        [label="I(1)"]
}

inputWorkspace    -> checkXUnit
checkXUnit        -> checkTransRun    [label="Yes"]
checkXUnit        -> convertDet       [label="Detectors"]
checkXUnit        -> checkMonUnity    [label="Monitors"]
checkMonUnity     -> convertMon       [label="Yes"]
checkMonUnity     -> valUnity         [label="No"]
convertDet        -> valDet
valDet            -> groupDet
procCommands      -> groupDet
convertMon        -> valMon
monIntWavInterval -> intMon
checkNormDetMon   -> intMon           [label="Yes"]
checkNormDetMon   -> divideDetMon     [label="No"]
groupDet          -> cropDetWS
wavMin            -> cropDetWS
wavMax            -> cropDetWS
cropDetWS         -> rebinDet
wavStep           -> rebinDet
rebinDet          -> detWS
detWS             -> rebinToWS
valMon            -> cropMonWS
monStartWSIndex   -> cropMonWS
monEndWSIndex     -> cropMonWS
cropMonWS         -> checkBgMinMax
checkBgMinMax     -> calcFlatBg       [label="Yes"]
checkBgMinMax     -> rebinToWS        [label="No"]
calcFlatBg        -> rebinToWS
rebinToWS         -> checkNormDetMon
detWS             -> checkMultDet
valUnity          -> divideDetMon
intMon            -> valIntegrated
valIntegrated     -> divideDetMon
checkMultDet      -> sumDirectBeam    [label="Yes"]
checkMultDet      -> divideDetMon     [label="No"]
regionOfDirectBeam -> sumDirectBeam
sumDirectBeam     -> rebinByDirectBeam
rebinByDirectBeam -> normalizeByDirectBeam
normalizeByDirectBeam -> divideDetMon
divideDetMon      -> checkTransRun
checkTransRun     -> checkCorrAlg     [label="No"]
checkTransRun     -> rebinByTransWS   [label="Yes"]
corrAlg           -> checkCorrAlg
checkCorrAlg      -> checkThetaIn     [label="None"]
checkCorrAlg      -> polyCorr         [label="PolynomialCorrection"]
checkCorrAlg      -> expCorr          [label="ExponentialCorrection"]
polyCorr          -> checkThetaIn
expCorr           -> checkThetaIn
firstTransRun     -> checkTransUnits
checkTransUnits   -> valTrans         [label="Yes"]
checkTransUnits   -> createTransWS    [label="No"]
secondTransRun    -> createTransWS
createTransWS     -> valTrans
valTrans          -> rebinByTransWS
rebinByTransWS    -> divideTrans
divideTrans       -> checkThetaIn
thetaIn           -> checkThetaIn
checkThetaIn      -> checkCorDetPos   [label="Yes"]
checkThetaIn      -> calcTheta        [label="No"]
calcTheta         -> checkCorDetPos
calcTheta         -> thetaOut
checkCorDetPos    -> specRefPosCor    [label="Yes"]
checkCorDetPos    -> outputWorkspaceWL[label="No"]
specRefPosCor     -> outputWorkspaceWL
outputWorkspaceWL -> checkSourceRotation
checkSourceRotation -> convertToMT [label="Yes"]
checkSourceRotation -> getSourceRotationAngle [label="No"]
getSourceRotationAngle -> sourceRotationAngle
sourceRotationAngle -> rotateSource
rotateSource      -> convertToMT
convertToMT       -> checkSourceRotationBack
checkSourceRotationBack -> rotateSourceBack [label = "Yes"]
checkSourceRotationBack -> outputWorkspaceMT [label="No"]
sourceRotationAngleBack -> rotateSourceBack [label = "Rotate back by Rotation Angle"]
rotateSourceBack    -> outputWorkspaceMT
outputWorkspaceMT   -> checkRebinMin
outputWorkspaceMT   -> checkRebinMax
outputWorkspaceMT   -> checkRebinStep
outputWorkspaceWL  -> calculateMomentumFromLambda
checkRebinMin     -> calculateMomentumFromLambda [label="No"]
checkRebinMax     -> calculateMomentumFromLambda [label="No"]
calculateMomentumFromLambda -> momentumTransferMin
calculateMomentumFromLambda -> momentumTransferMax
checkRebinStep    -> calcResolution [label="No"]
checkRebinMin     -> momentumTransferMin [label="Yes"]
checkRebinMax     -> momentumTransferMax [label="Yes"]
checkRebinStep    -> momentumTransferStep[label="Yes"]
calcResolution    -> momentumTransferStep
scaleFactor       -> checkScale
checkScale        -> scale [label="Yes"]
rebin             -> checkScale
checkScale        -> outputWorksapceMTScale [label="No"]
scale             -> outputWorksapceMTScale
momentumTransferMin -> rebin
momentumTransferStep -> rebin
momentumTransferMax -> rebin

}
