#include "MantidGeometry/Crystal/SpaceGroupFactory.h"
#include "MantidGeometry/Crystal/SymmetryOperationSymbolParser.h"
#include "MantidKernel/Exception.h"

#include "MantidGeometry/Crystal/ProductOfCyclicGroups.h"
#include "MantidGeometry/Crystal/CenteringGroup.h"
#include "MantidGeometry/Crystal/GroupTransformation.h"

#include "MantidKernel/LibraryManager.h"
#include "MantidKernel/StringTokenizer.h"

#include <boost/make_shared.hpp>
#include <boost/algorithm/string.hpp>
#include <locale>

namespace Mantid {
namespace Geometry {

using namespace Kernel;

/// Free function that tries to parse the given list of symmetry operations and
/// returns true if successfull.
bool isValidGeneratorString(const std::string &generatorString) {
  StringTokenizer generatorStrings(generatorString, ";",
                                   StringTokenizer::TOK_TRIM |
                                       StringTokenizer::TOK_IGNORE_EMPTY);

  for (auto &generatorString : generatorStrings) {
    try {
      SymmetryOperationSymbolParser::parseIdentifier(generatorString);
    } catch (Kernel::Exception::ParseError) {
      return false;
    }
  }

  return true;
}

/**
 * Transform a vector of strings using a symmetry operation
 *
 * This operator uses the matrix of the supplied symmetry operation to
 * transform the supplied vector of strings. For example
 *
 *  z,x,y * {a, b, c} -> c, a, b
 *
 * Only the first three elements of the vector are considered, the
 * rest is appended untransformed. Negative indices are transformed
 * to positive, so basically this is a way to get all permutations of
 * the first three elements of the vector.
 *
 * @param symOp :: SymmetryOperation to use for transformation.
 * @param strings :: String array to be transformed.
 * @return
 */
std::vector<std::string> operator*(const SymmetryOperation &symOp,
                                   const std::vector<std::string> &strings) {
  if (strings.size() < 3) {
    throw std::invalid_argument("There must be at least three strings in the "
                                "vector for SymmetryOperation * "
                                "std::vector<std::string>.");
  }

  std::vector<int> transformedIndices =
      symOp.matrix() * std::vector<int>{0, 1, 2};

  std::vector<std::string> transformedStrings;
  std::transform(transformedIndices.cbegin(), transformedIndices.cend(),
                 std::back_inserter(transformedStrings),
                 [=](int index) { return strings[abs(index)]; });

  if (transformedStrings.size() < strings.size()) {
    transformedStrings.insert(transformedStrings.end(),
                              strings.cbegin() + transformedStrings.size(),
                              strings.cend());
  }

  return transformedStrings;
}

/// Returns true if the supplied string contains a space
bool contains_space(const std::string &str) {
  return std::find(str.cbegin(), str.cend(), ' ') != str.cend();
}

/// Constructor for AbstractSpaceGroupGenerator
AbstractSpaceGroupGenerator::AbstractSpaceGroupGenerator(
    size_t number, const std::string &hmSymbol,
    const std::string &generatorInformation)
    : m_number(number), m_hmSymbol(hmSymbol),
      m_generatorString(generatorInformation), m_prototype() {}

/// Returns the internally stored prototype, generates one if necessary.
SpaceGroup_const_sptr AbstractSpaceGroupGenerator::getPrototype() {
  if (!hasValidPrototype()) {
    m_prototype = generatePrototype();
  }

  return m_prototype;
}

/**
 * Generates a prototype space group object
 *
 * Constructs a space group object using a Group generated by the pure virtual
 * generateGroup()-method along with the stored number and
 * Hermann-Mauguin-symbol.
 *
 * generateGroup() has to be implemented by sub-classes and should probably use
 * the generatorInformation supplied to the constructor.
 *
 * @return SpaceGroup prototype object
 */
SpaceGroup_const_sptr AbstractSpaceGroupGenerator::generatePrototype() {
  Group_const_sptr generatingGroup = generateGroup();

  if (!generatingGroup) {
    throw std::runtime_error(
        "Could not create group from supplied symmetry operations.");
  }

  return boost::make_shared<const SpaceGroup>(m_number, m_hmSymbol,
                                              *generatingGroup);
}

/// Constructor of AlgorithmicSpaceGroupGenerator which throws an
/// std::runtime_error exception when the generatorInformation string cannot be
/// interpreted as symmetry operations.
AlgorithmicSpaceGroupGenerator::AlgorithmicSpaceGroupGenerator(
    size_t number, const std::string &hmSymbol,
    const std::string &generatorInformation)
    : AbstractSpaceGroupGenerator(number, hmSymbol, generatorInformation) {
  if (!isValidGeneratorString(generatorInformation)) {
    throw std::runtime_error("Generator string could not be parsed: " +
                             generatorInformation);
  }
}

/// Uses an algorithm based on Shmueli, U. Acta Crystallogr. A 40, 559â€“567
/// (1984), http://dx.doi.org/10.1107/S0108767384001161 to generate the group.
Group_const_sptr AlgorithmicSpaceGroupGenerator::generateGroup() const {
  Group_const_sptr baseGroup =
      GroupFactory::create<ProductOfCyclicGroups>(getGeneratorString());
  Group_const_sptr centeringGroup =
      GroupFactory::create<CenteringGroup>(getCenteringSymbol());

  return baseGroup * centeringGroup;
}

/// Returns the centering symbol, which is extracted from the
/// Hermann-Mauguin-symbol.
std::string AlgorithmicSpaceGroupGenerator::getCenteringSymbol() const {
  return getHMSymbol().substr(0, 1);
}

/// Constructor of TransformationSpaceGroupGenerator that may throw an
/// std::invalid_argument exception when the generatorInformation-
/// argument can not be interpreted as (base group symbol | transformation).
TransformationSpaceGroupGenerator::TransformationSpaceGroupGenerator(
    size_t number, const std::string &hmSymbol,
    const std::string &generatorInformation)
    : AbstractSpaceGroupGenerator(number, hmSymbol, generatorInformation) {
  setBaseAndTransformation(generatorInformation);
}

/// Generates a group from the SymmetryOperations obtained by applying the
/// stored transformation to the base group.
Group_const_sptr TransformationSpaceGroupGenerator::generateGroup() const {
  SpaceGroup_const_sptr baseGroup = getBaseSpaceGroup();

  GroupTransformation transformation(m_transformation);

  return boost::make_shared<Group>(transformation(*baseGroup));
}

/// This method is virtual for testing purposes so that using the actual
/// SpaceGroupFactory can be circumvented in the unit tests.
SpaceGroup_const_sptr
TransformationSpaceGroupGenerator::getBaseSpaceGroup() const {
  return SpaceGroupFactory::Instance().createSpaceGroup(m_baseGroupHMSymbol);
}

/**
 * Method to extract base space group symbol and transformation
 *
 * This method tries to extract the symbol of the base space group and the
 * transformation matrix/vector pair from the supplied generator string.
 * The expected format of the string is:
 *
 *      Symbol of base space group | Specification of transformation
 *
 * An example could be, to generate space group P 1 n 1 from P 1 c 1:
 *
 *      P 1 c 1 | -x+z,y,-x
 *
 * This works similarly for origin shifts and so on.
 *
 * @param generatorInformation :: Generator string in the format (base group |
 *                                transformation).
 */
void TransformationSpaceGroupGenerator::setBaseAndTransformation(
    const std::string &generatorInformation) {
  StringTokenizer generatorParts(generatorInformation, "|",
                                 StringTokenizer::TOK_IGNORE_EMPTY |
                                     StringTokenizer::TOK_TRIM);

  if (generatorParts.count() != 2) {
    throw std::invalid_argument("Not a valid string for generation of "
                                "transformed space groups. Correct format is "
                                "'HM symbol | transformation'.");
  }

  m_baseGroupHMSymbol = generatorParts[0];
  m_transformation = generatorParts[1];
}

/// Constructor of TabulatedSpaceGroupGenerator, throws an std::runtime_error
/// exception if generatorInformation cannot be intepreted as symmetry
/// operations.
TabulatedSpaceGroupGenerator::TabulatedSpaceGroupGenerator(
    size_t number, const std::string &hmSymbol,
    const std::string &generatorInformation)
    : AbstractSpaceGroupGenerator(number, hmSymbol, generatorInformation) {
  if (!isValidGeneratorString(generatorInformation)) {
    throw std::runtime_error("Generator string could not be parsed: " +
                             generatorInformation);
  }
}

/// Returns a group that contains the symmetry operations in
Group_const_sptr TabulatedSpaceGroupGenerator::generateGroup() const {
  return GroupFactory::create<Group>(getGeneratorString());
}

/// Creates a space group given the Hermann-Mauguin symbol, throws
/// std::invalid_argument if symbol is not registered.
SpaceGroup_const_sptr
SpaceGroupFactoryImpl::createSpaceGroup(const std::string &hmSymbol) {
  if (!isSubscribed(hmSymbol)) {
    throw std::invalid_argument("Space group with symbol '" + hmSymbol +
                                "' is not registered.");
  }

  return constructFromPrototype(getPrototype(hmSymbol));
}

/// Returns true if space group with given symbol is subscribed.
bool SpaceGroupFactoryImpl::isSubscribed(const std::string &hmSymbol) const {
  return m_generatorMap.find(hmSymbol) != m_generatorMap.end() ||
         m_aliasMap.find(hmSymbol) != m_aliasMap.end();
}

/// Returns true if space group with given number is subscribed.
bool SpaceGroupFactoryImpl::isSubscribed(size_t number) const {
  return m_numberMap.find(number) != m_numberMap.end();
}

/// Returns a vector with all subscribed space group symbols.
std::vector<std::string>
SpaceGroupFactoryImpl::subscribedSpaceGroupSymbols() const {
  std::vector<std::string> symbols;
  symbols.reserve(m_generatorMap.size());

  for (const auto &generator : m_generatorMap) {
    symbols.push_back(generator.first);
  }

  return symbols;
}

/// Returns a vector with all symbols that correspond to a space group number
std::vector<std::string>
SpaceGroupFactoryImpl::subscribedSpaceGroupSymbols(size_t number) const {
  std::vector<std::string> symbols;

  auto keyPair = m_numberMap.equal_range(number);

  for (auto it = keyPair.first; it != keyPair.second; ++it) {
    symbols.push_back(it->second);
  }

  return symbols;
}

/// Returns a vector with all subscribed space group numbers.
std::vector<size_t> SpaceGroupFactoryImpl::subscribedSpaceGroupNumbers() const {
  std::vector<size_t> numbers;
  numbers.reserve(m_numberMap.size());

  for (auto it = m_numberMap.begin(); it != m_numberMap.end();
       it = m_numberMap.upper_bound(it->first)) {
    numbers.push_back(it->first);
  }

  return numbers;
}

std::vector<std::string> SpaceGroupFactoryImpl::subscribedSpaceGroupSymbols(
    const PointGroup_sptr &pointGroup) {
  if (m_pointGroupMap.empty()) {
    fillPointGroupMap();
  }

  std::string pointGroupSymbol = pointGroup->getSymbol();

  std::vector<std::string> symbols;
  auto keyPair = m_pointGroupMap.equal_range(pointGroupSymbol);

  for (auto it = keyPair.first; it != keyPair.second; ++it) {
    symbols.push_back(it->second);
  }

  return symbols;
}

/// Unsubscribes the space group with the given Hermann-Mauguin symbol, but
/// throws std::invalid_argument if symbol is not registered.
void SpaceGroupFactoryImpl::unsubscribeSpaceGroup(const std::string &hmSymbol) {
  auto eraseGenerator = m_generatorMap.find(hmSymbol);
  if (eraseGenerator == m_generatorMap.end()) {
    throw std::invalid_argument("Cannot unsubscribe space group that is not "
                                "registered. If you called this method with an "
                                "alias, try getting the subscribed symbol from "
                                "the generated space group.");
  }

  AbstractSpaceGroupGenerator_sptr generator = eraseGenerator->second;

  auto eraseNumber = m_numberMap.find(generator->getNumber());

  m_numberMap.erase(eraseNumber);
  m_generatorMap.erase(eraseGenerator);
  removeAllAliases(generator);
}

/**
 * Registers aliases for the supplied Hermann-Mauguin symbol
 *
 * This method registers aliases given in the second argument so that the space
 * group with the supplied symbol can be created using these aliases.
 *
 * Aliases must be a list of comma-separated strings (a list of length 1 is
 * acceptable). For each alias, a second alias with all spaces removed is
 * created as well. This is useful for example in the monoclinic case, where
 * C 2 and C2 should both be present, the same for different origin choices.
 *
 * If any alias in the list is already registered for something else, an
 * exception is thrown.
 *
 * @param hmSymbol :: Herrmann-Mauguin symbol for which to register aliases.
 * @param aliases :: Comma-separated list of aliases.
 */
void SpaceGroupFactoryImpl::registerAliases(const std::string &hmSymbol,
                                            const std::string &aliases) {
  AbstractSpaceGroupGenerator_sptr generator = getGenerator(hmSymbol);

  if (!generator) {
    throw std::invalid_argument("Can not register alias for " + hmSymbol +
                                ", it is not subscribed to the factory.");
  }

  insertAliases(aliases, generator);
}

/// Method to get the transformed symbol of an orthorhombic space group under
/// the supplied transformation.
std::string SpaceGroupFactoryImpl::getTransformedSymbolOrthorhombic(
    const std::string &hmSymbol, const std::string &transformation) const {
  // Split the symbol up in its components
  StringTokenizer tokenizer(hmSymbol, " ", StringTokenizer::TOK_IGNORE_EMPTY);

  std::vector<std::string> symbolComponents(tokenizer.cbegin(),
                                            tokenizer.cend());

  // Get the centering, that needs to be transformed as well.
  std::string centeringLowerCase =
      boost::to_lower_copy(symbolComponents.front());

  // Remove the centering, use only the a, b, c-part of the symbol
  symbolComponents.erase(symbolComponents.begin());

  // Use inverse symmetry operation to permute symbol
  SymmetryOperation op = SymmetryOperation(transformation).inverse();

  // Symbols that need to be replaced in the permutations
  std::vector<std::string> axes{"a", "b", "c"};
  std::vector<std::string> permutedAxes = op * axes;

  // Permutation of the symbol, re-append centering symbol, lower case.
  std::vector<std::string> permuted = op * symbolComponents;
  permuted.insert(permuted.begin(), centeringLowerCase);

  // Transform those components for which it is necessary (a, b, c)
  std::transform(
      permuted.begin(), permuted.end(), permuted.begin(),
      [&](const std::string &symbol) {
        auto needsTransformation =
            std::find(permutedAxes.cbegin(), permutedAxes.cend(), symbol);

        if (needsTransformation == permutedAxes.cend()) {
          return symbol;
        }

        return axes[std::distance(permutedAxes.cbegin(), needsTransformation)];
      });

  // Transform centering string back to upper case.
  boost::to_upper(*permuted.begin());

  return boost::join(permuted, " ");
}

/// Returns a copy-constructed instance of the supplied space group prototype
/// object.
SpaceGroup_const_sptr SpaceGroupFactoryImpl::constructFromPrototype(
    const SpaceGroup_const_sptr prototype) const {
  return boost::make_shared<const SpaceGroup>(*prototype);
}

/// Fills the internal multimap that maintains the mapping between space and
/// point groups.
void SpaceGroupFactoryImpl::fillPointGroupMap() {
  m_pointGroupMap.clear();

  for (auto &generator : m_generatorMap) {
    SpaceGroup_const_sptr spaceGroup = getPrototype(generator.first);

    m_pointGroupMap.emplace(spaceGroup->getPointGroup()->getSymbol(),
                            generator.first);
  }
}

/// Returns a prototype object for the requested space group.
SpaceGroup_const_sptr
SpaceGroupFactoryImpl::getPrototype(const std::string &hmSymbol) {
  AbstractSpaceGroupGenerator_sptr generator = getGenerator(hmSymbol);

  if (!generator) {
    generator = getGeneratorByAlias(hmSymbol);

    if (!generator) {
      throw std::runtime_error("No generator for symbol '" + hmSymbol + "'");
    }
  }

  return generator->getPrototype();
}

/// Returns the generator for the given symbol from the generator map, may be an
/// invalid pointer.
AbstractSpaceGroupGenerator_sptr
SpaceGroupFactoryImpl::getGenerator(const std::string &hmSymbol) {
  try {
    return m_generatorMap.at(hmSymbol);
  } catch (std::out_of_range) {
    return AbstractSpaceGroupGenerator_sptr();
  }
}

/// Returns the generator for the given alias from the alias map, may be an
/// invalid pointer
AbstractSpaceGroupGenerator_sptr
SpaceGroupFactoryImpl::getGeneratorByAlias(const std::string &alias) {
  try {
    return m_aliasMap.at(alias);
  } catch (std::out_of_range) {
    return AbstractSpaceGroupGenerator_sptr();
  }
}

/// Puts the space group factory into the factory.
void SpaceGroupFactoryImpl::subscribe(
    const AbstractSpaceGroupGenerator_sptr &generator) {
  if (!generator) {
    throw std::runtime_error("Cannot register null-generator.");
  }

  m_numberMap.emplace(generator->getNumber(), generator->getHMSymbol());
  m_generatorMap.emplace(generator->getHMSymbol(), generator);

  // Clear the point group map
  m_pointGroupMap.clear();
}

/// Remove all alias entries from the alias map for the given generator.
void SpaceGroupFactoryImpl::removeAllAliases(
    const AbstractSpaceGroupGenerator_sptr &generator) {
  auto iter = m_aliasMap.begin();
  auto end = m_aliasMap.end();

  while (iter != end) {
    if (iter->second == generator) {
      iter = m_aliasMap.erase(iter);
    } else {
      ++iter;
    }
  }
}

/// Store aliases for given generator. Will add a version without spaces for
/// each alias.
void SpaceGroupFactoryImpl::insertAliases(
    const std::string &aliases,
    const AbstractSpaceGroupGenerator_sptr &generator) {
  StringTokenizer tokenizer(aliases, ",",
                            StringTokenizer::TOK_TRIM |
                                StringTokenizer::TOK_IGNORE_EMPTY);

  std::vector<std::string> aliasList(tokenizer.cbegin(), tokenizer.cend());

  std::sort(aliasList.begin(), aliasList.end());
  aliasList.erase(std::unique(aliasList.begin(), aliasList.end()),
                  aliasList.end());

  for (const auto &alias : aliasList) {
    insertAlias(alias, generator);
  }
}

/// Store alias for given generator. Throws std::runtime_error if the alias
/// already exists.
void SpaceGroupFactoryImpl::insertAlias(
    const std::string &alias,
    const AbstractSpaceGroupGenerator_sptr &generator) {
  if (!m_aliasMap.emplace(alias, generator).second) {
    throw std::runtime_error("Alias already exists: " + alias);
  }
}

/// Constructor cannot be called, since SingletonHolder is used.
SpaceGroupFactoryImpl::SpaceGroupFactoryImpl()
    : m_numberMap(), m_generatorMap(), m_aliasMap(), m_pointGroupMap() {
  Kernel::LibraryManager::Instance();
}


} // namespace Geometry
} // namespace Mantid
