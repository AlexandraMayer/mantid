#pylint: disable=no-init, too-many-instance-attributes
from mantid import logger, AlgorithmFactory
from mantid.api import *
from mantid.kernel import *
from mantid.simpleapi import *
import os.path

class IqtFitSequential(PythonAlgorithm):

    _input_ws = None
    _function = None
    _fit_type = None
    _start_x = None
    _end_x = None
    _spec_min = None
    _spec_max = None
    _intensities_constrained = None
    _minimizer = None
    _max_iterations = None
    _result_name = None
    _parameter_name = None
    _fit_group_name = None


    def category(self):
        return "Workflow\\MIDAS"

    def summary(self):
        #pylint: disable=anomalous-backslash-in-string
        return "Fits an \*\_iqt file generated by I(Q,t) sequentially."

    def PyInit(self):
        self.declareProperty(MatrixWorkspaceProperty('InputWorkspace', '', direction=Direction.Input),
                             doc='The _iqt.nxs InputWorkspace used by the algorithm')

        self.declareProperty(name='Function', defaultValue='',
                             doc='The function to use in fitting')

        self.declareProperty(name='FitType', defaultValue='',
                             doc='The type of fit being carried out')

        self.declareProperty(name='StartX', defaultValue=0.0,
                             validator=FloatBoundedValidator(0.0),
                             doc="The first value for X")

        self.declareProperty(name='EndX', defaultValue=0.2,
                             validator=FloatBoundedValidator(0.0),
                             doc="The last value for X")

        self.declareProperty(name='SpecMin', defaultValue=0,
                             validator=IntBoundedValidator(0),
                             doc='Minimum spectra in the worksapce to fit')

        self.declareProperty(name='SpecMax', defaultValue=1,
                             validator=IntBoundedValidator(0),
                             doc='Maximum spectra in the worksapce to fit')

        self.declareProperty(name='Minimizer', defaultValue='Levenberg-Marquardt',
                             doc='The minimizer to use in fitting')

        self.declareProperty(name="MaxIterations", defaultValue=500,
                             validator=IntBoundedValidator(0),
                             doc="The Maximum number of iterations for the fit")

        self.declareProperty(name='ConstrainIntensities', defaultValue=False,
                             doc="If the Intensities should be constrained during the fit")

        self.declareProperty(MatrixWorkspaceProperty('OutputResultWorkspace', '', direction=Direction.Output),
                             doc='The outputworkspace containing the results of the fit data')

        self.declareProperty(ITableWorkspaceProperty('OutputParameterWorkspace', '', direction=Direction.Output),
                             doc='The outputworkspace containing the parameters for each fit')

        self.declareProperty(WorkspaceGroupProperty('OutputWorkspaceGroup', '', direction=Direction.Output),
                             doc='The OutputWorkspace group Data, Calc and Diff, values for the fit of each spectra')



    def validateInputs(self):
        self._get_properties()
        issues = dict()
        return issues

    def _get_properties(self):
        self._input_ws = self.getProperty('InputWorkspace').value
        self._function = self.getProperty('Function').value
        self._fit_type = self.getProperty('FitType').value
        self._start_x = self.getProperty('StartX').value
        self._end_x = self.getProperty('EndX').value
        self._spec_min = self.getProperty('SpecMin').value
        self._spec_max = self.getProperty('SpecMax').value
        self._intensities_constrained = self.getProperty('ConstrainIntensities').value
        self._minimizer = self.getProperty('Minimizer').value
        self._max_iterations = self.getProperty('MaxIterations').value
        self._result_name = self.getPropertyValue('OutputResultWorkspace')
        self._parameter_name = self.getPropertyValue('OutputParameterWorkspace')
        self._fit_group_name = self.getPropertyValue('OutputWorkspaceGroup')

    def PyExec(self):
        from IndirectDataAnalysis import (convertToElasticQ,
                                          createFuryMultiDomainFunction,
                                          transposeFitParametersTable)

        self._fit_type = ftype[:-2]
        logger.information('Option: ' + self._fit_type)
        logger.information(self._function)

        tmp_fit_workspace = "__furyfit_fit_ws"
        CropWorkspace(InputWorkspace=self._input_ws, OutputWorkspace=tmp_fit_workspace, XMin=self._start_x, XMax=endx)

        num_hist = mtd[inputWS].getNumberHistograms()
        if self._spec_max is None:
            self._spec_max = num_hist - 1

        # Name stem for generated workspace
        output_workspace = '%sfury_%s%d_to_%d' % (getWSprefix(inputWS), ftype, self._spec_min, self._spec_max)

        ConvertToHistogram(tmp_fit_workspace, OutputWorkspace=tmp_fit_workspace)
        convertToElasticQ(tmp_fit_workspace)

        # Build input string for PlotPeakByLogValue
        input_str = [tmp_fit_workspace + ',i%d' % i for i in range(self._spec_min, self._spec_max + 1)]
        input_str = ';'.join(input_str)

        PlotPeakByLogValue(Input=input_str,
                           OutputWorkspace=output_workspace,
                           Function=self._function,
                           Minimizer=self._minimizer,
                           MaxIterations=self._max_iterations,
                           StartX=self._start_x,
                           EndX=self._end_x,
                           FitType='Sequential',
                           CreateOutput=True)

        # Remove unsused workspaces
        DeleteWorkspace(output_workspace + '_NormalisedCovarianceMatrices')
        DeleteWorkspace(output_workspace + '_Parameters')

        fit_group = output_workspace + '_Workspaces'
        params_table = output_workspace + '_Parameters'
        RenameWorkspace(output_workspace, OutputWorkspace=params_table)

        # Create *_Result workspace
        result_workspace = output_workspace + "_Result"
        parameter_names = ['A0', 'Intensity', 'Tau', 'Beta']
        convertParametersToWorkspace(params_table, "axis-1", parameter_names, result_workspace)

        # Set x units to be momentum transfer
        axis = mtd[result_workspace].getAxis(0)
        axis.setUnit("MomentumTransfer")

        # Process generated workspaces
        wsnames = mtd[fit_group].getNames()
        for i, workspace in enumerate(wsnames):
            output_ws = output_workspace + '_%d_Workspace' % i
            RenameWorkspace(workspace, OutputWorkspace=output_ws)

        sample_logs  = {'start_x': self._start_x, 'end_x': self._end_x, 'fit_type': self._fit_type,
                        'intensities_constrained': self._intensities_constrained, 'beta_constrained': False}

        CopyLogs(InputWorkspace=inputWS, OutputWorkspace=fit_group)
        CopyLogs(InputWorkspace=inputWS, OutputWorkspace=result_workspace)

        log_names = [item[0] for item in sample_logs]
        log_values = [item[1] for item in sample_logs]
        AddSampleLogMultiple(Workspace=result_workspace, LogNames=log_names, LogValues=log_values)
        AddSampleLogMultiple(Workspace=fit_group, LogNames=log_names, LogValues=log_values)

        if Save:
            save_workspaces = [result_workspace, fit_group]
            furyFitSaveWorkspaces(save_workspaces)

        if Plot != 'None' :
            furyfitPlotSeq(result_workspace, Plot)


        return result_workspace

AlgorithmFactory.subscribe(IqtFitSequential)
